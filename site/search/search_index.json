{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Simple, privacy-focused, scalable Mimblewimble chain implementation. Grin aims to serve as digital cash. To provide electronic transactions for all, without censorship or restrictions. Principles Open Grin is developed openly, by individual contributors all over the world. There's no company or foundation behind it, and no ICO, founder reward, pre-mine or dev-tax. The coin distribution is designed to be as fair (but not gratis) as is known to be possible. Private Privacy by default. Transactions have no amount, no addresses and can be trivially aggregated. This enables complete fungibility without precluding the ability to selectively disclose information as needed. Scalable Scales mostly with the number of users and minimally with the number of transactions. Past transactional data can be pruned, making grin drastically lightweight compared to other blockchains. Simple Minimal implementation that strives to remain as clear and simple as possible, making it easy to audit and maintain over time. Proven Mimblewimble only relies on strong Elliptic Curve cryptography which has been tried and tested for decades. \u30c4","title":"./Grin"},{"location":"#principles","text":"","title":"Principles"},{"location":"#open","text":"Grin is developed openly, by individual contributors all over the world. There's no company or foundation behind it, and no ICO, founder reward, pre-mine or dev-tax. The coin distribution is designed to be as fair (but not gratis) as is known to be possible.","title":"Open"},{"location":"#private","text":"Privacy by default. Transactions have no amount, no addresses and can be trivially aggregated. This enables complete fungibility without precluding the ability to selectively disclose information as needed.","title":"Private"},{"location":"#scalable","text":"Scales mostly with the number of users and minimally with the number of transactions. Past transactional data can be pruned, making grin drastically lightweight compared to other blockchains.","title":"Scalable"},{"location":"#simple","text":"Minimal implementation that strives to remain as clear and simple as possible, making it easy to audit and maintain over time.","title":"Simple"},{"location":"#proven","text":"Mimblewimble only relies on strong Elliptic Curve cryptography which has been tried and tested for decades. \u30c4","title":"Proven"},{"location":"example/","text":"Full example from sanic import Sanic from sanic.response import json from sanic_camelcase_middleware import Camelize app = Sanic ( __name__ ) Camelize ( app ) @app.route ( \"/post\" , methods = [ \"POST\" ]) async def test ( request ): return json ( \"is_camelcase\" : True , \"message\" : request . json }) if __name__ == \"__main__\" : app . run ( host = \"0.0.0.0\" , port = 8000 )","title":"Full example"},{"location":"example/#full-example","text":"from sanic import Sanic from sanic.response import json from sanic_camelcase_middleware import Camelize app = Sanic ( __name__ ) Camelize ( app ) @app.route ( \"/post\" , methods = [ \"POST\" ]) async def test ( request ): return json ( \"is_camelcase\" : True , \"message\" : request . json }) if __name__ == \"__main__\" : app . run ( host = \"0.0.0.0\" , port = 8000 )","title":"Full example"},{"location":"about-grin/community/","text":"How is grin administrated? Who received the donations? Who manages the github organization? Of course, a protocol-derived pool of rewards with which to pay developers would have been much more convenient, but it would have completely undermined the political neutrality of the monetary system. rfcs acceptes list and pull requests page","title":"Community"},{"location":"about-grin/emission/","text":"Emission A new grin \u30c4 is emitted every second, forever, meaning the emission rate stays constant and completely linear. As time passes, the relative dilution becomes smaller; After 10 years, it falls below 10%. After 20, below 5%. This results in a decreasing inflation rate, known as disinflation. This simple design serves to ensure the long-term security and stability of grin, as well as provide a fair process of distribution. We'll set to explore those topics more thoroughly. The first four years of bitcoin's emission rate are identical to the first four of grin. Bitcoin had a full reward for 4 years, followed by half that for the following 4 years. So compared to a constant supply, after 8 years, the total amount of coins emitted is only 25% less. Compare that to daily price fluctuations. Security The more resources being spent on mining a proof-of-work chain, the less it's susceptible to various mining attacks, most prominently 51% attacks. The financial resources deployed, or the overall mining revenue, are often referred to as security spend , which is solely determined by the incentives provided as block rewards. This reward is composed both of transactions fees, and of the block subsidy, i.e. newly generated coins. Block Subsidy Grin introduces a constant block subsidy in order to remain sufficiently secure over the coming years and decades. Block reward is then guaranteed , regardless of how full the blocks are, or how much users are willing to pay in fees for faster confirmation. Furthermore, this type of emission removes a lot of uncertainty, and avoids the shortcomings of the standard rapidly decreasing emission which has yet to be proven stable and effective on a longer time horizon. Fees Most blockchains are designed to generate and distribute most of the currency supply early on, to directly benefit a few, and then increasingly rely on transaction fees to incentivize mining. One apparent issue with this approach is that the overall security spend is likely to decrease as time passes, making the chain fundamentally less secure in the face of mining attacks, whether by selfish attackers or state actors. This results in a \"tragedy of the commons\", as individual users strive to pay a minimum amount of fees, while also depending on the security that their fees are paying for. 1 Even then, the stability of a chain sustaining itself through high transaction fees is questionable. 2 It becomes potentially prone to a new set of mining attacks, all of which could be avoided given similar mining revenues earned through a block subsidy. Distribution How the coin gets distributed carries significant importance. Grin was not created to quickly enrich a few early users, but to provide digital cash to all. Fair The constant issuance establishes a fair coin distribution 3 , where equal opportunity is given to everyone, in any point in time. New users should not feel discouraged or disadvantaged when adopting a new form money. In constrast, distributing a very large portion of the coins early, mostly benefits the first users but presents an unwelcoming narrative to new ones, as it assigns them a substantially smaller portion of the network's value. This in turn affects the currency's long-standing story of distribution. 4 Wide As it stands today, the ownership of bitcoin is very centralized and will likely remain so. The situation is far worse in most other cryptocurrencies. Such concentration may give birth to a narrow group of individuals and organizations who may have an exorbitant amount of control over the market price. More importantly, they have the power to influence the project and its ecosystem more than any others, since early, disproportioned hoarding carries a good deal of centralization pressure. A constant emission aims to support grin's intent of being at the hands of many people and being used to transact freely, as a privacy-preserving medium of exchange. More Additional properties of constant emission that are worthy to consider: One of the pitfalls of monetary inflation in fiat currencies is governments can inflate the monetary supply on a whim. This has been used to disastrous effect throughout history. A consensus-based currency solves this issue by making the emission policy well known ahead of time, and makes it difficult if not impossible to change. Removing central authorities with arbitrary control is much more what makes bitcoin important than the arbitrary amount of its capped supply. By this definition, grin is just as much \"sound money\". 1 grin/s is very intuitive to understand. 5 A clear emission rule is more likely to be enforced by community consensus, unlike a blurred, complex model. When ownership is more evenly distributed, it likely means that more participants are holding a sizable portion of the network, and thus more users are meaningfully incentivized to advance its growth & improve it. Early users do not profit exponentially due to a decreasing supply, but purely through increasing demand for the coin. Bitcoin's Security Trilemma \u21a9 On the Instability of Bitcoin Without the Block Reward \u21a9 Grin and the Mythical Fair Launch \u21a9 The Story of Distribution \u21a9 Nick Szabo on Supply Predictabilty \u21a9","title":"Emission"},{"location":"about-grin/emission/#emission","text":"A new grin \u30c4 is emitted every second, forever, meaning the emission rate stays constant and completely linear. As time passes, the relative dilution becomes smaller; After 10 years, it falls below 10%. After 20, below 5%. This results in a decreasing inflation rate, known as disinflation. This simple design serves to ensure the long-term security and stability of grin, as well as provide a fair process of distribution. We'll set to explore those topics more thoroughly. The first four years of bitcoin's emission rate are identical to the first four of grin. Bitcoin had a full reward for 4 years, followed by half that for the following 4 years. So compared to a constant supply, after 8 years, the total amount of coins emitted is only 25% less. Compare that to daily price fluctuations.","title":"Emission"},{"location":"about-grin/emission/#security","text":"The more resources being spent on mining a proof-of-work chain, the less it's susceptible to various mining attacks, most prominently 51% attacks. The financial resources deployed, or the overall mining revenue, are often referred to as security spend , which is solely determined by the incentives provided as block rewards. This reward is composed both of transactions fees, and of the block subsidy, i.e. newly generated coins.","title":"Security"},{"location":"about-grin/emission/#block-subsidy","text":"Grin introduces a constant block subsidy in order to remain sufficiently secure over the coming years and decades. Block reward is then guaranteed , regardless of how full the blocks are, or how much users are willing to pay in fees for faster confirmation. Furthermore, this type of emission removes a lot of uncertainty, and avoids the shortcomings of the standard rapidly decreasing emission which has yet to be proven stable and effective on a longer time horizon.","title":"Block Subsidy"},{"location":"about-grin/emission/#fees","text":"Most blockchains are designed to generate and distribute most of the currency supply early on, to directly benefit a few, and then increasingly rely on transaction fees to incentivize mining. One apparent issue with this approach is that the overall security spend is likely to decrease as time passes, making the chain fundamentally less secure in the face of mining attacks, whether by selfish attackers or state actors. This results in a \"tragedy of the commons\", as individual users strive to pay a minimum amount of fees, while also depending on the security that their fees are paying for. 1 Even then, the stability of a chain sustaining itself through high transaction fees is questionable. 2 It becomes potentially prone to a new set of mining attacks, all of which could be avoided given similar mining revenues earned through a block subsidy.","title":"Fees"},{"location":"about-grin/emission/#distribution","text":"How the coin gets distributed carries significant importance. Grin was not created to quickly enrich a few early users, but to provide digital cash to all.","title":"Distribution"},{"location":"about-grin/emission/#fair","text":"The constant issuance establishes a fair coin distribution 3 , where equal opportunity is given to everyone, in any point in time. New users should not feel discouraged or disadvantaged when adopting a new form money. In constrast, distributing a very large portion of the coins early, mostly benefits the first users but presents an unwelcoming narrative to new ones, as it assigns them a substantially smaller portion of the network's value. This in turn affects the currency's long-standing story of distribution. 4","title":"Fair"},{"location":"about-grin/emission/#wide","text":"As it stands today, the ownership of bitcoin is very centralized and will likely remain so. The situation is far worse in most other cryptocurrencies. Such concentration may give birth to a narrow group of individuals and organizations who may have an exorbitant amount of control over the market price. More importantly, they have the power to influence the project and its ecosystem more than any others, since early, disproportioned hoarding carries a good deal of centralization pressure. A constant emission aims to support grin's intent of being at the hands of many people and being used to transact freely, as a privacy-preserving medium of exchange.","title":"Wide"},{"location":"about-grin/emission/#more","text":"Additional properties of constant emission that are worthy to consider: One of the pitfalls of monetary inflation in fiat currencies is governments can inflate the monetary supply on a whim. This has been used to disastrous effect throughout history. A consensus-based currency solves this issue by making the emission policy well known ahead of time, and makes it difficult if not impossible to change. Removing central authorities with arbitrary control is much more what makes bitcoin important than the arbitrary amount of its capped supply. By this definition, grin is just as much \"sound money\". 1 grin/s is very intuitive to understand. 5 A clear emission rule is more likely to be enforced by community consensus, unlike a blurred, complex model. When ownership is more evenly distributed, it likely means that more participants are holding a sizable portion of the network, and thus more users are meaningfully incentivized to advance its growth & improve it. Early users do not profit exponentially due to a decreasing supply, but purely through increasing demand for the coin. Bitcoin's Security Trilemma \u21a9 On the Instability of Bitcoin Without the Block Reward \u21a9 Grin and the Mythical Fair Launch \u21a9 The Story of Distribution \u21a9 Nick Szabo on Supply Predictabilty \u21a9","title":"More"},{"location":"about-grin/privacy/","text":"Privacy Overview Privacy is the foundation of a peer-to-peer electronic cash. In its essence, cash cannot distinguish between individuals, it does not reveal the amounts transferred or owned, and it holds no bias to the history of a specific coin or person. Cash is neutral, the way money should be. By cleverly employing mimblewimble along with several other methods, grin is able to achieve these qualities, while also keeping in mind its core design attributes of simplicity and scalability. Let's explore how and to what extent. Amounts First, there are no amounts. A mimblewimble implementation natively uses Confidential Transactions, meaning all amounts are hidden; They are provably impossible to uncover, yet easily verified. Even before anything else, simply hiding amounts makes any analysis significantly more challenging. Addresses Notably, there are no on-chain addresses either, as transaction building is interactive. Transactions hold minimal information, and each output is simply a commitment; a point on the curve. A transaction might look like this: transaction Inputs Outputs 08c482407fac2.....e335bf2f10d82 085cc6944467b.....a3f1d4274b79b 097b2588fd494.....494e43580476b Each transaction also carries rangeproofs and a kernel, which are mostly irrelevant for this topic. The above illustrates a normal transaction of 1 input and 2 outputs. The outputs (an input is also a reference to an output) are commitments, a 33 bytes blurb to any observer. There's no address to tie an identity to, and it's not clear which output is the change of the sender, and which belongs to the receiver. In a Bitcoin-like system, there are multiple ways in which a user might (accidentally or intentionally) link an address to his identity. Consequently, it is often trivial for analysis to link many of his addresses. Not only does his own privacy suffer, but also the entire network's privacy diminishes as a result. While a grin commitment is one unique output, a bitcoin address may be used to receive an unlimited amount of outputs. An interesting analogy could then be used to emphasize the difference: A commitment, once on-chain, is like a one-time-use address. Both of them only ever \"contain\" a single output. A commitment is not used to form transactions, unlike an address. A commitment is in fact a result of a transaction after it was built peer-to-peer. This makes it significantly harder to link an identity to. Aggregation Furthermore, a key concept of mimblewimble transactions is that several of them can be safely merged together, resulting in what looks like a single transaction. When done at the block level, every block essentially becomes one large transaction: block Inputs Outputs 08c482407fac2.....e335bf2f10d82 097b2588fd494.....494e43580476b 0857b6b7eb6a2.....a0a283ed35974 09f731e071316.....42dae69672dca 085e205dea687.....8b8aeac7562c6 085cc6944467b.....a3f1d4274b79b 09035d331b17a.....bb76238f605fb 094262a95a67a.....2f246f6ce60ce 0961ee1db49ad.....602489c9c4517 09cf2db66b748.....7327297b8e69c 09c2751af8fe9.....fc745808238b6 0900015eec3c1.....d52d78fca78de The outcome is a non-interactive CoinJoin with hidden amounts. It is named non-interactive since all transactions are aggregated into one without any coordination required between the different parties. This is possible to do at the protocol level, and is simply done automatically whenever several transactions meet each other. An observer knows how many transactions are included in the block, since each one carries a kernel, but nothing more. Any further information is impossible to obtain by looking at the chain. Cut-through Another trick mimblewimble sets the stage for is to perform cut-through. In an example scenario where A sent funds to B , and then B sent them over to C , any trace of B 's involvement can be completely removed, such that the result is seen as A -> C . cut-through Inputs Outputs \u21d2 Inputs Outputs A B \u21d2 A B C \u21d2 C This is could be done at any level of transaction building; Before broadcast, during peer propagation, or in a block. While this trick's use cases are limited, it is a unique manifestation of the \"right to be forgotten\" in a blockchain. Transaction Graph Despite the fact that chain analysis can extract very little (if any) information about users and outputs, it is possible to monitor peer-to-peer network activity and obtain the transactions before they're included in a block and aggregated with others. By setting up sniffing nodes connected to many peers, you can figure out which outputs are being spent by what transaction, allowing you to build a partial transaction graph by separating the aggregation done at the block level. It's unclear at this point if meaningful information could be derived from this, as the trail of data stops there. As of today, an almost complete transaction graph can be constructed. But as usage grows this will gradually become harder. Likewise, many privacy-enchancing techniques can be employed to easily remove linkability of outputs. Fortunately, with mimblewimble these may be added natively, such that nobody knows when a user takes extra privacy precautions to obfuscate the transaction graph, therefore no coins become \"tainted\". Dandelion An important piece of information that commonly leaks is the IP address that originally sent the transaction. Normally, a transaction is just broadcast to all connected peers and immediately spreads on the network, allowing for statistical analysis to deduce where it originated. In a peer-to-peer network, this might be hard as transactions are relayed, but over multiple transactions it becomes trivial. To tackle this issue, grin employs Dandelion++ (originally proposed as a BIP), a protocol designed to hide a transaction's origin IP address. Dandelion has two phases; a stem phase and a fluff phase. Once a transaction is initially broadcast, it enters the stem phase, in which it hops between individual peers. At a random point, the transaction enters its fluff phase and is spread (fluffed) among the entire network. This makes it almost impossible to deduce a reliable IP address, and renders statistical analysis impractical. Moreover, Dandelion provides an additional benefit unique to mimblewimble, as it allows for transactions to be aggregated at a very early stage. Right before a transaction beging its fluff phase, it enters a 30s waiting period in which it will be aggregated with any other transactions it meets, thus obscuring linkability of inputs and outputs that a sniffing node may have learned. However, the privacy gained from aggregation before fluffing depends on having many other transactions. Afterword Privacy is complex and information leakage is surprisingly easy. Privacy-preserving systems need to be extremely strong to ensure reasonable amounts of protection. Unfortunately, they often fail in practice simply because they are cumbersome to use, causing people to revert to convenience. Grin is committed to long term privacy protection and will continue to advance in that direction, while remaining practical and accessible to all, regardless of a person's sophistication or available resources.","title":"Privacy"},{"location":"about-grin/privacy/#privacy","text":"","title":"Privacy"},{"location":"about-grin/privacy/#overview","text":"Privacy is the foundation of a peer-to-peer electronic cash. In its essence, cash cannot distinguish between individuals, it does not reveal the amounts transferred or owned, and it holds no bias to the history of a specific coin or person. Cash is neutral, the way money should be. By cleverly employing mimblewimble along with several other methods, grin is able to achieve these qualities, while also keeping in mind its core design attributes of simplicity and scalability. Let's explore how and to what extent.","title":"Overview"},{"location":"about-grin/privacy/#amounts","text":"First, there are no amounts. A mimblewimble implementation natively uses Confidential Transactions, meaning all amounts are hidden; They are provably impossible to uncover, yet easily verified. Even before anything else, simply hiding amounts makes any analysis significantly more challenging.","title":"Amounts"},{"location":"about-grin/privacy/#addresses","text":"Notably, there are no on-chain addresses either, as transaction building is interactive. Transactions hold minimal information, and each output is simply a commitment; a point on the curve. A transaction might look like this: transaction Inputs Outputs 08c482407fac2.....e335bf2f10d82 085cc6944467b.....a3f1d4274b79b 097b2588fd494.....494e43580476b Each transaction also carries rangeproofs and a kernel, which are mostly irrelevant for this topic. The above illustrates a normal transaction of 1 input and 2 outputs. The outputs (an input is also a reference to an output) are commitments, a 33 bytes blurb to any observer. There's no address to tie an identity to, and it's not clear which output is the change of the sender, and which belongs to the receiver. In a Bitcoin-like system, there are multiple ways in which a user might (accidentally or intentionally) link an address to his identity. Consequently, it is often trivial for analysis to link many of his addresses. Not only does his own privacy suffer, but also the entire network's privacy diminishes as a result. While a grin commitment is one unique output, a bitcoin address may be used to receive an unlimited amount of outputs. An interesting analogy could then be used to emphasize the difference: A commitment, once on-chain, is like a one-time-use address. Both of them only ever \"contain\" a single output. A commitment is not used to form transactions, unlike an address. A commitment is in fact a result of a transaction after it was built peer-to-peer. This makes it significantly harder to link an identity to.","title":"Addresses"},{"location":"about-grin/privacy/#aggregation","text":"Furthermore, a key concept of mimblewimble transactions is that several of them can be safely merged together, resulting in what looks like a single transaction. When done at the block level, every block essentially becomes one large transaction: block Inputs Outputs 08c482407fac2.....e335bf2f10d82 097b2588fd494.....494e43580476b 0857b6b7eb6a2.....a0a283ed35974 09f731e071316.....42dae69672dca 085e205dea687.....8b8aeac7562c6 085cc6944467b.....a3f1d4274b79b 09035d331b17a.....bb76238f605fb 094262a95a67a.....2f246f6ce60ce 0961ee1db49ad.....602489c9c4517 09cf2db66b748.....7327297b8e69c 09c2751af8fe9.....fc745808238b6 0900015eec3c1.....d52d78fca78de The outcome is a non-interactive CoinJoin with hidden amounts. It is named non-interactive since all transactions are aggregated into one without any coordination required between the different parties. This is possible to do at the protocol level, and is simply done automatically whenever several transactions meet each other. An observer knows how many transactions are included in the block, since each one carries a kernel, but nothing more. Any further information is impossible to obtain by looking at the chain.","title":"Aggregation"},{"location":"about-grin/privacy/#cut-through","text":"Another trick mimblewimble sets the stage for is to perform cut-through. In an example scenario where A sent funds to B , and then B sent them over to C , any trace of B 's involvement can be completely removed, such that the result is seen as A -> C . cut-through Inputs Outputs \u21d2 Inputs Outputs A B \u21d2 A B C \u21d2 C This is could be done at any level of transaction building; Before broadcast, during peer propagation, or in a block. While this trick's use cases are limited, it is a unique manifestation of the \"right to be forgotten\" in a blockchain.","title":"Cut-through"},{"location":"about-grin/privacy/#transaction-graph","text":"Despite the fact that chain analysis can extract very little (if any) information about users and outputs, it is possible to monitor peer-to-peer network activity and obtain the transactions before they're included in a block and aggregated with others. By setting up sniffing nodes connected to many peers, you can figure out which outputs are being spent by what transaction, allowing you to build a partial transaction graph by separating the aggregation done at the block level. It's unclear at this point if meaningful information could be derived from this, as the trail of data stops there. As of today, an almost complete transaction graph can be constructed. But as usage grows this will gradually become harder. Likewise, many privacy-enchancing techniques can be employed to easily remove linkability of outputs. Fortunately, with mimblewimble these may be added natively, such that nobody knows when a user takes extra privacy precautions to obfuscate the transaction graph, therefore no coins become \"tainted\".","title":"Transaction Graph"},{"location":"about-grin/privacy/#dandelion","text":"An important piece of information that commonly leaks is the IP address that originally sent the transaction. Normally, a transaction is just broadcast to all connected peers and immediately spreads on the network, allowing for statistical analysis to deduce where it originated. In a peer-to-peer network, this might be hard as transactions are relayed, but over multiple transactions it becomes trivial. To tackle this issue, grin employs Dandelion++ (originally proposed as a BIP), a protocol designed to hide a transaction's origin IP address. Dandelion has two phases; a stem phase and a fluff phase. Once a transaction is initially broadcast, it enters the stem phase, in which it hops between individual peers. At a random point, the transaction enters its fluff phase and is spread (fluffed) among the entire network. This makes it almost impossible to deduce a reliable IP address, and renders statistical analysis impractical. Moreover, Dandelion provides an additional benefit unique to mimblewimble, as it allows for transactions to be aggregated at a very early stage. Right before a transaction beging its fluff phase, it enters a 30s waiting period in which it will be aggregated with any other transactions it meets, thus obscuring linkability of inputs and outputs that a sniffing node may have learned. However, the privacy gained from aggregation before fluffing depends on having many other transactions.","title":"Dandelion"},{"location":"about-grin/privacy/#afterword","text":"Privacy is complex and information leakage is surprisingly easy. Privacy-preserving systems need to be extremely strong to ensure reasonable amounts of protection. Unfortunately, they often fail in practice simply because they are cumbersome to use, causing people to revert to convenience. Grin is committed to long term privacy protection and will continue to advance in that direction, while remaining practical and accessible to all, regardless of a person's sophistication or available resources.","title":"Afterword"},{"location":"about-grin/proof-of-work/","text":"Proof of Work Proof of work is a consensus mechanism which allows anyone to extend the blockchain, by providing a piece of data that is both difficult to produce and easy to verify (according to set parameters). Proof of work also serves as the basis for the security and distribution of the coin. Grin has an average block time of 60 seconds and employs Cuckoo Cycle 1 , a memory bound proof of work algorithm, or more specifically, a variation of it named Cuckatoo that is meant to simplify ASICs. Cuckoo Cycle The algorithm finds length-42 cycles in a bipartite graph. The current (and final) grin PoW is Cuckatoo32+, in which a graph must have at least 2 32 + 2 32 nodes. For a comprehensive introduction, read here . Q: Why use a memory-hard proof of work? A: The point is that chips dominated by memory have rather different characteristics from computational chips; they run much cooler, dissipating less heat per unit of area. This shifts the mining cost from mostly opex (electricity) to mostly capex (hardware cost), which delays obsolescence and allows mining in places with higher electricity costs. Two Algorithms Grin has two PoW algorithms: Cuckatoo32+, The primary algorithm, meant to be ASIC-friendly . Begins at 10% and evolves to 100% over 2 years. Cuckaroo29, The secondary algorithm, aimed to be ASIC-resistant . Begins at 90% and decreases to 0% after 2 years. During the first 2 years of grin, the algorithms gradually balance themselves to satisfy the current ratio, starting from 90/10 and eventually becoming 0/100, such that the only proof of work remaining after those initial 2 years would be Cuckatoo32+. This period includes scheduled hardforks every 6 months, in which Cuckaroo29 is modified in order to interrupt possible ASIC development for it. The above simplifies a bit, since in practice Cuckatoo31+ was initially the primary PoW but was phased out completely after 18 months, for reasons we won\u2019t discuss here. You can read about it on this post . ASICs ASICs are special pieces of hardware especially designed to do a specific task as quickly and efficiently as possible. In our context, they solve PoW a algorithm at a much faster rate than general purpose hardware, such as consumer GPUs. The common arguments against ASICs are about how they raise the barrier to entry for mining, and the centralization that may occur when a single ASIC manufacturer has complete market dominance. These issues are mostly solved once a mature, competitive market for ASICs appears. However, as became apparent with bitcoin, this natural process may take time. Grin\u2019s Cuckatoo32+ simplifies ASIC design in hope to reduce the time until they become widely distributed and accessible. The choice of upholding some ASIC-resistance in the first 2 years was made to ensure fair initial distribution, in which no single party has a disproportional mining advantage at launch, before the market becomes populated and competitive enough. Let\u2019s see why encouraging ASIC development might be beneficial 2 in the first place: Security The security of a chain depends both on the amount of capital allocated to mine it (CAPEX), and on the cost of electricity & operation (OPEX). But the CAPEX is only relevant if the mining hardware's main function is to mine our specific chain and is mostly useless otherwise. We should want to avoid having the chain prone to attack by large hardware operators who own no stake in its success (no skin-in-the-game), since they can attack it and divert their hardware to other uses without incurring any loss to their capital. Therefore, to achieve optimal security, two conditions must be met: ASICs exist and perform significantly better than general-purpose hardware. Our chain has the largest economic value for its specific ASIC. If the same PoW algorithm is used by a bigger chain or serves another purpose, we encounter the same issue as described earlier. Inevitability There\u2019s increasingly more evidence that ASICs are inevitable, as dedicated hardware will always have ways in which it can improve upon general purpose hardware. While it is possible to make ASIC manufacturing more difficult, over a long period it is likely to end up a centralizing force in itself, as it makes the chain vulnerable to secret ASIC operations 3 . Cuckoo Cycle \u21a9 ASICs and Decentralization FAQ \u21a9 The State of Cryptocurrency Mining \u21a9","title":"Proof of Work"},{"location":"about-grin/proof-of-work/#proof-of-work","text":"Proof of work is a consensus mechanism which allows anyone to extend the blockchain, by providing a piece of data that is both difficult to produce and easy to verify (according to set parameters). Proof of work also serves as the basis for the security and distribution of the coin. Grin has an average block time of 60 seconds and employs Cuckoo Cycle 1 , a memory bound proof of work algorithm, or more specifically, a variation of it named Cuckatoo that is meant to simplify ASICs. Cuckoo Cycle The algorithm finds length-42 cycles in a bipartite graph. The current (and final) grin PoW is Cuckatoo32+, in which a graph must have at least 2 32 + 2 32 nodes. For a comprehensive introduction, read here . Q: Why use a memory-hard proof of work? A: The point is that chips dominated by memory have rather different characteristics from computational chips; they run much cooler, dissipating less heat per unit of area. This shifts the mining cost from mostly opex (electricity) to mostly capex (hardware cost), which delays obsolescence and allows mining in places with higher electricity costs.","title":"Proof of Work"},{"location":"about-grin/proof-of-work/#two-algorithms","text":"Grin has two PoW algorithms: Cuckatoo32+, The primary algorithm, meant to be ASIC-friendly . Begins at 10% and evolves to 100% over 2 years. Cuckaroo29, The secondary algorithm, aimed to be ASIC-resistant . Begins at 90% and decreases to 0% after 2 years. During the first 2 years of grin, the algorithms gradually balance themselves to satisfy the current ratio, starting from 90/10 and eventually becoming 0/100, such that the only proof of work remaining after those initial 2 years would be Cuckatoo32+. This period includes scheduled hardforks every 6 months, in which Cuckaroo29 is modified in order to interrupt possible ASIC development for it. The above simplifies a bit, since in practice Cuckatoo31+ was initially the primary PoW but was phased out completely after 18 months, for reasons we won\u2019t discuss here. You can read about it on this post .","title":"Two Algorithms"},{"location":"about-grin/proof-of-work/#asics","text":"ASICs are special pieces of hardware especially designed to do a specific task as quickly and efficiently as possible. In our context, they solve PoW a algorithm at a much faster rate than general purpose hardware, such as consumer GPUs. The common arguments against ASICs are about how they raise the barrier to entry for mining, and the centralization that may occur when a single ASIC manufacturer has complete market dominance. These issues are mostly solved once a mature, competitive market for ASICs appears. However, as became apparent with bitcoin, this natural process may take time. Grin\u2019s Cuckatoo32+ simplifies ASIC design in hope to reduce the time until they become widely distributed and accessible. The choice of upholding some ASIC-resistance in the first 2 years was made to ensure fair initial distribution, in which no single party has a disproportional mining advantage at launch, before the market becomes populated and competitive enough. Let\u2019s see why encouraging ASIC development might be beneficial 2 in the first place:","title":"ASICs"},{"location":"about-grin/proof-of-work/#security","text":"The security of a chain depends both on the amount of capital allocated to mine it (CAPEX), and on the cost of electricity & operation (OPEX). But the CAPEX is only relevant if the mining hardware's main function is to mine our specific chain and is mostly useless otherwise. We should want to avoid having the chain prone to attack by large hardware operators who own no stake in its success (no skin-in-the-game), since they can attack it and divert their hardware to other uses without incurring any loss to their capital. Therefore, to achieve optimal security, two conditions must be met: ASICs exist and perform significantly better than general-purpose hardware. Our chain has the largest economic value for its specific ASIC. If the same PoW algorithm is used by a bigger chain or serves another purpose, we encounter the same issue as described earlier.","title":"Security"},{"location":"about-grin/proof-of-work/#inevitability","text":"There\u2019s increasingly more evidence that ASICs are inevitable, as dedicated hardware will always have ways in which it can improve upon general purpose hardware. While it is possible to make ASIC manufacturing more difficult, over a long period it is likely to end up a centralizing force in itself, as it makes the chain vulnerable to secret ASIC operations 3 . Cuckoo Cycle \u21a9 ASICs and Decentralization FAQ \u21a9 The State of Cryptocurrency Mining \u21a9","title":"Inevitability"},{"location":"about-grin/scalability/","text":"Scalability A Mimblewimble chain is massively-prunable, which allows it to stay lightweight and cheap to verify. Its core essence is this unique balance of privacy and scalability. For a mimblewimble chain to be valid everything has to balance out, such that all outputs minus all inputs equals 0 (plus fees). Given that spending an output is practically just copying it to the input side of the equation, then that spent output can be completely removed from the chain and the balance still holds. Only a small kernel has to be kept for each past transaction, forever proving it's validity. Let's illustrate with a trail of transactions: (switch between tabs) Before Inputs Outputs t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel Cut-through Inputs Outputs t r a n s a c t i o n \u2731 \u2731 Kernel t r a n s a c t i o n \u2731 \u2731 \u2731 \u2731 Kernel t r a n s a c t i o n \u2731 \u2731 \u2731 \u2731 Kernel \u2731 \u2731 t r a n s a c t i o n \u2731 \u2731 Kernel \u2731 \u2731 After Inputs Outputs t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel An output is considered 'spent' once it is used as an input. As demonstrated above, every single input can disappear as well as every spent output. What remains is only the set of unspent outputs and all transaction kernels (~100 bytes). In order to verify the entire history starting from the genesis block, a verifier needs: Block headers Set of unspent outputs Kernels An output is a 33 bytes commitment accompanied by a 640 byte rangeproof. Following this logic, the chain mostly grows by the number of users, instead of the number of overall transactions. In fact, it often shrinks in size when more inputs are used than new outputs are created. Building, verifying and storing transactions requires minimal resources. Anyone can verify the entire chain on a phone or cheap hardware, and fully participate in areas with poor network connectivity. Comparison for bitcoiners At the time of this writing, there were 560M bitcoin transactions since its genesis. Anybody who wishes to verify the current state must replay each and every transaction in its history. They will go over billions of outputs to eventually derive the current set of 66M unspent outputs. Mimblewimble shrinks the transaction history such that a chain with bitcoin's history would be kept at around 1/4 the size. This difference becomes much more exciting if one remembers that confidential transactions are extremely resource consuming, since each output requires a large rangeproof. If the current bitcoin blockchain had hidden amounts, it's size would have been on the order of several terabyes.","title":"Scalability"},{"location":"about-grin/scalability/#scalability","text":"A Mimblewimble chain is massively-prunable, which allows it to stay lightweight and cheap to verify. Its core essence is this unique balance of privacy and scalability. For a mimblewimble chain to be valid everything has to balance out, such that all outputs minus all inputs equals 0 (plus fees). Given that spending an output is practically just copying it to the input side of the equation, then that spent output can be completely removed from the chain and the balance still holds. Only a small kernel has to be kept for each past transaction, forever proving it's validity. Let's illustrate with a trail of transactions: (switch between tabs) Before Inputs Outputs t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel Cut-through Inputs Outputs t r a n s a c t i o n \u2731 \u2731 Kernel t r a n s a c t i o n \u2731 \u2731 \u2731 \u2731 Kernel t r a n s a c t i o n \u2731 \u2731 \u2731 \u2731 Kernel \u2731 \u2731 t r a n s a c t i o n \u2731 \u2731 Kernel \u2731 \u2731 After Inputs Outputs t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel An output is considered 'spent' once it is used as an input. As demonstrated above, every single input can disappear as well as every spent output. What remains is only the set of unspent outputs and all transaction kernels (~100 bytes). In order to verify the entire history starting from the genesis block, a verifier needs: Block headers Set of unspent outputs Kernels An output is a 33 bytes commitment accompanied by a 640 byte rangeproof. Following this logic, the chain mostly grows by the number of users, instead of the number of overall transactions. In fact, it often shrinks in size when more inputs are used than new outputs are created. Building, verifying and storing transactions requires minimal resources. Anyone can verify the entire chain on a phone or cheap hardware, and fully participate in areas with poor network connectivity. Comparison for bitcoiners At the time of this writing, there were 560M bitcoin transactions since its genesis. Anybody who wishes to verify the current state must replay each and every transaction in its history. They will go over billions of outputs to eventually derive the current set of 66M unspent outputs. Mimblewimble shrinks the transaction history such that a chain with bitcoin's history would be kept at around 1/4 the size. This difference becomes much more exciting if one remembers that confidential transactions are extremely resource consuming, since each output requires a large rangeproof. If the current bitcoin blockchain had hidden amounts, it's size would have been on the order of several terabyes.","title":"Scalability"},{"location":"about-grin/story/","text":"Grin's Story Mimblewimble On Mon Aug 01 2016 a user named 'majorplayer' logged into the #bitcoin-wizards IRC channel, dropped a text file hosted on a Tor server and then disappeared. The document 1 was titled MIMBLEWIMBLE and authored under the pseudonym Tom Elvis Jedusor. It described a protocol which is both private and extremely lightweight. Tom Elvis Jedusor is the French name for Tom Riddle (Lord Voldemort) from the Harry Potter book series. Mimblewimble is a tongue-tying spell. -!- majorplayer [...] has joined #bitcoin-wizards <majorplayer> hi, i have an idea for improving privacy in bitcoin. my friend who knows technology says this channel would have interest http://5pdcbgndmprm4wud.onion/mimblewimble.txt -!- majorplayer [...] has quit [Client Quit] Its title: MIMBLEWIMBLE Tom Elvis Jedusor 19 July, 2016 The following day, users nsh and andytoshi (Andrew Poelstra) began discussing the idea proposed in the paper. The anonymous writer left several un-answered questions in the document, along with a general lack of details, so there was much to discuss. The conversation included a memorable moment: <nsh> gotta be some way this is sneaky, otherwise it's too good to be true... <andytoshi> hah, yeah, i know the feeling On Oct 10 2016 , Andrew Poelstra published a follow-up paper 2 about Mimblewimble, which introduced several refinements to the original proposal and describes further its technical details. Grin On Oct 20 2016 , a pseudonymous developer using the name Ignotus Peverell, announced in the bitcoin wizards IRC channel that he began work on a minimal implementation of the protocol, which he named Grin. Ignotus Peverell is the wizard who was gifted the Cloak of Invisibility by Death. Grin is short for the Gringotts wizarding bank. -!- igno_peverell [~user@104.238.169.137] has joined #bitcoin-wizards <igno_peverell> I have a minimal implementation of MimbleWimble available. It's very far from complete but has the basics, included the summing of pedersen commitments: <igno_peverell> https://github.com/ignopeverell/grin <igno_peverell> Any feedback or review is greatly appreciated. Thanks! Igno was joined on GitHub by other developers who took interest in the project, several of them bearing pseudonyms of other Harry Potter characters. While Mimblewimble serves as the foundation to a blockchain, it constitutes a relatively small part of a complete cryptocurrency, and many choices were yet to be made. Thus, began the journey to create a full implementation. A community of contributors and users slowly started to form around grin. Launch Grin's genesis block was mined on January 15th, 2019. It was, and still is, young and experimental. It currently goes through rapid changes, as its first 2 years include agreed-upon hardforks in 6-months intervals. Several months after launch, Ignotus Peverell disappeared and has yet to return. Developers distributed around the world are contributing to build grin, some of them funded by donations to work on the project full-time. Development will always remain completely transparent and open for anybody to join. The Mimblewimble Whitepaper \u21a9 Andrew Poelstra's Paper \u21a9","title":"Story"},{"location":"about-grin/story/#grins-story","text":"","title":"Grin's Story"},{"location":"about-grin/story/#mimblewimble","text":"On Mon Aug 01 2016 a user named 'majorplayer' logged into the #bitcoin-wizards IRC channel, dropped a text file hosted on a Tor server and then disappeared. The document 1 was titled MIMBLEWIMBLE and authored under the pseudonym Tom Elvis Jedusor. It described a protocol which is both private and extremely lightweight. Tom Elvis Jedusor is the French name for Tom Riddle (Lord Voldemort) from the Harry Potter book series. Mimblewimble is a tongue-tying spell. -!- majorplayer [...] has joined #bitcoin-wizards <majorplayer> hi, i have an idea for improving privacy in bitcoin. my friend who knows technology says this channel would have interest http://5pdcbgndmprm4wud.onion/mimblewimble.txt -!- majorplayer [...] has quit [Client Quit] Its title: MIMBLEWIMBLE Tom Elvis Jedusor 19 July, 2016 The following day, users nsh and andytoshi (Andrew Poelstra) began discussing the idea proposed in the paper. The anonymous writer left several un-answered questions in the document, along with a general lack of details, so there was much to discuss. The conversation included a memorable moment: <nsh> gotta be some way this is sneaky, otherwise it's too good to be true... <andytoshi> hah, yeah, i know the feeling On Oct 10 2016 , Andrew Poelstra published a follow-up paper 2 about Mimblewimble, which introduced several refinements to the original proposal and describes further its technical details.","title":"Mimblewimble"},{"location":"about-grin/story/#grin","text":"On Oct 20 2016 , a pseudonymous developer using the name Ignotus Peverell, announced in the bitcoin wizards IRC channel that he began work on a minimal implementation of the protocol, which he named Grin. Ignotus Peverell is the wizard who was gifted the Cloak of Invisibility by Death. Grin is short for the Gringotts wizarding bank. -!- igno_peverell [~user@104.238.169.137] has joined #bitcoin-wizards <igno_peverell> I have a minimal implementation of MimbleWimble available. It's very far from complete but has the basics, included the summing of pedersen commitments: <igno_peverell> https://github.com/ignopeverell/grin <igno_peverell> Any feedback or review is greatly appreciated. Thanks! Igno was joined on GitHub by other developers who took interest in the project, several of them bearing pseudonyms of other Harry Potter characters. While Mimblewimble serves as the foundation to a blockchain, it constitutes a relatively small part of a complete cryptocurrency, and many choices were yet to be made. Thus, began the journey to create a full implementation. A community of contributors and users slowly started to form around grin.","title":"Grin"},{"location":"about-grin/story/#launch","text":"Grin's genesis block was mined on January 15th, 2019. It was, and still is, young and experimental. It currently goes through rapid changes, as its first 2 years include agreed-upon hardforks in 6-months intervals. Several months after launch, Ignotus Peverell disappeared and has yet to return. Developers distributed around the world are contributing to build grin, some of them funded by donations to work on the project full-time. Development will always remain completely transparent and open for anybody to join. The Mimblewimble Whitepaper \u21a9 Andrew Poelstra's Paper \u21a9","title":"Launch"},{"location":"about-grin/transactions/","text":"Transactions Mimblewimble transactions are interactive, meaning both parties need some kind of communication to interact with each other and exchange the necessary data to create a transaction. Let's see how a standard transaction flow looks like: The slate is a sheet of incomplete transaction data. Wallets transfer it back and forth until the full signature is complete. In more detail, the process goes as follows: An address, often referred to as a Slatepack Address , is provided by the receiver. It is important to note; This slatepack address is only used to support peer-to-peer interaction, and is completely different from the familiar on-chain address, as it's not part of the ledger. It is in fact an ed25199 public key which serves a double role: A Tor hidden service address. Key to encrypt the data communicated between the sender and receiver. Sender begins building the transaction slate, encrypts it with the receiver's address (a public key), and passes it over. Receiver adds to the slate his own data and partial signature, and delivers it back. Sender finalizes the transaction by adding the final data and his own part partial signature to the slate, thus completing the transaction building process. He can then post it to the chain. One nice side-effect of interactive transactions is that coins can't accidentally be sent into the \"void\" (a public key/address which nobody controls). How does it happen? The interaction between sender and receiver happens in one of two ways. Tor As mentioned earlier, the slatepack address is also used to derive a Tor address. By default, the sender's wallet will try to communicate with the receiver's wallet via Tor. If the connection succeeds, all the rest is done automatically by the two wallets and no manual action is required. The process is exactly as described above, but it all happens under the hood without further intervention. However, if the Tor connection between the wallets is not successful for whatever reason, grin defaults to manually exchanging slate text messages, also called slatepacks. manually. Alternative Method: http Synchronous communication can also happen through regular http, but it requires opening port 3415 and thus might be complicated. We don't cover it here as this method will soon be deprecated. Slatepack Recall that slates are simply partial transactions. Slatepacks are slates encoded inside compact, neatly organized and encrypted text messages. Using this method, 2 nd and 3 rd steps, where the sender and receiver pass the slate to one another, would be done manually by exchanging these slatepack messages. To do so, almost every available communication channel will work; e-mail, forum, chat, social media, letters, pigeons etc. Creativity is the only limit. The address (public key) initially provided by the receiver will be used to the encrypt the slatepacks, so that only the transacting parties are able to see the data inside. Non-encrypted Slatepacks It is possible to skip the 1 st step (providing an address) and straight up send a non-encrypted slatepack to the receiver. Keep in mind that in this case, if the communication channel is compromised or public, observers may learn some transaction information. Invoice Invoice transactions are built much the same way, but with a different order where the receiver initiates the transaction by asking for a certain amount of coins. A slatepack address is provided by the sender (optional). Receiver creates an invoice, requesting to be paid the specified amount. In practice he starts building the transaction slate and writes a pre-determined amount into it. Sender decrypts the slate to confirm the amount he is about to pay, and adds his own data and signature. Receiver finalizes the transaction building process and posts it to the chain.","title":"Transactions"},{"location":"about-grin/transactions/#transactions","text":"Mimblewimble transactions are interactive, meaning both parties need some kind of communication to interact with each other and exchange the necessary data to create a transaction. Let's see how a standard transaction flow looks like: The slate is a sheet of incomplete transaction data. Wallets transfer it back and forth until the full signature is complete. In more detail, the process goes as follows: An address, often referred to as a Slatepack Address , is provided by the receiver. It is important to note; This slatepack address is only used to support peer-to-peer interaction, and is completely different from the familiar on-chain address, as it's not part of the ledger. It is in fact an ed25199 public key which serves a double role: A Tor hidden service address. Key to encrypt the data communicated between the sender and receiver. Sender begins building the transaction slate, encrypts it with the receiver's address (a public key), and passes it over. Receiver adds to the slate his own data and partial signature, and delivers it back. Sender finalizes the transaction by adding the final data and his own part partial signature to the slate, thus completing the transaction building process. He can then post it to the chain. One nice side-effect of interactive transactions is that coins can't accidentally be sent into the \"void\" (a public key/address which nobody controls).","title":"Transactions"},{"location":"about-grin/transactions/#how-does-it-happen","text":"The interaction between sender and receiver happens in one of two ways.","title":"How does it happen?"},{"location":"about-grin/transactions/#tor","text":"As mentioned earlier, the slatepack address is also used to derive a Tor address. By default, the sender's wallet will try to communicate with the receiver's wallet via Tor. If the connection succeeds, all the rest is done automatically by the two wallets and no manual action is required. The process is exactly as described above, but it all happens under the hood without further intervention. However, if the Tor connection between the wallets is not successful for whatever reason, grin defaults to manually exchanging slate text messages, also called slatepacks. manually. Alternative Method: http Synchronous communication can also happen through regular http, but it requires opening port 3415 and thus might be complicated. We don't cover it here as this method will soon be deprecated.","title":"Tor"},{"location":"about-grin/transactions/#slatepack","text":"Recall that slates are simply partial transactions. Slatepacks are slates encoded inside compact, neatly organized and encrypted text messages. Using this method, 2 nd and 3 rd steps, where the sender and receiver pass the slate to one another, would be done manually by exchanging these slatepack messages. To do so, almost every available communication channel will work; e-mail, forum, chat, social media, letters, pigeons etc. Creativity is the only limit. The address (public key) initially provided by the receiver will be used to the encrypt the slatepacks, so that only the transacting parties are able to see the data inside. Non-encrypted Slatepacks It is possible to skip the 1 st step (providing an address) and straight up send a non-encrypted slatepack to the receiver. Keep in mind that in this case, if the communication channel is compromised or public, observers may learn some transaction information.","title":"Slatepack"},{"location":"about-grin/transactions/#invoice","text":"Invoice transactions are built much the same way, but with a different order where the receiver initiates the transaction by asking for a certain amount of coins. A slatepack address is provided by the sender (optional). Receiver creates an invoice, requesting to be paid the specified amount. In practice he starts building the transaction slate and writes a pre-determined amount into it. Sender decrypts the slate to confirm the amount he is about to pay, and adds his own data and signature. Receiver finalizes the transaction building process and posts it to the chain.","title":"Invoice"},{"location":"getting-started/build/","text":"Read this in other languages: Espa\u00f1ol , Korean , \u65e5\u672c\u8a9e , \u7b80\u4f53\u4e2d\u6587 . Requirements Rust Install using rustup.rs : curl https://sh.rustup.rs -sSf | sh; source $HOME/.cargo/env If rust is already installed, you should update to the latest version by running rustup update . Grin currently does not support a minimum version of Rust, so it's recommended to build using the latest version. Dependencies git \u25cf tor \u25cf clang \u25cf ncurses and libs (ncurses, ncursesw5) \u25cf zlib libs (zlib1g-dev or zlib-devel) \u25cf pkg-config \u25cf libssl-dev \u25cf llvm \u25cf linux-headers (needed on Alpine linux) For Debian-based distributions (Ubuntu, Mint etc): apt install build-essential git tor cmake git libgit2-dev clang libncurses5-dev libncursesw5-dev zlib1g-dev pkg-config libssl-dev llvm For macOS: xcode-select --install brew install --with-toolchain llvm brew install pkg-config brew install openssl Build git clone https://github.com/mimblewimble/grin.git cd grin git checkout v4.0.2 cargo build --release Grin can also be built in debug mode (using the --debug or the --verbose flags) but this will render fast sync prohibitively slow due to the large overhead of cryptographic operations. Build errors \u21b4 Build error: Could not compile tokio-retry You might want to remove any previous rust installations to avoid conflicts. Use rustup to reinstall rust and cargo as described . NOTE: If you install rust or cargo with your package manager (most Linuxes anno 2017) you\u2019ll get too old versions. On Debian, you might have to manually compile cmake or get it from non-detault repositories. Build error: failed to select a version for \u2018serde_json\u2019 Run cargo update to fix this Build error: can\u2019t compile crate bitflags Chech rustc \u2013version and note that bitflags requires rust 1.21 or newer. Install via rustup and recommended you also remove any rust/cargo installed via your package manager. Build error: can\u2019t locate stdarg.h If librocksdb-sys fails to build, try symlinking stddef.h and stdarg.h from the gcc5 include directory. So probably from /usr/lib to /usr/include Build error: /usr/bin/ld: cannot find -lz On Ubuntu install the zlib development headers: apt install zlib1g-dev . Build error: /usr/bin/ld: cannot find -lncursesw On Ubuntu install the ncurses development headers: apt install libncursesw5-dev . What was built? Let's review what a succesfull build gets you. Binary target/release/grin is your main grin binary, located inside the build directory. To add it to your path, type: export PATH=`pwd`/target/release:$PATH You can then run grin from anywhere on your system. Data Files All data, configuration and log files created and used by grin are located by default in the hidden ~/.grin directory (under your user home directory). You can modify configuration values by editing the grin-server.toml file, located in ~/.grin/main/grin-server.toml . You can have grin create its data files in the current directory . To do this, run: grin server config This will generate a grin-server.toml file in the current directory. Running grin from a directory that contains grin-server.toml will use the values in that filem which will also be pre-configured to use the current directory for all of the node's data. Configuration Grin attempts to run with sensible defaults, and can be further configured via the grin-server.toml file, generated by grin on its first run. The file contains documentation on each available option. While it is recommended that you perform all grin server configuration via grin-server.toml , it's also possible to supply command line switches to grin that override any settings in the file. For help on grin commands and their switches, try: grin help grin server help grin client help Mining Once your grin node is up and running, you can start mining by building and running grin-miner against your node. For grin-miner to be able to communicate with your grin node, make sure that you have enable_stratum_server = true in your grin-server.toml configuration file and you have a wallet listener running ( grin-wallet listen ). Docker (Running grin in a container) docker build -t grin -f etc/Dockerfile . For floonet, use etc/Dockerfile.floonet instead You can bind-mount your grin cache to run inside the container. docker run -it -d -v $HOME /.grin:/root/.grin grin If you prefer to use a docker named volume, you can pass -v dotgrin:/root/.grin instead. Using a named volume copies default configurations upon volume creation.","title":"Build"},{"location":"getting-started/build/#requirements","text":"","title":"Requirements"},{"location":"getting-started/build/#rust","text":"Install using rustup.rs : curl https://sh.rustup.rs -sSf | sh; source $HOME/.cargo/env If rust is already installed, you should update to the latest version by running rustup update . Grin currently does not support a minimum version of Rust, so it's recommended to build using the latest version.","title":"Rust"},{"location":"getting-started/build/#dependencies","text":"git \u25cf tor \u25cf clang \u25cf ncurses and libs (ncurses, ncursesw5) \u25cf zlib libs (zlib1g-dev or zlib-devel) \u25cf pkg-config \u25cf libssl-dev \u25cf llvm \u25cf linux-headers (needed on Alpine linux) For Debian-based distributions (Ubuntu, Mint etc): apt install build-essential git tor cmake git libgit2-dev clang libncurses5-dev libncursesw5-dev zlib1g-dev pkg-config libssl-dev llvm For macOS: xcode-select --install brew install --with-toolchain llvm brew install pkg-config brew install openssl","title":"Dependencies"},{"location":"getting-started/build/#build","text":"git clone https://github.com/mimblewimble/grin.git cd grin git checkout v4.0.2 cargo build --release Grin can also be built in debug mode (using the --debug or the --verbose flags) but this will render fast sync prohibitively slow due to the large overhead of cryptographic operations. Build errors \u21b4 Build error: Could not compile tokio-retry You might want to remove any previous rust installations to avoid conflicts. Use rustup to reinstall rust and cargo as described . NOTE: If you install rust or cargo with your package manager (most Linuxes anno 2017) you\u2019ll get too old versions. On Debian, you might have to manually compile cmake or get it from non-detault repositories. Build error: failed to select a version for \u2018serde_json\u2019 Run cargo update to fix this Build error: can\u2019t compile crate bitflags Chech rustc \u2013version and note that bitflags requires rust 1.21 or newer. Install via rustup and recommended you also remove any rust/cargo installed via your package manager. Build error: can\u2019t locate stdarg.h If librocksdb-sys fails to build, try symlinking stddef.h and stdarg.h from the gcc5 include directory. So probably from /usr/lib to /usr/include Build error: /usr/bin/ld: cannot find -lz On Ubuntu install the zlib development headers: apt install zlib1g-dev . Build error: /usr/bin/ld: cannot find -lncursesw On Ubuntu install the ncurses development headers: apt install libncursesw5-dev .","title":"Build"},{"location":"getting-started/build/#what-was-built","text":"Let's review what a succesfull build gets you.","title":"What was built?"},{"location":"getting-started/build/#binary","text":"target/release/grin is your main grin binary, located inside the build directory. To add it to your path, type: export PATH=`pwd`/target/release:$PATH You can then run grin from anywhere on your system.","title":"Binary"},{"location":"getting-started/build/#data-files","text":"All data, configuration and log files created and used by grin are located by default in the hidden ~/.grin directory (under your user home directory). You can modify configuration values by editing the grin-server.toml file, located in ~/.grin/main/grin-server.toml . You can have grin create its data files in the current directory . To do this, run: grin server config This will generate a grin-server.toml file in the current directory. Running grin from a directory that contains grin-server.toml will use the values in that filem which will also be pre-configured to use the current directory for all of the node's data.","title":"Data Files"},{"location":"getting-started/build/#configuration","text":"Grin attempts to run with sensible defaults, and can be further configured via the grin-server.toml file, generated by grin on its first run. The file contains documentation on each available option. While it is recommended that you perform all grin server configuration via grin-server.toml , it's also possible to supply command line switches to grin that override any settings in the file. For help on grin commands and their switches, try: grin help grin server help grin client help Mining Once your grin node is up and running, you can start mining by building and running grin-miner against your node. For grin-miner to be able to communicate with your grin node, make sure that you have enable_stratum_server = true in your grin-server.toml configuration file and you have a wallet listener running ( grin-wallet listen ).","title":"Configuration"},{"location":"getting-started/build/#docker","text":"(Running grin in a container) docker build -t grin -f etc/Dockerfile . For floonet, use etc/Dockerfile.floonet instead You can bind-mount your grin cache to run inside the container. docker run -it -d -v $HOME /.grin:/root/.grin grin If you prefer to use a docker named volume, you can pass -v dotgrin:/root/.grin instead. Using a named volume copies default configurations upon volume creation.","title":"Docker"},{"location":"getting-started/wallet-handbook/","text":"CLI Wallet User Handbook Now that you've set up your node and learned how to form a simple transaction, let's get to know the wallet more deeply. The following document is an extremely comprehensive user guide to the reference grin wallet implementation, grin-wallet v4.0.0 . GUI Wallet Instructions on how to transact with a graphical user interface can be found in wallets . File Structure By default, grin will create all wallet files in the hidden directory .grin under your home directory (i.e. ~/.grin ). You can also create and use a wallet with data files in a custom directory, as will be explained later. A grin wallet maintains its state in an LMDB database, with the master seed stored in a separate file. When creating a new wallet, the file structure should be as follows: [wallet directory] \u251c\u2500\u2500 grin-wallet.log \u251c\u2500\u2500 grin-wallet.toml \u251c\u2500\u2500 tor \u2514\u2500\u2500 wallet_data \u251c\u2500\u2500 db \u2502 \u2514\u2500\u2500 lmdb \u2502 \u2514\u2500\u2500 wallet.seed grin-wallet.toml contains configuration information for the wallet. You can modify values within to change ports, the address of your grin node, or logging values. wallet.seed is your master seed file; the private keys of all your outputs are derived from it, and its contents are encrypted with your wallet password. The seed file can be recovered using the seed phrase. tor folder contains Tor configuration files used by the wallet listener. There should be no need to manipulate anything in this directory manually. Tor Configuration \u21b4 grin-wallet.toml contains a [tor] section used to configure values when sending or listening via TOR: use_tor_listener specifies whether the Tor listener should also be invoked when starting the wallet listener via listen (default = true). socks_proxy_addr contains the listening address of TOR's socks proxy port. This should generally be left alone. help grin-wallet help will display all the commands and every global flag. To get additional info about a specific command type grin-wallet help [command] , e.g: grin-wallet help send You can also pass --help or -h . init Before doing anything else, the wallet files need to be generated via the init command: grin-wallet init You'll be prompted to enter a password for the new wallet. It will be used to encrypt your master.seed file and you'll be asked to type it for most wallet commands. By default, your wallet files will be placed into `~/.grin . Alternatively, if you'd like to run a wallet in a directory of your choice, you can create one in the current directory by using flag -h , e.g: grin-wallet init -h This will create all the needed data files, including grin-wallet.toml and wallet.seed , in the current directory. When running any grin-wallet command, grin will check the working directory if these files exist. If not, it will use the default location ~/.grin . Upon a successful init , the wallet prints a 24-word recovery phrase, which you should write down and store in a non-digital format. This phrase can be used to re-create your master seed file if it gets lost or corrupted, or if you forget the wallet password. If you'd prefer to use a 12-word recovery phrase, you can use the -s --short_wordlist flag. init --recover If you need to recreate your wallet from an existing seed, you can init a wallet with a recovery phrase using the -r --recover flag. For example, the following command initializes a wallet in the current directory. grin-wallet init -hr File /home/tomriddle/wallet/grin-wallet.toml configured and created Please enter your recovery phrase: On the first run, the wallet will scan the entire chain and restore any outputs that belong to you. account The account command is used to manage wallet accounts. Let's print a list of your existing accounts: grin-wallet account Accounts could be thought of as somewhat similar to different bank accounts under the same name. Each account acts as a seperate wallet, but they are all derived from the same master seed. The default account is created when you initialize the wallet. To create a new account, pass the argument -c --create . grin-wallet account -c jedusor This will create a new account called 'jedusor'. All grin-wallet commands can then be passed the argument -a to specify an account for the command (otherwise default account is used), e.g: grin-wallet -a jedusor info info The info command summarizes wallet account balance. grin-wallet info ____ Wallet Summary Info - Account 'default' as of height 813137 ____ Confirmed Total | 5779.473029600 Awaiting Confirmation (< 10) | 0.000000000 Awaiting Finalization | 139.851133700 Locked by previous transaction | 389.859133700 -------------------------------- | ------------- Currently Spendable | 5779.473029600 Confirmed Total is your balance including both spendable coins and those awaiting confirmation. Awaiting Confirmation denotes the balance from transactions that have appeared on-chain, but for which your wallet is waiting a set number of blocks before treating them as spendable (default is 10 blocks). Awaiting Finalization is the balance from transactions that have not yet appeared on-chain. This could be due to the other party not having broadcast the transaction yet. Also, when you are the sender of a transaction, your change output will be denoted in this field as well. Locked by previous transaction shows the amount of coins locked by a previous transaction you have made and that is currently awaiting finalization. This is usually made up both of the amount being sent and of the change outputs waiting to be returned back to your wallet. Once the transaction appears on-chain, this balance unlocks and the output that was used will again become available for spending. address To get your wallet address, enter the address command. grin-wallet address grin1chv9p4uxp3qgl6qp4w6x5p2434varqwl6fdevg6342qr This command outputs the same address as using the listen command. The address serves a triple purpose: If Tor is available, it will serve as your Tor onion address. A key to encrypt the slatepack messages exchanged between you and your counterparty (more on that below). Payment proof identification. Address This is not the same concept of address that other cryptocurrencies might use; A Mimblewimble chain has no addresses. It is used purely for wallet to wallet communication. listen The listen command opens up a Tor listener. grin-wallet listen This will automatically configure a Tor hidden service and makes the wallet listen to it for incoming transactions. This allows you to transact directly through Tor with other users who are sending grins to your grin1... . Your wallet will listen for requests until the process is cancelled ( <Ctrl-C> ). tor or tor.exe need to be available on the system path. send The send command is the first step of building an interactive transaction. The transaction can either be an instant synchronous exchange through Tor, or it can be an asynchronous process, in which each step is done manually by exchanging easily copy-pastable strings called slatepacks. The choice between the two methods is handled automatically by using send in the form of send -d <address> <amount> . grin-wallet send -d grin1dhvv9mvarqwl6fderuxp3qgl6qpphvc9p4u24347ec0mvvg6342q4w6x5r 180 This command tries to send 180 grins to the specified address via Tor. If both wallets are accessible, the transaction would complete immediately with no further steps required. If the above communication fails, for whatever reason, your wallet will output a slatepack message: BEGINSLATEPACK. HctgNGXrJDGFY3B KrEF1meAezGjxQ6 Z93QF6Ps2m9yKCQ LfhZvpDY9ZXViM7 nDoNeMvwtYV2crr 8gDqvYDmtRfLL3n Uabao7VyWR4AuYg TXQUSWU83kEhKmr bRtdRjvpisx1LYo 9cyZGfsgsd7ZvDJ KKZPHhcPe4Eivtv cMvee3nwFFY3ZnM SoULNaHVJ38h3tZ vMXQMoMLB17L53o Xy6QQjDaG8avUBt LQq2GfGRTiUPQgn vQwFzfZPVzVKNLk 5AFmUQFZtiVdTJV xHvc1BuAqcamerv Y76KVccPY3WGupy 4zWFpkjTH65XNiH XqQnkb3EA1iVrHc tyTJ1PWb6X6oV1k ktYiWBpatyTirRy CywPyjr6c8XLr4Q 9VoCedU5BcdFdMB ACqQTwjgVXqjHoS 58ZPKFitjeH67Ts ah6twcKtMaFmTXD i7JEQ7qV6cewgxH 2jwWFxbb98mye6A Lm9movc6Wer26L2 91WQD3cbVpAZLEs APFPtyxnWjv8n3W ZXFLR2TPZwGc5Vt zwFUPoyWfKXasQy VVV6tbKWEEhqAZR e34M7uEwfurpUUi 9812VFPY1qw3K9b ynwQXuXMuWQCUnU s1JqWqFgSQKENUP tGCK19dys9twghA FaAc7ZXQHdMbUoL sVxVfdjE94F1Wpj M7QAM5VZuaauHdQ Mt2erFyxJ5vsYSZ hgS553UKoQL5YWX E7oRNdMDkJV6VkL i55kAQc1vWvW9ce 3MoXiBT4TJ1SyNS NVZKxgk8c. ENDSLATEPACK. This message contains the data required for the receiver's wallet to process the transaction via the receive command. This slatepack is also encypted for the recipient only, since you provided an address (which is a public key) by using the -d flag. Non-encrypted slatepack If the receiver does not want, or is not able to provide an address, you could use command send without the -d --dest flag. grin-wallet send 180 In this case, the wallet will simply output a non-encrypted slatepack message which can be sent to anybody. more flags -m --manual if present, don't attempt to interact via Tor, only output slatepack message. -f --fluff if present, ignore the dandelion relay protocol. Dandelion bounces your transactions directly through several nodes in a stem phase, after which the transaction randomly fluffs (broadcast) to the rest of the network. -n --no_payment_proof if present, do not request the data required for a payment proof. This shortens the slatepack message length. -e --estimate-selection if present, performs a \"dry-run\" of creating the transaction, without actually doing anything and locking the funds. It then lists different output selection strategies (outlined below) and their possible effect on your wallet outputs, if chosen. -s --selection allows you to choose between two output selection strategies, small and all . The default startegy is small , which includes the minimum number of inputs to cover the amount, starting with the smallest value output. In contrast, using all consolidates all of your outputs into a single new output, thus reducing your wallet size, increasing operation speed and reducing the UTXO-set size of the chain. The downside is that the entire contents of your wallet remain locked until the transaction is validated on-chain, and all outputs are linked to one another, a detriment to your privacy. -b --ttl_blocks allows you to specify a number of blocks into the future, after which a wallet should refuse to process the transaction further. This can be useful for putting time limits on transaction finalization, but please note this is not enforced at the grin protocol level; it's up to individual wallets whether they wish to respect this flag. receive The receive command proccesses the slatepack message provided by the sender. grin-wallet receive After entering the command, you'll be prompted to input the slatepack. Then your wallet will output another slatepack message to provide the other party, so they can finalize the transaction. Files When sending or receiving via slatepacks, the wallet will also create a text file containing the message it generated. Default path is ~/.grin/main/slatepacks . finalize The finalize command is the final step to any slatepack transaction. grin-wallet finalize After entering the command, you'll be prompted to input the slatepack message provided to you by the receiver. The transaction building process will then be finalized and your wallet will post it to the network. If the flag -n --nopost is present, the transaction would be finalized but not posted. post Manually post a finalized transaction to the network. Either type grin-wallet post and enter the slatepack message into the prompt, or specify the file path using the -i flag. grin-wallet post -i \"~/.grin/main/slatepacks/my_tx.S3.slatepack/\" proof Grin's privacy and scalability mechanics mean users no longer have the ability to simply prove a transaction has happened by pointing to it on the chain. By default, whenever a transaction sent to a destination addres using -d , a payment proof is created. Payers can then use these proofs to resolve future payment disputes and prove they sent funds to the correct recipient. The sender can export the payment proof by specifying the transaction id ( -i ) (obtained by txs ) or the tx-UUID ( -t ), and choosing the path for the proof file, e.g: grin-wallet export_proof -i 4 \"~/Documents/proof.txt\" The sender can then provide this proof to any other wallet for verification. Verification for e.g. grin-wallet verify_proof /path/proof.txt This will ensure that: The kernel for the transaction in the proof is validated and can be found on-chain. Both the sender and recipient's signatures correctly sign for the amount and the kernel. On top of that, if the receiver's address in the transaction belongs to the same wallet who's verifying, then the user will be informed as follows: grin-wallet verify_proof proof.txt Payment proof's signatures are valid. The proof's recipient address belongs to this wallet. Command 'verify_proof' completed successfully invoice The invoice command sends an invoice transaction, in which the initiator requests an amount for payment and sends that request to another party. Since invoice transactions require manual confirmation from the party paying the funds, they can only be created and sent to payers via slatepack. grin-wallet invoice -d grin1dhvv9mvarqwl6fderuxp3qgl6qpphvc9p4u24347ec0mvvg6342q4w6x5r 60 This command will create an encypted (since -d is provided) invoice, requesting a payment of 60 grins. The resulting slatepack can then be sent to the other party for them to pay . Upon receiving the back the slatepack from the payer, the transaction can then be finalized and posted using the finalize command. pay After receiving an invoice request, the payer can use the pay command to decode (also decrypt if possible) the slatepack and confirm the amount of coins being requested as payment. grin-wallet pay Please paste your encoded slatepack message: BEGINSLATEPACK. P9rVoTRyKdhVsuC a5SfwQMXbtsDBwD omfeWYWwkbK9AUD k2pZvpgeXmJSUcv y9Mi81ngsCrpW9r QW226CWwbxrSprJ cCJA9cACpguBHDj eExN8vuYc1SHj9B 2Xa1BPGB77kpY9q uG9eXmaeprY6CQt PAibwfMnwxVDJFU EeQfwwSnEUADkg3 wBYXcuSVTnfJ4Jj DnqawMkmAiWvhNm WLrdZ1Vh3P6TXP6 ZgJG9pRNi51mAtU 9soyVAgvFWoEpgn VA6suegVxTsWN1r V3LQHB7bjwX5Rwa yPfqhGTLwR. ENDSLATEPACK. This command will pay the amount specified in the invoice using your wallet's funds. After you confirm, the following will occur: * 10.000000000 of your wallet funds will be added to the transaction to pay this invoice. * The wallet will IMMEDIATELY attempt to send the resulting transaction to the wallet listening at: 'grin1ln4y82fw4urggk3hq0xkeqfhw3dfe6rhcv6a0v64uz4ny9epcc6qpuwx4k'. * If other wallet is not listening, the resulting transaction will output as a slatepack which you can manually send back to the invoice creator. Please review the above information carefully before proceeding To proceed, type the exact amount of the invoice as displayed above (or Q/q to quit) > To confirm the payment, type the exact amount in decimal, 10.000000000 in this example, into the prompt. Your wallet will then fill out the transaction slate and return a slatepack for you to provide back to the initiator, which they can then finalize . unpack Upon receiving a slatepack message or file from a party, whether in an encrypted form or not, the unpack command decrypts and decodes it to a bare slate JSON format (the format used by the wallet to read and contruct transactions). grin-wallet unpack This prompts you for a slatepack message. to decode a file, use the -i flag and provide the path. Result: SLATEPACK CONTENTS ------------------ { ... } ------------------ Slatepack is encrypted for this wallet DECRYPTED SLATEPACK ------------------- { ... } DECRYPTED SLATE --------------- { ... } Command 'unpack' completed successfully outputs To show a list of all your wallet's outputs, type: grin-wallet outputs allet Outputs - Account 'default' - Block Height: 814491 --------------------------------------------------------------------------------------------------------------------------------------------------------------- Output Commitment MMR Index Block Height Locked Until Status Coinbase? # Confirms Value Tx =============================================================================================================================================================== 08f4f062b99223d2d8a1ad1ae11085ab2d7b4f1bc603f9c29748f1b918861fdf23 7498573 743936 743936 Unspent false 70556 5198.081029600 1 --------------------------------------------------------------------------------------------------------------------------------------------------------------- 097fe8bf1ad6a792600d5e010d0b77c40b147ea122c176476259f100a48924d40c 7832632 790025 790025 Unspent false 24467 581.392000000 2 --------------------------------------------------------------------------------------------------------------------------------------------------------------- 08645896f150bfc70f36a602a7a5f41180ae8d5db42864f19f7257542cf2c7fc98 None 811501 0 Unspent false 2991 389.859133700 9 --------------------------------------------------------------------------------------------------------------------------------------------------------------- By default, only unspent outputs are listed. To show spent outputs, provide the -s flag. grin-wallet -s outputs txs Every time an action is performed in your wallet (send, receive, even if uncompleted), an entry is added to an internal transaction log containing vital information about the transaction. Because the grin blockchain contains no identifying information whatsoever, this transaction log is necessary for your wallet to keep track of transactions. To view the contents of your transaction log, use the command: grin-wallet txs Transaction Log - Account 'default' - Block Height: 814448 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Id Type Shared Transaction Id Creation Time TTL Cutoff Height Confirmed? Confirmation Time Num. Num. Amount Amount Fee Net Payment Kernel Tx Inputs Outputs Credited Debited Difference Proof Data ===================================================================================================================================================================================================================================================================================== 0 Received Tx 2b2ffc5e-8fa0-4450-b270-078df29b3e23 2020-07-28 13:18:18 None true 2020-07-28 13:18:18 0 1 389.892 0.0 0.007 389.892 None ddec166399348a24d2893c025b4b4d4a058f81834a663284ba23fe0bd0ac025b4b Yes ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1 Sent Tx fd9b3035-73d0-4ea3-8c3e-5d45c512ad8b 2020-08-03 15:32:19 None true 2020-08-03 15:42:20 2 1 389.8591337 390.8661337 0.007 -1.007 Yes 0834a66310df8a8b43093c025b4b4d4a058f8188ee24d2809e338e0bd0ae9e2c2c Yes ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2 Sent Tx ea92fcce-8fa0-48d0-b270-078df2e22d24 2020-08-04 18:51:47 None false None 1 1 139.8511337 389.8591337 0.008 -250.008 None 09fd95b4e40ce1c2d67376d46dc37ddec1aa0ae50ca9934ba271fff0b47510c72f Yes - Cancelled ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- To see the inputs & outputs associated with a particular transaction, as well as the payment proof associated with the transaction, use the -i switch and specify the id of the transaction, e.g: grin-wallet txs -i 0 cancel Cancels an in-progress created transaction, freeing previously locked outputs for use again. grin-wallet cancel -i 2 To specify which transaction to cancel, use the -i flag along with the tx id (obtained by txs ) or the -t flag with the tx-UUID. scan The scan command scans the entire UTXO (unspent tx outputs) set from the node, identifies which outputs are yours and updates your wallet state. grin-wallet scan It should not be necessary to run the scan command manually, as the wallet continually scans the outputs on the chain. However, if for some reason you believe your outputs and transactions are in an inconsistent state, you can initiate a manual scan to attempt to fix or restore them. flags -d --delete-unconfirmed if present, scan and cancel all pending transactions, freeing up any locked outputs. -h --start-height lets you specify a block height from which to start the manual scan. When initializing a wallet from an existing seed via the grin-wallet init -r command , this scan is performed automatically on the first run. recover The recover command displays the existing wallet's 24 (or 12) word seed phrase. grin-wallet recover arguments There are several global wallet arguments which you can provide for every command. account To set the account for a wallet command, provide the -a argument. grin-wallet -a jedusor info password You could specify your password on the directly command line by providing the -p argument. Please note this will place your password in your shell's command history, so use this switch with caution. grin-wallet -p mypass info node The wallet needs to talk to a running grin node in order to remain up-to-date and verify its contents. By default, it tries to contact a node at 127.0.0.1:3413. To change this, either modify the value in the grin_wallet.toml file, or alternatively, you can provide the -r (se r ver) switch to wallet commands. grin-wallet -r \"http://192.168.0.2:3413\" info","title":"CLI Handbook"},{"location":"getting-started/wallet-handbook/#cli-wallet-user-handbook","text":"Now that you've set up your node and learned how to form a simple transaction, let's get to know the wallet more deeply. The following document is an extremely comprehensive user guide to the reference grin wallet implementation, grin-wallet v4.0.0 . GUI Wallet Instructions on how to transact with a graphical user interface can be found in wallets .","title":"CLI Wallet User Handbook"},{"location":"getting-started/wallet-handbook/#file-structure","text":"By default, grin will create all wallet files in the hidden directory .grin under your home directory (i.e. ~/.grin ). You can also create and use a wallet with data files in a custom directory, as will be explained later. A grin wallet maintains its state in an LMDB database, with the master seed stored in a separate file. When creating a new wallet, the file structure should be as follows: [wallet directory] \u251c\u2500\u2500 grin-wallet.log \u251c\u2500\u2500 grin-wallet.toml \u251c\u2500\u2500 tor \u2514\u2500\u2500 wallet_data \u251c\u2500\u2500 db \u2502 \u2514\u2500\u2500 lmdb \u2502 \u2514\u2500\u2500 wallet.seed grin-wallet.toml contains configuration information for the wallet. You can modify values within to change ports, the address of your grin node, or logging values. wallet.seed is your master seed file; the private keys of all your outputs are derived from it, and its contents are encrypted with your wallet password. The seed file can be recovered using the seed phrase. tor folder contains Tor configuration files used by the wallet listener. There should be no need to manipulate anything in this directory manually. Tor Configuration \u21b4 grin-wallet.toml contains a [tor] section used to configure values when sending or listening via TOR: use_tor_listener specifies whether the Tor listener should also be invoked when starting the wallet listener via listen (default = true). socks_proxy_addr contains the listening address of TOR's socks proxy port. This should generally be left alone.","title":"File Structure"},{"location":"getting-started/wallet-handbook/#help","text":"grin-wallet help will display all the commands and every global flag. To get additional info about a specific command type grin-wallet help [command] , e.g: grin-wallet help send You can also pass --help or -h .","title":"help"},{"location":"getting-started/wallet-handbook/#init","text":"Before doing anything else, the wallet files need to be generated via the init command: grin-wallet init You'll be prompted to enter a password for the new wallet. It will be used to encrypt your master.seed file and you'll be asked to type it for most wallet commands. By default, your wallet files will be placed into `~/.grin . Alternatively, if you'd like to run a wallet in a directory of your choice, you can create one in the current directory by using flag -h , e.g: grin-wallet init -h This will create all the needed data files, including grin-wallet.toml and wallet.seed , in the current directory. When running any grin-wallet command, grin will check the working directory if these files exist. If not, it will use the default location ~/.grin . Upon a successful init , the wallet prints a 24-word recovery phrase, which you should write down and store in a non-digital format. This phrase can be used to re-create your master seed file if it gets lost or corrupted, or if you forget the wallet password. If you'd prefer to use a 12-word recovery phrase, you can use the -s --short_wordlist flag.","title":"init"},{"location":"getting-started/wallet-handbook/#init-recover","text":"If you need to recreate your wallet from an existing seed, you can init a wallet with a recovery phrase using the -r --recover flag. For example, the following command initializes a wallet in the current directory. grin-wallet init -hr File /home/tomriddle/wallet/grin-wallet.toml configured and created Please enter your recovery phrase: On the first run, the wallet will scan the entire chain and restore any outputs that belong to you.","title":"init --recover"},{"location":"getting-started/wallet-handbook/#account","text":"The account command is used to manage wallet accounts. Let's print a list of your existing accounts: grin-wallet account Accounts could be thought of as somewhat similar to different bank accounts under the same name. Each account acts as a seperate wallet, but they are all derived from the same master seed. The default account is created when you initialize the wallet. To create a new account, pass the argument -c --create . grin-wallet account -c jedusor This will create a new account called 'jedusor'. All grin-wallet commands can then be passed the argument -a to specify an account for the command (otherwise default account is used), e.g: grin-wallet -a jedusor info","title":"account"},{"location":"getting-started/wallet-handbook/#info","text":"The info command summarizes wallet account balance. grin-wallet info ____ Wallet Summary Info - Account 'default' as of height 813137 ____ Confirmed Total | 5779.473029600 Awaiting Confirmation (< 10) | 0.000000000 Awaiting Finalization | 139.851133700 Locked by previous transaction | 389.859133700 -------------------------------- | ------------- Currently Spendable | 5779.473029600 Confirmed Total is your balance including both spendable coins and those awaiting confirmation. Awaiting Confirmation denotes the balance from transactions that have appeared on-chain, but for which your wallet is waiting a set number of blocks before treating them as spendable (default is 10 blocks). Awaiting Finalization is the balance from transactions that have not yet appeared on-chain. This could be due to the other party not having broadcast the transaction yet. Also, when you are the sender of a transaction, your change output will be denoted in this field as well. Locked by previous transaction shows the amount of coins locked by a previous transaction you have made and that is currently awaiting finalization. This is usually made up both of the amount being sent and of the change outputs waiting to be returned back to your wallet. Once the transaction appears on-chain, this balance unlocks and the output that was used will again become available for spending.","title":"info"},{"location":"getting-started/wallet-handbook/#address","text":"To get your wallet address, enter the address command. grin-wallet address grin1chv9p4uxp3qgl6qp4w6x5p2434varqwl6fdevg6342qr This command outputs the same address as using the listen command. The address serves a triple purpose: If Tor is available, it will serve as your Tor onion address. A key to encrypt the slatepack messages exchanged between you and your counterparty (more on that below). Payment proof identification. Address This is not the same concept of address that other cryptocurrencies might use; A Mimblewimble chain has no addresses. It is used purely for wallet to wallet communication.","title":"address"},{"location":"getting-started/wallet-handbook/#listen","text":"The listen command opens up a Tor listener. grin-wallet listen This will automatically configure a Tor hidden service and makes the wallet listen to it for incoming transactions. This allows you to transact directly through Tor with other users who are sending grins to your grin1... . Your wallet will listen for requests until the process is cancelled ( <Ctrl-C> ). tor or tor.exe need to be available on the system path.","title":"listen"},{"location":"getting-started/wallet-handbook/#send","text":"The send command is the first step of building an interactive transaction. The transaction can either be an instant synchronous exchange through Tor, or it can be an asynchronous process, in which each step is done manually by exchanging easily copy-pastable strings called slatepacks. The choice between the two methods is handled automatically by using send in the form of send -d <address> <amount> . grin-wallet send -d grin1dhvv9mvarqwl6fderuxp3qgl6qpphvc9p4u24347ec0mvvg6342q4w6x5r 180 This command tries to send 180 grins to the specified address via Tor. If both wallets are accessible, the transaction would complete immediately with no further steps required. If the above communication fails, for whatever reason, your wallet will output a slatepack message: BEGINSLATEPACK. HctgNGXrJDGFY3B KrEF1meAezGjxQ6 Z93QF6Ps2m9yKCQ LfhZvpDY9ZXViM7 nDoNeMvwtYV2crr 8gDqvYDmtRfLL3n Uabao7VyWR4AuYg TXQUSWU83kEhKmr bRtdRjvpisx1LYo 9cyZGfsgsd7ZvDJ KKZPHhcPe4Eivtv cMvee3nwFFY3ZnM SoULNaHVJ38h3tZ vMXQMoMLB17L53o Xy6QQjDaG8avUBt LQq2GfGRTiUPQgn vQwFzfZPVzVKNLk 5AFmUQFZtiVdTJV xHvc1BuAqcamerv Y76KVccPY3WGupy 4zWFpkjTH65XNiH XqQnkb3EA1iVrHc tyTJ1PWb6X6oV1k ktYiWBpatyTirRy CywPyjr6c8XLr4Q 9VoCedU5BcdFdMB ACqQTwjgVXqjHoS 58ZPKFitjeH67Ts ah6twcKtMaFmTXD i7JEQ7qV6cewgxH 2jwWFxbb98mye6A Lm9movc6Wer26L2 91WQD3cbVpAZLEs APFPtyxnWjv8n3W ZXFLR2TPZwGc5Vt zwFUPoyWfKXasQy VVV6tbKWEEhqAZR e34M7uEwfurpUUi 9812VFPY1qw3K9b ynwQXuXMuWQCUnU s1JqWqFgSQKENUP tGCK19dys9twghA FaAc7ZXQHdMbUoL sVxVfdjE94F1Wpj M7QAM5VZuaauHdQ Mt2erFyxJ5vsYSZ hgS553UKoQL5YWX E7oRNdMDkJV6VkL i55kAQc1vWvW9ce 3MoXiBT4TJ1SyNS NVZKxgk8c. ENDSLATEPACK. This message contains the data required for the receiver's wallet to process the transaction via the receive command. This slatepack is also encypted for the recipient only, since you provided an address (which is a public key) by using the -d flag. Non-encrypted slatepack If the receiver does not want, or is not able to provide an address, you could use command send without the -d --dest flag. grin-wallet send 180 In this case, the wallet will simply output a non-encrypted slatepack message which can be sent to anybody.","title":"send"},{"location":"getting-started/wallet-handbook/#more-flags","text":"-m --manual if present, don't attempt to interact via Tor, only output slatepack message. -f --fluff if present, ignore the dandelion relay protocol. Dandelion bounces your transactions directly through several nodes in a stem phase, after which the transaction randomly fluffs (broadcast) to the rest of the network. -n --no_payment_proof if present, do not request the data required for a payment proof. This shortens the slatepack message length. -e --estimate-selection if present, performs a \"dry-run\" of creating the transaction, without actually doing anything and locking the funds. It then lists different output selection strategies (outlined below) and their possible effect on your wallet outputs, if chosen. -s --selection allows you to choose between two output selection strategies, small and all . The default startegy is small , which includes the minimum number of inputs to cover the amount, starting with the smallest value output. In contrast, using all consolidates all of your outputs into a single new output, thus reducing your wallet size, increasing operation speed and reducing the UTXO-set size of the chain. The downside is that the entire contents of your wallet remain locked until the transaction is validated on-chain, and all outputs are linked to one another, a detriment to your privacy. -b --ttl_blocks allows you to specify a number of blocks into the future, after which a wallet should refuse to process the transaction further. This can be useful for putting time limits on transaction finalization, but please note this is not enforced at the grin protocol level; it's up to individual wallets whether they wish to respect this flag.","title":"more flags"},{"location":"getting-started/wallet-handbook/#receive","text":"The receive command proccesses the slatepack message provided by the sender. grin-wallet receive After entering the command, you'll be prompted to input the slatepack. Then your wallet will output another slatepack message to provide the other party, so they can finalize the transaction. Files When sending or receiving via slatepacks, the wallet will also create a text file containing the message it generated. Default path is ~/.grin/main/slatepacks .","title":"receive"},{"location":"getting-started/wallet-handbook/#finalize","text":"The finalize command is the final step to any slatepack transaction. grin-wallet finalize After entering the command, you'll be prompted to input the slatepack message provided to you by the receiver. The transaction building process will then be finalized and your wallet will post it to the network. If the flag -n --nopost is present, the transaction would be finalized but not posted.","title":"finalize"},{"location":"getting-started/wallet-handbook/#post","text":"Manually post a finalized transaction to the network. Either type grin-wallet post and enter the slatepack message into the prompt, or specify the file path using the -i flag. grin-wallet post -i \"~/.grin/main/slatepacks/my_tx.S3.slatepack/\"","title":"post"},{"location":"getting-started/wallet-handbook/#proof","text":"Grin's privacy and scalability mechanics mean users no longer have the ability to simply prove a transaction has happened by pointing to it on the chain. By default, whenever a transaction sent to a destination addres using -d , a payment proof is created. Payers can then use these proofs to resolve future payment disputes and prove they sent funds to the correct recipient. The sender can export the payment proof by specifying the transaction id ( -i ) (obtained by txs ) or the tx-UUID ( -t ), and choosing the path for the proof file, e.g: grin-wallet export_proof -i 4 \"~/Documents/proof.txt\" The sender can then provide this proof to any other wallet for verification. Verification for e.g. grin-wallet verify_proof /path/proof.txt This will ensure that: The kernel for the transaction in the proof is validated and can be found on-chain. Both the sender and recipient's signatures correctly sign for the amount and the kernel. On top of that, if the receiver's address in the transaction belongs to the same wallet who's verifying, then the user will be informed as follows: grin-wallet verify_proof proof.txt Payment proof's signatures are valid. The proof's recipient address belongs to this wallet. Command 'verify_proof' completed successfully","title":"proof"},{"location":"getting-started/wallet-handbook/#invoice","text":"The invoice command sends an invoice transaction, in which the initiator requests an amount for payment and sends that request to another party. Since invoice transactions require manual confirmation from the party paying the funds, they can only be created and sent to payers via slatepack. grin-wallet invoice -d grin1dhvv9mvarqwl6fderuxp3qgl6qpphvc9p4u24347ec0mvvg6342q4w6x5r 60 This command will create an encypted (since -d is provided) invoice, requesting a payment of 60 grins. The resulting slatepack can then be sent to the other party for them to pay . Upon receiving the back the slatepack from the payer, the transaction can then be finalized and posted using the finalize command.","title":"invoice"},{"location":"getting-started/wallet-handbook/#pay","text":"After receiving an invoice request, the payer can use the pay command to decode (also decrypt if possible) the slatepack and confirm the amount of coins being requested as payment. grin-wallet pay Please paste your encoded slatepack message: BEGINSLATEPACK. P9rVoTRyKdhVsuC a5SfwQMXbtsDBwD omfeWYWwkbK9AUD k2pZvpgeXmJSUcv y9Mi81ngsCrpW9r QW226CWwbxrSprJ cCJA9cACpguBHDj eExN8vuYc1SHj9B 2Xa1BPGB77kpY9q uG9eXmaeprY6CQt PAibwfMnwxVDJFU EeQfwwSnEUADkg3 wBYXcuSVTnfJ4Jj DnqawMkmAiWvhNm WLrdZ1Vh3P6TXP6 ZgJG9pRNi51mAtU 9soyVAgvFWoEpgn VA6suegVxTsWN1r V3LQHB7bjwX5Rwa yPfqhGTLwR. ENDSLATEPACK. This command will pay the amount specified in the invoice using your wallet's funds. After you confirm, the following will occur: * 10.000000000 of your wallet funds will be added to the transaction to pay this invoice. * The wallet will IMMEDIATELY attempt to send the resulting transaction to the wallet listening at: 'grin1ln4y82fw4urggk3hq0xkeqfhw3dfe6rhcv6a0v64uz4ny9epcc6qpuwx4k'. * If other wallet is not listening, the resulting transaction will output as a slatepack which you can manually send back to the invoice creator. Please review the above information carefully before proceeding To proceed, type the exact amount of the invoice as displayed above (or Q/q to quit) > To confirm the payment, type the exact amount in decimal, 10.000000000 in this example, into the prompt. Your wallet will then fill out the transaction slate and return a slatepack for you to provide back to the initiator, which they can then finalize .","title":"pay"},{"location":"getting-started/wallet-handbook/#unpack","text":"Upon receiving a slatepack message or file from a party, whether in an encrypted form or not, the unpack command decrypts and decodes it to a bare slate JSON format (the format used by the wallet to read and contruct transactions). grin-wallet unpack This prompts you for a slatepack message. to decode a file, use the -i flag and provide the path. Result: SLATEPACK CONTENTS ------------------ { ... } ------------------ Slatepack is encrypted for this wallet DECRYPTED SLATEPACK ------------------- { ... } DECRYPTED SLATE --------------- { ... } Command 'unpack' completed successfully","title":"unpack"},{"location":"getting-started/wallet-handbook/#outputs","text":"To show a list of all your wallet's outputs, type: grin-wallet outputs allet Outputs - Account 'default' - Block Height: 814491 --------------------------------------------------------------------------------------------------------------------------------------------------------------- Output Commitment MMR Index Block Height Locked Until Status Coinbase? # Confirms Value Tx =============================================================================================================================================================== 08f4f062b99223d2d8a1ad1ae11085ab2d7b4f1bc603f9c29748f1b918861fdf23 7498573 743936 743936 Unspent false 70556 5198.081029600 1 --------------------------------------------------------------------------------------------------------------------------------------------------------------- 097fe8bf1ad6a792600d5e010d0b77c40b147ea122c176476259f100a48924d40c 7832632 790025 790025 Unspent false 24467 581.392000000 2 --------------------------------------------------------------------------------------------------------------------------------------------------------------- 08645896f150bfc70f36a602a7a5f41180ae8d5db42864f19f7257542cf2c7fc98 None 811501 0 Unspent false 2991 389.859133700 9 --------------------------------------------------------------------------------------------------------------------------------------------------------------- By default, only unspent outputs are listed. To show spent outputs, provide the -s flag. grin-wallet -s outputs","title":"outputs"},{"location":"getting-started/wallet-handbook/#txs","text":"Every time an action is performed in your wallet (send, receive, even if uncompleted), an entry is added to an internal transaction log containing vital information about the transaction. Because the grin blockchain contains no identifying information whatsoever, this transaction log is necessary for your wallet to keep track of transactions. To view the contents of your transaction log, use the command: grin-wallet txs Transaction Log - Account 'default' - Block Height: 814448 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Id Type Shared Transaction Id Creation Time TTL Cutoff Height Confirmed? Confirmation Time Num. Num. Amount Amount Fee Net Payment Kernel Tx Inputs Outputs Credited Debited Difference Proof Data ===================================================================================================================================================================================================================================================================================== 0 Received Tx 2b2ffc5e-8fa0-4450-b270-078df29b3e23 2020-07-28 13:18:18 None true 2020-07-28 13:18:18 0 1 389.892 0.0 0.007 389.892 None ddec166399348a24d2893c025b4b4d4a058f81834a663284ba23fe0bd0ac025b4b Yes ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1 Sent Tx fd9b3035-73d0-4ea3-8c3e-5d45c512ad8b 2020-08-03 15:32:19 None true 2020-08-03 15:42:20 2 1 389.8591337 390.8661337 0.007 -1.007 Yes 0834a66310df8a8b43093c025b4b4d4a058f8188ee24d2809e338e0bd0ae9e2c2c Yes ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2 Sent Tx ea92fcce-8fa0-48d0-b270-078df2e22d24 2020-08-04 18:51:47 None false None 1 1 139.8511337 389.8591337 0.008 -250.008 None 09fd95b4e40ce1c2d67376d46dc37ddec1aa0ae50ca9934ba271fff0b47510c72f Yes - Cancelled ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- To see the inputs & outputs associated with a particular transaction, as well as the payment proof associated with the transaction, use the -i switch and specify the id of the transaction, e.g: grin-wallet txs -i 0","title":"txs"},{"location":"getting-started/wallet-handbook/#cancel","text":"Cancels an in-progress created transaction, freeing previously locked outputs for use again. grin-wallet cancel -i 2 To specify which transaction to cancel, use the -i flag along with the tx id (obtained by txs ) or the -t flag with the tx-UUID.","title":"cancel"},{"location":"getting-started/wallet-handbook/#scan","text":"The scan command scans the entire UTXO (unspent tx outputs) set from the node, identifies which outputs are yours and updates your wallet state. grin-wallet scan It should not be necessary to run the scan command manually, as the wallet continually scans the outputs on the chain. However, if for some reason you believe your outputs and transactions are in an inconsistent state, you can initiate a manual scan to attempt to fix or restore them. flags -d --delete-unconfirmed if present, scan and cancel all pending transactions, freeing up any locked outputs. -h --start-height lets you specify a block height from which to start the manual scan. When initializing a wallet from an existing seed via the grin-wallet init -r command , this scan is performed automatically on the first run.","title":"scan"},{"location":"getting-started/wallet-handbook/#recover","text":"The recover command displays the existing wallet's 24 (or 12) word seed phrase. grin-wallet recover","title":"recover"},{"location":"getting-started/wallet-handbook/#arguments","text":"There are several global wallet arguments which you can provide for every command.","title":"arguments"},{"location":"getting-started/wallet-handbook/#account_1","text":"To set the account for a wallet command, provide the -a argument. grin-wallet -a jedusor info","title":"account"},{"location":"getting-started/wallet-handbook/#password","text":"You could specify your password on the directly command line by providing the -p argument. Please note this will place your password in your shell's command history, so use this switch with caution. grin-wallet -p mypass info","title":"password"},{"location":"getting-started/wallet-handbook/#node","text":"The wallet needs to talk to a running grin node in order to remain up-to-date and verify its contents. By default, it tries to contact a node at 127.0.0.1:3413. To change this, either modify the value in the grin_wallet.toml file, or alternatively, you can provide the -r (se r ver) switch to wallet commands. grin-wallet -r \"http://192.168.0.2:3413\" info","title":"node"},{"location":"getting-started/wallets/","text":"Grin Wallets \u2003Grin++ GUI wallet and node written in C++ \u2003 Windows, Linux, macOS How to: send/receive Download Download at grinplusplus.github.io Troubleshooting Receive Copy your address ( grin1... ) and provide it to the other party. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are: The sender will provide you a Slatepack message. Paste it into the Slatepack box and click Receive. Copy the Slatepack message your wallet generates. Provide it to the sender. Done! The sender will finalize the transaction and post it to the network. Send Click send. Choose the amount of grins. Enter the receiver's address and send. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are: Copy the Slatepack message your wallet generates and provide it to the receiver (however you want). You should get a Slatepack message back from the receiver. Paste it into the Slatepack box and click Finalize. Done! Your wallet will now finalize the transaction and post it to the network. \u2003Niffler GUI wallet and node using the Rust implementation as back-end \u2003 Windows, Linux, macOS How to: send/receive Download Download at github.com/grinfans/niffler/releases (by clicking on one of the listed download links) Receive Click on Receive, then Slatepack address. Copy your address ( grin1... ) and provide it to the other party. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are:* The sender will provide you a Slatepack message. Click again on Receive, then on Create response slatepack. Paste it into the Slatepack box and click Create response slatepack. Copy the new Slatepack message your wallet generates. Provide it to the sender. Done! The sender will then finalize the transaction and post it to the network. Send Click on Send, then Create slatepack. Enter the address and amount, then Create slatepack. Copy the Slatepack message your wallet generates and provide it to the receiver (however you want). You should get a Slatepack message back from the receiver. Click on Send, then on Finalize. Paste the Slatepack message into the box and confirm. Done! Your wallet will now finalize the transaction and post it to the network. \u2003Ironbelly Mobile wallet \u2003 iOS, Android How to: send/receive Download Download at https://ironbelly.app Receive Soon Send Soon Related Services \u2003Grinnode.live Public GRIN API and sync service","title":"Wallets"},{"location":"getting-started/wallets/#grin-wallets","text":"","title":"Grin Wallets"},{"location":"getting-started/wallets/#grin","text":"GUI wallet and node written in C++ \u2003 Windows, Linux, macOS How to: send/receive Download Download at grinplusplus.github.io Troubleshooting Receive Copy your address ( grin1... ) and provide it to the other party. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are: The sender will provide you a Slatepack message. Paste it into the Slatepack box and click Receive. Copy the Slatepack message your wallet generates. Provide it to the sender. Done! The sender will finalize the transaction and post it to the network. Send Click send. Choose the amount of grins. Enter the receiver's address and send. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are: Copy the Slatepack message your wallet generates and provide it to the receiver (however you want). You should get a Slatepack message back from the receiver. Paste it into the Slatepack box and click Finalize. Done! Your wallet will now finalize the transaction and post it to the network.","title":"&emsp;Grin++"},{"location":"getting-started/wallets/#niffler","text":"GUI wallet and node using the Rust implementation as back-end \u2003 Windows, Linux, macOS How to: send/receive Download Download at github.com/grinfans/niffler/releases (by clicking on one of the listed download links) Receive Click on Receive, then Slatepack address. Copy your address ( grin1... ) and provide it to the other party. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are:* The sender will provide you a Slatepack message. Click again on Receive, then on Create response slatepack. Paste it into the Slatepack box and click Create response slatepack. Copy the new Slatepack message your wallet generates. Provide it to the sender. Done! The sender will then finalize the transaction and post it to the network. Send Click on Send, then Create slatepack. Enter the address and amount, then Create slatepack. Copy the Slatepack message your wallet generates and provide it to the receiver (however you want). You should get a Slatepack message back from the receiver. Click on Send, then on Finalize. Paste the Slatepack message into the box and confirm. Done! Your wallet will now finalize the transaction and post it to the network.","title":"&emsp;Niffler"},{"location":"getting-started/wallets/#ironbelly","text":"Mobile wallet \u2003 iOS, Android How to: send/receive Download Download at https://ironbelly.app Receive Soon Send Soon","title":"&emsp;Ironbelly"},{"location":"getting-started/wallets/#related-services","text":"","title":"Related Services"},{"location":"getting-started/wallets/#grinnodelive","text":"Public GRIN API and sync service","title":"&emsp;Grinnode.live"},{"location":"getting-started/quickstart/initialize/","text":"Initializing Node and Wallet Running a Grin Node The rest of the documentation is common for Linux, macOS and Windows. Running a Grin node is as simple as typing the command: grin You should see the following window: Congratulations! \ud83c\udf89 You are now running a Grin full node. The initial sync might take anywhere from 30 minutes to a few hours depending on your connection speed and CPU performance. If you have a good Internet connection, you can help strengthen the network by keeping your PC running with a grin node and port 3414 open . All data files will be created at the hidden folder ~/.grin (under your home directory). Inside this folder, of special interest is the file grin-server.toml which can be used to modify configuration options. Creating a Grin Wallet While your node is syncing, let's initalize a new Grin wallet. In the command prompt type the following: grin-wallet init Your wallet will now ask you to create a password. Most wallet commands will require it, so you'll be typing the password quite often. In order to hide it, your keyboard input will not be displayed. Please enter a password for your new wallet Password: Confirm Password: Next, the wallet will show your recovery-phrase: Your recovery phrase is: fire execute festival romance just void lecture leopard balcony trick waste castle undo master custom ordinary million slam wise oil whisper mechanic episode room This phrase is a list of 24 words which encode all the information needed to recover your wallet. If your computer breaks or your hard drive becomes corrupted, you can enter grin-wallet init -r and type the phrase to recover your grins. Store it safely, preferably in a non-digital format.","title":"Initialize"},{"location":"getting-started/quickstart/initialize/#initializing-node-and-wallet","text":"","title":"Initializing Node and Wallet"},{"location":"getting-started/quickstart/initialize/#running-a-grin-node","text":"The rest of the documentation is common for Linux, macOS and Windows. Running a Grin node is as simple as typing the command: grin You should see the following window: Congratulations! \ud83c\udf89 You are now running a Grin full node. The initial sync might take anywhere from 30 minutes to a few hours depending on your connection speed and CPU performance. If you have a good Internet connection, you can help strengthen the network by keeping your PC running with a grin node and port 3414 open . All data files will be created at the hidden folder ~/.grin (under your home directory). Inside this folder, of special interest is the file grin-server.toml which can be used to modify configuration options.","title":"Running a Grin Node"},{"location":"getting-started/quickstart/initialize/#creating-a-grin-wallet","text":"While your node is syncing, let's initalize a new Grin wallet. In the command prompt type the following: grin-wallet init Your wallet will now ask you to create a password. Most wallet commands will require it, so you'll be typing the password quite often. In order to hide it, your keyboard input will not be displayed. Please enter a password for your new wallet Password: Confirm Password: Next, the wallet will show your recovery-phrase: Your recovery phrase is: fire execute festival romance just void lecture leopard balcony trick waste castle undo master custom ordinary million slam wise oil whisper mechanic episode room This phrase is a list of 24 words which encode all the information needed to recover your wallet. If your computer breaks or your hard drive becomes corrupted, you can enter grin-wallet init -r and type the phrase to recover your grins. Store it safely, preferably in a non-digital format.","title":"Creating a Grin Wallet"},{"location":"getting-started/quickstart/install/","text":"Install GUI Wallet To use Grin with a graphical user interface, see wallets . The Quickstart series will guide you in your first steps of installing a Grin node, creating a wallet, and making a transaction. We begin by downloading the precompiled binaries. grin - grin node. grin-wallet - command-line wallet. First, choose your operating system: Linux macOS Windows Linux Go to grin.mw/download and download the tgz files of grin and grin-wallet by clicking on their name titles. To verify the release, calculate the sha256sum of the binaries and compare the result against their respective SHA256 HASH on the website (or in releases ). sha256sum grin-wallet- $VERSION -linux-amd64.tar.gz sha256sum grin- $VERSION -linux-amd64.tar.gz Replace $VESION with the appropriate version for each binary, e.g. v4.0.2 Next, in the terminal, navigate to the directory where the files were downloaded and type: sudo tar -C /usr/local/bin -xzf grin- $VERSION -linux-amd64.tar.gz --strip-components = 1 sudo tar -C /usr/local/bin -xzf grin-wallet- $VERSION -linux-amd64.tar.gz --strip-components = 1 libncursesw error \u21b4 If you have the following error when you start grin: grin: error while loading shared libraries: libncursesw.so.5: cannot open shared object file: No such file or directory Then install libncursesw5 : sudo apt install libncursesw5 And you're done! Snap Store You can also install everything as Snap package , however, note that you can't verify its content. To install, type: snap install grin When installed with Snap, grin-wallet is accessible using the grin.wallet command instead of grin-wallet . macOS The easiest way to install grin and grin-wallet on macOS is with homebrew . If you do not have homebrew installed, open the \"Terminal.app\" and paste the following line: /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \" This will install homebrew on your computer. Once it's finished, you can simply install the binaries: brew install grin grin-wallet Windows Go to grin.mw/download and download the zip files of grin and grin-wallet by clicking on their name titles. We recommend that you create a directory called Grin in C:\\Users\\%USER%\\AppData\\Local . The parent directory is where most user windows apps are installed, but if you want to put them somewhere else, that'll work too. In this directory, extract both binaries grin.exe and grin-wallet.exe . Then, add them to your path by typing in the terminal: set PATH=%PATH%;C:\\Users\\%USER%\\AppData\\Local Remember to replace %USER% That's it, you're done!","title":"Install"},{"location":"getting-started/quickstart/install/#install","text":"GUI Wallet To use Grin with a graphical user interface, see wallets . The Quickstart series will guide you in your first steps of installing a Grin node, creating a wallet, and making a transaction. We begin by downloading the precompiled binaries. grin - grin node. grin-wallet - command-line wallet. First, choose your operating system: Linux macOS Windows","title":"Install"},{"location":"getting-started/quickstart/install/#linux","text":"Go to grin.mw/download and download the tgz files of grin and grin-wallet by clicking on their name titles. To verify the release, calculate the sha256sum of the binaries and compare the result against their respective SHA256 HASH on the website (or in releases ). sha256sum grin-wallet- $VERSION -linux-amd64.tar.gz sha256sum grin- $VERSION -linux-amd64.tar.gz Replace $VESION with the appropriate version for each binary, e.g. v4.0.2 Next, in the terminal, navigate to the directory where the files were downloaded and type: sudo tar -C /usr/local/bin -xzf grin- $VERSION -linux-amd64.tar.gz --strip-components = 1 sudo tar -C /usr/local/bin -xzf grin-wallet- $VERSION -linux-amd64.tar.gz --strip-components = 1 libncursesw error \u21b4 If you have the following error when you start grin: grin: error while loading shared libraries: libncursesw.so.5: cannot open shared object file: No such file or directory Then install libncursesw5 : sudo apt install libncursesw5 And you're done!","title":"Linux"},{"location":"getting-started/quickstart/install/#snap-store","text":"You can also install everything as Snap package , however, note that you can't verify its content. To install, type: snap install grin When installed with Snap, grin-wallet is accessible using the grin.wallet command instead of grin-wallet .","title":"Snap Store"},{"location":"getting-started/quickstart/install/#macos","text":"The easiest way to install grin and grin-wallet on macOS is with homebrew . If you do not have homebrew installed, open the \"Terminal.app\" and paste the following line: /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \" This will install homebrew on your computer. Once it's finished, you can simply install the binaries: brew install grin grin-wallet","title":"macOS"},{"location":"getting-started/quickstart/install/#windows","text":"Go to grin.mw/download and download the zip files of grin and grin-wallet by clicking on their name titles. We recommend that you create a directory called Grin in C:\\Users\\%USER%\\AppData\\Local . The parent directory is where most user windows apps are installed, but if you want to put them somewhere else, that'll work too. In this directory, extract both binaries grin.exe and grin-wallet.exe . Then, add them to your path by typing in the terminal: set PATH=%PATH%;C:\\Users\\%USER%\\AppData\\Local Remember to replace %USER% That's it, you're done!","title":"Windows"},{"location":"getting-started/quickstart/receive/","text":"Receiving Grins Let's see how you can receive your first grins. Interactive Transactions The nature of Mimblewimble protocol means that the sender & receiver need to interact with one another, in some way or another, in order to form transactions . The first step is to generate an address: grin-wallet address It is not an on-chain address, as it's only used for wallet-to-wallet communication. grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 Give it to the sender. To understand what comes next, you should know there are two primary ways to interact with the other party: Tor and Slatepack . A Tor connection is attempted first, but if it isn't accessible (counterparty offline, or either party doesn't have Tor service installed), then Slatepack method is automatically chosen. Tor All you need to do is type: grin-wallet listen Done! This sets up your wallet to listen for incoming connections through Tor. Just let the sender know that your wallet is ready. You can type grin-wallet info to check your wallet balance. Slatepack Slatepacks are encoded text messages used to transfer the data required to form a transaction, and are an alternative to a hands-off method such as Tor. The messages are easily copy-pasted and can be transferred in any communication channel imaginable: email, forum, social media, chat, letter, carrier pigeon etc. The text you receive from the sender should look like this: BEGINSLATEPACK. HctgNGXrJDGFY3B KrEF1meAezGjxQ6 Z93QF6Ps2m9yKCQ LfhZvpDY9ZXViM7 nDoNeMvwtYV2crr 8gDqvYDmtRfLL3n Uabao7VyWR4AuYg TXQUSWU83kEhKmr bRtdRjvpisx1LYo 9cyZGfsgsd7ZvDJ KKZPHhcPe4Eivtv cMvee3nwFFY3ZnM SoULNaHVJ38h3tZ vMXQMoMLB17L53o Xy6QQjDaG8avUBt LQq2GfGRTiUPQgn vQwFzfZPVzVKNLk 5AFmUQFZtiVdTJV xHvc1BuAqcamerv Y76KVccPY3WGupy 4zWFpkjTH65XNiH XqQnkb3EA1iVrHc tyTJ1PWb6X6oV1k ktYiWBpatyTirRy CywPyjr6c8XLr4Q 9VoCedU5BcdFdMB ACqQTwjgVXqjHoS 58ZPKFitjeH67Ts ah6twcKtMaFmTXD i7JEQ7qV6cewgxH 2jwWFxbb98mye6A Lm9movc6Wer26L2 91WQD3cbVpAZLEs APFPtyxnWjv8n3W ZXFLR2TPZwGc5Vt zwFUPoyWfKXasQy VVV6tbKWEEhqAZR e34M7uEwfurpUUi 9812VFPY1qw3K9b ynwQXuXMuWQCUnU s1JqWqFgSQKENUP tGCK19dys9twghA FaAc7ZXQHdMbUoL sVxVfdjE94F1Wpj M7QAM5VZuaauHdQ Mt2erFyxJ5vsYSZ hgS553UKoQL5YWX E7oRNdMDkJV6VkL i55kAQc1vWvW9ce 3MoXiBT4TJ1SyNS NVZKxgk8c. ENDSLATEPACK. Your next step would be to type: grin-wallet receive Then enter the message you were sent into the prompt. Next, your own wallet will output a beautiful Slatepack message as well: Copy and send it to the other party, and that's it, you've completed your role! It's now in the hands of the sender to finalize and post the transaction to the network. You can tell when it's accepted by the chain by typing grin-wallet info and seeing if there's an amount waiting for confirmation.","title":"Receive"},{"location":"getting-started/quickstart/receive/#receiving-grins","text":"Let's see how you can receive your first grins. Interactive Transactions The nature of Mimblewimble protocol means that the sender & receiver need to interact with one another, in some way or another, in order to form transactions . The first step is to generate an address: grin-wallet address It is not an on-chain address, as it's only used for wallet-to-wallet communication. grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 Give it to the sender. To understand what comes next, you should know there are two primary ways to interact with the other party: Tor and Slatepack . A Tor connection is attempted first, but if it isn't accessible (counterparty offline, or either party doesn't have Tor service installed), then Slatepack method is automatically chosen.","title":"Receiving Grins"},{"location":"getting-started/quickstart/receive/#tor","text":"All you need to do is type: grin-wallet listen Done! This sets up your wallet to listen for incoming connections through Tor. Just let the sender know that your wallet is ready. You can type grin-wallet info to check your wallet balance.","title":"Tor"},{"location":"getting-started/quickstart/receive/#slatepack","text":"Slatepacks are encoded text messages used to transfer the data required to form a transaction, and are an alternative to a hands-off method such as Tor. The messages are easily copy-pasted and can be transferred in any communication channel imaginable: email, forum, social media, chat, letter, carrier pigeon etc. The text you receive from the sender should look like this: BEGINSLATEPACK. HctgNGXrJDGFY3B KrEF1meAezGjxQ6 Z93QF6Ps2m9yKCQ LfhZvpDY9ZXViM7 nDoNeMvwtYV2crr 8gDqvYDmtRfLL3n Uabao7VyWR4AuYg TXQUSWU83kEhKmr bRtdRjvpisx1LYo 9cyZGfsgsd7ZvDJ KKZPHhcPe4Eivtv cMvee3nwFFY3ZnM SoULNaHVJ38h3tZ vMXQMoMLB17L53o Xy6QQjDaG8avUBt LQq2GfGRTiUPQgn vQwFzfZPVzVKNLk 5AFmUQFZtiVdTJV xHvc1BuAqcamerv Y76KVccPY3WGupy 4zWFpkjTH65XNiH XqQnkb3EA1iVrHc tyTJ1PWb6X6oV1k ktYiWBpatyTirRy CywPyjr6c8XLr4Q 9VoCedU5BcdFdMB ACqQTwjgVXqjHoS 58ZPKFitjeH67Ts ah6twcKtMaFmTXD i7JEQ7qV6cewgxH 2jwWFxbb98mye6A Lm9movc6Wer26L2 91WQD3cbVpAZLEs APFPtyxnWjv8n3W ZXFLR2TPZwGc5Vt zwFUPoyWfKXasQy VVV6tbKWEEhqAZR e34M7uEwfurpUUi 9812VFPY1qw3K9b ynwQXuXMuWQCUnU s1JqWqFgSQKENUP tGCK19dys9twghA FaAc7ZXQHdMbUoL sVxVfdjE94F1Wpj M7QAM5VZuaauHdQ Mt2erFyxJ5vsYSZ hgS553UKoQL5YWX E7oRNdMDkJV6VkL i55kAQc1vWvW9ce 3MoXiBT4TJ1SyNS NVZKxgk8c. ENDSLATEPACK. Your next step would be to type: grin-wallet receive Then enter the message you were sent into the prompt. Next, your own wallet will output a beautiful Slatepack message as well: Copy and send it to the other party, and that's it, you've completed your role! It's now in the hands of the sender to finalize and post the transaction to the network. You can tell when it's accepted by the chain by typing grin-wallet info and seeing if there's an amount waiting for confirmation.","title":"Slatepack"},{"location":"getting-started/quickstart/send/","text":"Sending Grins To send grins, use the send command and specify both the destination address ( -d ) and the amount. grin-wallet send -d [ address ] [ amount ] Example of sending 90 grins: grin-wallet send -d grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 90 Locked Outputs From now on and until confirmed in the chain, the outputs used in this transcation are locked . The wallets will interact through Tor and complete the process automatically. However, If the connection wasn't successful, your wallet will output a Slatepack message which you need to provide the receiver with. The receiver then uses the receive command to process it (as demonstrated earlier), and returns back a Slatepack he produced himself. Simply type the following command: grin-wallet finalize And enter into the prompt the Slatepack message you got from the receiver. Your wallet will complete the transaction building process and post it to the network, along with a fee, to be included in an upcoming block. Celebrate this milestone with an unapologizing smile \u30c4","title":"Send"},{"location":"getting-started/quickstart/send/#sending-grins","text":"To send grins, use the send command and specify both the destination address ( -d ) and the amount. grin-wallet send -d [ address ] [ amount ] Example of sending 90 grins: grin-wallet send -d grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 90 Locked Outputs From now on and until confirmed in the chain, the outputs used in this transcation are locked . The wallets will interact through Tor and complete the process automatically. However, If the connection wasn't successful, your wallet will output a Slatepack message which you need to provide the receiver with. The receiver then uses the receive command to process it (as demonstrated earlier), and returns back a Slatepack he produced himself. Simply type the following command: grin-wallet finalize And enter into the prompt the Slatepack message you got from the receiver. Your wallet will complete the transaction building process and post it to the network, along with a fee, to be included in an upcoming block. Celebrate this milestone with an unapologizing smile \u30c4","title":"Sending Grins"},{"location":"grin-rfcs/","text":"Grin RFCs This repository contains all Grin Project RFCs that have been proposed and accepted by the Grin community for further consideration. Grin RFCs may cover (but are not limited to) technical enhancements, changes to the governance structure or changes to project processes. Getting started To begin writing your own RFC or to find out more about the process and the general RFC guidelines, refer to the RFC that established this process . List of accepted RFCs Title Tl;dr 0001-rfc-process Introduce RFC process 0002-grin-governance Articulate community values, define core and sub-teams 0003-security-process Define community standards for ethical disclosure behaviour 0004-full-wallet-lifecycle Define API standard for sensitive wallet operations 0005-variable-size-kernels Introduce kernel variants that can be of different sizes 0006-payment-proofs Support generating and validating payment proofs for sender-initiated (i.e. non-invoice) transactions 0007-node-api-v2 Create a v2 JSON-RPC API for the Node API 0008-wallet-state-management Improve wallet state management 0009-enable-faster-sync Enable faster txhashset sync by changing output MMR commitment 0010-online-transacting-via-tor Define standard for transacting via Tor 0011-security-team Establish Grin Security team 0012-compact-slates Introduce new compact slate format (Slate V4) 0013-nrd-kernels Introduce relative timelocks through \"No Recent Duplicate\" transaction kernels 0014-general-fund-guidelines Define general fund spending guidelines 0015-slatepack Universal transaction standard for Grin License Apache License 2.0 Contributions Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, shall be licensed as above, without any additional terms or conditions.","title":"Grin RFCs"},{"location":"grin-rfcs/#grin-rfcs","text":"This repository contains all Grin Project RFCs that have been proposed and accepted by the Grin community for further consideration. Grin RFCs may cover (but are not limited to) technical enhancements, changes to the governance structure or changes to project processes.","title":"Grin RFCs"},{"location":"grin-rfcs/#getting-started","text":"To begin writing your own RFC or to find out more about the process and the general RFC guidelines, refer to the RFC that established this process .","title":"Getting started"},{"location":"grin-rfcs/#list-of-accepted-rfcs","text":"Title Tl;dr 0001-rfc-process Introduce RFC process 0002-grin-governance Articulate community values, define core and sub-teams 0003-security-process Define community standards for ethical disclosure behaviour 0004-full-wallet-lifecycle Define API standard for sensitive wallet operations 0005-variable-size-kernels Introduce kernel variants that can be of different sizes 0006-payment-proofs Support generating and validating payment proofs for sender-initiated (i.e. non-invoice) transactions 0007-node-api-v2 Create a v2 JSON-RPC API for the Node API 0008-wallet-state-management Improve wallet state management 0009-enable-faster-sync Enable faster txhashset sync by changing output MMR commitment 0010-online-transacting-via-tor Define standard for transacting via Tor 0011-security-team Establish Grin Security team 0012-compact-slates Introduce new compact slate format (Slate V4) 0013-nrd-kernels Introduce relative timelocks through \"No Recent Duplicate\" transaction kernels 0014-general-fund-guidelines Define general fund spending guidelines 0015-slatepack Universal transaction standard for Grin","title":"List of accepted RFCs"},{"location":"grin-rfcs/#license","text":"Apache License 2.0","title":"License"},{"location":"grin-rfcs/#contributions","text":"Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, shall be licensed as above, without any additional terms or conditions.","title":"Contributions"},{"location":"grin-rfcs/0000-template/","text":"Title: [edit and replace with a unique name like so: my-awesome-proposal ] Authors: Your Name Start date: [edit and replace the day work begun, i.e. Jan 15, 2019 ] RFC PR: Edit if merged: mimblewimble/grin-rfcs#0000 Tracking issue: [Edit if merged with link to tracking github issue] Summary One paragraph explanation of the improvement. Motivation Why are we doing this? What use cases does it support? What is the expected outcome? Community-level explanation Explain the proposal as if it were already introduced into the Grin ecosystem and you were teaching it to another community member. That generally means: Introducing new named concepts. Explaining the feature largely in terms of examples. Explaining how Grin community members should think about the improvement, and how it should impact the way they interact with Grin. It should explain the impact as concretely as possible. If applicable, provide sample error messages, deprecation warnings, or migration guidance. If applicable, describe the differences between teaching this to existing Grin community members and new Grin community members. For implementation-oriented RFCs (e.g. for wallet), this section should focus on how wallet contributors should think about the change, and give examples of its concrete impact. For policy RFCs, this section should provide an example-driven introduction to the policy, and explain its impact in concrete terms. Reference-level explanation This is the technical portion of the RFC. Explain the design in sufficient detail that: Its interaction with other features is clear. It is reasonably clear how the feature would be implemented. Corner cases are dissected by example. The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work. Drawbacks Why should we not do this? Rationale and alternatives Why is this design the best in the space of possible designs? What other designs have been considered and what is the rationale for not choosing them? What is the impact of not doing this? Prior art Discuss prior art, both the good and the bad, in relation to this proposal. A few examples of what this can include are: For core, node, wallet and infrastructure proposals: Does this feature exist in other projects and what experience have their community had? For community, ecosystem and moderation proposals: Is this done by some other community and what were their experiences with it? For other teams: What lessons can we learn from what other communities have done here? Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background. This section is intended to encourage you as an author to think about the lessons from other languages, provide readers of your RFC with a fuller picture. If there is no prior art, that is fine - your ideas are interesting to us whether they are brand new or if it is an adaptation from other projects. Note that while precedent set by other projects is some motivation, it does not on its own motivate an RFC. Please also take into consideration that Grin sometimes intentionally diverges from common project features. Unresolved questions What parts of the design do you expect to resolve through the RFC process before this gets merged? What parts of the design do you expect to resolve through the implementation of this feature before stabilization? What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC? Future possibilities Think about what the natural extension and evolution of your proposal would be and how it would affect the project and ecosystem as a whole in a holistic way. Try to use this section as a tool to more fully consider all possible interactions with the project and language in your proposal. Also consider how it fits into the road-map of the project and of the relevant sub-team. This is also a good place to \"dump ideas\", if they are out of scope for the RFC you are writing but otherwise related. If you have tried and cannot think of any future possibilities, you may simply state that you cannot think of anything. Note that having something written down in the future-possibilities section is not a reason to accept the current or a future RFC; such notes should be in the section on motivation or rationale in this or subsequent RFCs. The section merely provides additional information. References Include any references such as links to other documents or reference implementations.","title":"0000 template"},{"location":"grin-rfcs/0000-template/#summary","text":"One paragraph explanation of the improvement.","title":"Summary"},{"location":"grin-rfcs/0000-template/#motivation","text":"Why are we doing this? What use cases does it support? What is the expected outcome?","title":"Motivation"},{"location":"grin-rfcs/0000-template/#community-level-explanation","text":"Explain the proposal as if it were already introduced into the Grin ecosystem and you were teaching it to another community member. That generally means: Introducing new named concepts. Explaining the feature largely in terms of examples. Explaining how Grin community members should think about the improvement, and how it should impact the way they interact with Grin. It should explain the impact as concretely as possible. If applicable, provide sample error messages, deprecation warnings, or migration guidance. If applicable, describe the differences between teaching this to existing Grin community members and new Grin community members. For implementation-oriented RFCs (e.g. for wallet), this section should focus on how wallet contributors should think about the change, and give examples of its concrete impact. For policy RFCs, this section should provide an example-driven introduction to the policy, and explain its impact in concrete terms.","title":"Community-level explanation"},{"location":"grin-rfcs/0000-template/#reference-level-explanation","text":"This is the technical portion of the RFC. Explain the design in sufficient detail that: Its interaction with other features is clear. It is reasonably clear how the feature would be implemented. Corner cases are dissected by example. The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work.","title":"Reference-level explanation"},{"location":"grin-rfcs/0000-template/#drawbacks","text":"Why should we not do this?","title":"Drawbacks"},{"location":"grin-rfcs/0000-template/#rationale-and-alternatives","text":"Why is this design the best in the space of possible designs? What other designs have been considered and what is the rationale for not choosing them? What is the impact of not doing this?","title":"Rationale and alternatives"},{"location":"grin-rfcs/0000-template/#prior-art","text":"Discuss prior art, both the good and the bad, in relation to this proposal. A few examples of what this can include are: For core, node, wallet and infrastructure proposals: Does this feature exist in other projects and what experience have their community had? For community, ecosystem and moderation proposals: Is this done by some other community and what were their experiences with it? For other teams: What lessons can we learn from what other communities have done here? Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background. This section is intended to encourage you as an author to think about the lessons from other languages, provide readers of your RFC with a fuller picture. If there is no prior art, that is fine - your ideas are interesting to us whether they are brand new or if it is an adaptation from other projects. Note that while precedent set by other projects is some motivation, it does not on its own motivate an RFC. Please also take into consideration that Grin sometimes intentionally diverges from common project features.","title":"Prior art"},{"location":"grin-rfcs/0000-template/#unresolved-questions","text":"What parts of the design do you expect to resolve through the RFC process before this gets merged? What parts of the design do you expect to resolve through the implementation of this feature before stabilization? What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?","title":"Unresolved questions"},{"location":"grin-rfcs/0000-template/#future-possibilities","text":"Think about what the natural extension and evolution of your proposal would be and how it would affect the project and ecosystem as a whole in a holistic way. Try to use this section as a tool to more fully consider all possible interactions with the project and language in your proposal. Also consider how it fits into the road-map of the project and of the relevant sub-team. This is also a good place to \"dump ideas\", if they are out of scope for the RFC you are writing but otherwise related. If you have tried and cannot think of any future possibilities, you may simply state that you cannot think of anything. Note that having something written down in the future-possibilities section is not a reason to accept the current or a future RFC; such notes should be in the section on motivation or rationale in this or subsequent RFCs. The section merely provides additional information.","title":"Future possibilities"},{"location":"grin-rfcs/0000-template/#references","text":"Include any references such as links to other documents or reference implementations.","title":"References"},{"location":"grin-rfcs/text/0001-rfc-process/","text":"0001-rfc-process Title: rfc-process Authors: joltz , yeastplume , lehnberg Start date: June 21st, 2019 Summary The \"RFC\" (request for comments) process is intended to provide a consistent and controlled path for improvements to be made to Grin. Motivation Many changes, including bug fixes and documentation improvements can be implemented and reviewed via the normal GitHub pull request workflow. Some changes though are \"substantial\", and could benefit from being put through a more formal design process in order to produce a consensus among Grin community participants and stakeholders. When this process should be followed You need to follow this process if you intend to make \"substantial\" changes to the Grin codebase or governance process. What constitutes a \"substantial\" change may evolve based on community norms and individual definitions of sub-teams, but may include the following. Any semantic or syntactic change to the wallet, node, miner, or underlying crypto libraries that is not a bugfix. Major changes in ecosystem content such as the docs, site or explorer. Removing Grin features, including those that are feature-gated. Some changes do not require an RFC: Rephrasing, reorganizing, refactoring, or changes that are not visible to Grin's users. Additions that strictly improve objective, numerical quality criteria (warning removal, speedup, better platform coverage, more parallelism, trap more errors, etc.) Additions only likely to be noticed by other developers-of-grin, invisible to users-of-grin. If you submit a pull request to implement a new feature without going through the RFC process, it may be closed with a polite request to submit an RFC first. Team specific guidelines To be added here once available. Before creating an RFC A hastily-proposed RFC can hurt its chances of acceptance. Low quality proposals, proposals for previously-rejected features, or those that don't fit into the near-term roadmap, may be quickly rejected, which can be demotivating for the unprepared contributor. Laying some groundwork ahead of the RFC can make the process smoother. Although there is no single way to prepare for submitting an RFC, it is generally a good idea to pursue feedback from other project contributors beforehand, to ascertain that the RFC may be desirable; having a consistent impact on the project requires concerted effort toward consensus-building. Ways to prepare and pave the way for writing and submitting an RFC include discussing the topic or posting \"pre-RFCs\" to our forum for feedback. As a rule of thumb, receiving encouraging feedback from long-standing project contributors, and particularly members of the relevant team (if applicable) is a good indication that the RFC is worth pursuing. Process description In order to make a \"substantial\" change to Grin, one must first get an RFC merged into the RFC repo as a markdown file. At that point the RFC is \"active\" and may be implemented with the goal of eventual inclusion into Grin. Stages in detail Submission Fork the RFC repo https://github.com/mimblewimble/grin-rfcs Copy 0000-template.md to text/0000-my-feature.md (where \"my-feature\" is descriptive. don't assign an RFC number yet). If you include any assets, do so as /assets/0000-asset-description.xxx Write the RFC according to the template instructions. Submit a pull request. As a pull request the RFC will receive design feedback from the larger community, and the author should be prepared to revise it in response. Draft Each pull request will be labeled with the most relevant team, which will lead to it being triaged by that team and is assigned a shepherd from this team. The shepherd ensures the RFC progresses through the process and that a decision is reached, but they themselves do not make this decision. As the author, you build consensus and integrate feedback. RFCs that have broad support are much more likely to make progress than those that don't receive any comments. They are encouraged to reach out to the RFC shepherd in particular to get help identifying stakeholders and obstacles. The relevant team discuss the RFC pull request, as much as possible in the comment thread of the pull request itself. Offline discussion will be summarized on the pull request comment thread. RFCs rarely go through this process unchanged, especially as alternatives and drawbacks are shown. As an author you can make edits, big and small, to the RFC to clarify or change the design,but make changes as new commits to the pull request, and leave a comment on the pull request explaining your changes. Specifically, do not squash or rebase commits after they are visible on the pull request. Final Comment Period (FCP) At some point, a member of the assigned team will propose a \"motion for final comment period\" (FCP), along with a disposition for the RFC (merge, close, or postpone). This step is taken when enough of the tradeoffs have been discussed that the team is in a position to make a decision. That does not require consensus amongst all participants in the RFC thread (which is usually impossible). However, the argument supporting the disposition on the RFC needs to have already been clearly articulated, and there should not be a strong consensus against that position outside of the team. Team members use their best judgment in taking this step, and the FCP itself ensures there is ample time and notification for stakeholders to push back if it is made prematurely. For RFCs with lengthy discussion, the motion to FCP is usually preceded by a summary comment trying to lay out the current state of the discussion and major tradeoffs/points of disagreement. The FCP lasts ten calendar days, so that it is open for at least 5 business days. It is also advertised widely (i.e. in Grin News ). This way all stakeholders have a chance to lodge any final objections before a decision is reached. In most cases, the FCP period is quiet, and the RFC is either merged or closed. However, sometimes substantial new arguments or ideas are raised, the FCP is canceled, and the RFC goes back into draft mode. Active As FCP concludes and there are no objections to accepting the RFC, it gets merged into /grin-rfcs and becomes \"active\". Before merging, the shepherd: updates the RFC to give it an RFC number (which is the same as the number of the initial Pull Request). Renames the markdown file accordingly and any accompanied assets. If a tracking issue on the repo affected by the RFC has created, it is linked to in the header. Once active, the authors may then implement it and submit the feature as a pull request to the relevant repo. Being \"active\" is not a rubber stamp, and in particular still does not mean the feature will ultimately be merged; it does mean that in principle all the major stakeholders have agreed to the feature and are amenable to merging it. Furthermore, the fact that a given RFC has been accepted and is \"active\" implies nothing about what priority is assigned to its implementation, nor does it imply anything about whether a developer has been assigned the task of implementing the feature. While it is not necessary that the author of the RFC also write the implementation, it is by far the most effective way to see an RFC through to completion: authors should not expect that other project contributors will take on responsibility for implementing their accepted feature. Modifications to \"active\" RFCs can be done in follow-up pull requests. We strive to write each RFC in a manner that it will reflect the final design of the feature; but the nature of software development means that we cannot expect every merged RFC to actually reflect what the end result will be at the time of implementation. In general, once accepted, RFCs should not be substantially changed. Only very minor changes should be submitted as amendments. More substantial changes should be new RFCs, with a note added to the original RFC. Exactly what counts as a \"very minor change\" is up to the team to decide; check team specific guidelines for more details. Postponed Some RFC pull requests are tagged with the \"postponed\" label when they are closed (as part of the rejection process). An RFC closed with \"postponed\" is marked as such because we want neither to think about evaluating the proposal nor about implementing the described feature until some time in the future, and we believe that we can afford to wait until then to do so. Postponed pull requests may be re-opened when the time is right. We don't have any formal process for that, you should ask members of the relevant team. Usually an RFC pull request marked as \"postponed\" has already passed an informal first round of evaluation, namely the round of \"do we think we would ever possibly consider making this change, as outlined in the RFC pull request, or some semi-obvious variation of it.\" (When the answer to the latter question is \"no\", then the appropriate response is to close the RFC, not postpone it.) Closed A proposed RFC can be closed at any time before reaching \"active\" state. This is done by closing the pull request itself. This would happen for example if there is no support in the community for the proposal or if there are other underlying reasons why this is not a change the community wants to make. Changes to the RFC process In the spirit of the proposed process itself, a future \"substantial\" overhaul to the RFC process should be opened as a new RFC rather than making edits to this RFC. Minor changes can be made by opening pull requests against this document. As the RFC process is something that should be consistent across all teams and the project as a whole, changes to the process fall under Core's remit. As they evaluate proposals to modify the process, they are expected to consult with teams, and other stakeholders using or being affected by the process. Drawbacks May not encourage sufficient community engagement May slow down needed features May allow some features to be included too quickly Rationale and alternatives Alternatively, retain the current informal RFC process. The proposed RFC process is designed to improve over the informal process in the following ways: Discourage unactionable or vague RFCs Ensure that all serious RFCs are considered equally Improve transparency for how new features are added to Grin Give confidence to those with a stake in Grin's development that they understand why new features are being merged Assist the Grin community with feature and release planning. As an alternative, we could adopt an even stricter RFC process than the one proposed here. We could for example look to Bitcoin's BIP or Python's PEP process for inspiration. Prior art This process draws inspiration extensively from Rust's RFC process, where much credit for the process is due. Most decentralized cryptocurrency projects have adopted an RFC-like process to manage adding new features. Bitcoin uses BIPs which are an adaptation of Python's PEPs. These processes are similar to the Rust RFC process which has had success in the Rust community as well as in other cryptocurrency projects like Peercoin. Unresolved questions Does this RFC strike a favorable balance between formality and agility? Does this RFC address the issues with the current informal process adequately? Future possibilities This proposal was initially based on an RFC process for codebase development. As the process evolves it will have a larger impact in the governance of Grin. This is a relatively new area of exploration as governance processes can have wide ranging impacts on the ecosystem as a whole. Just as it is important to hone the language to support the development process and life-cycle, it is also important to sharpen the language to support governance processes and life-cycles for the Grin ecosystem. References https://github.com/rust-lang/rfcs https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki https://www.python.org/dev/peps/pep-0001/","title":"0001 rfc-process"},{"location":"grin-rfcs/text/0001-rfc-process/#0001-rfc-process","text":"Title: rfc-process Authors: joltz , yeastplume , lehnberg Start date: June 21st, 2019","title":"0001-rfc-process"},{"location":"grin-rfcs/text/0001-rfc-process/#summary","text":"The \"RFC\" (request for comments) process is intended to provide a consistent and controlled path for improvements to be made to Grin.","title":"Summary"},{"location":"grin-rfcs/text/0001-rfc-process/#motivation","text":"Many changes, including bug fixes and documentation improvements can be implemented and reviewed via the normal GitHub pull request workflow. Some changes though are \"substantial\", and could benefit from being put through a more formal design process in order to produce a consensus among Grin community participants and stakeholders.","title":"Motivation"},{"location":"grin-rfcs/text/0001-rfc-process/#when-this-process-should-be-followed","text":"You need to follow this process if you intend to make \"substantial\" changes to the Grin codebase or governance process. What constitutes a \"substantial\" change may evolve based on community norms and individual definitions of sub-teams, but may include the following. Any semantic or syntactic change to the wallet, node, miner, or underlying crypto libraries that is not a bugfix. Major changes in ecosystem content such as the docs, site or explorer. Removing Grin features, including those that are feature-gated. Some changes do not require an RFC: Rephrasing, reorganizing, refactoring, or changes that are not visible to Grin's users. Additions that strictly improve objective, numerical quality criteria (warning removal, speedup, better platform coverage, more parallelism, trap more errors, etc.) Additions only likely to be noticed by other developers-of-grin, invisible to users-of-grin. If you submit a pull request to implement a new feature without going through the RFC process, it may be closed with a polite request to submit an RFC first.","title":"When this process should be followed"},{"location":"grin-rfcs/text/0001-rfc-process/#team-specific-guidelines","text":"To be added here once available.","title":"Team specific guidelines"},{"location":"grin-rfcs/text/0001-rfc-process/#before-creating-an-rfc","text":"A hastily-proposed RFC can hurt its chances of acceptance. Low quality proposals, proposals for previously-rejected features, or those that don't fit into the near-term roadmap, may be quickly rejected, which can be demotivating for the unprepared contributor. Laying some groundwork ahead of the RFC can make the process smoother. Although there is no single way to prepare for submitting an RFC, it is generally a good idea to pursue feedback from other project contributors beforehand, to ascertain that the RFC may be desirable; having a consistent impact on the project requires concerted effort toward consensus-building. Ways to prepare and pave the way for writing and submitting an RFC include discussing the topic or posting \"pre-RFCs\" to our forum for feedback. As a rule of thumb, receiving encouraging feedback from long-standing project contributors, and particularly members of the relevant team (if applicable) is a good indication that the RFC is worth pursuing.","title":"Before creating an RFC"},{"location":"grin-rfcs/text/0001-rfc-process/#process-description","text":"In order to make a \"substantial\" change to Grin, one must first get an RFC merged into the RFC repo as a markdown file. At that point the RFC is \"active\" and may be implemented with the goal of eventual inclusion into Grin.","title":"Process description"},{"location":"grin-rfcs/text/0001-rfc-process/#stages-in-detail","text":"","title":"Stages in detail"},{"location":"grin-rfcs/text/0001-rfc-process/#submission","text":"Fork the RFC repo https://github.com/mimblewimble/grin-rfcs Copy 0000-template.md to text/0000-my-feature.md (where \"my-feature\" is descriptive. don't assign an RFC number yet). If you include any assets, do so as /assets/0000-asset-description.xxx Write the RFC according to the template instructions. Submit a pull request. As a pull request the RFC will receive design feedback from the larger community, and the author should be prepared to revise it in response.","title":"Submission"},{"location":"grin-rfcs/text/0001-rfc-process/#draft","text":"Each pull request will be labeled with the most relevant team, which will lead to it being triaged by that team and is assigned a shepherd from this team. The shepherd ensures the RFC progresses through the process and that a decision is reached, but they themselves do not make this decision. As the author, you build consensus and integrate feedback. RFCs that have broad support are much more likely to make progress than those that don't receive any comments. They are encouraged to reach out to the RFC shepherd in particular to get help identifying stakeholders and obstacles. The relevant team discuss the RFC pull request, as much as possible in the comment thread of the pull request itself. Offline discussion will be summarized on the pull request comment thread. RFCs rarely go through this process unchanged, especially as alternatives and drawbacks are shown. As an author you can make edits, big and small, to the RFC to clarify or change the design,but make changes as new commits to the pull request, and leave a comment on the pull request explaining your changes. Specifically, do not squash or rebase commits after they are visible on the pull request.","title":"Draft"},{"location":"grin-rfcs/text/0001-rfc-process/#final-comment-period-fcp","text":"At some point, a member of the assigned team will propose a \"motion for final comment period\" (FCP), along with a disposition for the RFC (merge, close, or postpone). This step is taken when enough of the tradeoffs have been discussed that the team is in a position to make a decision. That does not require consensus amongst all participants in the RFC thread (which is usually impossible). However, the argument supporting the disposition on the RFC needs to have already been clearly articulated, and there should not be a strong consensus against that position outside of the team. Team members use their best judgment in taking this step, and the FCP itself ensures there is ample time and notification for stakeholders to push back if it is made prematurely. For RFCs with lengthy discussion, the motion to FCP is usually preceded by a summary comment trying to lay out the current state of the discussion and major tradeoffs/points of disagreement. The FCP lasts ten calendar days, so that it is open for at least 5 business days. It is also advertised widely (i.e. in Grin News ). This way all stakeholders have a chance to lodge any final objections before a decision is reached. In most cases, the FCP period is quiet, and the RFC is either merged or closed. However, sometimes substantial new arguments or ideas are raised, the FCP is canceled, and the RFC goes back into draft mode.","title":"Final Comment Period (FCP)"},{"location":"grin-rfcs/text/0001-rfc-process/#active","text":"As FCP concludes and there are no objections to accepting the RFC, it gets merged into /grin-rfcs and becomes \"active\". Before merging, the shepherd: updates the RFC to give it an RFC number (which is the same as the number of the initial Pull Request). Renames the markdown file accordingly and any accompanied assets. If a tracking issue on the repo affected by the RFC has created, it is linked to in the header. Once active, the authors may then implement it and submit the feature as a pull request to the relevant repo. Being \"active\" is not a rubber stamp, and in particular still does not mean the feature will ultimately be merged; it does mean that in principle all the major stakeholders have agreed to the feature and are amenable to merging it. Furthermore, the fact that a given RFC has been accepted and is \"active\" implies nothing about what priority is assigned to its implementation, nor does it imply anything about whether a developer has been assigned the task of implementing the feature. While it is not necessary that the author of the RFC also write the implementation, it is by far the most effective way to see an RFC through to completion: authors should not expect that other project contributors will take on responsibility for implementing their accepted feature. Modifications to \"active\" RFCs can be done in follow-up pull requests. We strive to write each RFC in a manner that it will reflect the final design of the feature; but the nature of software development means that we cannot expect every merged RFC to actually reflect what the end result will be at the time of implementation. In general, once accepted, RFCs should not be substantially changed. Only very minor changes should be submitted as amendments. More substantial changes should be new RFCs, with a note added to the original RFC. Exactly what counts as a \"very minor change\" is up to the team to decide; check team specific guidelines for more details.","title":"Active"},{"location":"grin-rfcs/text/0001-rfc-process/#postponed","text":"Some RFC pull requests are tagged with the \"postponed\" label when they are closed (as part of the rejection process). An RFC closed with \"postponed\" is marked as such because we want neither to think about evaluating the proposal nor about implementing the described feature until some time in the future, and we believe that we can afford to wait until then to do so. Postponed pull requests may be re-opened when the time is right. We don't have any formal process for that, you should ask members of the relevant team. Usually an RFC pull request marked as \"postponed\" has already passed an informal first round of evaluation, namely the round of \"do we think we would ever possibly consider making this change, as outlined in the RFC pull request, or some semi-obvious variation of it.\" (When the answer to the latter question is \"no\", then the appropriate response is to close the RFC, not postpone it.)","title":"Postponed"},{"location":"grin-rfcs/text/0001-rfc-process/#closed","text":"A proposed RFC can be closed at any time before reaching \"active\" state. This is done by closing the pull request itself. This would happen for example if there is no support in the community for the proposal or if there are other underlying reasons why this is not a change the community wants to make.","title":"Closed"},{"location":"grin-rfcs/text/0001-rfc-process/#changes-to-the-rfc-process","text":"In the spirit of the proposed process itself, a future \"substantial\" overhaul to the RFC process should be opened as a new RFC rather than making edits to this RFC. Minor changes can be made by opening pull requests against this document. As the RFC process is something that should be consistent across all teams and the project as a whole, changes to the process fall under Core's remit. As they evaluate proposals to modify the process, they are expected to consult with teams, and other stakeholders using or being affected by the process.","title":"Changes to the RFC process"},{"location":"grin-rfcs/text/0001-rfc-process/#drawbacks","text":"May not encourage sufficient community engagement May slow down needed features May allow some features to be included too quickly","title":"Drawbacks"},{"location":"grin-rfcs/text/0001-rfc-process/#rationale-and-alternatives","text":"Alternatively, retain the current informal RFC process. The proposed RFC process is designed to improve over the informal process in the following ways: Discourage unactionable or vague RFCs Ensure that all serious RFCs are considered equally Improve transparency for how new features are added to Grin Give confidence to those with a stake in Grin's development that they understand why new features are being merged Assist the Grin community with feature and release planning. As an alternative, we could adopt an even stricter RFC process than the one proposed here. We could for example look to Bitcoin's BIP or Python's PEP process for inspiration.","title":"Rationale and alternatives"},{"location":"grin-rfcs/text/0001-rfc-process/#prior-art","text":"This process draws inspiration extensively from Rust's RFC process, where much credit for the process is due. Most decentralized cryptocurrency projects have adopted an RFC-like process to manage adding new features. Bitcoin uses BIPs which are an adaptation of Python's PEPs. These processes are similar to the Rust RFC process which has had success in the Rust community as well as in other cryptocurrency projects like Peercoin.","title":"Prior art"},{"location":"grin-rfcs/text/0001-rfc-process/#unresolved-questions","text":"Does this RFC strike a favorable balance between formality and agility? Does this RFC address the issues with the current informal process adequately?","title":"Unresolved questions"},{"location":"grin-rfcs/text/0001-rfc-process/#future-possibilities","text":"This proposal was initially based on an RFC process for codebase development. As the process evolves it will have a larger impact in the governance of Grin. This is a relatively new area of exploration as governance processes can have wide ranging impacts on the ecosystem as a whole. Just as it is important to hone the language to support the development process and life-cycle, it is also important to sharpen the language to support governance processes and life-cycles for the Grin ecosystem.","title":"Future possibilities"},{"location":"grin-rfcs/text/0001-rfc-process/#references","text":"https://github.com/rust-lang/rfcs https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki https://www.python.org/dev/peps/pep-0001/","title":"References"},{"location":"grin-rfcs/text/0002-grin-governance/","text":"0002-grin-governance Title: grin-governance Authors: lehnberg , yeastplume Start date: June 24th, 2019 Related issue: /grin-pm/#167 Summary Evolve Grin's governance: - Define general community principles; - Convert council into core team and define its responsibilities and processes; - Introduce RFC process; - Introduce self-governing teams that steward and guide work in each of their focus areas. Motivation Background Grin's governance today consists of the Grin Technocratic Council, and the rest of the community. The council came to be as there was a need for some sub-set of community members to manage the multi-sig keys of the Grin General Fund, and it became a modest first pass at a governance structure. Over time, it has come to be that a lot of responsibilities and day to day tasks are handled by Grin council members. This puts a heavy workload on council members, but it also inhibits other members of the community from becoming more engaged, contributing more, and becoming recognized for it. Naturally this implies that either the council would have to grow large in order to be able to fit all the members of the community that deserve recognition for their contributions, or that we end up not rewarding active contributors properly. In addition, as most decisions up to this point have been taken in the bi-weekly meetings, it's come to be that decisions take time to materialize: It can take up to 14 days just to have the initial conversation and sometimes multiples of that to reach an agreement. In these meetings the entire active community ends up participating in every discussion in a synchronous fashion that often does not end up being productive. We have also struggled to answer more fundamental questions about Grin's governance, as in how decisions are made, who has authority to make these, and what the path is for a community member who would like to take on greater responsibilities. This is a proposal to evolve our governance process. Objectives Reward and recognize contributions better. Offer different ways to become more engaged and give better recognition for work Empower more to contribute. Encourage more community members to participate, facilitate more initiative. Make Grin less centralized. Rather than relying on a small group of people, share responsibilities and make the project more resilient against shocks. Create a more transparent process. Not objectives Do not create fiefdoms. Do not create emperors. Nobody is the boss of anybody else. Do not create bureaucracy for the sake of bureaucracy. Do not impose death by a thousand papercuts or let forms and administration get in the way of making progress. Do not discourage contributions. Nobody can prevent someone else from doing work. Anyone can contribute in which ever way they find meaningful. You do not need to ask for permission. Community-level explanation This proposal outlines a set of loose principles to guide the work we do. While some of these may already be in use, they might not have been articulated before. It converts the council into a core team, and outlines its responsibilities for the first time. In addition, it's proposed that additional teams are introduced alongside it, as well as an RFC process. An initial teams breakdown is suggested, and the proposal concludes with a path to adoption. General principles Lead by example. \"Cypherpunks write code.\" We don't tell others what to do. We do what we can, and if we need to we ask for help. We suggest, but never command. We act as we want others to act. Not a democracy. We are evaluated based on the work we do. It's not a popularity contest, and the majority is not always right. Community members are here by their free will, participation is optional. Influence is measured by recent and not historical work. We are grateful for and respect historical contributions, but they do not lead to lifelong positions of authority. Influence is earned by making contributions consistently over time, allowing new contributors to join the ranks of the old. Transparency. Where possible, discussions and decisions are made in the open. We have nothing to hide, and we do not try to limit oversight unless there's a defensible reason to do so. Keep things lightweight. We strive to only put in place the minimal structure and organization that's needed, neither more nor less. Groups organize themselves. Structures do not need to be imposed tops down, and we recognise that what works for one group will not necessarily work for the other. Teams self-organize and define their own workflows and processes as they see fit. Consensus-seeking decision making. Voting creates winners and losers, and is polarizing. We recognize there are trade offs with everything and rarely any single right answer. This does not mean design by committee. We seek consensus through dialogue and discussion, but where there is a lack of consensus, we do not let it block us indefinitely. We're ready to make judgment calls to the best of our abilities. We speak for ourselves. We can only speak in the name of ourselves, as contributors to the project. We do not write blog posts, articles, tweets, or give interviews speaking on behalf of the project as a whole. Grin itself has no single voice. There's no need to ask for permission. We are not afraid to take decisions. We ask for feedback and opinions from others, but we do not need to ask for somebody's permission. If we believe it's in the best interest of Grin, we act, and are accountable for our actions. Mistakes are tolerated. As with any organization structure, mistakes happen. This is understood, and mistakes are accepted. We try to learn from them and improve. We assume we all act in good faith, until proven otherwise. Core team The existing grin council is proposed to be renamed to core team. Over time, it's intended to be a broad representation of the wider community with diverse stakeholders. Responsibilities The core team leads the wider Grin project as a whole. In particular: Sets overall direction and vision. Values and philosophies. Steering towards use cases and targets. Sets priorities and plans releases. Maintains high level planning, roadmaps, focus areas, decides on pace and the release schedule. Work on broader, cross-sectional issues. What falls in-between teams, taking a global view. Adds and removes teams. While proposals for new teams can come from anywhere, the core team is responsible to ensure structures are productive and make sense. Appoints initial team leadership. Once a new team is established, core appoints a leader that has the responsibility to grow the team. Responsible for security. Handles disclosures, vulnerabilities, audits, processes. Handles multi-sig keys and takes high level spending decisions. Spending proposals can be made by anyone, and teams can have their own own budgets to deal with as they please. Organization & Processes There's no defined maximum size of the team. New members are added through a core decision; A core member can nominate a new member for inclusion, there\u2019s discussion, and the process is consensus seeking. The general decision making process is consensus seeking - no majority rule based voting, but also not blocked by lack of explicit consensus. Core members have no explicit veto, but strong objections are considered. Nominations and discussions are kept private. The term of core members is currently undefined but may change in the future. A core member can resign by notifying the rest of the team. If unreachable for 30 days without any news, a core member can be removed through a core decision. The core team does not make rulings on RFCs of other teams, although individual team members might also participate in the discussions of sub teams or be members of those teams. Meeting notes should be published and made transparent to the community on a regular basis. RFC process An RFC is a Request For Comments document, outlining a proposed improvement or design change to an area of Grin. The exact specifics for the template is TBD. They are kept in their own dedicated repo and need to be accepted before a pull request is merged. Their purpose is to outline a standardized way of making proposals and allow the community to discuss and evaluate whether something is worth doing. Having an RFC accepted means that there's support \"in theory\" for the suggestion. It does not mean that a change becomes implemented automatically or in the exact way it is proposed, it is high-level design. The work still needs to be carried out. Accepted RFCs guide the broader planning work. Teams Overview Teams are groups organized around specific areas or knowledge fields. They are responsible for these areas, but do not do all the work. Anyone can contribute anywhere, and do not need to hold a particular title to do so. Rather, teams work on policies, processes, and workflows for their specific areas, as required. They are in charge of the RFC process in their specific field: They determine what requires an RFC in their area, they assign RFC shepherds that guide an RFC through its various stages and ensures the right stakeholders become aware of it and solicit their feedback. Ultimately, teams decide whether an RFC in their area should be accepted or rejected. They are responsible to ensure that each RFC in their area has a tracked status, and that they progress towards an outcome. Teams self-organize, but should be inclusive and adhere to community values. They should have a leader, often this leader may be part of the core team. They determine how members get added to the team. They should include area experts, and stakeholders. The decision making process should be consensus-seeking where possible. Teams can be broken down into smaller working groups or teams, permanent or temporary, as required and is seen necessary for them to be productive. Each team has a dedicated section on the forum, they should meet regularly, and keep some notes on what was covered and decided. Decisions do not need to happen in meetings, and could for example be handled asynchronously or in the RFC process. Meeting notes should be published and made transparent to the community on a regular basis. The teams In addition to Core team, the following teams are proposed to be created initially. Node development. Core Grin technology, changes and optimizations to the node and anything consensus related, research and discussion of new technologies, proof of work. Wallet development. wallet technology, wallet API, wallet-related research. Infrastructure. Technical documentation, non-technical documentation, QA, testing, toolchain, developer productivity, guides, how-tos. Ecosystem. 3rd party developers interaction (wallets, pools, exchanges and others), integration and technical assistance, growing the grin ecosystem, stakeholder collaboration. Community. Onboarding of new community members, website, chat channels, conferences, events, meetups. Fundraising. Sponsorships, donations, activities to increase project funds. Moderation. Code of conduct, handles violations, across all areas of the project. To avoid biases and conflicts of interest, this team does not contain any member of the core team. In case of conflicts, disagreement, or dissent Teams are created and appointed by the core, and core can decide to re-organize team structures and shut down dysfunctional teams. This is a \"nuclear\" option, such decisions should not be taken lightly. The repercussions of such actions can be worse than the initial situation. In practice, core team members might be engaging with teams as individual contributors. It is however not expected that \"the core team\" will become involved in the responsibilities of individual teams. Core sets the overall direction for the project, but should not micro manage teams as this defeats the entire purpose of having these teams in the first place. If there are conflicts within teams, these should ideally be resolved within the teams themselves. If this is not possible and there's contentious disagreements that need outside arbitration, teams can invite core or another team to become involved. Drawbacks Adds a lot more structure. This might create overhead. Could lead to infighting and conflict between teams. Could lead to situations where one team does work that conflicts with other teams, \"left hand not talking to the right\". Rationale and alternatives Keep the process as is. Change the process to something else. Prior art Python conducted a comprehensive survey of the governance structures of various open source projects in 2018 through PEP-8002 . This document is highly recommended reading for various alternative structures. Unresolved questions Far too many to all be listed here, but here are some: Is this too much structure for the amount of active contributors we have? Does this approach really address the problems as highlighted in the motivation? Does this legitimize the core team enough in the community? Future possibilities Introduce more teams Introduce an electorate Introduce terms Define firmer structures and organizational rules References Rust's governance process - https://rust-lang.github.io/rfcs/1068-rust-governance.html - https://predictablynoisy.com/rust-governance - http://mgattozzi.com/oss-governance-and-sustainablility-i/ Node.js governance - https://medium.com/the-node-js-collection/healthy-open-source-967fa8be7951 Swarmwise, by Rick Falkvinge - https://falkvinge.net/files/2013/04/Swarmwise-2013-by-Rick-Falkvinge-v1.1-2013Sep01.pdf","title":"0002 grin-governance"},{"location":"grin-rfcs/text/0002-grin-governance/#0002-grin-governance","text":"Title: grin-governance Authors: lehnberg , yeastplume Start date: June 24th, 2019 Related issue: /grin-pm/#167","title":"0002-grin-governance"},{"location":"grin-rfcs/text/0002-grin-governance/#summary","text":"Evolve Grin's governance: - Define general community principles; - Convert council into core team and define its responsibilities and processes; - Introduce RFC process; - Introduce self-governing teams that steward and guide work in each of their focus areas.","title":"Summary"},{"location":"grin-rfcs/text/0002-grin-governance/#motivation","text":"","title":"Motivation"},{"location":"grin-rfcs/text/0002-grin-governance/#background","text":"Grin's governance today consists of the Grin Technocratic Council, and the rest of the community. The council came to be as there was a need for some sub-set of community members to manage the multi-sig keys of the Grin General Fund, and it became a modest first pass at a governance structure. Over time, it has come to be that a lot of responsibilities and day to day tasks are handled by Grin council members. This puts a heavy workload on council members, but it also inhibits other members of the community from becoming more engaged, contributing more, and becoming recognized for it. Naturally this implies that either the council would have to grow large in order to be able to fit all the members of the community that deserve recognition for their contributions, or that we end up not rewarding active contributors properly. In addition, as most decisions up to this point have been taken in the bi-weekly meetings, it's come to be that decisions take time to materialize: It can take up to 14 days just to have the initial conversation and sometimes multiples of that to reach an agreement. In these meetings the entire active community ends up participating in every discussion in a synchronous fashion that often does not end up being productive. We have also struggled to answer more fundamental questions about Grin's governance, as in how decisions are made, who has authority to make these, and what the path is for a community member who would like to take on greater responsibilities. This is a proposal to evolve our governance process.","title":"Background"},{"location":"grin-rfcs/text/0002-grin-governance/#objectives","text":"Reward and recognize contributions better. Offer different ways to become more engaged and give better recognition for work Empower more to contribute. Encourage more community members to participate, facilitate more initiative. Make Grin less centralized. Rather than relying on a small group of people, share responsibilities and make the project more resilient against shocks. Create a more transparent process.","title":"Objectives"},{"location":"grin-rfcs/text/0002-grin-governance/#not-objectives","text":"Do not create fiefdoms. Do not create emperors. Nobody is the boss of anybody else. Do not create bureaucracy for the sake of bureaucracy. Do not impose death by a thousand papercuts or let forms and administration get in the way of making progress. Do not discourage contributions. Nobody can prevent someone else from doing work. Anyone can contribute in which ever way they find meaningful. You do not need to ask for permission.","title":"Not objectives"},{"location":"grin-rfcs/text/0002-grin-governance/#community-level-explanation","text":"This proposal outlines a set of loose principles to guide the work we do. While some of these may already be in use, they might not have been articulated before. It converts the council into a core team, and outlines its responsibilities for the first time. In addition, it's proposed that additional teams are introduced alongside it, as well as an RFC process. An initial teams breakdown is suggested, and the proposal concludes with a path to adoption.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0002-grin-governance/#general-principles","text":"Lead by example. \"Cypherpunks write code.\" We don't tell others what to do. We do what we can, and if we need to we ask for help. We suggest, but never command. We act as we want others to act. Not a democracy. We are evaluated based on the work we do. It's not a popularity contest, and the majority is not always right. Community members are here by their free will, participation is optional. Influence is measured by recent and not historical work. We are grateful for and respect historical contributions, but they do not lead to lifelong positions of authority. Influence is earned by making contributions consistently over time, allowing new contributors to join the ranks of the old. Transparency. Where possible, discussions and decisions are made in the open. We have nothing to hide, and we do not try to limit oversight unless there's a defensible reason to do so. Keep things lightweight. We strive to only put in place the minimal structure and organization that's needed, neither more nor less. Groups organize themselves. Structures do not need to be imposed tops down, and we recognise that what works for one group will not necessarily work for the other. Teams self-organize and define their own workflows and processes as they see fit. Consensus-seeking decision making. Voting creates winners and losers, and is polarizing. We recognize there are trade offs with everything and rarely any single right answer. This does not mean design by committee. We seek consensus through dialogue and discussion, but where there is a lack of consensus, we do not let it block us indefinitely. We're ready to make judgment calls to the best of our abilities. We speak for ourselves. We can only speak in the name of ourselves, as contributors to the project. We do not write blog posts, articles, tweets, or give interviews speaking on behalf of the project as a whole. Grin itself has no single voice. There's no need to ask for permission. We are not afraid to take decisions. We ask for feedback and opinions from others, but we do not need to ask for somebody's permission. If we believe it's in the best interest of Grin, we act, and are accountable for our actions. Mistakes are tolerated. As with any organization structure, mistakes happen. This is understood, and mistakes are accepted. We try to learn from them and improve. We assume we all act in good faith, until proven otherwise.","title":"General principles"},{"location":"grin-rfcs/text/0002-grin-governance/#core-team","text":"The existing grin council is proposed to be renamed to core team. Over time, it's intended to be a broad representation of the wider community with diverse stakeholders.","title":"Core team"},{"location":"grin-rfcs/text/0002-grin-governance/#responsibilities","text":"The core team leads the wider Grin project as a whole. In particular: Sets overall direction and vision. Values and philosophies. Steering towards use cases and targets. Sets priorities and plans releases. Maintains high level planning, roadmaps, focus areas, decides on pace and the release schedule. Work on broader, cross-sectional issues. What falls in-between teams, taking a global view. Adds and removes teams. While proposals for new teams can come from anywhere, the core team is responsible to ensure structures are productive and make sense. Appoints initial team leadership. Once a new team is established, core appoints a leader that has the responsibility to grow the team. Responsible for security. Handles disclosures, vulnerabilities, audits, processes. Handles multi-sig keys and takes high level spending decisions. Spending proposals can be made by anyone, and teams can have their own own budgets to deal with as they please.","title":"Responsibilities"},{"location":"grin-rfcs/text/0002-grin-governance/#organization-processes","text":"There's no defined maximum size of the team. New members are added through a core decision; A core member can nominate a new member for inclusion, there\u2019s discussion, and the process is consensus seeking. The general decision making process is consensus seeking - no majority rule based voting, but also not blocked by lack of explicit consensus. Core members have no explicit veto, but strong objections are considered. Nominations and discussions are kept private. The term of core members is currently undefined but may change in the future. A core member can resign by notifying the rest of the team. If unreachable for 30 days without any news, a core member can be removed through a core decision. The core team does not make rulings on RFCs of other teams, although individual team members might also participate in the discussions of sub teams or be members of those teams. Meeting notes should be published and made transparent to the community on a regular basis.","title":"Organization &amp; Processes"},{"location":"grin-rfcs/text/0002-grin-governance/#rfc-process","text":"An RFC is a Request For Comments document, outlining a proposed improvement or design change to an area of Grin. The exact specifics for the template is TBD. They are kept in their own dedicated repo and need to be accepted before a pull request is merged. Their purpose is to outline a standardized way of making proposals and allow the community to discuss and evaluate whether something is worth doing. Having an RFC accepted means that there's support \"in theory\" for the suggestion. It does not mean that a change becomes implemented automatically or in the exact way it is proposed, it is high-level design. The work still needs to be carried out. Accepted RFCs guide the broader planning work.","title":"RFC process"},{"location":"grin-rfcs/text/0002-grin-governance/#teams","text":"","title":"Teams"},{"location":"grin-rfcs/text/0002-grin-governance/#overview","text":"Teams are groups organized around specific areas or knowledge fields. They are responsible for these areas, but do not do all the work. Anyone can contribute anywhere, and do not need to hold a particular title to do so. Rather, teams work on policies, processes, and workflows for their specific areas, as required. They are in charge of the RFC process in their specific field: They determine what requires an RFC in their area, they assign RFC shepherds that guide an RFC through its various stages and ensures the right stakeholders become aware of it and solicit their feedback. Ultimately, teams decide whether an RFC in their area should be accepted or rejected. They are responsible to ensure that each RFC in their area has a tracked status, and that they progress towards an outcome. Teams self-organize, but should be inclusive and adhere to community values. They should have a leader, often this leader may be part of the core team. They determine how members get added to the team. They should include area experts, and stakeholders. The decision making process should be consensus-seeking where possible. Teams can be broken down into smaller working groups or teams, permanent or temporary, as required and is seen necessary for them to be productive. Each team has a dedicated section on the forum, they should meet regularly, and keep some notes on what was covered and decided. Decisions do not need to happen in meetings, and could for example be handled asynchronously or in the RFC process. Meeting notes should be published and made transparent to the community on a regular basis.","title":"Overview"},{"location":"grin-rfcs/text/0002-grin-governance/#the-teams","text":"In addition to Core team, the following teams are proposed to be created initially. Node development. Core Grin technology, changes and optimizations to the node and anything consensus related, research and discussion of new technologies, proof of work. Wallet development. wallet technology, wallet API, wallet-related research. Infrastructure. Technical documentation, non-technical documentation, QA, testing, toolchain, developer productivity, guides, how-tos. Ecosystem. 3rd party developers interaction (wallets, pools, exchanges and others), integration and technical assistance, growing the grin ecosystem, stakeholder collaboration. Community. Onboarding of new community members, website, chat channels, conferences, events, meetups. Fundraising. Sponsorships, donations, activities to increase project funds. Moderation. Code of conduct, handles violations, across all areas of the project. To avoid biases and conflicts of interest, this team does not contain any member of the core team.","title":"The teams"},{"location":"grin-rfcs/text/0002-grin-governance/#in-case-of-conflicts-disagreement-or-dissent","text":"Teams are created and appointed by the core, and core can decide to re-organize team structures and shut down dysfunctional teams. This is a \"nuclear\" option, such decisions should not be taken lightly. The repercussions of such actions can be worse than the initial situation. In practice, core team members might be engaging with teams as individual contributors. It is however not expected that \"the core team\" will become involved in the responsibilities of individual teams. Core sets the overall direction for the project, but should not micro manage teams as this defeats the entire purpose of having these teams in the first place. If there are conflicts within teams, these should ideally be resolved within the teams themselves. If this is not possible and there's contentious disagreements that need outside arbitration, teams can invite core or another team to become involved.","title":"In case of conflicts, disagreement, or dissent"},{"location":"grin-rfcs/text/0002-grin-governance/#drawbacks","text":"Adds a lot more structure. This might create overhead. Could lead to infighting and conflict between teams. Could lead to situations where one team does work that conflicts with other teams, \"left hand not talking to the right\".","title":"Drawbacks"},{"location":"grin-rfcs/text/0002-grin-governance/#rationale-and-alternatives","text":"Keep the process as is. Change the process to something else.","title":"Rationale and alternatives"},{"location":"grin-rfcs/text/0002-grin-governance/#prior-art","text":"Python conducted a comprehensive survey of the governance structures of various open source projects in 2018 through PEP-8002 . This document is highly recommended reading for various alternative structures.","title":"Prior art"},{"location":"grin-rfcs/text/0002-grin-governance/#unresolved-questions","text":"Far too many to all be listed here, but here are some: Is this too much structure for the amount of active contributors we have? Does this approach really address the problems as highlighted in the motivation? Does this legitimize the core team enough in the community?","title":"Unresolved questions"},{"location":"grin-rfcs/text/0002-grin-governance/#future-possibilities","text":"Introduce more teams Introduce an electorate Introduce terms Define firmer structures and organizational rules","title":"Future possibilities"},{"location":"grin-rfcs/text/0002-grin-governance/#references","text":"Rust's governance process - https://rust-lang.github.io/rfcs/1068-rust-governance.html - https://predictablynoisy.com/rust-governance - http://mgattozzi.com/oss-governance-and-sustainablility-i/ Node.js governance - https://medium.com/the-node-js-collection/healthy-open-source-967fa8be7951 Swarmwise, by Rick Falkvinge - https://falkvinge.net/files/2013/04/Swarmwise-2013-by-Rick-Falkvinge-v1.1-2013Sep01.pdf","title":"References"},{"location":"grin-rfcs/text/0003-security-process/","text":"Title: security-process Authors: John Woeltz Start date : July 18, 2019 RFC PR: mimblewimble/grin-rfcs#13 Tracking issue: mimblewimble/grin-pm#178 Summary This RFC improves the security processes for Grin by adopting a community standard for a public pre-commitment scheme for vulnerability sharing agreements. The standard proposed for adoption describes the norms for ethical disclosure behavior and provides a public pre-commitment scheme for the Grin community to clarify security process actions and expectations [2]. Motivation Improves transparency around Grin security and disclosure processes Decreases reaction time for mitigating security incidents across the Grin ecosystem Increases preparedness in the event of an extreme vulnerability Improves overall ecosystem resiliency Provides clarity around ethical behavior and expected deviations Makes possible the mapping of the vulnerability disclosure surface Community-level explanation This RFC proposes adopting a vulnerability disclosure standard for Grin that provides more guidance and clears up some unanswered questions from Grin's current security process . The community should think of this improvement as an extension to the existing security process with the following changes: Better define ethical behavior (and deviations) for vulnerability disclosure Better define the processes and expectations for receiving and sending disclosures Provide a framework for bi-lateral disclosure agreements with other projects/implementations A public commitment to the above This all results in a more robust security process for Grin that is transparent from the beginning to the community, vulnerability researchers, the core team and other neighboring projects that share threads in the same security blanket. An example of another project adopting the same standard can be found here in Zcash's vulnerability disclosure document. Reference-level explanation This RFC proposes to adopt a community responsible disclosure standard for Grin: https://github.com/RD-Crypto-Spec/Responsible-Disclosure Here we will describe the specific changes that would be made to SECURITY.md if the RFC is adopted. Many of the changes proposed are modeled from Zcash's security disclosure policy which adopts the same standard proposed here for Grin. All links to the standard in the actual implementation of SECURITY.md must be permanent. Changes to SECURITY.md The original Recognition and Bug Bounties section will be updated: Include a link to the Acknowledgements section of the standard Include a link to the Bounty Payments section of the standard Keep existing language such as: As of this writing, Grin is a traditional open source project with limited to no direct funding. As such, we have little means with which to compensate security researchers for their contributions. Remove unnecessary or old language such as: It is our hope that after mainnet release... Include a note that there is not currently a formal bug bounty program but that more donations can help provide the resources to run one in the future. Include a donation link here. The original Code Reviews and Audits section will be moved to a not yet determined page on the wiki . The original Chain Splits section will move to a not yet determined Github issue in the main repository. The following sections will be added to SECURITY.md and may replace existing sections as noted below. Responsible Disclosure Standard This section will replace the original vulnerability handling section Grin follows a community standard for responsible disclosure in cryptocurrency and related software. This document is a public commitment to following the standard. Any expected deviations are explained in the following sections. The standard provides detailed information for: - Initial Contact : how the initial contact process works - Giving Details : what details to include with your disclosure after receiving a response to your initial contact - Setting Dates : details for when to release updates and publicize details of the issue Receiving Disclosures This section will replace the will replace the original responsible disclosure section . Grin is committed to working with researchers who submit security vulnerability notifications to us to resolve those issues on an appropriate timeline and perform a coordinated release, giving credit to the reporter if they would like. Please submit issues to all of the following main points of contact for security related issues according to the initial contact and details guidelines. More information is available about the expected timelines for the full disclosure cycle . Emails and PGP keys for Grin's security contacts will be listed here as in the existing Responsible Disclosure and Public Key sections. Sending Disclosures In the case where we become aware of security issues affecting other projects that has never affected Grin, our intention is to inform those projects of security issues on a best effort basis. In the case where we fix a security issue in Grin that also affects the following neighboring projects, our intention is to engage in responsible disclosures with them as described in https://github.com/RD-Crypto-Spec/Responsible-Disclosure, subject to the deviations described in the 'Deviations from the Standard' section. Bilateral Responsible Disclosure Agreements Here we would list any agreements we have with neighboring projects to share vulnerability information in accordance with the standard itself and the 'Deviations from the Standard' section in the adoption of the standard. Agreements would be made by the core team or security team based on capacity to engage and relevance/impact on Grin's ecosystem and to an extent the greater cryptocurrency ecosystem. Deviations from the Standard Grin is a technology that provides strong privacy with zero-knowledge commitments and rangeproofs. Due to the nature of the cryptography used, if a counterfeiting bug results it could be exploited without a way to identify which data was corrupted. This renders rollbacks or other fork-based attempted fixes ineffective. The standard describes reporters of vulnerabilities including full details of an issue, in order to reproduce it. This is necessary for instance in the case of an external researcher both demonstrating and proving that there really is a security issue, and that security issue really has the impact that they say it has - allowing the development team to accurately prioritize and resolve the issue. In the case of a counterfeiting or privacy-breaking bug, however, we might decide not to include those details with our reports to partners ahead of coordinated release, so long as we are sure that they are vulnerable. Canaries For a privacy preserving project such as Grin, adversaries wishing to break that privacy may have incentive to disrupt Grin's security processes. This could be attempted via NSLs, FISA court orders, secret government subpoenas and rubber-hose tactics. The purpose of a PGP signed canary by each disclosure contact on a regular basis is to indicate that the disclosure contacts are not compelled in any way to take any actions (or non-actions) to jeopardize the security of Grin users. There are several examples of canaries in action, particularly in privacy preserving projects [5][6][7]. If this section is adopted with the RFC, canaries for each security contact for Grin vulnerability disclosures will be updated quarterly. Repos containing up to date signatures will be linked in the SECURITY.md document. In the event a security contact fails to keep their canary alive, they will be removed from the list of contacts. The specific language of each canary can be up to each contact unless a canary standard is adopted. Drawbacks This proposal could add complexity and overhead that a donation-supported decentralized project may not be able to uphold in good faith. Adopting and pre-committing to a standard and policy is not effective if it cannot be upheld through actions. This is amplified with bilateral agreements that extend through chains of vendors sharing code, many forks and multiple implementations with many operating publicly. For a project with extremely limited resources (relative to large companies) and no source of steady funding, it may not be possible to support the time and resources required to follow through on such a commitment. Rationale and alternatives Why is this design the best in the space of possible designs? This seems to be the most transparent and least centralized option that still provides the ability to efficiently handle cases of severe vulnerabilities that may be unique to Grin, while keeping with the minimalist philosophy. Relying on a single security@ disclosure email address provides a single point of failure. Additionally, not having clear pre-commitments to sharing agreements and expected ethical deviations can cause community contention at best and failure to successfully mitigate a vulnerability before it is exploited at worst. What other designs have been considered and what is the rationale for not choosing them? A less centralized model would be to attempt to guide this process with on-chain governance or an on-chain bug bounty program. Both of those not only challenge Grin's minimalist philosophy but are also extremely complicated to execute on. These do not seem to be viable options for Grin at this time. Ideally formal verification could be used to handle many of these security challenges but there is a huge gap between what formal verification can actually do and the complex blockchain related things we are doing today that we want formally verified. This may be more viable in the future, but it would require significant time and resource investment. It would not be responsible to rely on formal verification for a project like Grin today. What is the impact of not doing this? If we do not adopt a standard as proposed here, the community is left with unresolved problems: Who do we tell if we receive a vulnerability? What details are we obligated to share? Exploit code? What if it is an inflation bug? Do we attempt to collect a bug bounty? The community is exposed to risk by not having clear answers to these questions before it is presented with a critical security vulnerability. Even if the vulnerability has technically been fixed, there may be severe fallout in the community if it perceives the situation wasn't handled ethically by the parties involved in the disclosure. There is also risk of not implementing a fix in time across the community because there were internal disputes about who to tell. Without a public pre-commitment to expected actions taken during a vulnerability disclosure, Grin runs the risk of alienating the community in pursuit of security, or even worse, not implementing a critical fix before any user experiences privacy or value loss. Prior art The traditional disclosure model (RF Policy/security@) [0] handles interaction between researcher and vendor but does not quite fit for our use case of potentially multiple vendors up/down stream. There have been multi-party models proposed with single researcher and multiple vendors that have not been successful, nor do they sufficiently account for the challenges faced in public decentralized projects. Neither model fits with chains of vendors sharing code, protocols with multiple implementations and forks, all operating in public. We need a model that is better suited to handle cases of consensus critical vulnerabilities that require upgrades across many implementations, forks and projects both in the Grin and greater cryptocurrency ecosystems. Bitcoin has received some criticism over handling of disclosures, as it never had a robust, well-defined pre-committed standard to follow. We want to learn from those lessons to avoid putting more people in the position to repeat the same mistakes. Zcash, a privacy based cryptocurrency, experienced a critical vulnerability that inspired the creation of the standard this RFC proposes to adopt [1]. Due to the similar nature of the Zcash and Grin ecosystems, this prior art is highly relevant to the security process for Grin. Unresolved questions How can we further reduce centralization risk for Grin's security process? Disclosures are sent directly only to those listed in SECURITY.md. This poses a centralization risk for the community as there is no way to trustlessly publicly verify actions taken by individuals involved in a disclosure. While this RFC is a step in the right direction, it does not completely remove centralization risk for the disclosure process. How can we responsibly handle vulnerabilities in academic papers? It is possible that a vulnerability may be found in an underlying primitive at the specification level that Grin relies on. In this case not only do we have potential vulnerabilities in all implementations, but also in the specification itself. Without addressing these properly some may continue to use academic papers with vulnerable specifications as a reference for new development. What role will formal verification play in Grin's future? What form, if any, will the Bug Bounty process take? Future possibilities Security team If a security team is adopted in the future it would likely maintain these processes On-chain governance/bug bounties Bug bounty program Formal verification References [0] https://dl.packetstormsecurity.net/papers/general/rfpolicy-2.0.txt [1] https://www.youtube.com/watch?v=h7W1u1K2VjQ [2] https://github.com/RD-Crypto-Spec/Responsible-Disclosure [3] https://github.com/zcash/zcash/blob/master/responsible_disclosure.md [4] https://github.com/mimblewimble/grin/blob/09cf6de1d143ffbe007478372dc573213e06804d/SECURITY.md [5] https://github.com/QubesOS/qubes-secpack/blob/master/canaries/canary-020-2019.txt [6] https://riseup.net/about-us/canary/canary-statement-signed.txt [7] https://protonmail.com/blog/transparency-report/","title":"0003 security-process"},{"location":"grin-rfcs/text/0003-security-process/#summary","text":"This RFC improves the security processes for Grin by adopting a community standard for a public pre-commitment scheme for vulnerability sharing agreements. The standard proposed for adoption describes the norms for ethical disclosure behavior and provides a public pre-commitment scheme for the Grin community to clarify security process actions and expectations [2].","title":"Summary"},{"location":"grin-rfcs/text/0003-security-process/#motivation","text":"Improves transparency around Grin security and disclosure processes Decreases reaction time for mitigating security incidents across the Grin ecosystem Increases preparedness in the event of an extreme vulnerability Improves overall ecosystem resiliency Provides clarity around ethical behavior and expected deviations Makes possible the mapping of the vulnerability disclosure surface","title":"Motivation"},{"location":"grin-rfcs/text/0003-security-process/#community-level-explanation","text":"This RFC proposes adopting a vulnerability disclosure standard for Grin that provides more guidance and clears up some unanswered questions from Grin's current security process . The community should think of this improvement as an extension to the existing security process with the following changes: Better define ethical behavior (and deviations) for vulnerability disclosure Better define the processes and expectations for receiving and sending disclosures Provide a framework for bi-lateral disclosure agreements with other projects/implementations A public commitment to the above This all results in a more robust security process for Grin that is transparent from the beginning to the community, vulnerability researchers, the core team and other neighboring projects that share threads in the same security blanket. An example of another project adopting the same standard can be found here in Zcash's vulnerability disclosure document.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0003-security-process/#reference-level-explanation","text":"This RFC proposes to adopt a community responsible disclosure standard for Grin: https://github.com/RD-Crypto-Spec/Responsible-Disclosure Here we will describe the specific changes that would be made to SECURITY.md if the RFC is adopted. Many of the changes proposed are modeled from Zcash's security disclosure policy which adopts the same standard proposed here for Grin. All links to the standard in the actual implementation of SECURITY.md must be permanent.","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0003-security-process/#changes-to-securitymd","text":"The original Recognition and Bug Bounties section will be updated: Include a link to the Acknowledgements section of the standard Include a link to the Bounty Payments section of the standard Keep existing language such as: As of this writing, Grin is a traditional open source project with limited to no direct funding. As such, we have little means with which to compensate security researchers for their contributions. Remove unnecessary or old language such as: It is our hope that after mainnet release... Include a note that there is not currently a formal bug bounty program but that more donations can help provide the resources to run one in the future. Include a donation link here. The original Code Reviews and Audits section will be moved to a not yet determined page on the wiki . The original Chain Splits section will move to a not yet determined Github issue in the main repository. The following sections will be added to SECURITY.md and may replace existing sections as noted below.","title":"Changes to SECURITY.md"},{"location":"grin-rfcs/text/0003-security-process/#responsible-disclosure-standard","text":"This section will replace the original vulnerability handling section Grin follows a community standard for responsible disclosure in cryptocurrency and related software. This document is a public commitment to following the standard. Any expected deviations are explained in the following sections. The standard provides detailed information for: - Initial Contact : how the initial contact process works - Giving Details : what details to include with your disclosure after receiving a response to your initial contact - Setting Dates : details for when to release updates and publicize details of the issue","title":"Responsible Disclosure Standard"},{"location":"grin-rfcs/text/0003-security-process/#receiving-disclosures","text":"This section will replace the will replace the original responsible disclosure section . Grin is committed to working with researchers who submit security vulnerability notifications to us to resolve those issues on an appropriate timeline and perform a coordinated release, giving credit to the reporter if they would like. Please submit issues to all of the following main points of contact for security related issues according to the initial contact and details guidelines. More information is available about the expected timelines for the full disclosure cycle . Emails and PGP keys for Grin's security contacts will be listed here as in the existing Responsible Disclosure and Public Key sections.","title":"Receiving Disclosures"},{"location":"grin-rfcs/text/0003-security-process/#sending-disclosures","text":"In the case where we become aware of security issues affecting other projects that has never affected Grin, our intention is to inform those projects of security issues on a best effort basis. In the case where we fix a security issue in Grin that also affects the following neighboring projects, our intention is to engage in responsible disclosures with them as described in https://github.com/RD-Crypto-Spec/Responsible-Disclosure, subject to the deviations described in the 'Deviations from the Standard' section.","title":"Sending Disclosures"},{"location":"grin-rfcs/text/0003-security-process/#bilateral-responsible-disclosure-agreements","text":"Here we would list any agreements we have with neighboring projects to share vulnerability information in accordance with the standard itself and the 'Deviations from the Standard' section in the adoption of the standard. Agreements would be made by the core team or security team based on capacity to engage and relevance/impact on Grin's ecosystem and to an extent the greater cryptocurrency ecosystem.","title":"Bilateral Responsible Disclosure Agreements"},{"location":"grin-rfcs/text/0003-security-process/#deviations-from-the-standard","text":"Grin is a technology that provides strong privacy with zero-knowledge commitments and rangeproofs. Due to the nature of the cryptography used, if a counterfeiting bug results it could be exploited without a way to identify which data was corrupted. This renders rollbacks or other fork-based attempted fixes ineffective. The standard describes reporters of vulnerabilities including full details of an issue, in order to reproduce it. This is necessary for instance in the case of an external researcher both demonstrating and proving that there really is a security issue, and that security issue really has the impact that they say it has - allowing the development team to accurately prioritize and resolve the issue. In the case of a counterfeiting or privacy-breaking bug, however, we might decide not to include those details with our reports to partners ahead of coordinated release, so long as we are sure that they are vulnerable.","title":"Deviations from the Standard"},{"location":"grin-rfcs/text/0003-security-process/#canaries","text":"For a privacy preserving project such as Grin, adversaries wishing to break that privacy may have incentive to disrupt Grin's security processes. This could be attempted via NSLs, FISA court orders, secret government subpoenas and rubber-hose tactics. The purpose of a PGP signed canary by each disclosure contact on a regular basis is to indicate that the disclosure contacts are not compelled in any way to take any actions (or non-actions) to jeopardize the security of Grin users. There are several examples of canaries in action, particularly in privacy preserving projects [5][6][7]. If this section is adopted with the RFC, canaries for each security contact for Grin vulnerability disclosures will be updated quarterly. Repos containing up to date signatures will be linked in the SECURITY.md document. In the event a security contact fails to keep their canary alive, they will be removed from the list of contacts. The specific language of each canary can be up to each contact unless a canary standard is adopted.","title":"Canaries"},{"location":"grin-rfcs/text/0003-security-process/#drawbacks","text":"This proposal could add complexity and overhead that a donation-supported decentralized project may not be able to uphold in good faith. Adopting and pre-committing to a standard and policy is not effective if it cannot be upheld through actions. This is amplified with bilateral agreements that extend through chains of vendors sharing code, many forks and multiple implementations with many operating publicly. For a project with extremely limited resources (relative to large companies) and no source of steady funding, it may not be possible to support the time and resources required to follow through on such a commitment.","title":"Drawbacks"},{"location":"grin-rfcs/text/0003-security-process/#rationale-and-alternatives","text":"","title":"Rationale and alternatives"},{"location":"grin-rfcs/text/0003-security-process/#why-is-this-design-the-best-in-the-space-of-possible-designs","text":"This seems to be the most transparent and least centralized option that still provides the ability to efficiently handle cases of severe vulnerabilities that may be unique to Grin, while keeping with the minimalist philosophy. Relying on a single security@ disclosure email address provides a single point of failure. Additionally, not having clear pre-commitments to sharing agreements and expected ethical deviations can cause community contention at best and failure to successfully mitigate a vulnerability before it is exploited at worst.","title":"Why is this design the best in the space of possible designs?"},{"location":"grin-rfcs/text/0003-security-process/#what-other-designs-have-been-considered-and-what-is-the-rationale-for-not-choosing-them","text":"A less centralized model would be to attempt to guide this process with on-chain governance or an on-chain bug bounty program. Both of those not only challenge Grin's minimalist philosophy but are also extremely complicated to execute on. These do not seem to be viable options for Grin at this time. Ideally formal verification could be used to handle many of these security challenges but there is a huge gap between what formal verification can actually do and the complex blockchain related things we are doing today that we want formally verified. This may be more viable in the future, but it would require significant time and resource investment. It would not be responsible to rely on formal verification for a project like Grin today.","title":"What other designs have been considered and what is the rationale for not choosing them?"},{"location":"grin-rfcs/text/0003-security-process/#what-is-the-impact-of-not-doing-this","text":"If we do not adopt a standard as proposed here, the community is left with unresolved problems: Who do we tell if we receive a vulnerability? What details are we obligated to share? Exploit code? What if it is an inflation bug? Do we attempt to collect a bug bounty? The community is exposed to risk by not having clear answers to these questions before it is presented with a critical security vulnerability. Even if the vulnerability has technically been fixed, there may be severe fallout in the community if it perceives the situation wasn't handled ethically by the parties involved in the disclosure. There is also risk of not implementing a fix in time across the community because there were internal disputes about who to tell. Without a public pre-commitment to expected actions taken during a vulnerability disclosure, Grin runs the risk of alienating the community in pursuit of security, or even worse, not implementing a critical fix before any user experiences privacy or value loss.","title":"What is the impact of not doing this?"},{"location":"grin-rfcs/text/0003-security-process/#prior-art","text":"The traditional disclosure model (RF Policy/security@) [0] handles interaction between researcher and vendor but does not quite fit for our use case of potentially multiple vendors up/down stream. There have been multi-party models proposed with single researcher and multiple vendors that have not been successful, nor do they sufficiently account for the challenges faced in public decentralized projects. Neither model fits with chains of vendors sharing code, protocols with multiple implementations and forks, all operating in public. We need a model that is better suited to handle cases of consensus critical vulnerabilities that require upgrades across many implementations, forks and projects both in the Grin and greater cryptocurrency ecosystems. Bitcoin has received some criticism over handling of disclosures, as it never had a robust, well-defined pre-committed standard to follow. We want to learn from those lessons to avoid putting more people in the position to repeat the same mistakes. Zcash, a privacy based cryptocurrency, experienced a critical vulnerability that inspired the creation of the standard this RFC proposes to adopt [1]. Due to the similar nature of the Zcash and Grin ecosystems, this prior art is highly relevant to the security process for Grin.","title":"Prior art"},{"location":"grin-rfcs/text/0003-security-process/#unresolved-questions","text":"How can we further reduce centralization risk for Grin's security process? Disclosures are sent directly only to those listed in SECURITY.md. This poses a centralization risk for the community as there is no way to trustlessly publicly verify actions taken by individuals involved in a disclosure. While this RFC is a step in the right direction, it does not completely remove centralization risk for the disclosure process. How can we responsibly handle vulnerabilities in academic papers? It is possible that a vulnerability may be found in an underlying primitive at the specification level that Grin relies on. In this case not only do we have potential vulnerabilities in all implementations, but also in the specification itself. Without addressing these properly some may continue to use academic papers with vulnerable specifications as a reference for new development. What role will formal verification play in Grin's future? What form, if any, will the Bug Bounty process take?","title":"Unresolved questions"},{"location":"grin-rfcs/text/0003-security-process/#future-possibilities","text":"Security team If a security team is adopted in the future it would likely maintain these processes On-chain governance/bug bounties Bug bounty program Formal verification","title":"Future possibilities"},{"location":"grin-rfcs/text/0003-security-process/#references","text":"[0] https://dl.packetstormsecurity.net/papers/general/rfpolicy-2.0.txt [1] https://www.youtube.com/watch?v=h7W1u1K2VjQ [2] https://github.com/RD-Crypto-Spec/Responsible-Disclosure [3] https://github.com/zcash/zcash/blob/master/responsible_disclosure.md [4] https://github.com/mimblewimble/grin/blob/09cf6de1d143ffbe007478372dc573213e06804d/SECURITY.md [5] https://github.com/QubesOS/qubes-secpack/blob/master/canaries/canary-020-2019.txt [6] https://riseup.net/about-us/canary/canary-statement-signed.txt [7] https://protonmail.com/blog/transparency-report/","title":"References"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/","text":"Title: full-wallet-lifecycle Authors: Michael Cordner Start date : June 26th, 2019 RFC PR: mimblewimble/grin-rfcs#18 Tracking issue: mimblewimble/grin-wallet#212 Summary Increase the scope of the Grin Wallet's Owner API to support full wallet lifecycle functions. Motivation Grin Wallet's APIs currently provides functions for transacting and querying the contents of the wallet. However, several pieces of functionality around wallet creation and seed/password management are not included within the API. This means that any consumers of the API will either expect their users to initialize the wallet manually before the APIs can be used, or provide custom management for wallet lifecycle functions. The Wallet APIs are intended to be the foundation upon which community-created wallets should be built, and the job of a wallet creator is made far more difficult by the absence of wallet creation and seed management functions within the API. Ideally, it should be the case that a wallet can be instantiated and managed solely via the Owner API. Community-level explanation From an end-user perspective, (i.e. end-users of community wallets that use the wallet API,) this change should be transparent. Reference-level explanation Wallet Initialization Currently, wallet data does not exist until the user runs grin-wallet init . The init command creates grin-wallet.toml , in the ~/.grin/main directory (or ~/.grin/floonet , or the current directory via the -h flag), prompts the user for a password, creates a seed file, stores the resulting data files in the directory specified in grin-wallet.toml ( ~/.grin/main/wallet_data by default) and initialises the lmdb database. It should be possible to run grin-wallet owner_api or invoke the API directly from a linked binary without having instantiated a wallet. Security Model Given that the Wallet's Owner API needs to deal with sensitive data such as passwords and seed phrases, the API will be enhanced with a new ECDH and Token-based security model, the primary goals of which are to: Ensure sensitive data such as passwords or seed phrases are always end-to-end encrypted between the client and the Owner API server, regardless of what higher-level protocols are used during the exchange. Minimize the potential for damage that can be done by a third party listening on the exchange between a wallet client and its corresponding server. Ensure that sensitive data such as passwords or seed phrases are not resident in server-side memory any longer than they absolutely need to be. Note that this mode of operation is primarily intended for use over the JSON-RPC API, which supports many different architectural possiblities. Clients that link libraries directly and keep all sensitive data in the same process would see less benefit from this scheme, and an alternative model which doesn't encrypt any sensitive data is provided. Further, authors of existing wallets will need time to consider and/or implement the added complexity needed on the client-side to support ECDH and encryption. It's therefore proposed that the Owner API initially provide the new \"SecureAPI\" mode as an optional feature, with wallet authors strongly encouraged to make use of it. Support for the \"InsecureAPI\" model can be maintained indefinitely for directly-linked wallets, and for the JSON-RPC API until a cut-off release at some point in the future. Note that the \"SecureAPI\" mode and all lifecycle functions will be implemented in a V3 API, with the V2 API maintained for a time for backwards compatibility. The V3 API requires all JSON-RPC communication to be encrypted, with the exception of the init_secure_api function. SecureAPI Mode SecureAPI Mode consists of an ECDH key agreement followed by the establishment of an API Token that's used to XOR encrypt the wallet seed on the server side. The negotiated ECDH shared key is used to encrypt all requests and responses between the client and the JSON-RPC layer, while the token must be included in all API requests to allow the wallet backend to decrypt the seed. 'Open' wallets store their in-memory seeds XORed against the token, which is temporarily XORed against the supplied token during each request to reproduce the master seed. ECDH will use secp256k1 for key agreement. Encryption of JSON-RPC requests and responses will be performed using AEAD in GCM mode with 128-bit tags, 96 bit nonces, a 16 byte suffix length and an empty vector for the additional data. A 12 byte nonce will be applied in the encryption and included in each request/response to use o n the decrypting side. Encrypted requests and responses will be exchanged in valid JSON-RPC calls with the method \"encrypted_request_v3\" (with 'v3' here denoting the version of the API). They will have the following form: { \"jsonrpc\": \"2.0\", \"method: \"encrypted_request_v3\", \"id\": \"1\", \"params\": { \"nonce\": \"ef32...\", \"body_enc\": \"e0bcd...\" } } Security Mode Initialization To initialize the Secure API, clients will generate an EC keypair using the secp256k1 curve, and provide the public key to the Owner API server via a new init_secure_api method. Both client and server will calculate the shared key, and store this key for the remainder of the session. The sequence of operations is outlined below: The Secure API assumes that all requests (other than the actual call to init_secure_api itself) will be encrypted with the shared secret and presented in the above JSON-RPC format. All API calls other than open_wallet will be accompanied with a valid encrypted token derived during the call to the open_wallet function. This assumption will remain until the server process exits or a call to a corresponding close_api_secure function is called. The shared secret can be refreshed by the client at any time with another call to init_secure_api (either encrypted or unencrypted). Closing a wallet via the close_wallet function does not regenerate the shared secret but does invalidate the token and drops the XORed seed from memory. Legacy support The V2 API will remain active for a time the mode of operation for its JSON-RPC API will be assumed to work as currently, i.e. requests and responses are unencrypted, the wallet stores its full seed in-memory between requests and the providing of a token with each request is not requred. However, the new lifecycle functions described in this RFC, which deal with highly sensitive data such as passwords and master keys, will not be available in the V2 API. This setup should allow existing wallets to continue working as-is until a cutoff release for legacy mode is determined. Opening a Wallet in SecureAPI Mode Opening a wallet in SecureAPI mode consists of encrypting a request to open_wallet (which contains the wallet password) with the shared secret s . The request is decrypted in the JSON-RPC layer and the password is used in the wallet backend to unlock the wallet master seed. The master seed is stored XORed against a randomly-generated token T, which is returned to the client in an encrypted response for inclusion in all further API calls. T is valid for the lifetime of the process, or until a corresponding call to close_wallet . Calling API functions in SecureAPI Mode Calls to each API function proceed as per a call to open_wallet , however each encrypted request must contain the token provided by the open_wallet call. The token is XORed against the stored XORed seed to recover the original seed by the backend for the duration of each call, and the seed value is dropped and zeroed from memory when each call returns. Directly Linked Wallets Wallets that link the wallet API directly will not be required to encrypt parameters, as there would be little benefit to doing so within a single process. However, for consistency, they will be expected to store and supply a token to each API call. The modified workflow for a linked wallet is outlined below: 'Legacy' support will not be provided for directly-linked wallets on release of the features described in this RFC. It is expected that wallet authors will need to update their code to store and supply the token with each request. New Lifecycle API Functions The functions as shown here are for illustrative purposes, and their signatures will change during implementation. OwnerAPI::init_secure_api(pubkey: Secp256k1Point) -> Result<pubkey: Secp256K1Point, Error> Initializes secure API mode, returning the server-side public key to be used for key agreement All further calls to the JSON-RPC API must be encrypted with the shared secret OwnerAPI::set_wallet_directory(dir: String) -> Result<(), libwallet::Error> On API startup, it's assumed the top-level wallet data directory is ~/.grin/main/wallet_data (or floonet equivalent) Set the top-level system wallet directory from which named wallets are read. Further calls to lifecycle functions will use this wallet directory OwnerAPI::create_config(chain_type: &global::ChainTypes, config_overrides: Option<GlobalWalletConfig>) -> Result<(), libwallet::Error> Outputs a grin-wallet.toml file into current top-level system wallet directory Optionally takes wallet configuration structure to override defaults in the grin-wallet.toml file OwnerAPI::create_wallet(name: Option<String>, mnemonic: Option<ZeroingString>, mnemonic_length: usize, password: ZeroingString) -> Result<(), libwallet::Error> Creates and initializes a new wallet Initializes seed from given mnemonic if given, random seed otherwise Should error appropriately if the wallet already exists The 'name' parameter is included for future use as in open_wallet above. OwnerAPI::open_wallet(name: Option<String>, password: String) -> Result<t:Token, libwallet::Error> Opens a wallet and sets it as the 'active' wallet. All further API commands will be performed against this wallet. 'Opens' the wallet seed in memory, stored XORed against a new token. The token is to be returned to the client for use in all further API calls. The 'name' argument is included for future use, anticipating the inclusion of multiple wallets and seeds within a single top-level wallet directory. OwnerAPI::close_wallet(&mut self) -> Result<(), libwallet::Error> Closes the currently open wallet (i.e. drops the XORed seed from memory) OwnerAPI::get_mnemonic(t:Token) -> Result<ZeroingString, libwallet::Error> Returns the mnemonic from the active, (open) wallet OwnerAPI::change_password(old: ZeroingString, new: ZeroingString) -> Result<(), libwallet::Error> Changes the password for the open wallet. This will essentially: Close the wallet instance Confirm the existing seed can be opened with the given password Regenerate the wallet.seed file with the new password Re-open the wallet instance (Should this just operate on closed wallets instead?) OwnerAPI::delete_wallet(name: Option<String>, password: ZeroingString) -> Result<(), libwallet::Error> Dangerous function that removes all wallet data name argument reserved for future use API only Note that this RFC does not propose making user-facing changes to the existing CLI wallet to invoke these functions. It's expected that the existing cli functionality will be modified to invoke the new API functions. Implementation notes Although this document doesn't attempt to outline implementation, a few notes to consider for the implementor: Currently, the code that deals with wallet initialization and seed management sits outside the wallet APIs, in the impls crate, (denoting they're implementation specific). The implementation should attempt to refactor traits from these hard implementations into a new interface, similar to the existing WalletBackend and NodeClient interfaces (WalletLifecycleManager, for instance). The implementation within impls will then become an implementation of that trait and can be substituted by wallet authors with their own implementations. The implementation period of this RFC may be a good time to remove the BIP32 specific code out from Grin core into the wallet or into a separate rust crate (probably more desirable). New API functions should be implemented as additions, with the new features optional to ensure complete backwards compatibility Drawbacks Security-critical information such as passwords and mnemonics are covered via the encryption in the above scheme, but sending slate information via the OwnerAPI has privacy concerns. Unresolved questions Due to how this is likely to be implemented, the Foreign API will also have to provide a token for all wallet access. The Foreign API will need to store this token in-process, therefore negating much of the benefit of the scheme. Is there a cleverer way to deal with this? Future possibilities The changes in this RFC lead the way for: Support for multiple wallets in a single top-level data directory An alternate method of command-line invocation whereby the wallet presents its own prompt instead of using single-use commands. References None","title":"0004 full-wallet-lifecycle"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#summary","text":"Increase the scope of the Grin Wallet's Owner API to support full wallet lifecycle functions.","title":"Summary"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#motivation","text":"Grin Wallet's APIs currently provides functions for transacting and querying the contents of the wallet. However, several pieces of functionality around wallet creation and seed/password management are not included within the API. This means that any consumers of the API will either expect their users to initialize the wallet manually before the APIs can be used, or provide custom management for wallet lifecycle functions. The Wallet APIs are intended to be the foundation upon which community-created wallets should be built, and the job of a wallet creator is made far more difficult by the absence of wallet creation and seed management functions within the API. Ideally, it should be the case that a wallet can be instantiated and managed solely via the Owner API.","title":"Motivation"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#community-level-explanation","text":"From an end-user perspective, (i.e. end-users of community wallets that use the wallet API,) this change should be transparent.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#reference-level-explanation","text":"","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#wallet-initialization","text":"Currently, wallet data does not exist until the user runs grin-wallet init . The init command creates grin-wallet.toml , in the ~/.grin/main directory (or ~/.grin/floonet , or the current directory via the -h flag), prompts the user for a password, creates a seed file, stores the resulting data files in the directory specified in grin-wallet.toml ( ~/.grin/main/wallet_data by default) and initialises the lmdb database. It should be possible to run grin-wallet owner_api or invoke the API directly from a linked binary without having instantiated a wallet.","title":"Wallet Initialization"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#security-model","text":"Given that the Wallet's Owner API needs to deal with sensitive data such as passwords and seed phrases, the API will be enhanced with a new ECDH and Token-based security model, the primary goals of which are to: Ensure sensitive data such as passwords or seed phrases are always end-to-end encrypted between the client and the Owner API server, regardless of what higher-level protocols are used during the exchange. Minimize the potential for damage that can be done by a third party listening on the exchange between a wallet client and its corresponding server. Ensure that sensitive data such as passwords or seed phrases are not resident in server-side memory any longer than they absolutely need to be. Note that this mode of operation is primarily intended for use over the JSON-RPC API, which supports many different architectural possiblities. Clients that link libraries directly and keep all sensitive data in the same process would see less benefit from this scheme, and an alternative model which doesn't encrypt any sensitive data is provided. Further, authors of existing wallets will need time to consider and/or implement the added complexity needed on the client-side to support ECDH and encryption. It's therefore proposed that the Owner API initially provide the new \"SecureAPI\" mode as an optional feature, with wallet authors strongly encouraged to make use of it. Support for the \"InsecureAPI\" model can be maintained indefinitely for directly-linked wallets, and for the JSON-RPC API until a cut-off release at some point in the future. Note that the \"SecureAPI\" mode and all lifecycle functions will be implemented in a V3 API, with the V2 API maintained for a time for backwards compatibility. The V3 API requires all JSON-RPC communication to be encrypted, with the exception of the init_secure_api function.","title":"Security Model"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#secureapi-mode","text":"SecureAPI Mode consists of an ECDH key agreement followed by the establishment of an API Token that's used to XOR encrypt the wallet seed on the server side. The negotiated ECDH shared key is used to encrypt all requests and responses between the client and the JSON-RPC layer, while the token must be included in all API requests to allow the wallet backend to decrypt the seed. 'Open' wallets store their in-memory seeds XORed against the token, which is temporarily XORed against the supplied token during each request to reproduce the master seed. ECDH will use secp256k1 for key agreement. Encryption of JSON-RPC requests and responses will be performed using AEAD in GCM mode with 128-bit tags, 96 bit nonces, a 16 byte suffix length and an empty vector for the additional data. A 12 byte nonce will be applied in the encryption and included in each request/response to use o n the decrypting side. Encrypted requests and responses will be exchanged in valid JSON-RPC calls with the method \"encrypted_request_v3\" (with 'v3' here denoting the version of the API). They will have the following form: { \"jsonrpc\": \"2.0\", \"method: \"encrypted_request_v3\", \"id\": \"1\", \"params\": { \"nonce\": \"ef32...\", \"body_enc\": \"e0bcd...\" } }","title":"SecureAPI Mode"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#security-mode-initialization","text":"To initialize the Secure API, clients will generate an EC keypair using the secp256k1 curve, and provide the public key to the Owner API server via a new init_secure_api method. Both client and server will calculate the shared key, and store this key for the remainder of the session. The sequence of operations is outlined below: The Secure API assumes that all requests (other than the actual call to init_secure_api itself) will be encrypted with the shared secret and presented in the above JSON-RPC format. All API calls other than open_wallet will be accompanied with a valid encrypted token derived during the call to the open_wallet function. This assumption will remain until the server process exits or a call to a corresponding close_api_secure function is called. The shared secret can be refreshed by the client at any time with another call to init_secure_api (either encrypted or unencrypted). Closing a wallet via the close_wallet function does not regenerate the shared secret but does invalidate the token and drops the XORed seed from memory.","title":"Security Mode Initialization"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#legacy-support","text":"The V2 API will remain active for a time the mode of operation for its JSON-RPC API will be assumed to work as currently, i.e. requests and responses are unencrypted, the wallet stores its full seed in-memory between requests and the providing of a token with each request is not requred. However, the new lifecycle functions described in this RFC, which deal with highly sensitive data such as passwords and master keys, will not be available in the V2 API. This setup should allow existing wallets to continue working as-is until a cutoff release for legacy mode is determined.","title":"Legacy support"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#opening-a-wallet-in-secureapi-mode","text":"Opening a wallet in SecureAPI mode consists of encrypting a request to open_wallet (which contains the wallet password) with the shared secret s . The request is decrypted in the JSON-RPC layer and the password is used in the wallet backend to unlock the wallet master seed. The master seed is stored XORed against a randomly-generated token T, which is returned to the client in an encrypted response for inclusion in all further API calls. T is valid for the lifetime of the process, or until a corresponding call to close_wallet .","title":"Opening a Wallet in SecureAPI Mode"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#calling-api-functions-in-secureapi-mode","text":"Calls to each API function proceed as per a call to open_wallet , however each encrypted request must contain the token provided by the open_wallet call. The token is XORed against the stored XORed seed to recover the original seed by the backend for the duration of each call, and the seed value is dropped and zeroed from memory when each call returns.","title":"Calling API functions in SecureAPI Mode"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#directly-linked-wallets","text":"Wallets that link the wallet API directly will not be required to encrypt parameters, as there would be little benefit to doing so within a single process. However, for consistency, they will be expected to store and supply a token to each API call. The modified workflow for a linked wallet is outlined below: 'Legacy' support will not be provided for directly-linked wallets on release of the features described in this RFC. It is expected that wallet authors will need to update their code to store and supply the token with each request.","title":"Directly Linked Wallets"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#new-lifecycle-api-functions","text":"The functions as shown here are for illustrative purposes, and their signatures will change during implementation. OwnerAPI::init_secure_api(pubkey: Secp256k1Point) -> Result<pubkey: Secp256K1Point, Error> Initializes secure API mode, returning the server-side public key to be used for key agreement All further calls to the JSON-RPC API must be encrypted with the shared secret OwnerAPI::set_wallet_directory(dir: String) -> Result<(), libwallet::Error> On API startup, it's assumed the top-level wallet data directory is ~/.grin/main/wallet_data (or floonet equivalent) Set the top-level system wallet directory from which named wallets are read. Further calls to lifecycle functions will use this wallet directory OwnerAPI::create_config(chain_type: &global::ChainTypes, config_overrides: Option<GlobalWalletConfig>) -> Result<(), libwallet::Error> Outputs a grin-wallet.toml file into current top-level system wallet directory Optionally takes wallet configuration structure to override defaults in the grin-wallet.toml file OwnerAPI::create_wallet(name: Option<String>, mnemonic: Option<ZeroingString>, mnemonic_length: usize, password: ZeroingString) -> Result<(), libwallet::Error> Creates and initializes a new wallet Initializes seed from given mnemonic if given, random seed otherwise Should error appropriately if the wallet already exists The 'name' parameter is included for future use as in open_wallet above. OwnerAPI::open_wallet(name: Option<String>, password: String) -> Result<t:Token, libwallet::Error> Opens a wallet and sets it as the 'active' wallet. All further API commands will be performed against this wallet. 'Opens' the wallet seed in memory, stored XORed against a new token. The token is to be returned to the client for use in all further API calls. The 'name' argument is included for future use, anticipating the inclusion of multiple wallets and seeds within a single top-level wallet directory. OwnerAPI::close_wallet(&mut self) -> Result<(), libwallet::Error> Closes the currently open wallet (i.e. drops the XORed seed from memory) OwnerAPI::get_mnemonic(t:Token) -> Result<ZeroingString, libwallet::Error> Returns the mnemonic from the active, (open) wallet OwnerAPI::change_password(old: ZeroingString, new: ZeroingString) -> Result<(), libwallet::Error> Changes the password for the open wallet. This will essentially: Close the wallet instance Confirm the existing seed can be opened with the given password Regenerate the wallet.seed file with the new password Re-open the wallet instance (Should this just operate on closed wallets instead?) OwnerAPI::delete_wallet(name: Option<String>, password: ZeroingString) -> Result<(), libwallet::Error> Dangerous function that removes all wallet data name argument reserved for future use","title":"New Lifecycle API Functions"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#api-only","text":"Note that this RFC does not propose making user-facing changes to the existing CLI wallet to invoke these functions. It's expected that the existing cli functionality will be modified to invoke the new API functions.","title":"API only"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#implementation-notes","text":"Although this document doesn't attempt to outline implementation, a few notes to consider for the implementor: Currently, the code that deals with wallet initialization and seed management sits outside the wallet APIs, in the impls crate, (denoting they're implementation specific). The implementation should attempt to refactor traits from these hard implementations into a new interface, similar to the existing WalletBackend and NodeClient interfaces (WalletLifecycleManager, for instance). The implementation within impls will then become an implementation of that trait and can be substituted by wallet authors with their own implementations. The implementation period of this RFC may be a good time to remove the BIP32 specific code out from Grin core into the wallet or into a separate rust crate (probably more desirable). New API functions should be implemented as additions, with the new features optional to ensure complete backwards compatibility","title":"Implementation notes"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#drawbacks","text":"Security-critical information such as passwords and mnemonics are covered via the encryption in the above scheme, but sending slate information via the OwnerAPI has privacy concerns.","title":"Drawbacks"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#unresolved-questions","text":"Due to how this is likely to be implemented, the Foreign API will also have to provide a token for all wallet access. The Foreign API will need to store this token in-process, therefore negating much of the benefit of the scheme. Is there a cleverer way to deal with this?","title":"Unresolved questions"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#future-possibilities","text":"The changes in this RFC lead the way for: Support for multiple wallets in a single top-level data directory An alternate method of command-line invocation whereby the wallet presents its own prompt instead of using single-use commands.","title":"Future possibilities"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#references","text":"None","title":"References"},{"location":"grin-rfcs/text/0005-variable-size-kernels/","text":"Title: variable-size-kernels Authors: Antioch Peverell Start date: Aug 13, 2019 RFC PR: mimblewimble/grin-rfcs#21 Tracking issue: mimblewimble/grin#3038 Summary We minimize the size of binary serialized transaction kernels by including only the data applicable for each kernel variant. Height locked kernels include a fee and a lock height. Plain kernels include only a fee. Coinbase kernels include neither a fee nor a lock height. Each kernel feature variant will serialize to a fixed size in bytes but this size will differ across the kernel variants. Motivation We were originally including both fee and lock_height on every kernel in the binary serialization format. We were storing a fee of 0 on coinbase kernels and a lock_height of 0 on both plain and coinbase kernels. Kernels are never pruned and must be maintained forever so this overhead is relatively expensive. By only serializing data strictly necessary for each kernel variant we minimize storage and transmission costs. This also provides the flexibility necessary to introduce new kernel variants in the future, for example the proposed relative kernels . Community-level explanation Each transaction kernel variant may have associated data. For example, height locked kernels include an associated lock height and non-coinbase kernels have an associated fee. Each kernel variant serializes to a fixed size in bytes but this size may be different for each kernel variants. This allows kernels to be serialized efficiently and provides flexibility to introduce new kernel variants that have additional associated data in the future. A plain kernel is 106 bytes compared to 114 bytes for a height locked kernel. Omitting the lock height from plain kernels saves approximately 7% in kernel storage costs. These changes affect serialization/deserialization of transaction kernels. Kernels are included in p2p messages for transactions and full blocks. Older nodes will serialize transaction kernels differently so nodes on the network need to be able to handle old and new serialization formats. The kernel MMR is also included in the txhashset state file during fast sync so nodes need to be able to support old and new formats of the state file. Reference-level explanation Protocol Version 1 (Previous Version) In protocol version 1 all transaction kernels are serialized using the same structure, regardless of kernel variant. All kernels include 8 bytes for the fee and 8 bytes for the lock_height, even if unused. features (1 byte) | fee (8 bytes) | lock_height (8 bytes) | excess (33 bytes) | signature (64 bytes) 00 | 00 00 00 00 01 f7 8a 40 | 00 00 00 00 00 00 00 00 | 08 b1 ... 22 d8 | 33 11 ... b9 69 All kernels contain a feature byte to determine the variant. Kernels always include an excess commitment and signature, 33 bytes and 64 bytes respectively. The proposal is to have variant specific data follow the feature byte. The initial feature byte would determine the number of subsequent bytes to read for variant specific data. 00 (plain): following 8 bytes for the fee. 01 (coinbase): no additional bytes. 02 (height locked): following 8 bytes for the fee and additional 8 bytes for the lock height. This would always be followed by a fixed 33 bytes for the excess commitment and 64 bytes for the kernel signature. Protocol Version 2 (Current Version) Plain kernel, includes fee. features (1 byte) | fee (8 bytes) | excess (33 bytes) | signature (64 bytes) 00 | 00 00 00 00 01 f7 8a 40 | 08 b1 ... 22 d8 | 33 11 ... b9 69 Coinbase kernel, no fee, no lock height. features (1 byte) | excess (33 bytes) | signature (64 bytes) 01 | 08 b2 ... 15 36 | 08 14 ... 98 96 Height locked kernel, include fee and lock height. features (1 byte) | fee (8 bytes) | lock_height (8 bytes) | excess (33 bytes) | signature (64 bytes) 02 | 00 00 00 00 00 6a cf c0 | 00 00 00 00 00 00 04 14 | 09 4d ... bb 9a | 09 c7 ... bd 54 Backward Compatibility (Protocol Version Support) Network p2p messages The following p2p messages include serialized transaction kernels - transaction full block compact block (incl. coinbase kernel) Each node has a \"local\" protocol version. Nodes exchange protocol versions during the initial handshake when setting up a connection. If both nodes are running protocol version 2 then no translation is required and transaction kernels can be serialized using protocol version 2. If both nodes are running protocol version 1 then again no translation is required. The complexity arises when one node is running protocol version 2 and the other node is running protocol version 1. Node A: protocol version 2 Node B: protocol version 1 If node A and node B are communicating they must both send and receive using a protocol version compatible with both nodes. In this case protocol version 1. Receiving messages using previous protocol version Node B will broadcast transactions and blocks using protocol version 1. Node A will need to use the previous protocol version and not the local version when deserializing these messages. Sending messages using previous protocol version Node A will need to ensure anything broadcast to Node B is compatible with protocol version 1. In both cases node A is responsible for translating to and from the previous protocol version. Local db storage Each node has a \"db\" protocol version. All entries in the db serialize/deserialize using that protocol version. Nodes support a process for local migration of data. On startup, the db is inspected and if necessary a migration is performed upgrading all entries in the db to the latest protocol version. This process can be disabled locally to allow nodes to run against old databases without upgrading the protocol version. This is useful in cases where nodes do not wish to immediately upgrade the db, allowing for previous versions of code to run without problems. Kernel MMR storage Each node maintains a kernel MMR as part of the txhashset data structure. Each node has an MMR protocol version. The node will serialize/deserialize kernel entries in the kernel MMR data file according to the MMR protocol version. Fast sync (txhashset.zip state file) Internally nodes are free to use any protocol version but the kernel MMR is also provided to other nodes during initial fast sync. A node joining the network requests a txhashset state file and this includes the kernel MMR. It is important that nodes send and receive the txhashset file using a compatible protocol version. This is a special case of \"p2p messages\" above with the txhashset state file provided as an attachment to the txhashset message. If node A (protocol version 2) requests a txhashset from node B (protocol version 1) then it must read the file using protocol version 1. Similarly, if node B requests txhashset from node A then node A must provide the file such that it is compatible with protocol version 1. The simplest way to achieve this is for all nodes to continue to use protocol version 1 internally for MMR storage, even if they use protocol version 2 externally for p2p messages. A transition period will be in place until a majority of nodes support protocol version 2 at which time nodes can migrate their MMR storage to protocol version 2. Wallet Compatibility Interactive transaction building involves a transaction \"slate\" passed between parties. This includes a json serialized representation of the transaction. To minimize compatibility issues between wallets we have maintained this existing json format. Transaction kernels are represented in a single consistent json format, with fee and lock_height both included, regardless of kernel variant. Plain kernels have an associated lock_height of 0 and coinbase kernels include a 0 fee. This is consistent with the current \"v2\" slate. \"kernels\": [ { \"features\": \"Plain\", \"fee\": \"7000000\", \"lock_height\": \"0\", \"excess\": \"08b1...22d8\", \"excess_sig\": \"3311...b969\" }, ... ] Future possibilities Support for variable size kernels allows new kernel variants to be introduced in the future. One proposed kernel variant is No Recent Duplicate (NRD) kernels . Kernels with relative lock heights will have an associated reference to a prior kernel in addition to a lock height based on that prior kernel. References RFC 0000-nrd-kernels [fix link once RFC merged] PR #2734 Support for variable size MMRs PR #2824 Protocol version support PR #2859 Kernel feature variants","title":"0005 variable-size-kernels"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#summary","text":"We minimize the size of binary serialized transaction kernels by including only the data applicable for each kernel variant. Height locked kernels include a fee and a lock height. Plain kernels include only a fee. Coinbase kernels include neither a fee nor a lock height. Each kernel feature variant will serialize to a fixed size in bytes but this size will differ across the kernel variants.","title":"Summary"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#motivation","text":"We were originally including both fee and lock_height on every kernel in the binary serialization format. We were storing a fee of 0 on coinbase kernels and a lock_height of 0 on both plain and coinbase kernels. Kernels are never pruned and must be maintained forever so this overhead is relatively expensive. By only serializing data strictly necessary for each kernel variant we minimize storage and transmission costs. This also provides the flexibility necessary to introduce new kernel variants in the future, for example the proposed relative kernels .","title":"Motivation"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#community-level-explanation","text":"Each transaction kernel variant may have associated data. For example, height locked kernels include an associated lock height and non-coinbase kernels have an associated fee. Each kernel variant serializes to a fixed size in bytes but this size may be different for each kernel variants. This allows kernels to be serialized efficiently and provides flexibility to introduce new kernel variants that have additional associated data in the future. A plain kernel is 106 bytes compared to 114 bytes for a height locked kernel. Omitting the lock height from plain kernels saves approximately 7% in kernel storage costs. These changes affect serialization/deserialization of transaction kernels. Kernels are included in p2p messages for transactions and full blocks. Older nodes will serialize transaction kernels differently so nodes on the network need to be able to handle old and new serialization formats. The kernel MMR is also included in the txhashset state file during fast sync so nodes need to be able to support old and new formats of the state file.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#reference-level-explanation","text":"","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#protocol-version-1-previous-version","text":"In protocol version 1 all transaction kernels are serialized using the same structure, regardless of kernel variant. All kernels include 8 bytes for the fee and 8 bytes for the lock_height, even if unused. features (1 byte) | fee (8 bytes) | lock_height (8 bytes) | excess (33 bytes) | signature (64 bytes) 00 | 00 00 00 00 01 f7 8a 40 | 00 00 00 00 00 00 00 00 | 08 b1 ... 22 d8 | 33 11 ... b9 69 All kernels contain a feature byte to determine the variant. Kernels always include an excess commitment and signature, 33 bytes and 64 bytes respectively. The proposal is to have variant specific data follow the feature byte. The initial feature byte would determine the number of subsequent bytes to read for variant specific data. 00 (plain): following 8 bytes for the fee. 01 (coinbase): no additional bytes. 02 (height locked): following 8 bytes for the fee and additional 8 bytes for the lock height. This would always be followed by a fixed 33 bytes for the excess commitment and 64 bytes for the kernel signature.","title":"Protocol Version 1 (Previous Version)"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#protocol-version-2-current-version","text":"Plain kernel, includes fee. features (1 byte) | fee (8 bytes) | excess (33 bytes) | signature (64 bytes) 00 | 00 00 00 00 01 f7 8a 40 | 08 b1 ... 22 d8 | 33 11 ... b9 69 Coinbase kernel, no fee, no lock height. features (1 byte) | excess (33 bytes) | signature (64 bytes) 01 | 08 b2 ... 15 36 | 08 14 ... 98 96 Height locked kernel, include fee and lock height. features (1 byte) | fee (8 bytes) | lock_height (8 bytes) | excess (33 bytes) | signature (64 bytes) 02 | 00 00 00 00 00 6a cf c0 | 00 00 00 00 00 00 04 14 | 09 4d ... bb 9a | 09 c7 ... bd 54","title":"Protocol Version 2 (Current Version)"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#backward-compatibility-protocol-version-support","text":"","title":"Backward Compatibility (Protocol Version Support)"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#network-p2p-messages","text":"The following p2p messages include serialized transaction kernels - transaction full block compact block (incl. coinbase kernel) Each node has a \"local\" protocol version. Nodes exchange protocol versions during the initial handshake when setting up a connection. If both nodes are running protocol version 2 then no translation is required and transaction kernels can be serialized using protocol version 2. If both nodes are running protocol version 1 then again no translation is required. The complexity arises when one node is running protocol version 2 and the other node is running protocol version 1. Node A: protocol version 2 Node B: protocol version 1 If node A and node B are communicating they must both send and receive using a protocol version compatible with both nodes. In this case protocol version 1. Receiving messages using previous protocol version Node B will broadcast transactions and blocks using protocol version 1. Node A will need to use the previous protocol version and not the local version when deserializing these messages. Sending messages using previous protocol version Node A will need to ensure anything broadcast to Node B is compatible with protocol version 1. In both cases node A is responsible for translating to and from the previous protocol version.","title":"Network p2p messages"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#local-db-storage","text":"Each node has a \"db\" protocol version. All entries in the db serialize/deserialize using that protocol version. Nodes support a process for local migration of data. On startup, the db is inspected and if necessary a migration is performed upgrading all entries in the db to the latest protocol version. This process can be disabled locally to allow nodes to run against old databases without upgrading the protocol version. This is useful in cases where nodes do not wish to immediately upgrade the db, allowing for previous versions of code to run without problems.","title":"Local db storage"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#kernel-mmr-storage","text":"Each node maintains a kernel MMR as part of the txhashset data structure. Each node has an MMR protocol version. The node will serialize/deserialize kernel entries in the kernel MMR data file according to the MMR protocol version.","title":"Kernel MMR storage"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#fast-sync-txhashsetzip-state-file","text":"Internally nodes are free to use any protocol version but the kernel MMR is also provided to other nodes during initial fast sync. A node joining the network requests a txhashset state file and this includes the kernel MMR. It is important that nodes send and receive the txhashset file using a compatible protocol version. This is a special case of \"p2p messages\" above with the txhashset state file provided as an attachment to the txhashset message. If node A (protocol version 2) requests a txhashset from node B (protocol version 1) then it must read the file using protocol version 1. Similarly, if node B requests txhashset from node A then node A must provide the file such that it is compatible with protocol version 1. The simplest way to achieve this is for all nodes to continue to use protocol version 1 internally for MMR storage, even if they use protocol version 2 externally for p2p messages. A transition period will be in place until a majority of nodes support protocol version 2 at which time nodes can migrate their MMR storage to protocol version 2.","title":"Fast sync (txhashset.zip state file)"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#wallet-compatibility","text":"Interactive transaction building involves a transaction \"slate\" passed between parties. This includes a json serialized representation of the transaction. To minimize compatibility issues between wallets we have maintained this existing json format. Transaction kernels are represented in a single consistent json format, with fee and lock_height both included, regardless of kernel variant. Plain kernels have an associated lock_height of 0 and coinbase kernels include a 0 fee. This is consistent with the current \"v2\" slate. \"kernels\": [ { \"features\": \"Plain\", \"fee\": \"7000000\", \"lock_height\": \"0\", \"excess\": \"08b1...22d8\", \"excess_sig\": \"3311...b969\" }, ... ]","title":"Wallet Compatibility"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#future-possibilities","text":"Support for variable size kernels allows new kernel variants to be introduced in the future. One proposed kernel variant is No Recent Duplicate (NRD) kernels . Kernels with relative lock heights will have an associated reference to a prior kernel in addition to a lock height based on that prior kernel.","title":"Future possibilities"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#references","text":"RFC 0000-nrd-kernels [fix link once RFC merged] PR #2734 Support for variable size MMRs PR #2824 Protocol version support PR #2859 Kernel feature variants","title":"References"},{"location":"grin-rfcs/text/0006-payment-proofs/","text":"Title: payment-proofs Authors: David Burkett Start date: Nov 5, 2019 RFC PR: mimblewimble/grin-rfcs#31 Tracking issue: mimblewimble/grin-wallet#230 Summary Support generating and validating payment proofs for sender-initiated (i.e. non-invoice) transactions. Motivation Bitcoin and other cryptocurrencies with transparent protocol-level addressing and immutable, unprunable blockchains can prove sender, receiver, and amounts of payments simply by pointing to the transaction in the blockchain. Grin's privacy and scalability means users no longer have this ability. This prevents some merchants from accepting Grin due to the high possibility of payment disputes that are unresolvable in the same way they are for transparent coins. This RFC changes the transaction building process where payers can require payees to create a \"proof\" they've received a payment before the payer finalizes and broadcasts the transaction. Community-level explanation From an end-user perspective, payers can require payees to prove receipt of funds as part of the transacting process. Payers can then use these \"proofs\" to resolve payment disputes and prove they sent funds to the correct payee. Reference-level explanation Slate changes A new (optional) structure ( payment_info ) will be added to transaction slates, along with a version increase. The payment_info structure will contain: sender_address - An ed25519 public key generated by the sender. receiver_address - An ed25519 public key for the receiver, typically the public key of the user's v3 onion address. receiver_signature - A signature of the sender_address, received amount, and kernel commitment that validates against the receiver_address . Generating proofs Receipt confirmations ( receiver_signature ) will be generated by the payee by providing an ED25519 signature of: (amount || kernel_commitment || sender_address) , using the private key of the receiver_address . The sender_signature can be generated for (amount || kernel_commitment || sender_address) using the private key of the sender_address . Sender will then create and store the following info, which can be considered the complete payment_proof : receiver_address receiver_signature amount kernel_commitment sender_address sender_signature Verifying Proofs This payment_proof can be provided by the sender at any time to convince a payee that a payment was made to them. The proof can be verified as follows: Ensure the kernel_commitment is confirmed on-chain. Verify that the receiver_address belongs to the payee. Verify that the receiver_signature is valid. Verify that the sender_signature is valid. Wallet actions init-send As part of the first step of the tx-building process, the sender/payer generates the sender_address using their keychain. The receiver_address and keychain path of the sender_address must be stored locally, along with the slate_id . The sender_address and receiver_address will then be added to the payment_proof structure of the slate. receive If the payment_proof structure exists on the slate, it is mandatory that the receiver_signature is generated and added to the slate as part of the receive tx-building step. finalize Using the slate_id , the sender can retrieve the original sender_address and receiver_address that were included in the slate, and verify that those fields remain unchanged. The sender must then validate the receiver_signature . If any of the original payment_proof slate fields were modified, or if the receiver_signature is invalid, the transaction must be rejected by the sender. Once the payment_info details have been validated, the sender can generate and store the payment_proof (See Generating Proofs above), and then finalize the transaction as normal. Drawbacks Increases the size of tx slates. Possibility of privacy leakage through address reuse. Rationale and alternatives This design works well with TOR tx building, yet is generic enough to work with all known transacting mechanisms. Prior art Wallet713 implements payment proofs for grinbox transactions, which our design adapts and builds on to work more seemlessly with onion addresses and with transaction building methods that don't inherently rely on addresses. Unresolved questions Can this be adapted to work for invoices? Future possibilities Payment proofs could potentially be added to invoice payments in the future, but at the cost of an additional round of communication. References Tx slate structure: https://github.com/mimblewimble/grin-wallet/blob/master/libwallet/src/slate.rs Beam's payment proof model: https://github.com/BeamMW/beam/blob/c9beb0eae55fa6b7fb3084ebe9b5db2850cf83b9/wallet/wallet_db.cpp#L3231-L3236","title":"0006 payment-proofs"},{"location":"grin-rfcs/text/0006-payment-proofs/#summary","text":"Support generating and validating payment proofs for sender-initiated (i.e. non-invoice) transactions.","title":"Summary"},{"location":"grin-rfcs/text/0006-payment-proofs/#motivation","text":"Bitcoin and other cryptocurrencies with transparent protocol-level addressing and immutable, unprunable blockchains can prove sender, receiver, and amounts of payments simply by pointing to the transaction in the blockchain. Grin's privacy and scalability means users no longer have this ability. This prevents some merchants from accepting Grin due to the high possibility of payment disputes that are unresolvable in the same way they are for transparent coins. This RFC changes the transaction building process where payers can require payees to create a \"proof\" they've received a payment before the payer finalizes and broadcasts the transaction.","title":"Motivation"},{"location":"grin-rfcs/text/0006-payment-proofs/#community-level-explanation","text":"From an end-user perspective, payers can require payees to prove receipt of funds as part of the transacting process. Payers can then use these \"proofs\" to resolve payment disputes and prove they sent funds to the correct payee.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0006-payment-proofs/#reference-level-explanation","text":"","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0006-payment-proofs/#slate-changes","text":"A new (optional) structure ( payment_info ) will be added to transaction slates, along with a version increase. The payment_info structure will contain: sender_address - An ed25519 public key generated by the sender. receiver_address - An ed25519 public key for the receiver, typically the public key of the user's v3 onion address. receiver_signature - A signature of the sender_address, received amount, and kernel commitment that validates against the receiver_address .","title":"Slate changes"},{"location":"grin-rfcs/text/0006-payment-proofs/#generating-proofs","text":"Receipt confirmations ( receiver_signature ) will be generated by the payee by providing an ED25519 signature of: (amount || kernel_commitment || sender_address) , using the private key of the receiver_address . The sender_signature can be generated for (amount || kernel_commitment || sender_address) using the private key of the sender_address . Sender will then create and store the following info, which can be considered the complete payment_proof : receiver_address receiver_signature amount kernel_commitment sender_address sender_signature","title":"Generating proofs"},{"location":"grin-rfcs/text/0006-payment-proofs/#verifying-proofs","text":"This payment_proof can be provided by the sender at any time to convince a payee that a payment was made to them. The proof can be verified as follows: Ensure the kernel_commitment is confirmed on-chain. Verify that the receiver_address belongs to the payee. Verify that the receiver_signature is valid. Verify that the sender_signature is valid.","title":"Verifying Proofs"},{"location":"grin-rfcs/text/0006-payment-proofs/#wallet-actions","text":"","title":"Wallet actions"},{"location":"grin-rfcs/text/0006-payment-proofs/#init-send","text":"As part of the first step of the tx-building process, the sender/payer generates the sender_address using their keychain. The receiver_address and keychain path of the sender_address must be stored locally, along with the slate_id . The sender_address and receiver_address will then be added to the payment_proof structure of the slate.","title":"init-send"},{"location":"grin-rfcs/text/0006-payment-proofs/#receive","text":"If the payment_proof structure exists on the slate, it is mandatory that the receiver_signature is generated and added to the slate as part of the receive tx-building step.","title":"receive"},{"location":"grin-rfcs/text/0006-payment-proofs/#finalize","text":"Using the slate_id , the sender can retrieve the original sender_address and receiver_address that were included in the slate, and verify that those fields remain unchanged. The sender must then validate the receiver_signature . If any of the original payment_proof slate fields were modified, or if the receiver_signature is invalid, the transaction must be rejected by the sender. Once the payment_info details have been validated, the sender can generate and store the payment_proof (See Generating Proofs above), and then finalize the transaction as normal.","title":"finalize"},{"location":"grin-rfcs/text/0006-payment-proofs/#drawbacks","text":"Increases the size of tx slates. Possibility of privacy leakage through address reuse.","title":"Drawbacks"},{"location":"grin-rfcs/text/0006-payment-proofs/#rationale-and-alternatives","text":"This design works well with TOR tx building, yet is generic enough to work with all known transacting mechanisms.","title":"Rationale and alternatives"},{"location":"grin-rfcs/text/0006-payment-proofs/#prior-art","text":"Wallet713 implements payment proofs for grinbox transactions, which our design adapts and builds on to work more seemlessly with onion addresses and with transaction building methods that don't inherently rely on addresses.","title":"Prior art"},{"location":"grin-rfcs/text/0006-payment-proofs/#unresolved-questions","text":"Can this be adapted to work for invoices?","title":"Unresolved questions"},{"location":"grin-rfcs/text/0006-payment-proofs/#future-possibilities","text":"Payment proofs could potentially be added to invoice payments in the future, but at the cost of an additional round of communication.","title":"Future possibilities"},{"location":"grin-rfcs/text/0006-payment-proofs/#references","text":"Tx slate structure: https://github.com/mimblewimble/grin-wallet/blob/master/libwallet/src/slate.rs Beam's payment proof model: https://github.com/BeamMW/beam/blob/c9beb0eae55fa6b7fb3084ebe9b5db2850cf83b9/wallet/wallet_db.cpp#L3231-L3236","title":"References"},{"location":"grin-rfcs/text/0007-node-api-v2/","text":"Title: node-api-v2 Authors: Quentin Le Sceller Start date: September 30th, 2019 RFC PR: mimblewimble/grin-rfcs#28 Tracking issue: mimblewimble/grin#3158 Table of Contents Summary Motivation Community-level explanation Reference-level explanation Current Endpoints with the v1 API Proposed Endpoints Owner API Endpoints get_status validate_chain compact_chain get_peers get_connected_peers ban_peer unban_peer Foreign API Endpoints get_version get_header get_block get_tip get_kernel get_outputs get_unspent_outputs get_pmmr_indices get_pool_size get_stempool_size get_unconfirmed_transactions push_transaction Errors JSON-RPC Errors API Result Errors Authentication Wallet support Legacy support API only Node V1 Deprecation Timeline Drawbacks Prior art Future possibilities References Summary Create a v2 JSON-RPC API for the Node API. Motivation The previous Node API (referred to here as v1) was a REST API. This API while simple had a few drawbacks: Manually documented (current documentation is available here . Contains call with heterogenous args such as ?byid=xxx and commitment/xxx which can be confusing and lack some uniformity. Uses REST which is bound to HTTP while v2 wallet API uses JSON-RPC. No difference between node management and simple information endpoints (i.e. exposing the node on the internet would allow anyone to query sensitive endpoints) This RFC provides a new v2 API with: - Cleaner methods and errors. - Owner and Foreign API. - Generated documentation directly on docs.rs. - Automatic testing with doc tests. - Stronger basis for future improvements. Community-level explanation This new API will be particularly useful for wallet developer and should ultimately simplify their work on Grin. Moreover, this RFC does not introduce any breaking changes as the v1 REST API will still be around until completely deprecated. Reference-level explanation V1 Endpoints While the endpoints are documented in details here , here is an overview of the REST API Endpoints of the v1 API. [ \"get blocks\" , \"get headers\" , \"get chain\" , \"post chain/compact\" , \"get chain/validate\" , \"get chain/kernels/xxx?min_height=yyy&max_height=zzz\" , \"get chain/outputs/byids?id=xxx,yyy,zzz\" , \"get chain/outputs/byheight?start_height=101&end_height=200\" , \"get status\" , \"get txhashset/roots\" , \"get txhashset/lastoutputs?n=10\" , \"get txhashset/lastrangeproofs\" , \"get txhashset/lastkernels\" , \"get txhashset/outputs?start_index=1&max=100\" , \"get txhashset/merkleproof?n=1\" , \"get pool\" , \"post pool/push_tx\" , \"post peers/a.b.c.d:p/ban\" , \"post peers/a.b.c.d:p/unban\" , \"get peers/all\" , \"get peers/connected\" , \"get peers/a.b.c.d\" , \"get version\" ] These endpoints can be grouped into 5 categories: miscellaneous endpoints (which contain status and version endpoints) chain endpoints (which also contain blocks , chain and headers` endpoints) peer endpoints pool endpoints txhashset endpoints V2 Endpoints The following endpoints are kept and refactored: [ \"get blocks\" , \"get headers\" , \"get chain\" , \"post chain/compact\" , \"get chain/validate\" , \"get chain/kernels/xxx?min_height=yyy&max_height=zzz\" , \"get chain/outputs/byids?id=xxx,yyy,zzz\" , \"get chain/outputs/byheight?start_height=101&end_height=200\" , \"get status\" , \"get txhashset/outputs?start_index=1&max=100\" , \"get pool\" , \"post pool/push_tx\" , \"post peers/a.b.c.d:p/ban\" , \"post peers/a.b.c.d:p/unban\" , \"get peers/all\" , \"get peers/connected\" , \"get peers/a.b.c.d\" , \"get version\" ] The logic of the following endpoints will NOT be implemented as they are purely internals: \"get txhashset/roots\" , \"get txhashset/lastoutputs?n=10\" , \"get txhashset/lastrangeproofs\" , \"get txhashset/lastkernels\" , \"get txhashset/merkleproof?n=1\" , The new Owner API endpoint methods are the following: get_status validate_chain compact_chain get_peers get_connected_peers ban_peer unban_peer The new Foreign API endpoint methods are the following: get_version get_header get_block get_tip get_kernel get_outputs get_unspent_outputs get_pool_size get_stempool_size get_unconfirmed_transactions push_transaction When running grin with defaults, the V2 apis are available at - localhost:3413/v2/owner for the owner API. - localhost:3413/v2/foreign for the foreign API. Owner API Endpoints get_status Returns various information about the node, the network and the current sync status. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_status\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"protocol_version\" : \"2\" , \"user_agent\" : \"MW/Grin 2.x.x\" , \"connections\" : \"8\" , \"tip\" : { \"height\" : 371553 , \"last_block_pushed\" : \"00001d1623db988d7ed10c5b6319360a52f20c89b4710474145806ba0e8455ec\" , \"prev_block_to_last\" : \"0000029f51bacee81c49a27b4bc9c6c446e03183867c922890f90bb17108d89f\" , \"total_difficulty\" : 1127628411943045 }, \"sync_status\" : \"header_sync\" , \"sync_info\" : { \"current_height\" : 371553 , \"highest_height\" : 0 } } } } validate_chain Trigger a validation of the chain state. { \"jsonrpc\" : \"2.0\" , \"method\" : \"validate_chain\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : null } } compact_chain Trigger a compaction of the chain state to regain storage space. { \"jsonrpc\" : \"2.0\" , \"method\" : \"compact_chain\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : null } } get_peers Retrieves information about peers. If null is provided, get_peers will list all stored peers. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_peers\" , \"params\" : [ \"70.50.33.130:3414\" ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : [ { \"addr\" : \"70.50.33.130:3414\" , \"ban_reason\" : \"None\" , \"capabilities\" : { \"bits\" : 15 }, \"flags\" : \"Defunct\" , \"last_banned\" : 0 , \"last_connected\" : 1570129317 , \"user_agent\" : \"MW/Grin 2.0.0\" } ] } } get_connected_peers Retrieves a list of all connected peers. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_connected_peers\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : [ { \"addr\" : \"35.176.195.242:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"47.97.198.21:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"148.251.16.13:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"68.195.18.155:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"52.53.221.15:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 0 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"109.74.202.16:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"121.43.183.180:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"35.157.247.209:23414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 } ] } } ban_peer Bans a specific peer. { \"jsonrpc\" : \"2.0\" , \"method\" : \"ban_peer\" , \"params\" : [ \"70.50.33.130:3414\" ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : null } } unban_peer Unbans a specific peer. { \"jsonrpc\" : \"2.0\" , \"method\" : \"unban_peer\" , \"params\" : [ \"70.50.33.130:3414\" ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : null } } Foreign API Endpoints get_version Returns the node version and block header version (used by grin-wallet). { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_version\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"node_version\" : \"2.1.0-beta.2\" , \"block_header_version\" : 2 } } } get_header Gets block header given either a height, a hash or an unspent output commitment. Only one parameter is required. If multiple parameters are provided only the first one in the list is used. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_header\" , \"params\" : [ null , \"00000100c54dcb7a9cbb03aaf55da511aca2c98b801ffd45046b3991e4f697f9\" , null ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"cuckoo_solution\" : [ 9886309 , 35936712 , 43170402 , 48069549 , 70022151 , 97464262 , 107044653 , 108342481 , 118947913 , 130828808 , 144192311 , 149269998 , 179888206 , 180736988 , 207416734 , 227431174 , 238941623 , 245603454 , 261819503 , 280895459 , 284655965 , 293675096 , 297070583 , 299129598 , 302141405 , 313482158 , 321703003 , 351704938 , 376529742 , 381955038 , 383597880 , 408364901 , 423241240 , 436882285 , 442043438 , 446377997 , 470779425 , 473427731 , 477149621 , 483204863 , 496335498 , 534567776 ], \"edge_bits\" : 29 , \"hash\" : \"00000100c54dcb7a9cbb03aaf55da511aca2c98b801ffd45046b3991e4f697f9\" , \"height\" : 374336 , \"kernel_root\" : \"d294e6017b9905b288dc62f6f725c864665391c41da20a18a371e3492c448b88\" , \"nonce\" : 4715085839955132421 , \"output_root\" : \"12464313f7cd758a7761f65b2837e9b9af62ad4060c97180555bfc7e7e5808fa\" , \"prev_root\" : \"e22090fefaece85df1441e62179af097458e2bdcf600f8629b977470db1b6db1\" , \"previous\" : \"0000015957d92c9e04c6f3aec8c5b9976f3d25f52ff459c630a01a643af4a88c\" , \"range_proof_root\" : \"4fd9a9189e0965aa9cdeb9cf7873ecd9e6586eac1dd9ca3915bc50824a253b02\" , \"secondary_scaling\" : 561 , \"timestamp\" : \"2019-10-03T16:08:11+00:00\" , \"total_difficulty\" : 1133587428693359 , \"total_kernel_offset\" : \"0320b6f8a4a4180ed79ecd67c8059c1d7bd74afe144d225395857386e5822314\" , \"version\" : 2 } } } get_block Gets block details given either a height, a hash or an unspent output commitment. Only one parameter is required. If multiple parameters are provided only the first one in the list is used. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_block\" , \"params\" : [ 374274 , null , null ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"header\" : { \"cuckoo_solution\" : [ 1263501 , 14648727 , 42430559 , 58137254 , 68666726 , 72784903 , 101936839 , 104273571 , 123886748 , 131179768 , 155443226 , 162493783 , 164784425 , 167313215 , 169806918 , 183041591 , 184403611 , 210351649 , 215159650 , 239995384 , 240935454 , 257742462 , 280820644 , 300143903 , 303146496 , 311804841 , 341039986 , 354918290 , 363508555 , 377618528 , 396693709 , 397417856 , 399875872 , 413238540 , 413767813 , 432697194 , 436903767 , 447257325 , 453337210 , 459401597 , 496068509 , 511300624 ], \"edge_bits\" : 29 , \"hash\" : \"000001e16cb374e38c979c353a0aaffbf5b939da7688f69ad99efda6c112ea9b\" , \"height\" : 374274 , \"kernel_root\" : \"e17920c0e456a6feebf19e24a46f510a85f21cb60e81012f843c00fe2c4cad6e\" , \"nonce\" : 4354431877761457166 , \"output_root\" : \"1e9daee31b80c6b83573eacfd3048a4af57c614bd36f9acd5fb50fbd236beb16\" , \"prev_root\" : \"9827b8ffab942e264b6ac81f2b487e3de65e411145c514092ce783df9344fa8a\" , \"previous\" : \"00001266a73ba6a8032ef8b4d4f5508407ffb1c270c105dac06f4669c17af020\" , \"range_proof_root\" : \"3491b8c46a3919df637a636ca72824377f89c4967dcfe4857379a4a82b510069\" , \"secondary_scaling\" : 571 , \"timestamp\" : \"2019-10-03T15:15:35+00:00\" , \"total_difficulty\" : 1133438031814173 , \"total_kernel_offset\" : \"63315ca0be65c9f6ddf2d3306876caf9f458a01d1a0bf50cc4d3c9b699161958\" , \"version\" : 2 }, \"inputs\" : [], \"kernels\" : [ { \"excess\" : \"08761e9cb1eea5bfcf771d1218b5ec802798d6eecaf75faae50ba3a1997aaef009\" , \"excess_sig\" : \"971317046c533d21dff3e449cc9380c2be10b0274f70e009aa2453f755239e3299883c09a1785b15a141d89d563cdd59395886c7d63aba9c2b6438575555e2c4\" , \"features\" : \"Coinbase\" , \"fee\" : 0 , \"lock_height\" : 0 } ], \"outputs\" : [ { \"block_height\" : 374274 , \"commit\" : \"09d33615563ba2d65acc2b295a024337166b9f520122d49730c73e8bfb43017610\" , \"merkle_proof\" : \"00000000003e6f5e000000000000000f60fe09a7601a519d9be71135404580ad9de0964c70a7619b1731dca2cd8c1ae1dce9f544df671d63ff0e05b58f070cb48e163ca8f44fb4446c9fe1fc9cfef90e4b81e7119e8cf60acb9515363ecaea1ce20d2a8ea2f6f638f79a33a19d0d7b54cfff3daf8d21c243ba4ccd2c0fbda833edfa2506b1b326059d124e0c2e27cda90268e66f2dcc7576efac9ebbb831894d7776c191671c3294c2ca0af23201498a7f5ce98d5440ca24116b40ac98b1c5e38b28c8b560afc4f4684b81ab34f8cf162201040d4779195ba0e4967d1dd8184b579208e9ebebafa2f5004c51f5902a94bf268fd498f0247e8ba1a46efec8d88fa44d5ecb206fbe728ee56c24af36442eba416ea4d06e1ea267309bc2e6f961c57069e2525d17e78748254729d7fdec56720aa85fe6d89b2756a7eeed0a7aa5d13cfb874e3c65576ec8a15d6df17d7d4856653696b10fb9ec205f5e4d1c7a1f3e2dd2994b12eeed93e84776d8dcd8a5d78aecd4f96ae95c0b090d104adf2aa84f0a1fbd8d319fea5476d1a306b2800716e60b00115a5cca678617361c5a89660b4536c56254bc8dd7035d96f05de62b042d16acaeff57c111fdf243b859984063e3fcfdf40c4c4a52889706857a7c3e90e264f30f40cc87bd20e74689f14284bc5ea0a540950dfcc8d33c503477eb1c60\" , \"mmr_index\" : 4091742 , \"output_type\" : \"Coinbase\" , \"proof\" : \"7adae7bcecf735c70eaa21e8fdce1d3c83d7b593f082fc29e16ff2c64ee5aaa15b682e5583257cf351de457dda8f877f4d8c1492af3aaf25cf5f496fce7ca54a0ef78cc61c4252c490386f3c69132960e9edc811add6415a6026d53d604414a5f4dd330a63fcbb005ba908a45b2fb1950a9529f793405832e57c89a36d3920715bc2d43db16a718ecd19aeb23428b5d3eeb89d73c28272a7f2b39b8923e777d8eb2c5ce9872353ba026dc79fdb093a6538868b4d184215afc29a9f90548f9c32aa663f9197fea1cadbb28d40d35ed79947b4b2b722e30e877a15aa2ecf95896faad173af2e2795b36ce342dfdacf13a2f4f273ab9927371f52913367d1d58246a0c35c8f0d2330fcddb9eec34c277b1cfdaf7639eec2095930b2adef17e0eb94f32e071bf1c607d2ef1757d66647477335188e5afc058c07fe0440a67804fbdd5d35d850391ead3e9c8a3136ae1c42a33d5b01fb2c6ec84a465df3f74358cbc28542036ae4ef3e63046fbd2bce6b12f829ed193fb51ea87790e88f1ea686d943c46714b076fb8c6be7c577bca5b2792e63d5f7b8f6018730b6f9ddaf5758a5fa6a3859d68b317ad4383719211e78f2ca832fd34c6a222a8488e40519179209ad1979f3095b7b7ba7f57e81c371989a4ace465149b0fe576d89473bc596c54cee663fbf78196e7eb31e4d56604c5226e9242a68bda95e1b45473c52f63fe865901839e82079a9935e25fe8d44e339484ba0a62d20857c6b3f15ab5c56b59c7523b63f86fa8977e3f4c35dc8b1c446c48a28947f9d9bd9992763404bcba95f94b45d643f07bb7c352bfad30809c741938b103a44218696206ca1e18f0b10b222d8685cc1ed89d5fdb0c7258b66486e35c0fd560a678864fd64c642b2b689a0c46d1be6b402265b7808cd61a95c2b4a4df280e3f0ec090197fb039d32538d05d3f0a082f5\" , \"proof_hash\" : \"cfd97db403c274220bb0dbaf3ecc88e483c0b707d8e6f16dfda37cd4f2c3211c\" , \"spent\" : false } ] } } } get_tip Returns details about the state of the current fork tip. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_tip\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"height\" : 374350 , \"last_block_pushed\" : \"000000543c69a0306b5463b92939643442a44a6d9be5bef72bea9fc1d718d310\" , \"prev_block_to_last\" : \"000001237c6bac162f1add2b122fab6a254b9fcc2c4b4c8c632a8c39855521f1\" , \"total_difficulty\" : 1133621604919005 } } } get_kernel Returns a LocatedTxKernel based on the kernel excess. The min_height and max_height parameters are both optional. If not supplied, min_height will be set to 0 and max_height will be set to the head of the chain. The method will start at the block height max_height and traverse the kernel MMR backwards, until either the kernel is found or min_height is reached. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_kernel\" , \"params\" : [ \"09c868a2fed619580f296e91d2819b6b3ae61ab734bf3d9c3eafa6d9700f00361b\" , null , null ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"height\" : 374557 , \"mmr_index\" : 2211662 , \"tx_kernel\" : { \"excess\" : \"09c868a2fed619580f296e91d2819b6b3ae61ab734bf3d9c3eafa6d9700f00361b\" , \"excess_sig\" : \"1720ec1b94aa5d6ba4d567f7446314f9a6d064eea69c5675cc5659f65f290d80b0e9e3a48d818cadba0a4e894bbc6eb6754b56f53813e2ee0b1447969894ca4a\" , \"features\" : \"Coinbase\" } } } } get_outputs Retrieves details about specifics outputs. Supports retrieval of multiple outputs in a single request. Support retrieval by both commitment string and block height. Last field are for whether or not the response will include rangeproof and merkle proof. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_outputs\" , \"params\" : [[ \"09bab2bdba2e6aed690b5eda11accc13c06723ca5965bb460c5f2383655989af3f\" , \"08ecd94ae293863286e99d37f4685f07369bc084ba74d5c59c7f15359a75c84c03\" ], 376150 , 376154 , true , true ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : [ { \"block_height\" : 374568 , \"commit\" : \"09bab2bdba2e6aed690b5eda11accc13c06723ca5965bb460c5f2383655989af3f\" , \"merkle_proof\" : null , \"mmr_index\" : 4093403 , \"output_type\" : \"Transaction\" , \"proof\" : \"e30aa961d6f89361a9a3c60f73e3551f50a3887212e524b5874ac50c1759bb95bc8e588d82dd51d84c7cbaa9abe79e0b8fe902bcfda17276c24d269fbf636aa2016c65a760a02e18338a33e83dec8e51fbfd953ee5b765d97ce39ba0850790d2104812a1d15d5eaa174de548144d3a7d413906d85e22f89065ef727910ee4c573494520c43e36e83dacee8096666aa4033b5e8322e72930c3f8476bb7be9aef0838a2ad6c28f4f5212708bf3e5954fc3971d66b7835383b96406fa65415b64ecd53a747f41d785c3e3615c18dfdbe39a0920fefcf6bc55fe65b4b215b1ad98c80fdafbef6f21ab60596f2d9a3e7bc45d750e807d5eb883dadde1625d4f20af9f1315b8bea08c97fad922afe2000c84c9eb5f96b2a24da7a637f95c1102ecfc1257e19bc4120082f5ee76448c90abd55108256f8341e0f4009cfc3906a598de465467ee1ee072bfd3384e1a0b9039192d1edc33092d7b09d1164c4fc4c378227a391600a8a5d5ba5fe36a2a4eabe0dbae270aefa5a5f2df810cda79211805206ad93ae08689e2675aad025db3499d43f1effc110dfb2f540ccd6eb972c02f98e8151535c099381c8aeb1ea8aad2cfdf952e6ab9d26e74a5611d943d02315e212eb06ce2cd20b4675e6f245e5302cdb8b31d46bb2e718b50ecfad2d440323826570447c2498376c8bad6e4ee97bde41c47f6a20eea406d758c53fb9e8542f114c1a277a6335ad97fdc542c6bbec756dc4a9085c319fe6f0c9e1bb043f01a43c12aa6f4dff8b1220e7f16bc56dee9ccb59fb7c3b7aa6bb33b41c33d8e4b03b6b9cb89491504210dd691b46ffe2862387339d2b62a9dc4c20d629e23eb8b06490c4999433c1b4626fb4d21517072bd8e82511c115ee47bf9a5e40f0a74177f5b573db2e277459877a01b172e026cbb3f76aaf0c61f244584f3a76804dea62175a80d777238\" , \"proof_hash\" : \"660d706330fc36f611c50d90cb965fddf750cc91f8891a58b5e39b83a5fc6b46\" , \"spent\" : false }, { \"block_height\" : 376151 , \"commit\" : \"08ecd94ae293863286e99d37f4685f07369bc084ba74d5c59c7f15359a75c84c03\" , \"merkle_proof\" : \"6b2abbd334c9d75409461fba9c1acd4a8d7bc2ab0bc43143f42388b2a3a87b881505ccf8ffc8737fa6fd4fe412a082d974911bd223eae612d0d1d7ddcc09b5e6079c40b011405b2ccb49ce32473c93aea6d843488d5765fea114d3368d34cd05fcb8c2de3903fbaf39b1f064c809f9f1c0d47959d81a508957040eda55c6dce6dd8c43a79c72faffacfabe1d73055790b6249de2f7c603f186cb109eee58fb1426ea48cb781f88df9acd8996d235fe6bfe60e02aae6e3bfe38ed2599baca1430b3b637072d9bdcdc7644f873728e3cd38eff7124ea848cfad67f8e114cf8595c89a3686a4271cfb2b5098597c315c01d04270ca8f70262af967a947f49adacfa4aad8b6fd196dd0ef4e5cefa132c38c7e5f43db12b3d74f0a8d83c3404e73c6b25a12bff70a8ef4526c89b1558810bb744ede53f8c4cc8cc2555e953637722adb41ea5752281cf1f75599f7e59b17f11f5f9ce4f6b2da4141a3398f51d8b834cdc8b00f61915a41d200572a10bb2102cbae7e94aa7ced3c388dcd58282932c99a8fa66f6fc511ff3e8c60d442bbdb49cca1166328ca8c9bbc97d024570b4cc1ca6c7dba3db223e9e27fd9345b94d3cf10e2b54915b87c57e32965bc2db1b1f956d1962812738ca9b2c93fd7825adf4dffddc97aa85ca0f3f412f02d30678a816d2efbfb6778305fd5e610b6e8af30030bc059880c337bfde326b392d5dcd7c36cb0076fbccc7099b94f1f03bdb525d6e3818b6d50b93ced802957a4b03892c71b6679052bd35e92ceea71a96b22b2ed2c129755f0c74fa172f43da2790f3132a7e57e408d2fc5f1126b088cd0398e6dedcb237242e6720e12e8d7a5a1e196eda6241cfee1cc85e9d20af67f3f9bdf91160516ebcd0b8da6bb7b12229e1112b22c9f1aaef1d75441465cfee2ac1c47b5255514316ed4637e192b00ff28491168f2f2b00\" , \"mmr_index\" : 4107711 , \"output_type\" : \"Coinbase\" , \"proof\" : \"7083884b5f64e4e61fb910d2c3c603f7c94490716d95e7144b4c927d0ca6ccc0e069cc285e25f38ee90c402ef26005cad2b4073eeba17f0ae3ea2b87095106ef00634f321d8a49c2feaad485bc9ee552564a6a883c99886d0d3a85af3490d718f5a5cbc70f9dcc9bf5d987fb6072132a4c247d4bbd4af927532a887b1e4250b7277771f6b82f43f4fb5a48089ed58e7d3190a19197e07acfed650f8b2cd5f103e994fb3d3735c5727f06f302bd1f182586297dd57a7951ff296bdf6106704abedc39db77f1293effaa7496a77d19420a6208bc1c589b33dad9540cb6180cccf5e085006b01309419f931e54531d770e5fe00eca584072692a7e4883fd65ed4a7c460665608ab96bf0c7d564fe96a341f14066db413a6fddc359eb11f6f962aca70ca1414c35d7941ce06b77d0a0606081b78d5e64a4501f8e8eba9f0e0889042bc54b4cbfd71087a95af63e0306dba214084d4860b0ce66dc80af44224e5a6fef55800650b05cf1639f81bfdc30950f3634d1fd4375d50c22c7f13f3dfb690e5f155a535aff041b7f800bfe74c60f606e8ab47df60754a0e08221c2a50abe643bb086433afd040a7e6290d1d00b3fe657be3bb05c67f90eb183c2acb53c81e1ca15cd8d35fe9d7d52d8f455398e905bdc77ffb211697d477af25704cf9896e8ce797f4fed03e2ba1615e3ad5646eecaa698470f99437d01d5193f041201502763e8bde51e6dc830b5c676d05c8f7f87c4972c578b8d9d5922ba29f6e4a89a123311d02b5ac44a7d5307f7ed5e4e66aaf749afc76c6fc1114445d6fafeea816a0f985eeacdbe9e6d32a8514ca4aaf7faad4e9d43cde55327ac84bac4d70a9319840e136e713aa31d639e43302f3c71a79f08f4e5c9a19a48d4b46403734cd8f3cc9b67bc26ea8e2a01e63a6f5be6e044e8ed5db5f26d15d25de75f672a79315c5e2407e\" , \"proof_hash\" : \"7cf77fdaecef6c6fc01edca744c1521581f854a9bac0153971edbb1618fc36ad\" , \"spent\" : false }, { \"block_height\" : 376154 , \"commit\" : \"095c12db5e57e4a1ead0870219bda4ebfb1419f6ab1501386b9dd8dc9811a8c5ff\" , \"merkle_proof\" : \"00000000003eadc6000000000000000e13c509a17cbb0d81634215cd2482ab6d9eb58b332fcbe6b2c4fa458a63d3cb0dfe3614ebe6e52657870df225d132179fa1ea0fdc2105f0e51d03bc3765a9cd059c60d434a7cae0a3d669b37588c25410f57405c841312cfa50cf514678877a3f4ce8bd3e57723ba75a2b7d61027b2088fbabebdb7336b97ea88b00a7e809a6245def980eba18d987601f4cbd6c3cc9f12a5684fe7a1bc2565a9f8ab63c2db1afa8304f5e23d4754cd97f29c8b06dcb3de4f6d3a83079676b6e9941afe5553a7195384b564ecd6d37522cb5e452cc930d2b549af22698a8fd9bf6cad05a06b09e3f6e672b94e82c0255394b5c187ab76fda653a2491378997ba3d49f9d9c34ca93bc627fe5d98b327c03d429b5473f62672e9d73c4eafd9cb8f62e5158a1ec7eb56653696b10fb9ec205f5e4d1c7a1f3e2dd2994b12eeed93e84776d8dcd8a5d78aecd4f96ae95c0b090d104adf2aa84f0a1fbd8d319fea5476d1a306b2800716e60b00115a5cca678617361c5a89660b4536c56254bc8dd7035d96f05de62b042d16acaeff57c111fdf243b859984063e3fcfdf40c4c4a52889706857a7c3e90e264f30f40cc87bd20e74689f14284bc5ea0a540950dfcc8d33c503477eb1c60\" , \"mmr_index\" : 4107717 , \"output_type\" : \"Coinbase\" , \"proof\" : \"073593bc475478f1e4b648ab261df3b0a6e5a58a617176dd0c8f5e0e1d58b012b40eb9b341d16ee22baf3645ea37705895e731dee5c220b58b0f780d781806a10dfa33e870d0494fba18aaa8a7a709bfb3ddf9eb3e4e75a525b382df68dc6f710275cdffb623373c47c1310ae63479826f435ca4520fdc13bb0d995b7d9a10a7587d61bd4a51c9e32c87f3eb6b0f862cdff19a9ac6cb04d6f7fafb8e94508a851dcf5dc6acea4271bb40117a45319da5522b966091b089698f4f940842458b5b49e212d846be35e0c2b98a00ac3d0b7ceaf081272dbed8abd84fe8f26d57bac1340e8184602436ed8c4470ef9dc214df3405de0e71703abec4456b15e122a94706852bb476213ceadf00529d00d8d3b16dc57f4e4a9a86dacfa719e00366728de42f3f830e73f6113f1e391fab07eba1b40f6466203b0ce14701230e934f6138c575660a03dbb0e59d7295df3115a4fc0909a5520d74657b319fc83481079ad6c13400175e39fa2b86071ba563ce8836320713ef8f55d4e90bee3f57df96c7aef0f2e896f57192fae9675471cd9751bcaf2b15e5a65a9733a6f7f9b8147b8f6e8dac51d056018d411fd252225cf88e56f143143f49e8a0d2e43c10de0442dbc84966817532b1256b6769db987526790a389c371a1fe7a36eacffef82877b4db7a9b5e58722ffbd0fc4fdbd7624365ee326bb8b1e60b999f513715b30f37ef6116eabf53b3524b46c33a1fac49205b39e24aa388d823269c1fc43c3599a06b69433a0a47a03bd871321afb7846a6dbfd5891bd84f89c556231745c929d08445f66f332857bfda1c4f86ae58a01007b7303f870ac24e0ba72d84c0ef4903ac2ff777e2c2dcb4d8e303c74e0c8a559686b4d4c25024ee97601787d4e5a97224af41e5d35d91744292f5a41f64d4e1cae77bebebd77a473f3b54e86f7221aac230942f0468\" , \"proof_hash\" : \"5dd69c083e2c0fd797a499bbafedee0728849afa3476034280ecadf6eb4bffc2\" , \"spent\" : false }, { \"block_height\" : 376153 , \"commit\" : \"0948cb346b7affe004a6f84fa4b5b44995830f1c332b03537df4c258d51d1afb50\" , \"merkle_proof\" : \"00000000003eadc4000000000000000dfe3614ebe6e52657870df225d132179fa1ea0fdc2105f0e51d03bc3765a9cd059c60d434a7cae0a3d669b37588c25410f57405c841312cfa50cf514678877a3f4ce8bd3e57723ba75a2b7d61027b2088fbabebdb7336b97ea88b00a7e809a6245def980eba18d987601f4cbd6c3cc9f12a5684fe7a1bc2565a9f8ab63c2db1afa8304f5e23d4754cd97f29c8b06dcb3de4f6d3a83079676b6e9941afe5553a7195384b564ecd6d37522cb5e452cc930d2b549af22698a8fd9bf6cad05a06b09e3f6e672b94e82c0255394b5c187ab76fda653a2491378997ba3d49f9d9c34ca93bc627fe5d98b327c03d429b5473f62672e9d73c4eafd9cb8f62e5158a1ec7eb56653696b10fb9ec205f5e4d1c7a1f3e2dd2994b12eeed93e84776d8dcd8a5d78aecd4f96ae95c0b090d104adf2aa84f0a1fbd8d319fea5476d1a306b2800716e60b00115a5cca678617361c5a89660b4536c56254bc8dd7035d96f05de62b042d16acaeff57c111fdf243b859984063e3fcfdf40c4c4a52889706857a7c3e90e264f30f40cc87bd20e74689f14284bc5ea0a540950dfcc8d33c503477eb1c60\" , \"mmr_index\" : 4107716 , \"output_type\" : \"Coinbase\" , \"proof\" : \"72950da23ad7f0d0381e2f788bf0ac6b6bcb17aaccf0373534122a95714d2d0dbf6a24822b4aab0711a595c80bc36122957111c39292f2a36a973252fb88cbda0b1d61ea8ea84f5171a61f751cac97332637b7cf74cc73144b912ba700dedaa60895f06e947f1e42a8c79d70f924f45fdcb6df5d30289f36ff77d0ae368df5775a739b7a25cbfb63f0cdbdc167b046067c2a021fe0950c7b67515b185b9e4a00ce63b795d49ae184fe5cc726d72fc05d717c4fb55dd5f65967dc282d3c47cb6f8a92cb696e5a1d8cca21214bc766e3de6271791cebf646cda97ae77035da16606f3397f71e103137358c97b9943c3e15403184f61230bd0e3954c7681a0891aa7a0cc32e82d830fb7d8759a04d1da7058630a853508df095142f22158c28bd5e3f2477ad6c8990e63d0377a0fa3d588b6584453778eb38cbaec8a33c1d3772c97a826d4a2f6953c35342993b04567e9fea6fc64fb714653f934faa1a8f635d39eb2903de4bed960a3df07dce7c2e3ff517bbc15f467d0190a579bc07b0f1a910b23269d794835bbb34e8318dcc4fd4159f8f03faa77842d445cf61af9e33caf46aa5fae0812a6476a09c0757e929271a96a245701ab14c1fdd836b92b7e763afa623017f68f1bc4eb716ce735820a1311b743dd8d5c6bb275a2e4e7d2eff8f45417b60cc937086c3e7fd3b612ae064d7237eb6a7bd1a39d8575fac312068fa060bc1ceac4df0754601edaf04ecb1b89c0661ea01a593c3763e456bebbd8487edc0ff3bc6f203965cd92b1706070c59a3795f9dee23087cea0aaec015f1b7bfe4df81818d7a37af781ca7b757ace2fa489f85215ecb85976b1c74c7f1df6d834a8bc63e887407ef6e233c55ea040bc5f2471e99ebc92f2283ff592ff751d9226bd105e68e187c91ecb236c9fa4fb060ae4d706c571ac2123da1debd12737d98be118578\" , \"proof_hash\" : \"0ce421970d13fe9b3981e308c5d0b549982cdda9f69918289cd95ffcd09e0fc2\" , \"spent\" : false } ] } } get_unspent_outputs UTXO traversal. Retrieves last utxos since a start index until a max. Last boolean is optional to whether or not return the rangeproof. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_unspent_outputs\" , \"params\" : [ 1 , 2 , true ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"highest_index\" : 2078061 , \"last_retrieved_index\" : 30 , \"outputs\" : [ { \"block_height\" : 1 , \"commit\" : \"08b7e57c448db5ef25aa119dde2312c64d7ff1b890c416c6dda5ec73cbfed2edea\" , \"merkle_proof\" : null , \"mmr_index\" : 1 , \"output_type\" : \"Coinbase\" , \"proof\" : \"9330ad8cde205f317c6537eca96b866293a0489615a9a277b4d3a597c873544c82474932b641e06ac8719604ee52e895e8cd4621b6bfb85780cd9becce14d0700b83a664db2f52a26c425fd777ad88944cdfff38043a2793ed4d9aa67e36cbfd5585579fc69dda930418af5eaf603654f6f751258d2dfc8c2113c171e130f31ec1e6cce2a718e435298fce5d64ffe1bd3464fd7c87cfa92093855be034bfe4439e928bd92ad77fd0a0e00355ee1d1a9ceb1ed0c408dcfdba8c583e7598dc700aaa9f91432097259a405f5b7315a2f7658861e3349bb0dc8bf883726a215f0149ded6613e5ac0670c0c5202247d7c27c8a7d03bdb03c9cf5455463f9b42cf87403e31f8383cc4f49a34c62ae459f5801a9eed4f0ee3dfd5f55b7011c0cae393c474abd6f8c7965b9b5fff3104dd4e39542077c0c8dd2f8ffceb6bb598512d90506d0a7184f20f1498cf458787f23284b54888c9be416d103f760406357a16b6d841a303d5c95b6b474d2d7f0fea0a2a76c897dd2110e9303f54684169421147684c6f1819c33cef3f38ec995a508450c02cd1872f8065fdee723109c18b1dd2ddde75825546ecf0df0793c353b20c946cd64122cea8c116f432336899a16ad24a2aafcb8f900e09a1147135fcf2a54cbf81db308a47a08a49c77c130e5dc5e661cd55a5cc69e607055a5b08111bf61a62ea5778f85119043633f1cab8c756d756c5a34851024ac311a596b1cd919bbca43226f0ba057f6b57de2f6955b0823c3826de7f6096c1c1b6b9b8e4063e1645c0bff32f80561aaa959d97120fbc2ecd9d2be28bd0c17811dc59a88049f6d8952ee9a0a0207693c89ca3ad1197e9bfdfc03be9d845aea8d663969217e3b494cee9e652bc9f8713e2fd5cb1843848f46c3a6ab024d0e3d57ca45454cdbda414adaa835fa147deb4ffb7129cf3a8d86726a0144794\" , \"proof_hash\" : \"6c301688d9186c3a99444f827bdfe3b858fe87fc314737a4dc1155d9884491d2\" , \"spent\" : false }, { \"block_height\" : 29 , \"commit\" : \"09bab1ddad0f6fec1aedcd3830c5c647515ad543929e722344e4a8d390b6fdd51b\" , \"merkle_proof\" : null , \"mmr_index\" : 55 , \"output_type\" : \"Coinbase\" , \"proof\" : \"4a5f858d4311bdd902f4446682f27f64be376283b1171060fd2ad33d85350fee13c25a030874d6308d2b325995a3fe545eb1d85ba66e2ba002b794edfdeacb3f0fd2a690b9a78137771b3633aaef2a77f62fbe4d6b4b373c4bdb7e5f58cfae361a3b4c2e4420cc0d38465b2444e01b50e57c6ebfc2afd6dda9017e54585638bddef17d181d1fd7064d975d8bb1dcfd96c89486aed4680b4d39294a141581d1f51c1acfbb80e2ffc40f8499cdc43be04cacda1e34dd6592edfc500229aa70db1c2869f974cfe9aee0cab696c198624de8ecdaf5ae481a1e46fe79fe983209459b89492f2b24416c368394c43c60c33d0fdd1792f0a58d11763e7c8b89d27da25109db346e4d7b62935d182b45dfb659829c55922350e6f7e3452d9311e527ec5b561f4d043cef865f683fce1ce2d410d414f5bcee63c4bbc00964b0fa757bdfd68158e22c1068d871a45759fbd527883c0451db6f36b15139864b6177a78ad64d326e0152914e5313a97ed7b685e5089f2758bf072c804560306bd944831f067c3413ded09330fd788f353e4ee875d3c9303dd4ec0dda9d55b4a27d7748b3247fe85cf3d26b7004e6e3379041fad136fccdacd02b06456a50ad40a3259842c0794f2d59dbd8fa6b4af065b38c388d76b82136b633b06779e4eb05b5b62ec37cdc2986327639bafa8651318f4c00c066e6f45504ec9a96874d5510b519f434a1a88175d51f86e8ee36ae18d107cfaf83e60b2e62fff032c7539be66d776e3a52c5f9b0ee6fe08820d65cd75d35c793e5ab3914adf5a97b7dba75e90d4a4c9aa844e2f1e9464cd5fc4923b475defca4e3b03e1b33353ff91ac1084712cf4445e329ffdbe1e2da16ae71dee0e914b546fdc0db9b0fcde80822ee716e9f2eec90db7aa4417d53a1266e1e8383e20c9a9548bae35c2a8e1293a49e7afbd8011a9e66e79ed6be\" , \"proof_hash\" : \"a64ed774d824dc55123c6c5ba46d84bac15b6ead8cb60200836c2a0e74506ab0\" , \"spent\" : false } ] } } } get_pmmr_indices Retrieves the PMMR indices based on the provided block height(s). { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_pmmr_indices\" , \"params\" : [ 1 , 200 ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"highest_index\" : 398 , \"last_retrieved_index\" : 2 , \"outputs\" : [] } } } get_pool_size Returns the number of transactions in the transaction pool. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_pool_size\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : 1 } } get_stempool_size Returns the number of transactions in the stem transaction pool. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_stempool_size\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : 0 } } get_unconfirmed_transactions Returns the unconfirmed transactions in the transaction pool. Will not return transactions in the stempool. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_unconfirmed_transactions\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : [ { \"src\" : \"Broadcast\" , \"tx\" : { \"body\" : { \"inputs\" : [ { \"commit\" : \"0992ce1827ec349e9f339ce183ffd01db39bf43999799d8191bfc267a58f0a715c\" , \"features\" : \"Coinbase\" }, { \"commit\" : \"0943a3c4ee4a22a5b086c26f8e6dc534204dafde0cf4c07e0c468d224dd79127ec\" , \"features\" : \"Plain\" } ], \"kernels\" : [ { \"excess\" : \"083c49eaaf6380d44596f52cce4cf278cfac6dd34fbef73981002d8f1e8ee8abe4\" , \"excess_sig\" : \"3f011e7e288231d67f42cb4f6416c4720e6170d5e3c805a52d33aa4521328f9be0303be654bc8ddcd3111aadc27c848b9cf07e0a70885ef79be70b7bb70f8c75\" , \"features\" : { \"Plain\" : { \"fee\" : 7000000 } } } ], \"outputs\" : [ { \"commit\" : \"0873fafd4a0e4f365939e24c68eeb18aafc6674ca244a364dcdbfa8fa525e7bae1\" , \"features\" : \"Plain\" , \"proof\" : \"4b675be40672d5965c43d9f03880560a8ac784ee3de8768e28c236a4bc43b8c3d4bc83dee00d2b96530af9607c3b91d9a828f0234bf2aaf7e7c0e9cf936db69c04ca1b267668fbdb2f08ce05c8b119c9d886ceaafb4634b7fae7ea01966ad825dddc9ffab8093155d9c5d268160b86fcad95f4f5e66bf46ff642a51629dbdfd7bba7936846915b925d547337a1b95c33030fad4178468825936242e631797aa3a8f0a5ae0d23040938622648c8432fc247a902abad27e383affb4ec518e4f6f55f55e264bc0f99957be203cfb26d4b8e561fb36da55a50b6ef5861134c484556d701133e1dceda5ea53e731184e0a11f33d06e13ca37d03d39dd047170580534b049862fcd6c73decc7c0af45a267ed148fe6ef2cc375ffebfa8187d2fa0a134428a036d2ec1f65d3ce036b955730fc1ee43b23b574bae2b58b7adfa2a7a45cdec393d9b658857c911560aa3c44cf4435a99d68f3dbc81c82ea43e426ef0198148a90336ee72472aab5f7feea1df93ec830fe5ec642c93c1046dec955df361bfdc3ab74477f847a1b72e8735ef65a8a6d1680745c0152bfb5cbb2a4b4671491a253a1a09d5a07d55f4872c9f0a3d25e07b257926629d5bb96aed96f5debab02503eb0ac45033323cc5a46c8e5d4469ee9f3dd618a20d54d6f5740c010fe5a0fe853efeb253a6df196bd24469ac51c1be8ba84737cecdb5ab73d7c52570d2273621fb69bd7ed985bbc6999dbd2d6fd2687ae44a391d604ff232cc6b3fbedd5d1cd0cd8c658c5d56069b5a5099cc5c9f48bbf7d7e83b4f9a7bdef6eabd164c8395468f818e8cd8c1c800bc3adfd66dbcb247d1bda5a7af38c288c0beb8e0d9160bf67500094530a0f8be52e97b5c2114f5a4a333a11c7f37f4c47a437422455d8cbcfa770cdc85ec55accf48cf14550b07f1346a02fccdf280fcb24c1fb38751d889a17e\" }, { \"commit\" : \"08de9e42d361cabd99e566c67f7f8599c7e6985cd285a841277f1aeb89ad6c8fe3\" , \"features\" : \"Plain\" , \"proof\" : \"5eb7afa00e9681e3b6425fb4256c96905303505787d6a065e88a50154410b9a371b0f879d3f97cfa00425e9c8266e180188656acdbb46cacfdfb159fb135c5eb03b08be3c231c4b21df777da2e2afe8d30db91e602dc4ceed71aeb1b45a0266cfeadc4acbf9fdf7a67f67408fbbea7bf14182bc407373d243c6875373b655695604deb575369a9b28274885601b338882219c7f508aa2a0ae1d02736af2249327145f1d3d00093f9587f0e0b408692700fac0f2a048c329e81cabaa4b997dd88923fe97420125f394e21b4835e36cce9de383d9e223df1b5a6ba6f48ffeac315991189dc2716cc7ec07f6ccc8062344d5ed4fcaddf9070f44f0c59ffe8160d1f6fdfe42b40066f51e687d38b6b5255771800ac060bd8034cd68d14eee1b2f43b6d7bf20d71549ea9a50006dd30b9a795e785385801546eb9a83721a09fc34d3b69d4ccdc0ff0fb74d224048aeb66ecff5515296cadd57f42e0717cbba7c70719a10c007db4520e868efe98a51001b67952d7bda3174195a3d76b93ee4dac60137a38b2e8309cad13ef1cfb6c467f1969385e5b334b52f4fd55da440e036d2a428e9f3be905d79f717c169060468acc6d469636fed098b1aba5cd055a120314bcab55d5b8b6889321edf373517e93ef67fbe74557ec6c0211265efefa25a34ac267cf1db891c47163bfed20d2b535abfe60390c2844dcef5f0aad5fa7f1db9f726d7f223c025861069603936a22377707cdd3915e762e7061132124c716212b0e91bb7fc5d7816366f5d169d93fe75669a6ba19057bb2450958aa6f5ada09042570f46215af5a41b623d140be574b7a8c9ab24ea48da416dbe6ec0fa3b889206fb804df8d69805ceb80f1e9d4e8b664b3939491cba946d87585c830e3dab0638fa279b5e911642f18452e2731764aa62f92bbcf194c97f344c90c1931fd2c3af4bcf6b0\" } ] }, \"offset\" : \"0eb2c2669ce918675c72697891e5527bd13da5a499396381409219b8bbbd8129\" }, \"tx_at\" : \"2019-10-07T16:20:08.709114Z\" } ] } } push_transaction Push new transaction to our local transaction pool. Optional fluff boolean to bypass Dandelion relay (false by default). { \"jsonrpc\" : \"2.0\" , \"method\" : \"push_transaction\" , \"params\" : [ { \"body\" : { \"inputs\" : [ { \"commit\" : \"0904cbd34d0745eb00ffc3e95c9f4746738794d00268e243e9b57163a73b384102\" , \"features\" : \"Coinbase\" } ], \"kernels\" : [ { \"excess\" : \"08385257d22f1b8a758903f78ae12545245d620cffc50e7ee7bc852c5815513dc7\" , \"excess_sig\" : \"e001a7349fd40d4a9dfc1df275d30906fb3b304f8c7892a20ed5c9b10923c871cbabedcf322511a9ce56f10113b48855441f681280133e121b25ea1ff7efad9e\" , \"features\" : { \"Plain\" : { \"fee\" : 8000000 } } } ], \"outputs\" : [ { \"commit\" : \"087c3ca7419751e96cdae4908bb8a92fc2826f2ad36690420b905d51beb7409ca0\" , \"features\" : \"Plain\" , \"proof\" : \"379ae236937883c2e1e613fb30f1b18d2a44d4173360e94bcd07862aafaf81b3aaa1154d67287cc03efde0d3981c6da8a18e2e426f5c30afc0f2e3a75012448402d8d56df52b87f4815575a56d4da174f8187e4faae64bf883b249ceed694271f84ef62a3711d36c997dff7a11111419011e36e3a070b7552415a55faaa3999f99439edccdfe5313277147fdb42be1798442bb225c2b546f5347920584b365aa81a0365b4a706c97c89617b0e6218d2c9bc15805caab27c438ed06340cc4f8dc7bfca0e9d38864c88bb0c834372f6b662b9159134f3f8ec9b8a87878739a7e516b97419ac29e1d4a2b250321470a9a6b98d07065bb7e79afc25a5ab6fc47108f53223078a64502bd4af1a109641447dab82741ebe3fbdbd803ee7a42fe2554e78fa86bd1d1e6e3b913118e9419b0be6f976b2404447d943b5f1bac19a5809fd6834797945a62d21b1ecb6ddebbc5ef94ca9e704d033bd64afde67bd3e06e2cca3bb10190188afc0af80b48dd862b86753d8b4af314763324deb1c97cf020cb87285a47cd28874bb91c6cdf858965e8b9daafbcbc1b4817d334a97d7e25e01b2d072d8dcc6418e3dc7b8e7712632f939238e65ed0731c7af02d55a8884cd8f7f88dc0f63a21955a7364562532f5716c89e14f8f23ad78f6fe2f1649e13ea8f8185f3ee63cc174684d1ef8d8c33fb25bc802f8e05e53fe200b1ea5231f588a020942e6fd7eec67301700088dae8816c16a337120063c21e1604e009df932032812f88be6473af13f802b42d8ad6fc14230fbe13ede178319a7b6540656234ec1f2fcfa70f6faa9c4b6b8150b81fe0fdc273a9bb385d766a02041a5c3f58471d42059c17d84d13ad592aa0ccf337970e7eef06f306b13288795123c9c005b815d848f359b23450656b310f09cda9ad4b7b6931805d47dcd10a8745d834a984e2055168ac3\" }, { \"commit\" : \"09a7b2c1d4b346c4ebe9c6c979e32e7740446624d5439d9d7abb82166c2545e5be\" , \"features\" : \"Plain\" , \"proof\" : \"5fb0ee4093a153e2ed173207dbfa02b4d185f1f313ea4cbf222558819074543f19e9bcdb595a23d4ee971aafcc614b6d2774e22cee6627bc4388297fe6ebf03e0d422f3eb8003cc8516417a6b32eb22f87e1745e0ae5bf1733f2ea253399719b1ef0067934dc548c58729604d24a44040165b32d05e82c9efc9a1f30151dd73ce893ae94709ec2fe5d0f409bb54a86604f0e92915b4f93e7adde823eccf87830ae91d71a7b99967dbcc8531fee44c20c24fb6fe2a34fe86ba5da3a9235cbcdcde033ead57d65c03903a9c9ed877bf0fab9f26d08552c64ea668d5408c84b74bc3ac8335aaaa04ebcf523d36d2207fb8770e976b6fde7d04e2148de5a4169c60b1958bb840b79a8c8f356e1f1fadc35a5a7e276fcd67c354cde546548c9bf788981f38edf5a406977826aa4524004e770b3d3cd6b26f0dc99729ffd9929fa4509b145ef0c3e4293e71b964da731a47cc9f082350acf32afb64b3b12f8383c8f2cc9880131a80ea957b2908c92f21d2db7aa5d67bafb11eb07674e52b920e67a86259dd9c5dcdd18bad182fd85ec4b659c47ea2e2e8a89c57e4d2cde87958fc2ab932e169f6805d2fb14549ac93807bc426eb4cf6d29ff6a4cf22e35dbb27f04211b06b65173501c17a3bb3ff0eecc9bb05dca23379abe457ca3010ebea69e1a2f7f3ed6531bf766007cdd1ac7d6c762785fb56f36194cc2ccaee76a499a7383288e84981b103d76cbe007f66c913eacb277746e78ae08627b279ac1f9a43ab284d8a3b32c6edcd2ea99e8ea836b31a1e2582be6c41f2282cf5fc7bdb95e4b412a5eeccad29670197873a888a100c4b2704ce75137fc997a5632d81001f9b57300a9bf99edd857065be83f835e4c49d852165ba18e1c96316c153459a913773d5d86ddc26c5cd1fff38a8fbb62506b0aef6076382674c0fa95a50a03b0c3df0a688a2cbf\" } ] }, \"offset\" : \"0ec14d3875ad5a366418256fe65bad2a4d4ff1914e1b9488db72dd355138ca3a\" }, true ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : null } } Errors There is two kind of errors that can appear when making a call on the API v2: basic JSON-RPC errors and API result errors JSON-RPC Errors These errors are often due to a miscontructed JSON body. For example when there is not enough parameters: { \"error\" : { \"code\" : -32602 , \"message\" : \"WrongNumberOfArgs. Expected 4. Actual 5\" }, \"id\" : 1 , \"jsonrpc\" : \"2.0\" } or invalid type of data entered: { \"error\" : { \"code\" : -32602 , \"message\" : \"InvalidArgStructure \\\"start_height\\\" at position 1.\" }, \"id\" : 1 , \"jsonrpc\" : \"2.0\" } or method not found: { \"error\" : { \"code\" : -32601 , \"message\" : \"Method not found\" }, \"id\" : 2 , \"jsonrpc\" : \"2.0\" } this list of errors is not exhaustive, for more information about the possible error objects see the JSON RPC 2.0 specifications . API Result Errors These type of errors are due to an API error during the query. This type of error is wrapped into the result. The possible error objects are defined in the grin_api crate For example, trying to ban a peer that's already banned: { \"id\" : 2 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Err\" : { \"Internal\" : \"ban peer error: PeerNotFound\" } } } or a block that doesn't exist: { \"id\" : 2 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Err\" : \"NotFound\" } } Authentication Like the v1 API, the v2 API uses basic auth. However, the foreign and owner API do not share the same secret. - The Owner API use the same token as the V1 Rest API, usually defined in .grin/main/.api_secret . - The Foreign API use its own token, usually defined in .grin/main/.foreign_api_secret . Wallet support For full compatibility, grin-wallet will migrate to use the v2 Node API. Legacy support The v1 API will remain active for a time the mode of operation for its REST API will be assumed to work as currently. This setup should allow existing wallets and apps to continue working as-is until a cutoff release for legacy mode is determined. API only Note that this RFC doe not make user-facing changes to the existing CLI (invoked by grin client ) to invoke these functions. It's expected that the existing cli functionality will be modified to invoke the new API functions. Node V1 Deprecation Timeline v3.0.0 (January 2020): Node API v1 is marked as deprecated and will be remove in next major version. v4.0.0 (July 2020): Node API v1 is removed from the code. Drawbacks This RFC temporarily introduces some additional code complexity as v1 and v2 node API will need to coexist for the duration of the deprecation period of v1. Prior art This kind of JSON-RPC API is widely used for cryptocurrencies. For instance: Bitcoin Ethereum Monero Tezos Future possibilities This API simplifies the deployment of new methods and drastically simplifies the work of developers by providing a clear documentation directly on docs.rs. References JSON-RPC 2.0 Specification Bitcoin JSON-RPC Doc Ethereum JSON-RPC Doc Monero JSON-RPC Doc Tezos JSON-RPC Doc","title":"0007 node-api-v2"},{"location":"grin-rfcs/text/0007-node-api-v2/#table-of-contents","text":"Summary Motivation Community-level explanation Reference-level explanation Current Endpoints with the v1 API Proposed Endpoints Owner API Endpoints get_status validate_chain compact_chain get_peers get_connected_peers ban_peer unban_peer Foreign API Endpoints get_version get_header get_block get_tip get_kernel get_outputs get_unspent_outputs get_pmmr_indices get_pool_size get_stempool_size get_unconfirmed_transactions push_transaction Errors JSON-RPC Errors API Result Errors Authentication Wallet support Legacy support API only Node V1 Deprecation Timeline Drawbacks Prior art Future possibilities References","title":"Table of Contents"},{"location":"grin-rfcs/text/0007-node-api-v2/#summary","text":"Create a v2 JSON-RPC API for the Node API.","title":"Summary"},{"location":"grin-rfcs/text/0007-node-api-v2/#motivation","text":"The previous Node API (referred to here as v1) was a REST API. This API while simple had a few drawbacks: Manually documented (current documentation is available here . Contains call with heterogenous args such as ?byid=xxx and commitment/xxx which can be confusing and lack some uniformity. Uses REST which is bound to HTTP while v2 wallet API uses JSON-RPC. No difference between node management and simple information endpoints (i.e. exposing the node on the internet would allow anyone to query sensitive endpoints) This RFC provides a new v2 API with: - Cleaner methods and errors. - Owner and Foreign API. - Generated documentation directly on docs.rs. - Automatic testing with doc tests. - Stronger basis for future improvements.","title":"Motivation"},{"location":"grin-rfcs/text/0007-node-api-v2/#community-level-explanation","text":"This new API will be particularly useful for wallet developer and should ultimately simplify their work on Grin. Moreover, this RFC does not introduce any breaking changes as the v1 REST API will still be around until completely deprecated.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0007-node-api-v2/#reference-level-explanation","text":"","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0007-node-api-v2/#v1-endpoints","text":"While the endpoints are documented in details here , here is an overview of the REST API Endpoints of the v1 API. [ \"get blocks\" , \"get headers\" , \"get chain\" , \"post chain/compact\" , \"get chain/validate\" , \"get chain/kernels/xxx?min_height=yyy&max_height=zzz\" , \"get chain/outputs/byids?id=xxx,yyy,zzz\" , \"get chain/outputs/byheight?start_height=101&end_height=200\" , \"get status\" , \"get txhashset/roots\" , \"get txhashset/lastoutputs?n=10\" , \"get txhashset/lastrangeproofs\" , \"get txhashset/lastkernels\" , \"get txhashset/outputs?start_index=1&max=100\" , \"get txhashset/merkleproof?n=1\" , \"get pool\" , \"post pool/push_tx\" , \"post peers/a.b.c.d:p/ban\" , \"post peers/a.b.c.d:p/unban\" , \"get peers/all\" , \"get peers/connected\" , \"get peers/a.b.c.d\" , \"get version\" ] These endpoints can be grouped into 5 categories: miscellaneous endpoints (which contain status and version endpoints) chain endpoints (which also contain blocks , chain and headers` endpoints) peer endpoints pool endpoints txhashset endpoints","title":"V1 Endpoints"},{"location":"grin-rfcs/text/0007-node-api-v2/#v2-endpoints","text":"The following endpoints are kept and refactored: [ \"get blocks\" , \"get headers\" , \"get chain\" , \"post chain/compact\" , \"get chain/validate\" , \"get chain/kernels/xxx?min_height=yyy&max_height=zzz\" , \"get chain/outputs/byids?id=xxx,yyy,zzz\" , \"get chain/outputs/byheight?start_height=101&end_height=200\" , \"get status\" , \"get txhashset/outputs?start_index=1&max=100\" , \"get pool\" , \"post pool/push_tx\" , \"post peers/a.b.c.d:p/ban\" , \"post peers/a.b.c.d:p/unban\" , \"get peers/all\" , \"get peers/connected\" , \"get peers/a.b.c.d\" , \"get version\" ] The logic of the following endpoints will NOT be implemented as they are purely internals: \"get txhashset/roots\" , \"get txhashset/lastoutputs?n=10\" , \"get txhashset/lastrangeproofs\" , \"get txhashset/lastkernels\" , \"get txhashset/merkleproof?n=1\" , The new Owner API endpoint methods are the following: get_status validate_chain compact_chain get_peers get_connected_peers ban_peer unban_peer The new Foreign API endpoint methods are the following: get_version get_header get_block get_tip get_kernel get_outputs get_unspent_outputs get_pool_size get_stempool_size get_unconfirmed_transactions push_transaction When running grin with defaults, the V2 apis are available at - localhost:3413/v2/owner for the owner API. - localhost:3413/v2/foreign for the foreign API.","title":"V2 Endpoints"},{"location":"grin-rfcs/text/0007-node-api-v2/#owner-api-endpoints","text":"","title":"Owner API Endpoints"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_status","text":"Returns various information about the node, the network and the current sync status. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_status\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"protocol_version\" : \"2\" , \"user_agent\" : \"MW/Grin 2.x.x\" , \"connections\" : \"8\" , \"tip\" : { \"height\" : 371553 , \"last_block_pushed\" : \"00001d1623db988d7ed10c5b6319360a52f20c89b4710474145806ba0e8455ec\" , \"prev_block_to_last\" : \"0000029f51bacee81c49a27b4bc9c6c446e03183867c922890f90bb17108d89f\" , \"total_difficulty\" : 1127628411943045 }, \"sync_status\" : \"header_sync\" , \"sync_info\" : { \"current_height\" : 371553 , \"highest_height\" : 0 } } } }","title":"get_status"},{"location":"grin-rfcs/text/0007-node-api-v2/#validate_chain","text":"Trigger a validation of the chain state. { \"jsonrpc\" : \"2.0\" , \"method\" : \"validate_chain\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : null } }","title":"validate_chain"},{"location":"grin-rfcs/text/0007-node-api-v2/#compact_chain","text":"Trigger a compaction of the chain state to regain storage space. { \"jsonrpc\" : \"2.0\" , \"method\" : \"compact_chain\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : null } }","title":"compact_chain"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_peers","text":"Retrieves information about peers. If null is provided, get_peers will list all stored peers. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_peers\" , \"params\" : [ \"70.50.33.130:3414\" ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : [ { \"addr\" : \"70.50.33.130:3414\" , \"ban_reason\" : \"None\" , \"capabilities\" : { \"bits\" : 15 }, \"flags\" : \"Defunct\" , \"last_banned\" : 0 , \"last_connected\" : 1570129317 , \"user_agent\" : \"MW/Grin 2.0.0\" } ] } }","title":"get_peers"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_connected_peers","text":"Retrieves a list of all connected peers. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_connected_peers\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : [ { \"addr\" : \"35.176.195.242:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"47.97.198.21:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"148.251.16.13:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"68.195.18.155:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"52.53.221.15:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 0 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"109.74.202.16:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"121.43.183.180:3414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 }, { \"addr\" : \"35.157.247.209:23414\" , \"capabilities\" : { \"bits\" : 15 }, \"direction\" : \"Outbound\" , \"height\" : 374510 , \"total_difficulty\" : 1133954621205750 , \"user_agent\" : \"MW/Grin 2.0.0\" , \"version\" : 1 } ] } }","title":"get_connected_peers"},{"location":"grin-rfcs/text/0007-node-api-v2/#ban_peer","text":"Bans a specific peer. { \"jsonrpc\" : \"2.0\" , \"method\" : \"ban_peer\" , \"params\" : [ \"70.50.33.130:3414\" ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : null } }","title":"ban_peer"},{"location":"grin-rfcs/text/0007-node-api-v2/#unban_peer","text":"Unbans a specific peer. { \"jsonrpc\" : \"2.0\" , \"method\" : \"unban_peer\" , \"params\" : [ \"70.50.33.130:3414\" ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : null } }","title":"unban_peer"},{"location":"grin-rfcs/text/0007-node-api-v2/#foreign-api-endpoints","text":"","title":"Foreign API Endpoints"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_version","text":"Returns the node version and block header version (used by grin-wallet). { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_version\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"node_version\" : \"2.1.0-beta.2\" , \"block_header_version\" : 2 } } }","title":"get_version"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_header","text":"Gets block header given either a height, a hash or an unspent output commitment. Only one parameter is required. If multiple parameters are provided only the first one in the list is used. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_header\" , \"params\" : [ null , \"00000100c54dcb7a9cbb03aaf55da511aca2c98b801ffd45046b3991e4f697f9\" , null ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"cuckoo_solution\" : [ 9886309 , 35936712 , 43170402 , 48069549 , 70022151 , 97464262 , 107044653 , 108342481 , 118947913 , 130828808 , 144192311 , 149269998 , 179888206 , 180736988 , 207416734 , 227431174 , 238941623 , 245603454 , 261819503 , 280895459 , 284655965 , 293675096 , 297070583 , 299129598 , 302141405 , 313482158 , 321703003 , 351704938 , 376529742 , 381955038 , 383597880 , 408364901 , 423241240 , 436882285 , 442043438 , 446377997 , 470779425 , 473427731 , 477149621 , 483204863 , 496335498 , 534567776 ], \"edge_bits\" : 29 , \"hash\" : \"00000100c54dcb7a9cbb03aaf55da511aca2c98b801ffd45046b3991e4f697f9\" , \"height\" : 374336 , \"kernel_root\" : \"d294e6017b9905b288dc62f6f725c864665391c41da20a18a371e3492c448b88\" , \"nonce\" : 4715085839955132421 , \"output_root\" : \"12464313f7cd758a7761f65b2837e9b9af62ad4060c97180555bfc7e7e5808fa\" , \"prev_root\" : \"e22090fefaece85df1441e62179af097458e2bdcf600f8629b977470db1b6db1\" , \"previous\" : \"0000015957d92c9e04c6f3aec8c5b9976f3d25f52ff459c630a01a643af4a88c\" , \"range_proof_root\" : \"4fd9a9189e0965aa9cdeb9cf7873ecd9e6586eac1dd9ca3915bc50824a253b02\" , \"secondary_scaling\" : 561 , \"timestamp\" : \"2019-10-03T16:08:11+00:00\" , \"total_difficulty\" : 1133587428693359 , \"total_kernel_offset\" : \"0320b6f8a4a4180ed79ecd67c8059c1d7bd74afe144d225395857386e5822314\" , \"version\" : 2 } } }","title":"get_header"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_block","text":"Gets block details given either a height, a hash or an unspent output commitment. Only one parameter is required. If multiple parameters are provided only the first one in the list is used. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_block\" , \"params\" : [ 374274 , null , null ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"header\" : { \"cuckoo_solution\" : [ 1263501 , 14648727 , 42430559 , 58137254 , 68666726 , 72784903 , 101936839 , 104273571 , 123886748 , 131179768 , 155443226 , 162493783 , 164784425 , 167313215 , 169806918 , 183041591 , 184403611 , 210351649 , 215159650 , 239995384 , 240935454 , 257742462 , 280820644 , 300143903 , 303146496 , 311804841 , 341039986 , 354918290 , 363508555 , 377618528 , 396693709 , 397417856 , 399875872 , 413238540 , 413767813 , 432697194 , 436903767 , 447257325 , 453337210 , 459401597 , 496068509 , 511300624 ], \"edge_bits\" : 29 , \"hash\" : \"000001e16cb374e38c979c353a0aaffbf5b939da7688f69ad99efda6c112ea9b\" , \"height\" : 374274 , \"kernel_root\" : \"e17920c0e456a6feebf19e24a46f510a85f21cb60e81012f843c00fe2c4cad6e\" , \"nonce\" : 4354431877761457166 , \"output_root\" : \"1e9daee31b80c6b83573eacfd3048a4af57c614bd36f9acd5fb50fbd236beb16\" , \"prev_root\" : \"9827b8ffab942e264b6ac81f2b487e3de65e411145c514092ce783df9344fa8a\" , \"previous\" : \"00001266a73ba6a8032ef8b4d4f5508407ffb1c270c105dac06f4669c17af020\" , \"range_proof_root\" : \"3491b8c46a3919df637a636ca72824377f89c4967dcfe4857379a4a82b510069\" , \"secondary_scaling\" : 571 , \"timestamp\" : \"2019-10-03T15:15:35+00:00\" , \"total_difficulty\" : 1133438031814173 , \"total_kernel_offset\" : \"63315ca0be65c9f6ddf2d3306876caf9f458a01d1a0bf50cc4d3c9b699161958\" , \"version\" : 2 }, \"inputs\" : [], \"kernels\" : [ { \"excess\" : \"08761e9cb1eea5bfcf771d1218b5ec802798d6eecaf75faae50ba3a1997aaef009\" , \"excess_sig\" : \"971317046c533d21dff3e449cc9380c2be10b0274f70e009aa2453f755239e3299883c09a1785b15a141d89d563cdd59395886c7d63aba9c2b6438575555e2c4\" , \"features\" : \"Coinbase\" , \"fee\" : 0 , \"lock_height\" : 0 } ], \"outputs\" : [ { \"block_height\" : 374274 , \"commit\" : \"09d33615563ba2d65acc2b295a024337166b9f520122d49730c73e8bfb43017610\" , \"merkle_proof\" : \"00000000003e6f5e000000000000000f60fe09a7601a519d9be71135404580ad9de0964c70a7619b1731dca2cd8c1ae1dce9f544df671d63ff0e05b58f070cb48e163ca8f44fb4446c9fe1fc9cfef90e4b81e7119e8cf60acb9515363ecaea1ce20d2a8ea2f6f638f79a33a19d0d7b54cfff3daf8d21c243ba4ccd2c0fbda833edfa2506b1b326059d124e0c2e27cda90268e66f2dcc7576efac9ebbb831894d7776c191671c3294c2ca0af23201498a7f5ce98d5440ca24116b40ac98b1c5e38b28c8b560afc4f4684b81ab34f8cf162201040d4779195ba0e4967d1dd8184b579208e9ebebafa2f5004c51f5902a94bf268fd498f0247e8ba1a46efec8d88fa44d5ecb206fbe728ee56c24af36442eba416ea4d06e1ea267309bc2e6f961c57069e2525d17e78748254729d7fdec56720aa85fe6d89b2756a7eeed0a7aa5d13cfb874e3c65576ec8a15d6df17d7d4856653696b10fb9ec205f5e4d1c7a1f3e2dd2994b12eeed93e84776d8dcd8a5d78aecd4f96ae95c0b090d104adf2aa84f0a1fbd8d319fea5476d1a306b2800716e60b00115a5cca678617361c5a89660b4536c56254bc8dd7035d96f05de62b042d16acaeff57c111fdf243b859984063e3fcfdf40c4c4a52889706857a7c3e90e264f30f40cc87bd20e74689f14284bc5ea0a540950dfcc8d33c503477eb1c60\" , \"mmr_index\" : 4091742 , \"output_type\" : \"Coinbase\" , \"proof\" : \"7adae7bcecf735c70eaa21e8fdce1d3c83d7b593f082fc29e16ff2c64ee5aaa15b682e5583257cf351de457dda8f877f4d8c1492af3aaf25cf5f496fce7ca54a0ef78cc61c4252c490386f3c69132960e9edc811add6415a6026d53d604414a5f4dd330a63fcbb005ba908a45b2fb1950a9529f793405832e57c89a36d3920715bc2d43db16a718ecd19aeb23428b5d3eeb89d73c28272a7f2b39b8923e777d8eb2c5ce9872353ba026dc79fdb093a6538868b4d184215afc29a9f90548f9c32aa663f9197fea1cadbb28d40d35ed79947b4b2b722e30e877a15aa2ecf95896faad173af2e2795b36ce342dfdacf13a2f4f273ab9927371f52913367d1d58246a0c35c8f0d2330fcddb9eec34c277b1cfdaf7639eec2095930b2adef17e0eb94f32e071bf1c607d2ef1757d66647477335188e5afc058c07fe0440a67804fbdd5d35d850391ead3e9c8a3136ae1c42a33d5b01fb2c6ec84a465df3f74358cbc28542036ae4ef3e63046fbd2bce6b12f829ed193fb51ea87790e88f1ea686d943c46714b076fb8c6be7c577bca5b2792e63d5f7b8f6018730b6f9ddaf5758a5fa6a3859d68b317ad4383719211e78f2ca832fd34c6a222a8488e40519179209ad1979f3095b7b7ba7f57e81c371989a4ace465149b0fe576d89473bc596c54cee663fbf78196e7eb31e4d56604c5226e9242a68bda95e1b45473c52f63fe865901839e82079a9935e25fe8d44e339484ba0a62d20857c6b3f15ab5c56b59c7523b63f86fa8977e3f4c35dc8b1c446c48a28947f9d9bd9992763404bcba95f94b45d643f07bb7c352bfad30809c741938b103a44218696206ca1e18f0b10b222d8685cc1ed89d5fdb0c7258b66486e35c0fd560a678864fd64c642b2b689a0c46d1be6b402265b7808cd61a95c2b4a4df280e3f0ec090197fb039d32538d05d3f0a082f5\" , \"proof_hash\" : \"cfd97db403c274220bb0dbaf3ecc88e483c0b707d8e6f16dfda37cd4f2c3211c\" , \"spent\" : false } ] } } }","title":"get_block"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_tip","text":"Returns details about the state of the current fork tip. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_tip\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"height\" : 374350 , \"last_block_pushed\" : \"000000543c69a0306b5463b92939643442a44a6d9be5bef72bea9fc1d718d310\" , \"prev_block_to_last\" : \"000001237c6bac162f1add2b122fab6a254b9fcc2c4b4c8c632a8c39855521f1\" , \"total_difficulty\" : 1133621604919005 } } }","title":"get_tip"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_kernel","text":"Returns a LocatedTxKernel based on the kernel excess. The min_height and max_height parameters are both optional. If not supplied, min_height will be set to 0 and max_height will be set to the head of the chain. The method will start at the block height max_height and traverse the kernel MMR backwards, until either the kernel is found or min_height is reached. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_kernel\" , \"params\" : [ \"09c868a2fed619580f296e91d2819b6b3ae61ab734bf3d9c3eafa6d9700f00361b\" , null , null ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"height\" : 374557 , \"mmr_index\" : 2211662 , \"tx_kernel\" : { \"excess\" : \"09c868a2fed619580f296e91d2819b6b3ae61ab734bf3d9c3eafa6d9700f00361b\" , \"excess_sig\" : \"1720ec1b94aa5d6ba4d567f7446314f9a6d064eea69c5675cc5659f65f290d80b0e9e3a48d818cadba0a4e894bbc6eb6754b56f53813e2ee0b1447969894ca4a\" , \"features\" : \"Coinbase\" } } } }","title":"get_kernel"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_outputs","text":"Retrieves details about specifics outputs. Supports retrieval of multiple outputs in a single request. Support retrieval by both commitment string and block height. Last field are for whether or not the response will include rangeproof and merkle proof. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_outputs\" , \"params\" : [[ \"09bab2bdba2e6aed690b5eda11accc13c06723ca5965bb460c5f2383655989af3f\" , \"08ecd94ae293863286e99d37f4685f07369bc084ba74d5c59c7f15359a75c84c03\" ], 376150 , 376154 , true , true ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : [ { \"block_height\" : 374568 , \"commit\" : \"09bab2bdba2e6aed690b5eda11accc13c06723ca5965bb460c5f2383655989af3f\" , \"merkle_proof\" : null , \"mmr_index\" : 4093403 , \"output_type\" : \"Transaction\" , \"proof\" : \"e30aa961d6f89361a9a3c60f73e3551f50a3887212e524b5874ac50c1759bb95bc8e588d82dd51d84c7cbaa9abe79e0b8fe902bcfda17276c24d269fbf636aa2016c65a760a02e18338a33e83dec8e51fbfd953ee5b765d97ce39ba0850790d2104812a1d15d5eaa174de548144d3a7d413906d85e22f89065ef727910ee4c573494520c43e36e83dacee8096666aa4033b5e8322e72930c3f8476bb7be9aef0838a2ad6c28f4f5212708bf3e5954fc3971d66b7835383b96406fa65415b64ecd53a747f41d785c3e3615c18dfdbe39a0920fefcf6bc55fe65b4b215b1ad98c80fdafbef6f21ab60596f2d9a3e7bc45d750e807d5eb883dadde1625d4f20af9f1315b8bea08c97fad922afe2000c84c9eb5f96b2a24da7a637f95c1102ecfc1257e19bc4120082f5ee76448c90abd55108256f8341e0f4009cfc3906a598de465467ee1ee072bfd3384e1a0b9039192d1edc33092d7b09d1164c4fc4c378227a391600a8a5d5ba5fe36a2a4eabe0dbae270aefa5a5f2df810cda79211805206ad93ae08689e2675aad025db3499d43f1effc110dfb2f540ccd6eb972c02f98e8151535c099381c8aeb1ea8aad2cfdf952e6ab9d26e74a5611d943d02315e212eb06ce2cd20b4675e6f245e5302cdb8b31d46bb2e718b50ecfad2d440323826570447c2498376c8bad6e4ee97bde41c47f6a20eea406d758c53fb9e8542f114c1a277a6335ad97fdc542c6bbec756dc4a9085c319fe6f0c9e1bb043f01a43c12aa6f4dff8b1220e7f16bc56dee9ccb59fb7c3b7aa6bb33b41c33d8e4b03b6b9cb89491504210dd691b46ffe2862387339d2b62a9dc4c20d629e23eb8b06490c4999433c1b4626fb4d21517072bd8e82511c115ee47bf9a5e40f0a74177f5b573db2e277459877a01b172e026cbb3f76aaf0c61f244584f3a76804dea62175a80d777238\" , \"proof_hash\" : \"660d706330fc36f611c50d90cb965fddf750cc91f8891a58b5e39b83a5fc6b46\" , \"spent\" : false }, { \"block_height\" : 376151 , \"commit\" : \"08ecd94ae293863286e99d37f4685f07369bc084ba74d5c59c7f15359a75c84c03\" , \"merkle_proof\" : \"6b2abbd334c9d75409461fba9c1acd4a8d7bc2ab0bc43143f42388b2a3a87b881505ccf8ffc8737fa6fd4fe412a082d974911bd223eae612d0d1d7ddcc09b5e6079c40b011405b2ccb49ce32473c93aea6d843488d5765fea114d3368d34cd05fcb8c2de3903fbaf39b1f064c809f9f1c0d47959d81a508957040eda55c6dce6dd8c43a79c72faffacfabe1d73055790b6249de2f7c603f186cb109eee58fb1426ea48cb781f88df9acd8996d235fe6bfe60e02aae6e3bfe38ed2599baca1430b3b637072d9bdcdc7644f873728e3cd38eff7124ea848cfad67f8e114cf8595c89a3686a4271cfb2b5098597c315c01d04270ca8f70262af967a947f49adacfa4aad8b6fd196dd0ef4e5cefa132c38c7e5f43db12b3d74f0a8d83c3404e73c6b25a12bff70a8ef4526c89b1558810bb744ede53f8c4cc8cc2555e953637722adb41ea5752281cf1f75599f7e59b17f11f5f9ce4f6b2da4141a3398f51d8b834cdc8b00f61915a41d200572a10bb2102cbae7e94aa7ced3c388dcd58282932c99a8fa66f6fc511ff3e8c60d442bbdb49cca1166328ca8c9bbc97d024570b4cc1ca6c7dba3db223e9e27fd9345b94d3cf10e2b54915b87c57e32965bc2db1b1f956d1962812738ca9b2c93fd7825adf4dffddc97aa85ca0f3f412f02d30678a816d2efbfb6778305fd5e610b6e8af30030bc059880c337bfde326b392d5dcd7c36cb0076fbccc7099b94f1f03bdb525d6e3818b6d50b93ced802957a4b03892c71b6679052bd35e92ceea71a96b22b2ed2c129755f0c74fa172f43da2790f3132a7e57e408d2fc5f1126b088cd0398e6dedcb237242e6720e12e8d7a5a1e196eda6241cfee1cc85e9d20af67f3f9bdf91160516ebcd0b8da6bb7b12229e1112b22c9f1aaef1d75441465cfee2ac1c47b5255514316ed4637e192b00ff28491168f2f2b00\" , \"mmr_index\" : 4107711 , \"output_type\" : \"Coinbase\" , \"proof\" : \"7083884b5f64e4e61fb910d2c3c603f7c94490716d95e7144b4c927d0ca6ccc0e069cc285e25f38ee90c402ef26005cad2b4073eeba17f0ae3ea2b87095106ef00634f321d8a49c2feaad485bc9ee552564a6a883c99886d0d3a85af3490d718f5a5cbc70f9dcc9bf5d987fb6072132a4c247d4bbd4af927532a887b1e4250b7277771f6b82f43f4fb5a48089ed58e7d3190a19197e07acfed650f8b2cd5f103e994fb3d3735c5727f06f302bd1f182586297dd57a7951ff296bdf6106704abedc39db77f1293effaa7496a77d19420a6208bc1c589b33dad9540cb6180cccf5e085006b01309419f931e54531d770e5fe00eca584072692a7e4883fd65ed4a7c460665608ab96bf0c7d564fe96a341f14066db413a6fddc359eb11f6f962aca70ca1414c35d7941ce06b77d0a0606081b78d5e64a4501f8e8eba9f0e0889042bc54b4cbfd71087a95af63e0306dba214084d4860b0ce66dc80af44224e5a6fef55800650b05cf1639f81bfdc30950f3634d1fd4375d50c22c7f13f3dfb690e5f155a535aff041b7f800bfe74c60f606e8ab47df60754a0e08221c2a50abe643bb086433afd040a7e6290d1d00b3fe657be3bb05c67f90eb183c2acb53c81e1ca15cd8d35fe9d7d52d8f455398e905bdc77ffb211697d477af25704cf9896e8ce797f4fed03e2ba1615e3ad5646eecaa698470f99437d01d5193f041201502763e8bde51e6dc830b5c676d05c8f7f87c4972c578b8d9d5922ba29f6e4a89a123311d02b5ac44a7d5307f7ed5e4e66aaf749afc76c6fc1114445d6fafeea816a0f985eeacdbe9e6d32a8514ca4aaf7faad4e9d43cde55327ac84bac4d70a9319840e136e713aa31d639e43302f3c71a79f08f4e5c9a19a48d4b46403734cd8f3cc9b67bc26ea8e2a01e63a6f5be6e044e8ed5db5f26d15d25de75f672a79315c5e2407e\" , \"proof_hash\" : \"7cf77fdaecef6c6fc01edca744c1521581f854a9bac0153971edbb1618fc36ad\" , \"spent\" : false }, { \"block_height\" : 376154 , \"commit\" : \"095c12db5e57e4a1ead0870219bda4ebfb1419f6ab1501386b9dd8dc9811a8c5ff\" , \"merkle_proof\" : \"00000000003eadc6000000000000000e13c509a17cbb0d81634215cd2482ab6d9eb58b332fcbe6b2c4fa458a63d3cb0dfe3614ebe6e52657870df225d132179fa1ea0fdc2105f0e51d03bc3765a9cd059c60d434a7cae0a3d669b37588c25410f57405c841312cfa50cf514678877a3f4ce8bd3e57723ba75a2b7d61027b2088fbabebdb7336b97ea88b00a7e809a6245def980eba18d987601f4cbd6c3cc9f12a5684fe7a1bc2565a9f8ab63c2db1afa8304f5e23d4754cd97f29c8b06dcb3de4f6d3a83079676b6e9941afe5553a7195384b564ecd6d37522cb5e452cc930d2b549af22698a8fd9bf6cad05a06b09e3f6e672b94e82c0255394b5c187ab76fda653a2491378997ba3d49f9d9c34ca93bc627fe5d98b327c03d429b5473f62672e9d73c4eafd9cb8f62e5158a1ec7eb56653696b10fb9ec205f5e4d1c7a1f3e2dd2994b12eeed93e84776d8dcd8a5d78aecd4f96ae95c0b090d104adf2aa84f0a1fbd8d319fea5476d1a306b2800716e60b00115a5cca678617361c5a89660b4536c56254bc8dd7035d96f05de62b042d16acaeff57c111fdf243b859984063e3fcfdf40c4c4a52889706857a7c3e90e264f30f40cc87bd20e74689f14284bc5ea0a540950dfcc8d33c503477eb1c60\" , \"mmr_index\" : 4107717 , \"output_type\" : \"Coinbase\" , \"proof\" : \"073593bc475478f1e4b648ab261df3b0a6e5a58a617176dd0c8f5e0e1d58b012b40eb9b341d16ee22baf3645ea37705895e731dee5c220b58b0f780d781806a10dfa33e870d0494fba18aaa8a7a709bfb3ddf9eb3e4e75a525b382df68dc6f710275cdffb623373c47c1310ae63479826f435ca4520fdc13bb0d995b7d9a10a7587d61bd4a51c9e32c87f3eb6b0f862cdff19a9ac6cb04d6f7fafb8e94508a851dcf5dc6acea4271bb40117a45319da5522b966091b089698f4f940842458b5b49e212d846be35e0c2b98a00ac3d0b7ceaf081272dbed8abd84fe8f26d57bac1340e8184602436ed8c4470ef9dc214df3405de0e71703abec4456b15e122a94706852bb476213ceadf00529d00d8d3b16dc57f4e4a9a86dacfa719e00366728de42f3f830e73f6113f1e391fab07eba1b40f6466203b0ce14701230e934f6138c575660a03dbb0e59d7295df3115a4fc0909a5520d74657b319fc83481079ad6c13400175e39fa2b86071ba563ce8836320713ef8f55d4e90bee3f57df96c7aef0f2e896f57192fae9675471cd9751bcaf2b15e5a65a9733a6f7f9b8147b8f6e8dac51d056018d411fd252225cf88e56f143143f49e8a0d2e43c10de0442dbc84966817532b1256b6769db987526790a389c371a1fe7a36eacffef82877b4db7a9b5e58722ffbd0fc4fdbd7624365ee326bb8b1e60b999f513715b30f37ef6116eabf53b3524b46c33a1fac49205b39e24aa388d823269c1fc43c3599a06b69433a0a47a03bd871321afb7846a6dbfd5891bd84f89c556231745c929d08445f66f332857bfda1c4f86ae58a01007b7303f870ac24e0ba72d84c0ef4903ac2ff777e2c2dcb4d8e303c74e0c8a559686b4d4c25024ee97601787d4e5a97224af41e5d35d91744292f5a41f64d4e1cae77bebebd77a473f3b54e86f7221aac230942f0468\" , \"proof_hash\" : \"5dd69c083e2c0fd797a499bbafedee0728849afa3476034280ecadf6eb4bffc2\" , \"spent\" : false }, { \"block_height\" : 376153 , \"commit\" : \"0948cb346b7affe004a6f84fa4b5b44995830f1c332b03537df4c258d51d1afb50\" , \"merkle_proof\" : \"00000000003eadc4000000000000000dfe3614ebe6e52657870df225d132179fa1ea0fdc2105f0e51d03bc3765a9cd059c60d434a7cae0a3d669b37588c25410f57405c841312cfa50cf514678877a3f4ce8bd3e57723ba75a2b7d61027b2088fbabebdb7336b97ea88b00a7e809a6245def980eba18d987601f4cbd6c3cc9f12a5684fe7a1bc2565a9f8ab63c2db1afa8304f5e23d4754cd97f29c8b06dcb3de4f6d3a83079676b6e9941afe5553a7195384b564ecd6d37522cb5e452cc930d2b549af22698a8fd9bf6cad05a06b09e3f6e672b94e82c0255394b5c187ab76fda653a2491378997ba3d49f9d9c34ca93bc627fe5d98b327c03d429b5473f62672e9d73c4eafd9cb8f62e5158a1ec7eb56653696b10fb9ec205f5e4d1c7a1f3e2dd2994b12eeed93e84776d8dcd8a5d78aecd4f96ae95c0b090d104adf2aa84f0a1fbd8d319fea5476d1a306b2800716e60b00115a5cca678617361c5a89660b4536c56254bc8dd7035d96f05de62b042d16acaeff57c111fdf243b859984063e3fcfdf40c4c4a52889706857a7c3e90e264f30f40cc87bd20e74689f14284bc5ea0a540950dfcc8d33c503477eb1c60\" , \"mmr_index\" : 4107716 , \"output_type\" : \"Coinbase\" , \"proof\" : \"72950da23ad7f0d0381e2f788bf0ac6b6bcb17aaccf0373534122a95714d2d0dbf6a24822b4aab0711a595c80bc36122957111c39292f2a36a973252fb88cbda0b1d61ea8ea84f5171a61f751cac97332637b7cf74cc73144b912ba700dedaa60895f06e947f1e42a8c79d70f924f45fdcb6df5d30289f36ff77d0ae368df5775a739b7a25cbfb63f0cdbdc167b046067c2a021fe0950c7b67515b185b9e4a00ce63b795d49ae184fe5cc726d72fc05d717c4fb55dd5f65967dc282d3c47cb6f8a92cb696e5a1d8cca21214bc766e3de6271791cebf646cda97ae77035da16606f3397f71e103137358c97b9943c3e15403184f61230bd0e3954c7681a0891aa7a0cc32e82d830fb7d8759a04d1da7058630a853508df095142f22158c28bd5e3f2477ad6c8990e63d0377a0fa3d588b6584453778eb38cbaec8a33c1d3772c97a826d4a2f6953c35342993b04567e9fea6fc64fb714653f934faa1a8f635d39eb2903de4bed960a3df07dce7c2e3ff517bbc15f467d0190a579bc07b0f1a910b23269d794835bbb34e8318dcc4fd4159f8f03faa77842d445cf61af9e33caf46aa5fae0812a6476a09c0757e929271a96a245701ab14c1fdd836b92b7e763afa623017f68f1bc4eb716ce735820a1311b743dd8d5c6bb275a2e4e7d2eff8f45417b60cc937086c3e7fd3b612ae064d7237eb6a7bd1a39d8575fac312068fa060bc1ceac4df0754601edaf04ecb1b89c0661ea01a593c3763e456bebbd8487edc0ff3bc6f203965cd92b1706070c59a3795f9dee23087cea0aaec015f1b7bfe4df81818d7a37af781ca7b757ace2fa489f85215ecb85976b1c74c7f1df6d834a8bc63e887407ef6e233c55ea040bc5f2471e99ebc92f2283ff592ff751d9226bd105e68e187c91ecb236c9fa4fb060ae4d706c571ac2123da1debd12737d98be118578\" , \"proof_hash\" : \"0ce421970d13fe9b3981e308c5d0b549982cdda9f69918289cd95ffcd09e0fc2\" , \"spent\" : false } ] } }","title":"get_outputs"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_unspent_outputs","text":"UTXO traversal. Retrieves last utxos since a start index until a max. Last boolean is optional to whether or not return the rangeproof. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_unspent_outputs\" , \"params\" : [ 1 , 2 , true ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"highest_index\" : 2078061 , \"last_retrieved_index\" : 30 , \"outputs\" : [ { \"block_height\" : 1 , \"commit\" : \"08b7e57c448db5ef25aa119dde2312c64d7ff1b890c416c6dda5ec73cbfed2edea\" , \"merkle_proof\" : null , \"mmr_index\" : 1 , \"output_type\" : \"Coinbase\" , \"proof\" : \"9330ad8cde205f317c6537eca96b866293a0489615a9a277b4d3a597c873544c82474932b641e06ac8719604ee52e895e8cd4621b6bfb85780cd9becce14d0700b83a664db2f52a26c425fd777ad88944cdfff38043a2793ed4d9aa67e36cbfd5585579fc69dda930418af5eaf603654f6f751258d2dfc8c2113c171e130f31ec1e6cce2a718e435298fce5d64ffe1bd3464fd7c87cfa92093855be034bfe4439e928bd92ad77fd0a0e00355ee1d1a9ceb1ed0c408dcfdba8c583e7598dc700aaa9f91432097259a405f5b7315a2f7658861e3349bb0dc8bf883726a215f0149ded6613e5ac0670c0c5202247d7c27c8a7d03bdb03c9cf5455463f9b42cf87403e31f8383cc4f49a34c62ae459f5801a9eed4f0ee3dfd5f55b7011c0cae393c474abd6f8c7965b9b5fff3104dd4e39542077c0c8dd2f8ffceb6bb598512d90506d0a7184f20f1498cf458787f23284b54888c9be416d103f760406357a16b6d841a303d5c95b6b474d2d7f0fea0a2a76c897dd2110e9303f54684169421147684c6f1819c33cef3f38ec995a508450c02cd1872f8065fdee723109c18b1dd2ddde75825546ecf0df0793c353b20c946cd64122cea8c116f432336899a16ad24a2aafcb8f900e09a1147135fcf2a54cbf81db308a47a08a49c77c130e5dc5e661cd55a5cc69e607055a5b08111bf61a62ea5778f85119043633f1cab8c756d756c5a34851024ac311a596b1cd919bbca43226f0ba057f6b57de2f6955b0823c3826de7f6096c1c1b6b9b8e4063e1645c0bff32f80561aaa959d97120fbc2ecd9d2be28bd0c17811dc59a88049f6d8952ee9a0a0207693c89ca3ad1197e9bfdfc03be9d845aea8d663969217e3b494cee9e652bc9f8713e2fd5cb1843848f46c3a6ab024d0e3d57ca45454cdbda414adaa835fa147deb4ffb7129cf3a8d86726a0144794\" , \"proof_hash\" : \"6c301688d9186c3a99444f827bdfe3b858fe87fc314737a4dc1155d9884491d2\" , \"spent\" : false }, { \"block_height\" : 29 , \"commit\" : \"09bab1ddad0f6fec1aedcd3830c5c647515ad543929e722344e4a8d390b6fdd51b\" , \"merkle_proof\" : null , \"mmr_index\" : 55 , \"output_type\" : \"Coinbase\" , \"proof\" : \"4a5f858d4311bdd902f4446682f27f64be376283b1171060fd2ad33d85350fee13c25a030874d6308d2b325995a3fe545eb1d85ba66e2ba002b794edfdeacb3f0fd2a690b9a78137771b3633aaef2a77f62fbe4d6b4b373c4bdb7e5f58cfae361a3b4c2e4420cc0d38465b2444e01b50e57c6ebfc2afd6dda9017e54585638bddef17d181d1fd7064d975d8bb1dcfd96c89486aed4680b4d39294a141581d1f51c1acfbb80e2ffc40f8499cdc43be04cacda1e34dd6592edfc500229aa70db1c2869f974cfe9aee0cab696c198624de8ecdaf5ae481a1e46fe79fe983209459b89492f2b24416c368394c43c60c33d0fdd1792f0a58d11763e7c8b89d27da25109db346e4d7b62935d182b45dfb659829c55922350e6f7e3452d9311e527ec5b561f4d043cef865f683fce1ce2d410d414f5bcee63c4bbc00964b0fa757bdfd68158e22c1068d871a45759fbd527883c0451db6f36b15139864b6177a78ad64d326e0152914e5313a97ed7b685e5089f2758bf072c804560306bd944831f067c3413ded09330fd788f353e4ee875d3c9303dd4ec0dda9d55b4a27d7748b3247fe85cf3d26b7004e6e3379041fad136fccdacd02b06456a50ad40a3259842c0794f2d59dbd8fa6b4af065b38c388d76b82136b633b06779e4eb05b5b62ec37cdc2986327639bafa8651318f4c00c066e6f45504ec9a96874d5510b519f434a1a88175d51f86e8ee36ae18d107cfaf83e60b2e62fff032c7539be66d776e3a52c5f9b0ee6fe08820d65cd75d35c793e5ab3914adf5a97b7dba75e90d4a4c9aa844e2f1e9464cd5fc4923b475defca4e3b03e1b33353ff91ac1084712cf4445e329ffdbe1e2da16ae71dee0e914b546fdc0db9b0fcde80822ee716e9f2eec90db7aa4417d53a1266e1e8383e20c9a9548bae35c2a8e1293a49e7afbd8011a9e66e79ed6be\" , \"proof_hash\" : \"a64ed774d824dc55123c6c5ba46d84bac15b6ead8cb60200836c2a0e74506ab0\" , \"spent\" : false } ] } } }","title":"get_unspent_outputs"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_pmmr_indices","text":"Retrieves the PMMR indices based on the provided block height(s). { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_pmmr_indices\" , \"params\" : [ 1 , 200 ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : { \"highest_index\" : 398 , \"last_retrieved_index\" : 2 , \"outputs\" : [] } } }","title":"get_pmmr_indices"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_pool_size","text":"Returns the number of transactions in the transaction pool. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_pool_size\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : 1 } }","title":"get_pool_size"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_stempool_size","text":"Returns the number of transactions in the stem transaction pool. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_stempool_size\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : 0 } }","title":"get_stempool_size"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_unconfirmed_transactions","text":"Returns the unconfirmed transactions in the transaction pool. Will not return transactions in the stempool. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_unconfirmed_transactions\" , \"params\" : [], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : [ { \"src\" : \"Broadcast\" , \"tx\" : { \"body\" : { \"inputs\" : [ { \"commit\" : \"0992ce1827ec349e9f339ce183ffd01db39bf43999799d8191bfc267a58f0a715c\" , \"features\" : \"Coinbase\" }, { \"commit\" : \"0943a3c4ee4a22a5b086c26f8e6dc534204dafde0cf4c07e0c468d224dd79127ec\" , \"features\" : \"Plain\" } ], \"kernels\" : [ { \"excess\" : \"083c49eaaf6380d44596f52cce4cf278cfac6dd34fbef73981002d8f1e8ee8abe4\" , \"excess_sig\" : \"3f011e7e288231d67f42cb4f6416c4720e6170d5e3c805a52d33aa4521328f9be0303be654bc8ddcd3111aadc27c848b9cf07e0a70885ef79be70b7bb70f8c75\" , \"features\" : { \"Plain\" : { \"fee\" : 7000000 } } } ], \"outputs\" : [ { \"commit\" : \"0873fafd4a0e4f365939e24c68eeb18aafc6674ca244a364dcdbfa8fa525e7bae1\" , \"features\" : \"Plain\" , \"proof\" : \"4b675be40672d5965c43d9f03880560a8ac784ee3de8768e28c236a4bc43b8c3d4bc83dee00d2b96530af9607c3b91d9a828f0234bf2aaf7e7c0e9cf936db69c04ca1b267668fbdb2f08ce05c8b119c9d886ceaafb4634b7fae7ea01966ad825dddc9ffab8093155d9c5d268160b86fcad95f4f5e66bf46ff642a51629dbdfd7bba7936846915b925d547337a1b95c33030fad4178468825936242e631797aa3a8f0a5ae0d23040938622648c8432fc247a902abad27e383affb4ec518e4f6f55f55e264bc0f99957be203cfb26d4b8e561fb36da55a50b6ef5861134c484556d701133e1dceda5ea53e731184e0a11f33d06e13ca37d03d39dd047170580534b049862fcd6c73decc7c0af45a267ed148fe6ef2cc375ffebfa8187d2fa0a134428a036d2ec1f65d3ce036b955730fc1ee43b23b574bae2b58b7adfa2a7a45cdec393d9b658857c911560aa3c44cf4435a99d68f3dbc81c82ea43e426ef0198148a90336ee72472aab5f7feea1df93ec830fe5ec642c93c1046dec955df361bfdc3ab74477f847a1b72e8735ef65a8a6d1680745c0152bfb5cbb2a4b4671491a253a1a09d5a07d55f4872c9f0a3d25e07b257926629d5bb96aed96f5debab02503eb0ac45033323cc5a46c8e5d4469ee9f3dd618a20d54d6f5740c010fe5a0fe853efeb253a6df196bd24469ac51c1be8ba84737cecdb5ab73d7c52570d2273621fb69bd7ed985bbc6999dbd2d6fd2687ae44a391d604ff232cc6b3fbedd5d1cd0cd8c658c5d56069b5a5099cc5c9f48bbf7d7e83b4f9a7bdef6eabd164c8395468f818e8cd8c1c800bc3adfd66dbcb247d1bda5a7af38c288c0beb8e0d9160bf67500094530a0f8be52e97b5c2114f5a4a333a11c7f37f4c47a437422455d8cbcfa770cdc85ec55accf48cf14550b07f1346a02fccdf280fcb24c1fb38751d889a17e\" }, { \"commit\" : \"08de9e42d361cabd99e566c67f7f8599c7e6985cd285a841277f1aeb89ad6c8fe3\" , \"features\" : \"Plain\" , \"proof\" : \"5eb7afa00e9681e3b6425fb4256c96905303505787d6a065e88a50154410b9a371b0f879d3f97cfa00425e9c8266e180188656acdbb46cacfdfb159fb135c5eb03b08be3c231c4b21df777da2e2afe8d30db91e602dc4ceed71aeb1b45a0266cfeadc4acbf9fdf7a67f67408fbbea7bf14182bc407373d243c6875373b655695604deb575369a9b28274885601b338882219c7f508aa2a0ae1d02736af2249327145f1d3d00093f9587f0e0b408692700fac0f2a048c329e81cabaa4b997dd88923fe97420125f394e21b4835e36cce9de383d9e223df1b5a6ba6f48ffeac315991189dc2716cc7ec07f6ccc8062344d5ed4fcaddf9070f44f0c59ffe8160d1f6fdfe42b40066f51e687d38b6b5255771800ac060bd8034cd68d14eee1b2f43b6d7bf20d71549ea9a50006dd30b9a795e785385801546eb9a83721a09fc34d3b69d4ccdc0ff0fb74d224048aeb66ecff5515296cadd57f42e0717cbba7c70719a10c007db4520e868efe98a51001b67952d7bda3174195a3d76b93ee4dac60137a38b2e8309cad13ef1cfb6c467f1969385e5b334b52f4fd55da440e036d2a428e9f3be905d79f717c169060468acc6d469636fed098b1aba5cd055a120314bcab55d5b8b6889321edf373517e93ef67fbe74557ec6c0211265efefa25a34ac267cf1db891c47163bfed20d2b535abfe60390c2844dcef5f0aad5fa7f1db9f726d7f223c025861069603936a22377707cdd3915e762e7061132124c716212b0e91bb7fc5d7816366f5d169d93fe75669a6ba19057bb2450958aa6f5ada09042570f46215af5a41b623d140be574b7a8c9ab24ea48da416dbe6ec0fa3b889206fb804df8d69805ceb80f1e9d4e8b664b3939491cba946d87585c830e3dab0638fa279b5e911642f18452e2731764aa62f92bbcf194c97f344c90c1931fd2c3af4bcf6b0\" } ] }, \"offset\" : \"0eb2c2669ce918675c72697891e5527bd13da5a499396381409219b8bbbd8129\" }, \"tx_at\" : \"2019-10-07T16:20:08.709114Z\" } ] } }","title":"get_unconfirmed_transactions"},{"location":"grin-rfcs/text/0007-node-api-v2/#push_transaction","text":"Push new transaction to our local transaction pool. Optional fluff boolean to bypass Dandelion relay (false by default). { \"jsonrpc\" : \"2.0\" , \"method\" : \"push_transaction\" , \"params\" : [ { \"body\" : { \"inputs\" : [ { \"commit\" : \"0904cbd34d0745eb00ffc3e95c9f4746738794d00268e243e9b57163a73b384102\" , \"features\" : \"Coinbase\" } ], \"kernels\" : [ { \"excess\" : \"08385257d22f1b8a758903f78ae12545245d620cffc50e7ee7bc852c5815513dc7\" , \"excess_sig\" : \"e001a7349fd40d4a9dfc1df275d30906fb3b304f8c7892a20ed5c9b10923c871cbabedcf322511a9ce56f10113b48855441f681280133e121b25ea1ff7efad9e\" , \"features\" : { \"Plain\" : { \"fee\" : 8000000 } } } ], \"outputs\" : [ { \"commit\" : \"087c3ca7419751e96cdae4908bb8a92fc2826f2ad36690420b905d51beb7409ca0\" , \"features\" : \"Plain\" , \"proof\" : \"379ae236937883c2e1e613fb30f1b18d2a44d4173360e94bcd07862aafaf81b3aaa1154d67287cc03efde0d3981c6da8a18e2e426f5c30afc0f2e3a75012448402d8d56df52b87f4815575a56d4da174f8187e4faae64bf883b249ceed694271f84ef62a3711d36c997dff7a11111419011e36e3a070b7552415a55faaa3999f99439edccdfe5313277147fdb42be1798442bb225c2b546f5347920584b365aa81a0365b4a706c97c89617b0e6218d2c9bc15805caab27c438ed06340cc4f8dc7bfca0e9d38864c88bb0c834372f6b662b9159134f3f8ec9b8a87878739a7e516b97419ac29e1d4a2b250321470a9a6b98d07065bb7e79afc25a5ab6fc47108f53223078a64502bd4af1a109641447dab82741ebe3fbdbd803ee7a42fe2554e78fa86bd1d1e6e3b913118e9419b0be6f976b2404447d943b5f1bac19a5809fd6834797945a62d21b1ecb6ddebbc5ef94ca9e704d033bd64afde67bd3e06e2cca3bb10190188afc0af80b48dd862b86753d8b4af314763324deb1c97cf020cb87285a47cd28874bb91c6cdf858965e8b9daafbcbc1b4817d334a97d7e25e01b2d072d8dcc6418e3dc7b8e7712632f939238e65ed0731c7af02d55a8884cd8f7f88dc0f63a21955a7364562532f5716c89e14f8f23ad78f6fe2f1649e13ea8f8185f3ee63cc174684d1ef8d8c33fb25bc802f8e05e53fe200b1ea5231f588a020942e6fd7eec67301700088dae8816c16a337120063c21e1604e009df932032812f88be6473af13f802b42d8ad6fc14230fbe13ede178319a7b6540656234ec1f2fcfa70f6faa9c4b6b8150b81fe0fdc273a9bb385d766a02041a5c3f58471d42059c17d84d13ad592aa0ccf337970e7eef06f306b13288795123c9c005b815d848f359b23450656b310f09cda9ad4b7b6931805d47dcd10a8745d834a984e2055168ac3\" }, { \"commit\" : \"09a7b2c1d4b346c4ebe9c6c979e32e7740446624d5439d9d7abb82166c2545e5be\" , \"features\" : \"Plain\" , \"proof\" : \"5fb0ee4093a153e2ed173207dbfa02b4d185f1f313ea4cbf222558819074543f19e9bcdb595a23d4ee971aafcc614b6d2774e22cee6627bc4388297fe6ebf03e0d422f3eb8003cc8516417a6b32eb22f87e1745e0ae5bf1733f2ea253399719b1ef0067934dc548c58729604d24a44040165b32d05e82c9efc9a1f30151dd73ce893ae94709ec2fe5d0f409bb54a86604f0e92915b4f93e7adde823eccf87830ae91d71a7b99967dbcc8531fee44c20c24fb6fe2a34fe86ba5da3a9235cbcdcde033ead57d65c03903a9c9ed877bf0fab9f26d08552c64ea668d5408c84b74bc3ac8335aaaa04ebcf523d36d2207fb8770e976b6fde7d04e2148de5a4169c60b1958bb840b79a8c8f356e1f1fadc35a5a7e276fcd67c354cde546548c9bf788981f38edf5a406977826aa4524004e770b3d3cd6b26f0dc99729ffd9929fa4509b145ef0c3e4293e71b964da731a47cc9f082350acf32afb64b3b12f8383c8f2cc9880131a80ea957b2908c92f21d2db7aa5d67bafb11eb07674e52b920e67a86259dd9c5dcdd18bad182fd85ec4b659c47ea2e2e8a89c57e4d2cde87958fc2ab932e169f6805d2fb14549ac93807bc426eb4cf6d29ff6a4cf22e35dbb27f04211b06b65173501c17a3bb3ff0eecc9bb05dca23379abe457ca3010ebea69e1a2f7f3ed6531bf766007cdd1ac7d6c762785fb56f36194cc2ccaee76a499a7383288e84981b103d76cbe007f66c913eacb277746e78ae08627b279ac1f9a43ab284d8a3b32c6edcd2ea99e8ea836b31a1e2582be6c41f2282cf5fc7bdb95e4b412a5eeccad29670197873a888a100c4b2704ce75137fc997a5632d81001f9b57300a9bf99edd857065be83f835e4c49d852165ba18e1c96316c153459a913773d5d86ddc26c5cd1fff38a8fbb62506b0aef6076382674c0fa95a50a03b0c3df0a688a2cbf\" } ] }, \"offset\" : \"0ec14d3875ad5a366418256fe65bad2a4d4ff1914e1b9488db72dd355138ca3a\" }, true ], \"id\" : 1 } { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Ok\" : null } }","title":"push_transaction"},{"location":"grin-rfcs/text/0007-node-api-v2/#errors","text":"There is two kind of errors that can appear when making a call on the API v2: basic JSON-RPC errors and API result errors","title":"Errors"},{"location":"grin-rfcs/text/0007-node-api-v2/#json-rpc-errors","text":"These errors are often due to a miscontructed JSON body. For example when there is not enough parameters: { \"error\" : { \"code\" : -32602 , \"message\" : \"WrongNumberOfArgs. Expected 4. Actual 5\" }, \"id\" : 1 , \"jsonrpc\" : \"2.0\" } or invalid type of data entered: { \"error\" : { \"code\" : -32602 , \"message\" : \"InvalidArgStructure \\\"start_height\\\" at position 1.\" }, \"id\" : 1 , \"jsonrpc\" : \"2.0\" } or method not found: { \"error\" : { \"code\" : -32601 , \"message\" : \"Method not found\" }, \"id\" : 2 , \"jsonrpc\" : \"2.0\" } this list of errors is not exhaustive, for more information about the possible error objects see the JSON RPC 2.0 specifications .","title":"JSON-RPC Errors"},{"location":"grin-rfcs/text/0007-node-api-v2/#api-result-errors","text":"These type of errors are due to an API error during the query. This type of error is wrapped into the result. The possible error objects are defined in the grin_api crate For example, trying to ban a peer that's already banned: { \"id\" : 2 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Err\" : { \"Internal\" : \"ban peer error: PeerNotFound\" } } } or a block that doesn't exist: { \"id\" : 2 , \"jsonrpc\" : \"2.0\" , \"result\" : { \"Err\" : \"NotFound\" } }","title":"API Result Errors"},{"location":"grin-rfcs/text/0007-node-api-v2/#authentication","text":"Like the v1 API, the v2 API uses basic auth. However, the foreign and owner API do not share the same secret. - The Owner API use the same token as the V1 Rest API, usually defined in .grin/main/.api_secret . - The Foreign API use its own token, usually defined in .grin/main/.foreign_api_secret .","title":"Authentication"},{"location":"grin-rfcs/text/0007-node-api-v2/#wallet-support","text":"For full compatibility, grin-wallet will migrate to use the v2 Node API.","title":"Wallet support"},{"location":"grin-rfcs/text/0007-node-api-v2/#legacy-support","text":"The v1 API will remain active for a time the mode of operation for its REST API will be assumed to work as currently. This setup should allow existing wallets and apps to continue working as-is until a cutoff release for legacy mode is determined.","title":"Legacy support"},{"location":"grin-rfcs/text/0007-node-api-v2/#api-only","text":"Note that this RFC doe not make user-facing changes to the existing CLI (invoked by grin client ) to invoke these functions. It's expected that the existing cli functionality will be modified to invoke the new API functions.","title":"API only"},{"location":"grin-rfcs/text/0007-node-api-v2/#node-v1-deprecation-timeline","text":"v3.0.0 (January 2020): Node API v1 is marked as deprecated and will be remove in next major version. v4.0.0 (July 2020): Node API v1 is removed from the code.","title":"Node V1 Deprecation Timeline"},{"location":"grin-rfcs/text/0007-node-api-v2/#drawbacks","text":"This RFC temporarily introduces some additional code complexity as v1 and v2 node API will need to coexist for the duration of the deprecation period of v1.","title":"Drawbacks"},{"location":"grin-rfcs/text/0007-node-api-v2/#prior-art","text":"This kind of JSON-RPC API is widely used for cryptocurrencies. For instance: Bitcoin Ethereum Monero Tezos","title":"Prior art"},{"location":"grin-rfcs/text/0007-node-api-v2/#future-possibilities","text":"This API simplifies the deployment of new methods and drastically simplifies the work of developers by providing a clear documentation directly on docs.rs.","title":"Future possibilities"},{"location":"grin-rfcs/text/0007-node-api-v2/#references","text":"JSON-RPC 2.0 Specification Bitcoin JSON-RPC Doc Ethereum JSON-RPC Doc Monero JSON-RPC Doc Tezos JSON-RPC Doc","title":"References"},{"location":"grin-rfcs/text/0008-wallet-state-management/","text":"Title: improved-wallet-state-management Authors: Michael Cordner Start date: Nov 4th, 2019 RFC PR: mimblewimble/grin-rfcs#30 Tracking issue: mimblewimble/grin-wallet#244 Summary The changes outlined in the RFC are intended to make process of updating a wallet's state from the chain more consistent for developers and more transparent to the end user. This includes the following changes: The wallet's update process is modified to be more consistent and encapsulated. The check-repair process is run periodically as part of normal wallet update operations The ability for the wallet to run the update process on a separate thread is added. A TTL (Time-to-Live) field is added to the slate The default output selection method is set to smallest Motivation Grin wallet previously updated the state of its outputs and transactions using a combination of UTXO updates, Kernel Lookups and UTXO set scanning. These 'primitives' on their own are generally enough to keep wallet states consistent, however the manner in which they were previously invoked was less than ideal and relied heavily on manually invoking the check-repair process and cancel command. To rectify this situation, this RFC outlines enhancements made to the wallet update process that have the goal of ensuring wallets are always in a consistent state in a manner that is transparent to the user. After adopting these changes, most wallets should automatically keep themselves in sync with the chain in all cases, and users will not usually have to invoke the check-repair or cancel commands. Community-level explanation While these changes should be transparent to end users, wallet developers should note the changes to how the wallet updates itself via these processes. Special attention should be paid to the new update thread API functions, as well as the new TTL field and default selection strategy change. Reference-level explanation Wallet Update Procedures The following sections outlines the processes used in the creation and update of outputs and related transactions within the wallet. Transaction and Output Creation Coinbase Output + Transaction Creation Coinbase outputs and their related transactions are created via the wallet listener as part of the mining process. The workflow is: When mining, create a potential coinbase output for the target block. If the block is accepted and the output is detected in the UTXO set (via the Update by Output process , create a transaction log entry of type 'Confirmed Coinbase', with 'confirmed' set to true. Transacting (Payer -> Payee) Output + Transaction Creation Outputs and tranasctions are created during the transaction exchange process as follows. Note that the invoicing workflow is mostly identical with the roles of Payer and Payee reversed, so this workflow is not outlined separately. The sender creates a new 'blank' transaction Slate, adding inputs and change outputs to the slate. The sender generates a random kernel offset. (The kernel offset is always generated by the slate creator) The sender sends the slate to the payee (via file or http). If sending synchronously, (e.g. via http) the associated transaction is saved to the log after a response from the payee's listener. If sending asynchronously, (e.g. via file), the transaction is saved immediately. When saved, the associated transaction is set to type 'Sent Tx' with a status of 'unconfirmed', inputs are locked internally and a change output is added with status 'unconfirmed'. The payee receives the slate, creates (an) output(s) for the received amount with status unconfirmed, and immediately stores a transaction in their log of type 'Received Tx' with confirmed set to false. The payee calculates and saves the transaction kernel commitment for later reference. The slate is returned to the payer for completion, who calculates and saves the transaction kernel. The transaction is sent to a node for validation. Transaction and Output Statue Update Processes Update by Output Process The Update by Output Process is the main method by which the wallet updates its internal state, decides whether a transaction has been confirmed and when to remove or confirm individual outputs. This process works as follows: For every unspent output in the wallet: If the output's status in the user's wallet is 'unconfirmed' and it is present in the UTXO set, change the output's status to 'confirmed', and update the associated transaction status to 'confirmed'. If the output's status in the user's wallet is 'confirmed' and it no longer appears in the UTXO set, set its status to 'Spent'. Note these outputs will usually be locked so they cannot be selected for spending again. Kernel Lookup Process It is also possible to look up a transaction via the kernel that was stored when the transaction and outputs were created. This is necessary in cases such as where a participant in a transaction doesn't have any change outputs, which means the output update process won't detect when to mark a transaction confirmed. This process is: Retrieve the transaction kernel from the node using the kernel excess value calculated during the transaction creation process. If the kernel exists, update the status of the associated transaction to 'Confirmed' Check-Repair Process The Update by Output process on its own is not enough to ensure the contents of a wallet is correct. There are many easily-encountered situations in the course of a wallet's operation where this process is insufficient and can potentially lead to an wallet state that's inconsistent with the UTXO set, including but not limited to: Manually cancelling transactions and unlocking outputs before they've had a chance to confirm on the chain. Running multiple wallets from the same seed Fork situations The check-repair process fixes most of these potential issues by scanning every single output in the UTXO set and testing for ownership by determining if its bullet proof can be decoded using the wallet's master key. It will then 'check and repair' all outputs and transactions in the wallet as follows: If an output exists in the UTXO set and is not in the wallet, create an output for the wallet at the derivation path stored in the bullet proof, and create a new transaction crediting the amount If an output exists in the UTXO set and is marked as 'spent', mark it as unspent and cancel any associated transaction log entries. Additionally, the check-repair process can take a flag instructing it to delete unconfirmed outputs and reset all outstanding transactions. If this flag is set: If a locked output exists in the UTXO set, unlock it and set any associated transactions to cancelled If an 'unconfirmed' output is not in the UTXO set, delete it and cancel any associated transaction log entries. Note that the wallet restore process works very similarly to the check-repair process, however it must always operate on an empty wallet meaning it is limited to creating outputs and transactions in the wallet. Previous Overall Update Process All of the procedures outlined above can be considered set of 'primitives' available for the wallet to keep itself updated. The previous update process was somewhat limited, and had the tendency to require a significant amount of manual updating using the check-repair command. The previous process was as follows: Invoke the 'Update by Output' process before retrieving any info relating to the wallet state ( txs , info or outputs commands,) or creating a new transaction. This invocation is usually done internally and in a syncronous blocking manner by each command that requires the wallet state to be as up to date as possible. During the txs retrieval command, for each unconfirmed transaction with an amount recieved field set to 0, invoke the 'Kernel Lookup' process. If the user suspects the wallet state to be inconsistent with the node's UTXO state, the user can run the manual check-repair command. This will scan all UTXOs in the set from position 1 in the output PMMR. The user can optionally provide a flag to remove all unconfirmed transactions. If a transaction and associated outputs appear 'stuck' or 'locked' due to the other party not completing a transaction, the user must manually cancel the transactions and unlock the outputs for re-use. (or provide the cancel-unconfirmed flag to the check-repair process) The default selection strategy is to 'sweep' the wallet of outputs on each transaction creation, meaning that by default, no further transaction can usually be made while a transaction is outstanding. Changes to Overall Update Process and Procedures While a combination of the 'primitives' listed above should be enough to keep a wallet's state consistent with a node's UTXO set, the previous method of invoking the vital check-repair command was a manual step that had to be run on the entire UTXO set each time. The overall update process is modified to incorporate the previous check-repair logic as part of normal operation. To ensure a wallet is only scanning the part of the UTXO set required, the wallet stores details on what parts of the UTXO set it has already scanned, and performs incremental scans as part of normal update operation. check-repair is renamed to scan The naming of the previous check-repair command and functionality implied something had gone wrong, whereas it really should be considered a necessary part of normal wallet operation. It is therefore renamed to a more friendly-sounding scan process. Overall Update Process The Overall Update process is outlined as follows: Perform the 'Update by Output' process. Perform the 'Kernel Update' process for transactions where the incoming amount is 0. Query the wallet's internal data for the last block height scanned via the scan process. If the stored block's header hash doesn't match the version currently on the node's UTXO set, scan the range of the UTXO set corresponding to the last stored block - 100 blocks up until the current block. If the stored block's header matches the version on the chain, scan a range of the UTXO set corresponding to the stored block height to the current block height. Save the last block scanned by the scan process. New / Recovered Wallets Newly created and recovered wallets scan the UTXO set as follows: New wallets generated with a new random seed will mark themselves as new , and set their last scanned block to the block height reported on first successful contact with a node. Wallets recovered with an existing mnemonic will set the last scanned block to 1 , triggering the scan process and thereby restoring any associated outputs. The restore command will be removed in favor of the scan process. Manual Scans It is still be possible to manually scan the chain via the scan ( check ) command, however the command is modified to allow the user to specify a range of block heights to scan. If this is not provided, the scan occurs from the current block - 1 week's worth of blocks. Invocation of Update Process The update process was previously run inline in a synchronous blocking fashion as part of individual wallet commands. With the scan command becoming part of normal operations, it's expected that a particular invocation of the overall update process could potentially take a long time. This is acceptable in single-use modes such as the single invocation model of grin-wallet , but is far less usable in environments where the wallet and Owner API stay resident and the caller may not have any particular insight as to why a call invoking the update process might be taking a long time to complete. To address this, the wallet provides a method of calling the Overall Update Process in its own thread that attempts to minimise its usage of the wallet lock. The Wallet's Owner API (V3 Only) is extended with the following functions: start_update_thread(interval) => Starts the update thread, calling the Overall Update Process at the frequency specified stop_update_thread() => Stops the update thread get_update_status() => Returns the current status of the update thread, along with as much information as possible about what the thread is doing and, in the case of the scan process, the percentage complete. Further, if the update thread is currently running, commands that previously always called the Overall Update Process (such as info , txs , etc...) do not call the update process. This means that when invoked via the command line, the behaviour is unchanged. However, wallets running the Owner API can instead choose to run and monitor the background update thread at the desired frequency while keeping the user informed of any long-running update processes. Transaction TTL The Update process outlined above does not cover the case where a slate is exchanged and outputs are locked, but one party doesn't complete the transaction for whatever reason. Previously, a situation such as this meant that the outputs associated with a transaction sat locked indefinitely within a user's wallet, with the only way to unlock them a manual cancel command (or a check-repair with the delete-unconfirmed flag set). Worse, the wallet's default selection strategy was set to all meaning an entire wallet's contents usually became locked on each transaction, and thus a single uncompleted transaction would render a user's entire wallet balance unspendable. To rectify these problems, the following changes are made: A Time-To-Live ( TTL ) field is added to the Slate, which is defined as the last block height at which a wallet should attempt to complete a transaction. This field should be respected at the wallet-exchange level, but is not currently commit to at a consensus level. If a wallet detects a particular transaction's TTL has expired, it will automatically cancel the transaction and unlock associated outputs. Note this doesn't prevent the other party sending the transaction to the node after this happens, but there is no guarantee the outputs will still be available. However, if this does happen the scan command will correct the wallet state. The default output selection method is changed to smallest , to prevent all wallet amounts being locked on every transaction. The smallest strategy prefers using the smallest (or 'dust') outputs as inputs to a transaction, and it is conjectured that the overall effect on Grin's UTXO size will be negligible in the longer term, provided users continue to transact. The all method of output selection also has privacy implications in that it makes it easier for an observer to identify a group of outputs as belonging to a single wallet (or indeed, representing the entire contents of a wallet in most cases). Unresolved questions Do we limit the Kernel Lookup part of the process to just cases where there is no change output. Is there any benefit to calling it for all outstanding transactions on each lookup (or any particular downside to doing so?) What is the effect on UTXO set size of changing the selection method to smallest ? Confirm sensible defaults for how far to scan back on a scan","title":"0008 wallet-state-management"},{"location":"grin-rfcs/text/0008-wallet-state-management/#summary","text":"The changes outlined in the RFC are intended to make process of updating a wallet's state from the chain more consistent for developers and more transparent to the end user. This includes the following changes: The wallet's update process is modified to be more consistent and encapsulated. The check-repair process is run periodically as part of normal wallet update operations The ability for the wallet to run the update process on a separate thread is added. A TTL (Time-to-Live) field is added to the slate The default output selection method is set to smallest","title":"Summary"},{"location":"grin-rfcs/text/0008-wallet-state-management/#motivation","text":"Grin wallet previously updated the state of its outputs and transactions using a combination of UTXO updates, Kernel Lookups and UTXO set scanning. These 'primitives' on their own are generally enough to keep wallet states consistent, however the manner in which they were previously invoked was less than ideal and relied heavily on manually invoking the check-repair process and cancel command. To rectify this situation, this RFC outlines enhancements made to the wallet update process that have the goal of ensuring wallets are always in a consistent state in a manner that is transparent to the user. After adopting these changes, most wallets should automatically keep themselves in sync with the chain in all cases, and users will not usually have to invoke the check-repair or cancel commands.","title":"Motivation"},{"location":"grin-rfcs/text/0008-wallet-state-management/#community-level-explanation","text":"While these changes should be transparent to end users, wallet developers should note the changes to how the wallet updates itself via these processes. Special attention should be paid to the new update thread API functions, as well as the new TTL field and default selection strategy change.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0008-wallet-state-management/#reference-level-explanation","text":"","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0008-wallet-state-management/#wallet-update-procedures","text":"The following sections outlines the processes used in the creation and update of outputs and related transactions within the wallet.","title":"Wallet Update Procedures"},{"location":"grin-rfcs/text/0008-wallet-state-management/#transaction-and-output-creation","text":"","title":"Transaction and Output Creation"},{"location":"grin-rfcs/text/0008-wallet-state-management/#coinbase-output-transaction-creation","text":"Coinbase outputs and their related transactions are created via the wallet listener as part of the mining process. The workflow is: When mining, create a potential coinbase output for the target block. If the block is accepted and the output is detected in the UTXO set (via the Update by Output process , create a transaction log entry of type 'Confirmed Coinbase', with 'confirmed' set to true.","title":"Coinbase Output + Transaction Creation"},{"location":"grin-rfcs/text/0008-wallet-state-management/#transacting-payer-payee-output-transaction-creation","text":"Outputs and tranasctions are created during the transaction exchange process as follows. Note that the invoicing workflow is mostly identical with the roles of Payer and Payee reversed, so this workflow is not outlined separately. The sender creates a new 'blank' transaction Slate, adding inputs and change outputs to the slate. The sender generates a random kernel offset. (The kernel offset is always generated by the slate creator) The sender sends the slate to the payee (via file or http). If sending synchronously, (e.g. via http) the associated transaction is saved to the log after a response from the payee's listener. If sending asynchronously, (e.g. via file), the transaction is saved immediately. When saved, the associated transaction is set to type 'Sent Tx' with a status of 'unconfirmed', inputs are locked internally and a change output is added with status 'unconfirmed'. The payee receives the slate, creates (an) output(s) for the received amount with status unconfirmed, and immediately stores a transaction in their log of type 'Received Tx' with confirmed set to false. The payee calculates and saves the transaction kernel commitment for later reference. The slate is returned to the payer for completion, who calculates and saves the transaction kernel. The transaction is sent to a node for validation.","title":"Transacting (Payer -&gt; Payee) Output + Transaction Creation"},{"location":"grin-rfcs/text/0008-wallet-state-management/#transaction-and-output-statue-update-processes","text":"","title":"Transaction and Output Statue Update Processes"},{"location":"grin-rfcs/text/0008-wallet-state-management/#update-by-output-process","text":"The Update by Output Process is the main method by which the wallet updates its internal state, decides whether a transaction has been confirmed and when to remove or confirm individual outputs. This process works as follows: For every unspent output in the wallet: If the output's status in the user's wallet is 'unconfirmed' and it is present in the UTXO set, change the output's status to 'confirmed', and update the associated transaction status to 'confirmed'. If the output's status in the user's wallet is 'confirmed' and it no longer appears in the UTXO set, set its status to 'Spent'. Note these outputs will usually be locked so they cannot be selected for spending again.","title":"Update by Output Process"},{"location":"grin-rfcs/text/0008-wallet-state-management/#kernel-lookup-process","text":"It is also possible to look up a transaction via the kernel that was stored when the transaction and outputs were created. This is necessary in cases such as where a participant in a transaction doesn't have any change outputs, which means the output update process won't detect when to mark a transaction confirmed. This process is: Retrieve the transaction kernel from the node using the kernel excess value calculated during the transaction creation process. If the kernel exists, update the status of the associated transaction to 'Confirmed'","title":"Kernel Lookup Process"},{"location":"grin-rfcs/text/0008-wallet-state-management/#check-repair-process","text":"The Update by Output process on its own is not enough to ensure the contents of a wallet is correct. There are many easily-encountered situations in the course of a wallet's operation where this process is insufficient and can potentially lead to an wallet state that's inconsistent with the UTXO set, including but not limited to: Manually cancelling transactions and unlocking outputs before they've had a chance to confirm on the chain. Running multiple wallets from the same seed Fork situations The check-repair process fixes most of these potential issues by scanning every single output in the UTXO set and testing for ownership by determining if its bullet proof can be decoded using the wallet's master key. It will then 'check and repair' all outputs and transactions in the wallet as follows: If an output exists in the UTXO set and is not in the wallet, create an output for the wallet at the derivation path stored in the bullet proof, and create a new transaction crediting the amount If an output exists in the UTXO set and is marked as 'spent', mark it as unspent and cancel any associated transaction log entries. Additionally, the check-repair process can take a flag instructing it to delete unconfirmed outputs and reset all outstanding transactions. If this flag is set: If a locked output exists in the UTXO set, unlock it and set any associated transactions to cancelled If an 'unconfirmed' output is not in the UTXO set, delete it and cancel any associated transaction log entries. Note that the wallet restore process works very similarly to the check-repair process, however it must always operate on an empty wallet meaning it is limited to creating outputs and transactions in the wallet.","title":"Check-Repair Process"},{"location":"grin-rfcs/text/0008-wallet-state-management/#previous-overall-update-process","text":"All of the procedures outlined above can be considered set of 'primitives' available for the wallet to keep itself updated. The previous update process was somewhat limited, and had the tendency to require a significant amount of manual updating using the check-repair command. The previous process was as follows: Invoke the 'Update by Output' process before retrieving any info relating to the wallet state ( txs , info or outputs commands,) or creating a new transaction. This invocation is usually done internally and in a syncronous blocking manner by each command that requires the wallet state to be as up to date as possible. During the txs retrieval command, for each unconfirmed transaction with an amount recieved field set to 0, invoke the 'Kernel Lookup' process. If the user suspects the wallet state to be inconsistent with the node's UTXO state, the user can run the manual check-repair command. This will scan all UTXOs in the set from position 1 in the output PMMR. The user can optionally provide a flag to remove all unconfirmed transactions. If a transaction and associated outputs appear 'stuck' or 'locked' due to the other party not completing a transaction, the user must manually cancel the transactions and unlock the outputs for re-use. (or provide the cancel-unconfirmed flag to the check-repair process) The default selection strategy is to 'sweep' the wallet of outputs on each transaction creation, meaning that by default, no further transaction can usually be made while a transaction is outstanding.","title":"Previous Overall Update Process"},{"location":"grin-rfcs/text/0008-wallet-state-management/#changes-to-overall-update-process-and-procedures","text":"While a combination of the 'primitives' listed above should be enough to keep a wallet's state consistent with a node's UTXO set, the previous method of invoking the vital check-repair command was a manual step that had to be run on the entire UTXO set each time. The overall update process is modified to incorporate the previous check-repair logic as part of normal operation. To ensure a wallet is only scanning the part of the UTXO set required, the wallet stores details on what parts of the UTXO set it has already scanned, and performs incremental scans as part of normal update operation.","title":"Changes to Overall Update Process and Procedures"},{"location":"grin-rfcs/text/0008-wallet-state-management/#check-repair-is-renamed-to-scan","text":"The naming of the previous check-repair command and functionality implied something had gone wrong, whereas it really should be considered a necessary part of normal wallet operation. It is therefore renamed to a more friendly-sounding scan process.","title":"check-repair is renamed to scan"},{"location":"grin-rfcs/text/0008-wallet-state-management/#overall-update-process","text":"The Overall Update process is outlined as follows: Perform the 'Update by Output' process. Perform the 'Kernel Update' process for transactions where the incoming amount is 0. Query the wallet's internal data for the last block height scanned via the scan process. If the stored block's header hash doesn't match the version currently on the node's UTXO set, scan the range of the UTXO set corresponding to the last stored block - 100 blocks up until the current block. If the stored block's header matches the version on the chain, scan a range of the UTXO set corresponding to the stored block height to the current block height. Save the last block scanned by the scan process.","title":"Overall Update Process"},{"location":"grin-rfcs/text/0008-wallet-state-management/#new-recovered-wallets","text":"Newly created and recovered wallets scan the UTXO set as follows: New wallets generated with a new random seed will mark themselves as new , and set their last scanned block to the block height reported on first successful contact with a node. Wallets recovered with an existing mnemonic will set the last scanned block to 1 , triggering the scan process and thereby restoring any associated outputs. The restore command will be removed in favor of the scan process.","title":"New / Recovered Wallets"},{"location":"grin-rfcs/text/0008-wallet-state-management/#manual-scans","text":"It is still be possible to manually scan the chain via the scan ( check ) command, however the command is modified to allow the user to specify a range of block heights to scan. If this is not provided, the scan occurs from the current block - 1 week's worth of blocks.","title":"Manual Scans"},{"location":"grin-rfcs/text/0008-wallet-state-management/#invocation-of-update-process","text":"The update process was previously run inline in a synchronous blocking fashion as part of individual wallet commands. With the scan command becoming part of normal operations, it's expected that a particular invocation of the overall update process could potentially take a long time. This is acceptable in single-use modes such as the single invocation model of grin-wallet , but is far less usable in environments where the wallet and Owner API stay resident and the caller may not have any particular insight as to why a call invoking the update process might be taking a long time to complete. To address this, the wallet provides a method of calling the Overall Update Process in its own thread that attempts to minimise its usage of the wallet lock. The Wallet's Owner API (V3 Only) is extended with the following functions: start_update_thread(interval) => Starts the update thread, calling the Overall Update Process at the frequency specified stop_update_thread() => Stops the update thread get_update_status() => Returns the current status of the update thread, along with as much information as possible about what the thread is doing and, in the case of the scan process, the percentage complete. Further, if the update thread is currently running, commands that previously always called the Overall Update Process (such as info , txs , etc...) do not call the update process. This means that when invoked via the command line, the behaviour is unchanged. However, wallets running the Owner API can instead choose to run and monitor the background update thread at the desired frequency while keeping the user informed of any long-running update processes.","title":"Invocation of Update Process"},{"location":"grin-rfcs/text/0008-wallet-state-management/#transaction-ttl","text":"The Update process outlined above does not cover the case where a slate is exchanged and outputs are locked, but one party doesn't complete the transaction for whatever reason. Previously, a situation such as this meant that the outputs associated with a transaction sat locked indefinitely within a user's wallet, with the only way to unlock them a manual cancel command (or a check-repair with the delete-unconfirmed flag set). Worse, the wallet's default selection strategy was set to all meaning an entire wallet's contents usually became locked on each transaction, and thus a single uncompleted transaction would render a user's entire wallet balance unspendable. To rectify these problems, the following changes are made: A Time-To-Live ( TTL ) field is added to the Slate, which is defined as the last block height at which a wallet should attempt to complete a transaction. This field should be respected at the wallet-exchange level, but is not currently commit to at a consensus level. If a wallet detects a particular transaction's TTL has expired, it will automatically cancel the transaction and unlock associated outputs. Note this doesn't prevent the other party sending the transaction to the node after this happens, but there is no guarantee the outputs will still be available. However, if this does happen the scan command will correct the wallet state. The default output selection method is changed to smallest , to prevent all wallet amounts being locked on every transaction. The smallest strategy prefers using the smallest (or 'dust') outputs as inputs to a transaction, and it is conjectured that the overall effect on Grin's UTXO size will be negligible in the longer term, provided users continue to transact. The all method of output selection also has privacy implications in that it makes it easier for an observer to identify a group of outputs as belonging to a single wallet (or indeed, representing the entire contents of a wallet in most cases).","title":"Transaction TTL"},{"location":"grin-rfcs/text/0008-wallet-state-management/#unresolved-questions","text":"Do we limit the Kernel Lookup part of the process to just cases where there is no change output. Is there any benefit to calling it for all outstanding transactions on each lookup (or any particular downside to doing so?) What is the effect on UTXO set size of changing the selection method to smallest ? Confirm sensible defaults for how far to scan back on a scan","title":"Unresolved questions"},{"location":"grin-rfcs/text/0009-enable-faster-sync/","text":"Title: enable-faster-sync Authors: Antioch Peverell , John Tromp Start date: Oct 25, 2019 RFC PR: mimblewimble/grin-rfcs#29 Tracking issue: mimblewimble/grin-wallet#3173 Summary This RFC introduces changes that reduce the time it takes for a node joining the Grin network to fully sync. Data can be downloaded in batches and partially verified without the bottleneck of waiting to receive all data. These batches can be requested from multiple peers in parallel and verified as they are received. This improves the performance and the robustness of the \"fast sync\" process and allows for futher improvements to be explored in the future. A consensus change is required to facilitate this, with a change to what we commit to in each block header. We propose making this consensus change as part of the upcoming scheduled hardfork (HF2 scheduled for Jan 2020). Motivation The initial sync process involves downloading all kernels, all unspent outputs and their corresponding rangeproofs. The unspent outputs are maintained in a \"Prunable Merkle Mountain Range\" (PMMR). Briefly, this consists of unpruned output data, a set of intermediate hashes representing pruned subtrees and a \"leafset\" bitmap representing the position of unpruned, unspent outputs in the PMMR. The previous implementation packaged all of the above data into a single zip file, requested and received from a single peer. This was both a performance bottleneck and a single point of failure. To increase reliability and performance we split this data up into smaller chunks and request from multiple peers. It was previously only possible to validate the full set of unspent outputs. We were unable to validate a partial set of outputs as we compared the total output sum to the total kernel sum plus the total kernel offset. By design, there is no partial kernel sum to compare against a partial output sum. This RFC describes how we split the output PMMR into subtrees, requesting these subtrees along with the corresponding bitmap fragment and the necessary Merkle proofs. Each output subtree can be verified with its corresponding bitmap fragment. By committing to the leafset bitmap in addition to the output PMMR we can verify the output subtrees. The final \"sum to zero\" validation remains unchanged but the partial verification of the individual output subtrees allows for more granular, and earlier verification of the data as it is received. Community-level explanation Validation of full transaction history is not necessary when joining the Grin network and access to full block history is not required. The initial sync process involves downloading all block headers, all kernels, all unspent outputs and their corresponding rangeproofs. Historical spent outputs are not necessary for validation. Nodes prune historical spent outputs, with a few days of recent history retained. Kernels are not pruned and must be retained indefinitely. The unspent outputs are maintained in a \"Prunable Merkle Mountain Range\" (PMMR). Briefly, this consists of unpruned output data, a set of intermediate hashes representing pruned subtrees and a \"leafset\" bitmap representing the position of unpruned, unspent outputs in the PMMR. Subtrees of the output PMMR are requested from peers and these subtrees are verified together with the corresponding fragment of the leafset bitmap. Merkle proofs are provided to prove inclusion of both the output subtree and bitmap fragments beneath the root committed to in the block header. Once all subtrees are received and verified, the unspent outputs are summed together and checked against the sum of all kernels plus the kernel offset from the block header. This allows us to download outputs from multiple peers, in parallel and verify them as they are received. The node does not need to wait for the full output PMMR to be received before validation can begin. Reference-level explanation The leafset bitmap is committed to by splitting the bitmap into smaller fragments, adding these fragments to an MMR and committing to the root of the bitmap MMR. The leafset bitmap represents leaf positions, in insertion order, of the underlying output PMMR. The output PMMR is append-only and the order of these outputs does not change. The first (leftmost) bit in the bitmap maps directly to the first output inserted into the output PMMR. The next bit in the bitmap maps to the second output inserted into the output PMMR etc. The bitmap 11100010 represents outputs [0, 1, 2, 6] in the PMMR. The bitmap is then split into smaller fragments of 1024 bits, representing contiguous sequences of bits of the bitmap. The two fragments 0000...0001, 1000...0000 represent outputs [1023, 1024] in the output PMMR. Every fragment is exactly 1024 bits in length with the final fragment padded with 0 values to fill the full 1024 bits. The bitmap MMR itself is not append-only as fragments of the bitmap will be updated over time as outputs are spent. Recent outputs are more likely to be spent than old output, resulting in updates clustering around the most recent (rightmost) fragments in the MMR. This has the nice property of minimizing the amount of updating and rehashing necessary to keep the bitmap MMR updated over time as older fragments will change only rarely. Merkle proofs can be provided for both a subtree of the output PMMR and a fragment in the bitmap MMR. These are used during validation to locate the output subtree in the overall output PMMR and to verify the bitmap fragment corresponds to the same output positions. To commit to the root of both the output PMMR and the root of the bitmap MMR we hash the roots together and commit to this single composite root H(output_root|bitmap_root) in the the block header. This allows us to reuse the existing output_root field on the header to commit to both MMR roots. Drawbacks These changes necessitate a change to the data committed to in the block header. This is a consensus breaking change and comes with all risks and complexity inherent to any consensus breaking change. As block headers are retained indefinitely the implementation will need to maintain compatibility for headers pre and post hardfork indefinitely. Rationale and alternatives We believe we cannot make the desired changes to fast sync without committing to the leafset bitmap. The previous approach of implicitly validating this as part of the overall \"sum to zero\" kernel validation does not allow for a batched approach. The previous approach was by design \"all or nothing\" with validation only possible once we have downloaded the full set of kernels and unspent outputs. The details are around precisely how to commit to this bitmap and there are various alternatives possible here. The leafset bitmap is implemented as a \"roaring bitmap\" internally but we want to commit to a canonical representation of this data. The obvious choice here is the uncompressed bitmap data itself. We could simply hash the full bitmap but this is not efficient as we would need to rehash all the data for every block header. The other extreme would be to treat each individual bit in the bitmap as a leaf of a Merkle tree. This would also be inefficent as we would require a 32 byte hash for every individual bit. The proposed solution is to break the bitmap up into smaller chunks and add these chunks as leaves of an MMR. Recent outputs are more likely to be spent than older outputs and bitmap chunks to the right of the MMR are more likely to change over time. These rightmost chunks have shorter paths to the associated peak in the MMR with correspondingly shorter Merkle proofs. The cost of updating more recent fragments is also minimized as the number of rehashing operations up to the peak is small. The proposal is to break the bitmap up into 1024 bit (128 byte) chunks and use these as leaves in the bitmap MMR. The other question is what data to add to the header itself. We propose combining the bitmap root and the output MMR root into a single output_root hash on the block header. This changes the semantics of the existing output_root field. This solutiuon has the advantage of maintaining the existing header serialization. No new header field would be necessary. An alternative solution would be to keep the two MMR roots separate and to introduce the new bitmap root as a new header field. The would affect serialization at both the p2p layer and the local database and would add significant complexity to the implementation. The two roots are closely related and we propose committing to them together as a single combined hash. References Merkle Mountain Range (OpenTimestamps) Prunable Merkle Mountain Ranges (Grin)","title":"0009 enable-faster-sync"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#summary","text":"This RFC introduces changes that reduce the time it takes for a node joining the Grin network to fully sync. Data can be downloaded in batches and partially verified without the bottleneck of waiting to receive all data. These batches can be requested from multiple peers in parallel and verified as they are received. This improves the performance and the robustness of the \"fast sync\" process and allows for futher improvements to be explored in the future. A consensus change is required to facilitate this, with a change to what we commit to in each block header. We propose making this consensus change as part of the upcoming scheduled hardfork (HF2 scheduled for Jan 2020).","title":"Summary"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#motivation","text":"The initial sync process involves downloading all kernels, all unspent outputs and their corresponding rangeproofs. The unspent outputs are maintained in a \"Prunable Merkle Mountain Range\" (PMMR). Briefly, this consists of unpruned output data, a set of intermediate hashes representing pruned subtrees and a \"leafset\" bitmap representing the position of unpruned, unspent outputs in the PMMR. The previous implementation packaged all of the above data into a single zip file, requested and received from a single peer. This was both a performance bottleneck and a single point of failure. To increase reliability and performance we split this data up into smaller chunks and request from multiple peers. It was previously only possible to validate the full set of unspent outputs. We were unable to validate a partial set of outputs as we compared the total output sum to the total kernel sum plus the total kernel offset. By design, there is no partial kernel sum to compare against a partial output sum. This RFC describes how we split the output PMMR into subtrees, requesting these subtrees along with the corresponding bitmap fragment and the necessary Merkle proofs. Each output subtree can be verified with its corresponding bitmap fragment. By committing to the leafset bitmap in addition to the output PMMR we can verify the output subtrees. The final \"sum to zero\" validation remains unchanged but the partial verification of the individual output subtrees allows for more granular, and earlier verification of the data as it is received.","title":"Motivation"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#community-level-explanation","text":"Validation of full transaction history is not necessary when joining the Grin network and access to full block history is not required. The initial sync process involves downloading all block headers, all kernels, all unspent outputs and their corresponding rangeproofs. Historical spent outputs are not necessary for validation. Nodes prune historical spent outputs, with a few days of recent history retained. Kernels are not pruned and must be retained indefinitely. The unspent outputs are maintained in a \"Prunable Merkle Mountain Range\" (PMMR). Briefly, this consists of unpruned output data, a set of intermediate hashes representing pruned subtrees and a \"leafset\" bitmap representing the position of unpruned, unspent outputs in the PMMR. Subtrees of the output PMMR are requested from peers and these subtrees are verified together with the corresponding fragment of the leafset bitmap. Merkle proofs are provided to prove inclusion of both the output subtree and bitmap fragments beneath the root committed to in the block header. Once all subtrees are received and verified, the unspent outputs are summed together and checked against the sum of all kernels plus the kernel offset from the block header. This allows us to download outputs from multiple peers, in parallel and verify them as they are received. The node does not need to wait for the full output PMMR to be received before validation can begin.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#reference-level-explanation","text":"The leafset bitmap is committed to by splitting the bitmap into smaller fragments, adding these fragments to an MMR and committing to the root of the bitmap MMR. The leafset bitmap represents leaf positions, in insertion order, of the underlying output PMMR. The output PMMR is append-only and the order of these outputs does not change. The first (leftmost) bit in the bitmap maps directly to the first output inserted into the output PMMR. The next bit in the bitmap maps to the second output inserted into the output PMMR etc. The bitmap 11100010 represents outputs [0, 1, 2, 6] in the PMMR. The bitmap is then split into smaller fragments of 1024 bits, representing contiguous sequences of bits of the bitmap. The two fragments 0000...0001, 1000...0000 represent outputs [1023, 1024] in the output PMMR. Every fragment is exactly 1024 bits in length with the final fragment padded with 0 values to fill the full 1024 bits. The bitmap MMR itself is not append-only as fragments of the bitmap will be updated over time as outputs are spent. Recent outputs are more likely to be spent than old output, resulting in updates clustering around the most recent (rightmost) fragments in the MMR. This has the nice property of minimizing the amount of updating and rehashing necessary to keep the bitmap MMR updated over time as older fragments will change only rarely. Merkle proofs can be provided for both a subtree of the output PMMR and a fragment in the bitmap MMR. These are used during validation to locate the output subtree in the overall output PMMR and to verify the bitmap fragment corresponds to the same output positions. To commit to the root of both the output PMMR and the root of the bitmap MMR we hash the roots together and commit to this single composite root H(output_root|bitmap_root) in the the block header. This allows us to reuse the existing output_root field on the header to commit to both MMR roots.","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#drawbacks","text":"These changes necessitate a change to the data committed to in the block header. This is a consensus breaking change and comes with all risks and complexity inherent to any consensus breaking change. As block headers are retained indefinitely the implementation will need to maintain compatibility for headers pre and post hardfork indefinitely.","title":"Drawbacks"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#rationale-and-alternatives","text":"We believe we cannot make the desired changes to fast sync without committing to the leafset bitmap. The previous approach of implicitly validating this as part of the overall \"sum to zero\" kernel validation does not allow for a batched approach. The previous approach was by design \"all or nothing\" with validation only possible once we have downloaded the full set of kernels and unspent outputs. The details are around precisely how to commit to this bitmap and there are various alternatives possible here. The leafset bitmap is implemented as a \"roaring bitmap\" internally but we want to commit to a canonical representation of this data. The obvious choice here is the uncompressed bitmap data itself. We could simply hash the full bitmap but this is not efficient as we would need to rehash all the data for every block header. The other extreme would be to treat each individual bit in the bitmap as a leaf of a Merkle tree. This would also be inefficent as we would require a 32 byte hash for every individual bit. The proposed solution is to break the bitmap up into smaller chunks and add these chunks as leaves of an MMR. Recent outputs are more likely to be spent than older outputs and bitmap chunks to the right of the MMR are more likely to change over time. These rightmost chunks have shorter paths to the associated peak in the MMR with correspondingly shorter Merkle proofs. The cost of updating more recent fragments is also minimized as the number of rehashing operations up to the peak is small. The proposal is to break the bitmap up into 1024 bit (128 byte) chunks and use these as leaves in the bitmap MMR. The other question is what data to add to the header itself. We propose combining the bitmap root and the output MMR root into a single output_root hash on the block header. This changes the semantics of the existing output_root field. This solutiuon has the advantage of maintaining the existing header serialization. No new header field would be necessary. An alternative solution would be to keep the two MMR roots separate and to introduce the new bitmap root as a new header field. The would affect serialization at both the p2p layer and the local database and would add significant complexity to the implementation. The two roots are closely related and we propose committing to them together as a single combined hash.","title":"Rationale and alternatives"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#references","text":"Merkle Mountain Range (OpenTimestamps) Prunable Merkle Mountain Ranges (Grin)","title":"References"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/","text":"Title: online-transacting-via-tor Authors: David Burkett Start date: September 1, 2019 RFC PR: mimblewimble/grin-rfcs#24 Tracking issue: mimblewimble/grin-wallet#280 Summary Describes a standardized addressing and communication protocol for building Grin transactions. Wallets will attempt to connect to the recipient directly to build transactions over a TOR hidden service similar to how http(s) transaction building works today. This RFC does not cover the offline transacting problem. Motivation Grin is unique in that it requires the sender and receiver to interact in order to transact. This presents a lot of unique challenges that most coins don\u2019t have to deal with. There are a number of different incompatible standards for sending and receiving, resulting in confusion and headaches for many users. The hope is that the addressing mechanism described here will become the new default method for sending and receiving, deprecating several less secure and less private methods in the process. Description Community-level explanation From an end-user perspective, there should no longer be a need to configure routers and firewalls to receive grins. Sending and receiving should feel like any other cryptocurrency, where a simple encoded address is all you need to share before receiving. No firewall or router configuration should be necessary. Reference-level explanation Addressing Onion addresses for TOR hidden services are generated from an ed25519 public key (32 bytes), and include a checksum and a version[1]. This provides an equivalent level of security as bitcoin addresses, and can be ephemeral or permanent, depending on the user\u2019s needs. Grin addresses should be generated and base32 encoded in the same way as TOR v3 addresses. Although ed25519 is a different curve than used by the grin protocol, we can still use our HD wallets to generate deterministic ed25519 public keys (and therefore Grin addresses). For account m/0 , addresses will be generated using keychain paths m/0/1/x , for account m/1 , addresses will be generated using m/1/1/x , etc. To generate addresses for a keychain path, we derive the private key in the usual way, but then blake2b hash the derived key to get the ed25519 secret key, which can then be used to calculate the public key and address. TOR Hidden Services TOR hidden services can be used to directly serve the existing foreign APIs. When configuring TOR (whether bundled with grin, or installed separately), you would just publish a hidden service and configure TOR to forward all traffic to port 3420. This means we can continue supporting http(s) sending/receiving with no disruption, though it\u2019s advisable to avoid sending directly over http(s) asap.In future versions of Grin, we can stop allowing non-local connections to the foreign wallet APIs. Drawbacks Requires users to setup TOR, or bundle it with Grin, which could be non-trivial, and could conflict with locally installed/running versions. Unresolved questions How often should addresses change? Should users manually request a new address, or should they auto expire? Should we support multiple? Future possibilities The changes in this RFC lead the way for: * Payment proofs * Offline transacting via SBBS/Grinbox-style relay system. See 0000-asynchronous-transacting-via-relays RFC References [1] https://github.com/torproject/torspec/blob/87698dc1c0fa4cf2186f180a636fc7ad1c5fb5fd/rend-spec-v3.txt#L2059-L2081 [2] https://github.com/mimblewimble/grin/blob/d918c5fe84e859290c9d09f5cfc167ed41d27bff/keychain/src/extkey_bip32.rs#L122","title":"0010 online-transacting-via-tor"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#summary","text":"Describes a standardized addressing and communication protocol for building Grin transactions. Wallets will attempt to connect to the recipient directly to build transactions over a TOR hidden service similar to how http(s) transaction building works today. This RFC does not cover the offline transacting problem.","title":"Summary"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#motivation","text":"Grin is unique in that it requires the sender and receiver to interact in order to transact. This presents a lot of unique challenges that most coins don\u2019t have to deal with. There are a number of different incompatible standards for sending and receiving, resulting in confusion and headaches for many users. The hope is that the addressing mechanism described here will become the new default method for sending and receiving, deprecating several less secure and less private methods in the process.","title":"Motivation"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#description","text":"","title":"Description"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#community-level-explanation","text":"From an end-user perspective, there should no longer be a need to configure routers and firewalls to receive grins. Sending and receiving should feel like any other cryptocurrency, where a simple encoded address is all you need to share before receiving. No firewall or router configuration should be necessary.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#reference-level-explanation","text":"","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#addressing","text":"Onion addresses for TOR hidden services are generated from an ed25519 public key (32 bytes), and include a checksum and a version[1]. This provides an equivalent level of security as bitcoin addresses, and can be ephemeral or permanent, depending on the user\u2019s needs. Grin addresses should be generated and base32 encoded in the same way as TOR v3 addresses. Although ed25519 is a different curve than used by the grin protocol, we can still use our HD wallets to generate deterministic ed25519 public keys (and therefore Grin addresses). For account m/0 , addresses will be generated using keychain paths m/0/1/x , for account m/1 , addresses will be generated using m/1/1/x , etc. To generate addresses for a keychain path, we derive the private key in the usual way, but then blake2b hash the derived key to get the ed25519 secret key, which can then be used to calculate the public key and address.","title":"Addressing"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#tor-hidden-services","text":"TOR hidden services can be used to directly serve the existing foreign APIs. When configuring TOR (whether bundled with grin, or installed separately), you would just publish a hidden service and configure TOR to forward all traffic to port 3420. This means we can continue supporting http(s) sending/receiving with no disruption, though it\u2019s advisable to avoid sending directly over http(s) asap.In future versions of Grin, we can stop allowing non-local connections to the foreign wallet APIs.","title":"TOR Hidden Services"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#drawbacks","text":"Requires users to setup TOR, or bundle it with Grin, which could be non-trivial, and could conflict with locally installed/running versions.","title":"Drawbacks"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#unresolved-questions","text":"How often should addresses change? Should users manually request a new address, or should they auto expire? Should we support multiple?","title":"Unresolved questions"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#future-possibilities","text":"The changes in this RFC lead the way for: * Payment proofs * Offline transacting via SBBS/Grinbox-style relay system. See 0000-asynchronous-transacting-via-relays RFC","title":"Future possibilities"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#references","text":"[1] https://github.com/torproject/torspec/blob/87698dc1c0fa4cf2186f180a636fc7ad1c5fb5fd/rend-spec-v3.txt#L2059-L2081 [2] https://github.com/mimblewimble/grin/blob/d918c5fe84e859290c9d09f5cfc167ed41d27bff/keychain/src/extkey_bip32.rs#L122","title":"References"},{"location":"grin-rfcs/text/0011-security-team/","text":"Title: security-team Authors: joltz Start date: Jan 22 2020 RFC PR: mimblewimble/grin-rfcs#39 Tracking issue: mimblewimble/grin-pm/#258 Summary The security team for Grin carries out the security priorities of the Grin community and core team, which are to be defined prior to formation of the team. The security team streamlines the security decision making process for the core team while maintaining a careful balance of security and transparency for the community. Motivation Improve transparency, efficiency, decisiveness and scalability around security-related decision making Dedicated support for security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work Increase confidence in the ecosystem for future contributions A clear and structured decision making process is needed to fully support the current security process as well as community initiatives such as bilateral disclosure agreements, bug bounty programs and future audit work. This process was previously maintained by the core team who had many areas of focus, leading to a lack of clarity, timeliness and ability to decisively execute on community security initiatives. The security team frees up core resources to focus on other important areas while expanding dedicated resources to security work, allowing the Grin ecosystem to continue to scale. A clear decision making structure around the security process instills confidence in the greater ecosystem and encourages projects, developers and users to continue to increase contributions of time and resources into Grin. Community-level explanation Grin's security team is responsible for making predefined security related decisions for the Grin project. This includes, but is not limited to, decisions about the specification and implementation of Grin's security processes. As much as possible Grin's security team carries out the security priorities of the community and core team in a transparent manner. There may be some unique security-related cases that require the security team to make some decisions in private to protect the security of Grin users. In these cases, once it is safe to do so, the security team is responsible for sharing as many details as possible with the community for transparency and accountability purposes. The primary day-to-day impact this will have on the community is making available structured support around security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work. The community and other teams will have regular opportunity to interact with, provide input to and receive input from the security team. Example Here we will walk through an example case that highlights how Grin's security team would operate, contrasting with the current process. In the example case, a vulnerability is disclosed to the disclosure contacts listed in Grin's security policy. It is shown that the community gains greater transparency into the decision making process and related outcomes with the proposed security team. Additionally the disclosure map is more tightly contained in the proposed process, resulting in less risk of vulnerability exploitation to the community. Previous Process Grin's security contacts make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, all details of the disclosure are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy Once the vulnerability is mitigated the core team may optionally share some of the details with the community Security Team Process Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, a conversation and plan of action is determined and executed by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated the security team must disclose all information that is not still security-critical with the community Reference-level explanation Grin's security team will be implemented as stated below. Membership Bootstrapped by existing security contacts (@lehnberg, @hashmap, @joltz) Minimum three, maximum five members Membership is recommended by the security team and approved by the core team All members must have relevant domain expertise in security, cryptography, the Grin codebase or Grin community All members must have high competency in maintaining personal operational security (keeping private keys secure, maintaining secure communications channels etc.) Membership is revoked by failure to update the canary, unanimous decision by team or decision from the core team Note if the core team engages in removing members from the security team without reasonable justification, the security team loses purpose, becomes ineffective and is relegated to useless security theater Decision Making Distinction between security-team decisions and security-related decisions : The security team is responsible for making predefined security-team decisions, not all possible ambiguous security-related decisions Decisions are made primarily with consideration to the security priorities outlined prior to the team's formation Unanimous approval of security team members is needed to make all impactful decisions Some decisions made must also be approved by the core team to be carried out: Adding/removing parties from disclosure agreements Adding members to the security team Updating the security policy In the event that the core team does not follow a security team recommendation, a reasonable explanation must be provided as to why the security recommendation was not followed Some decisions must be made without fully informing the core team of all details: When fixing a vulnerability requires a deviation from the standard In these cases not all information will be shared with core team, such as specific details to carry out an exploit, full impact and other relevant information that will create unnecessary risk if disclosed The core team must be notified of all cases of these decisions within a reasonable time frame that does not pose a security risk (e.g. after a fix is implemented) and provided with a reasonable explanation by the security team Vetoes Any member of the security team may veto an impactful security team decision The ability to veto an impactful security team decision is important to preserve the ability for members of the security team to make honest recommendations. Important and controversial decisions will be made and members of the security team need the ability to not sign their names to a decision they are not comfortable with that could have serious ramifications. These cases will be handled according to the Deadlocks section below. The security team should always strive to reach its own decisions. Constant vetoes and inability to reach unanimous decisions will dampen the advantages of the existence of the team and may render it obsolete. It is important to strike the right balance of different perspectives, expertise and reasonability in members to take advantage of the benefits that come with a diverse and functional security-related decision making process. Deadlocks Impactful security team decisions that can't be made unanimously by the security team will be made by the core team according to their decision making process If the core team is deadlocked, the decision made will be whichever decision, if any, will provide the end user with the greatest measure of security Deadlocks should be avoided at all costs. The inability of the security team to reach a unanimous decision based on the security priorities of Grin's community and core team should be a red flag to the community and core team for the health of the team. All members should be able to clearly discuss the factual merits of the options and reach a decision that is in the clear best possible interest for the security of Grin's ecosystem and users. Example By following the previous example in more detail, critical differences can be further explored between the current process and the proposed security team process in the handling of a unique case. In cases where fixing a vulnerability is so critical that it requires a deviation from the standard , the proposed process reduces the likelihood of the vulnerability being exploited with a focused decision making process and by restricting the details to essential persons only. Previous Process Grin's security contacts make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug All details of the disclosure, including the steps to carry out the exploit, are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy This conversation may take days or weeks as there is no particular decision making process for security-related issues Once the vulnerability is mitigated the core team may optionally share some of the details with the community Security Team Process Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug A conversation and plan of action is quickly and unanimously determined and executed on by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated, the security team must disclose all information that is not still security-critical with the community Drawbacks The core team is already busy and the formation and management of a security team may distract from other pressing and immediate issues Even though it decentralizes the core team, it potentially creates another point of centralization Adds resource overhead to the project that must be upheld (it is not acceptable to fail to follow through in security processes once established!) Possibly distracts from other important work- we don't want to spread attention too wide too early Adds bulk to Grin's governance structure The community may trust core more than a team to make critical security decisions Rationale and alternatives One alternative, currently in use, is adding the input of a security expert to the existing core decision making process This is better than nothing but we lose a few benefits without a dedicated security team: Strengthened security process: reduced likelihood of exploit leaks Improved transparency: there is currently little transparency around core's security decision making process Improved reaction times: informed, thoughtful, decisive actions with input from relevant experts only Possibility for security initiatives: clear decision making process for bilateral disclosure agreements, bug bounty programs, audit work Stronger commitments to the community, ecosystem and other projects: viable with a dedicated, clear decision making process Long-term scalability: extend capacity for security work to grow beyond the core team's attention capacity Another alternative is to rely on an open community to handle all incidents as they come in This is less desirable than both the previous process and security team process: Vulnerabilities would essentially be public before they can by mitigated There is no decision making team so mitigation actions may be slow and contentious There is no accountability to ensure that the responsible disclosure process is followed This model is much more transparent than other alternatives but comes with the unacceptable associated costs above Prior art grin-governance[0] and security-process[1] RFCs lay groundwork for the security-team RFC. Unresolved questions What are the security priorities of the Grin community and core team? (e.g. is privacy a higher priority than undetectable inflation?) Is this the most minimal model that can have long-term success for Grin's security-related decision making process? Is the single-veto model sufficient for a consistent, timely decision making process? Future possibilities Budget allocation and management Manage an allocated budget for possible initiatives Bug bounty programs Audits Full time contributors Development of security tooling Security team working groups Red team Blue team Audit team Bug bounty team Community outreach team Expanding security-team decisions Currently security-team decisions are restricted to predefined decisions around the security processes In the future security-team decisions can be expanded to include more security-related decisions References [0] https://github.com/mimblewimble/grin-rfcs/blob/master/text/0002-grin-governance.md#teams [1] https://github.com/mimblewimble/grin-rfcs/blob/master/text/0003-security-process.md","title":"0011 security-team"},{"location":"grin-rfcs/text/0011-security-team/#summary","text":"The security team for Grin carries out the security priorities of the Grin community and core team, which are to be defined prior to formation of the team. The security team streamlines the security decision making process for the core team while maintaining a careful balance of security and transparency for the community.","title":"Summary"},{"location":"grin-rfcs/text/0011-security-team/#motivation","text":"Improve transparency, efficiency, decisiveness and scalability around security-related decision making Dedicated support for security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work Increase confidence in the ecosystem for future contributions A clear and structured decision making process is needed to fully support the current security process as well as community initiatives such as bilateral disclosure agreements, bug bounty programs and future audit work. This process was previously maintained by the core team who had many areas of focus, leading to a lack of clarity, timeliness and ability to decisively execute on community security initiatives. The security team frees up core resources to focus on other important areas while expanding dedicated resources to security work, allowing the Grin ecosystem to continue to scale. A clear decision making structure around the security process instills confidence in the greater ecosystem and encourages projects, developers and users to continue to increase contributions of time and resources into Grin.","title":"Motivation"},{"location":"grin-rfcs/text/0011-security-team/#community-level-explanation","text":"Grin's security team is responsible for making predefined security related decisions for the Grin project. This includes, but is not limited to, decisions about the specification and implementation of Grin's security processes. As much as possible Grin's security team carries out the security priorities of the community and core team in a transparent manner. There may be some unique security-related cases that require the security team to make some decisions in private to protect the security of Grin users. In these cases, once it is safe to do so, the security team is responsible for sharing as many details as possible with the community for transparency and accountability purposes. The primary day-to-day impact this will have on the community is making available structured support around security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work. The community and other teams will have regular opportunity to interact with, provide input to and receive input from the security team.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0011-security-team/#example","text":"Here we will walk through an example case that highlights how Grin's security team would operate, contrasting with the current process. In the example case, a vulnerability is disclosed to the disclosure contacts listed in Grin's security policy. It is shown that the community gains greater transparency into the decision making process and related outcomes with the proposed security team. Additionally the disclosure map is more tightly contained in the proposed process, resulting in less risk of vulnerability exploitation to the community.","title":"Example"},{"location":"grin-rfcs/text/0011-security-team/#previous-process","text":"Grin's security contacts make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, all details of the disclosure are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy Once the vulnerability is mitigated the core team may optionally share some of the details with the community","title":"Previous Process"},{"location":"grin-rfcs/text/0011-security-team/#security-team-process","text":"Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, a conversation and plan of action is determined and executed by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated the security team must disclose all information that is not still security-critical with the community","title":"Security Team Process"},{"location":"grin-rfcs/text/0011-security-team/#reference-level-explanation","text":"Grin's security team will be implemented as stated below.","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0011-security-team/#membership","text":"Bootstrapped by existing security contacts (@lehnberg, @hashmap, @joltz) Minimum three, maximum five members Membership is recommended by the security team and approved by the core team All members must have relevant domain expertise in security, cryptography, the Grin codebase or Grin community All members must have high competency in maintaining personal operational security (keeping private keys secure, maintaining secure communications channels etc.) Membership is revoked by failure to update the canary, unanimous decision by team or decision from the core team Note if the core team engages in removing members from the security team without reasonable justification, the security team loses purpose, becomes ineffective and is relegated to useless security theater","title":"Membership"},{"location":"grin-rfcs/text/0011-security-team/#decision-making","text":"Distinction between security-team decisions and security-related decisions : The security team is responsible for making predefined security-team decisions, not all possible ambiguous security-related decisions Decisions are made primarily with consideration to the security priorities outlined prior to the team's formation Unanimous approval of security team members is needed to make all impactful decisions Some decisions made must also be approved by the core team to be carried out: Adding/removing parties from disclosure agreements Adding members to the security team Updating the security policy In the event that the core team does not follow a security team recommendation, a reasonable explanation must be provided as to why the security recommendation was not followed Some decisions must be made without fully informing the core team of all details: When fixing a vulnerability requires a deviation from the standard In these cases not all information will be shared with core team, such as specific details to carry out an exploit, full impact and other relevant information that will create unnecessary risk if disclosed The core team must be notified of all cases of these decisions within a reasonable time frame that does not pose a security risk (e.g. after a fix is implemented) and provided with a reasonable explanation by the security team","title":"Decision Making"},{"location":"grin-rfcs/text/0011-security-team/#vetoes","text":"Any member of the security team may veto an impactful security team decision The ability to veto an impactful security team decision is important to preserve the ability for members of the security team to make honest recommendations. Important and controversial decisions will be made and members of the security team need the ability to not sign their names to a decision they are not comfortable with that could have serious ramifications. These cases will be handled according to the Deadlocks section below. The security team should always strive to reach its own decisions. Constant vetoes and inability to reach unanimous decisions will dampen the advantages of the existence of the team and may render it obsolete. It is important to strike the right balance of different perspectives, expertise and reasonability in members to take advantage of the benefits that come with a diverse and functional security-related decision making process.","title":"Vetoes"},{"location":"grin-rfcs/text/0011-security-team/#deadlocks","text":"Impactful security team decisions that can't be made unanimously by the security team will be made by the core team according to their decision making process If the core team is deadlocked, the decision made will be whichever decision, if any, will provide the end user with the greatest measure of security Deadlocks should be avoided at all costs. The inability of the security team to reach a unanimous decision based on the security priorities of Grin's community and core team should be a red flag to the community and core team for the health of the team. All members should be able to clearly discuss the factual merits of the options and reach a decision that is in the clear best possible interest for the security of Grin's ecosystem and users.","title":"Deadlocks"},{"location":"grin-rfcs/text/0011-security-team/#example_1","text":"By following the previous example in more detail, critical differences can be further explored between the current process and the proposed security team process in the handling of a unique case. In cases where fixing a vulnerability is so critical that it requires a deviation from the standard , the proposed process reduces the likelihood of the vulnerability being exploited with a focused decision making process and by restricting the details to essential persons only.","title":"Example"},{"location":"grin-rfcs/text/0011-security-team/#previous-process_1","text":"Grin's security contacts make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug All details of the disclosure, including the steps to carry out the exploit, are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy This conversation may take days or weeks as there is no particular decision making process for security-related issues Once the vulnerability is mitigated the core team may optionally share some of the details with the community","title":"Previous Process"},{"location":"grin-rfcs/text/0011-security-team/#security-team-process_1","text":"Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug A conversation and plan of action is quickly and unanimously determined and executed on by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated, the security team must disclose all information that is not still security-critical with the community","title":"Security Team Process"},{"location":"grin-rfcs/text/0011-security-team/#drawbacks","text":"The core team is already busy and the formation and management of a security team may distract from other pressing and immediate issues Even though it decentralizes the core team, it potentially creates another point of centralization Adds resource overhead to the project that must be upheld (it is not acceptable to fail to follow through in security processes once established!) Possibly distracts from other important work- we don't want to spread attention too wide too early Adds bulk to Grin's governance structure The community may trust core more than a team to make critical security decisions","title":"Drawbacks"},{"location":"grin-rfcs/text/0011-security-team/#rationale-and-alternatives","text":"One alternative, currently in use, is adding the input of a security expert to the existing core decision making process This is better than nothing but we lose a few benefits without a dedicated security team: Strengthened security process: reduced likelihood of exploit leaks Improved transparency: there is currently little transparency around core's security decision making process Improved reaction times: informed, thoughtful, decisive actions with input from relevant experts only Possibility for security initiatives: clear decision making process for bilateral disclosure agreements, bug bounty programs, audit work Stronger commitments to the community, ecosystem and other projects: viable with a dedicated, clear decision making process Long-term scalability: extend capacity for security work to grow beyond the core team's attention capacity Another alternative is to rely on an open community to handle all incidents as they come in This is less desirable than both the previous process and security team process: Vulnerabilities would essentially be public before they can by mitigated There is no decision making team so mitigation actions may be slow and contentious There is no accountability to ensure that the responsible disclosure process is followed This model is much more transparent than other alternatives but comes with the unacceptable associated costs above","title":"Rationale and alternatives"},{"location":"grin-rfcs/text/0011-security-team/#prior-art","text":"grin-governance[0] and security-process[1] RFCs lay groundwork for the security-team RFC.","title":"Prior art"},{"location":"grin-rfcs/text/0011-security-team/#unresolved-questions","text":"What are the security priorities of the Grin community and core team? (e.g. is privacy a higher priority than undetectable inflation?) Is this the most minimal model that can have long-term success for Grin's security-related decision making process? Is the single-veto model sufficient for a consistent, timely decision making process?","title":"Unresolved questions"},{"location":"grin-rfcs/text/0011-security-team/#future-possibilities","text":"Budget allocation and management Manage an allocated budget for possible initiatives Bug bounty programs Audits Full time contributors Development of security tooling Security team working groups Red team Blue team Audit team Bug bounty team Community outreach team Expanding security-team decisions Currently security-team decisions are restricted to predefined decisions around the security processes In the future security-team decisions can be expanded to include more security-related decisions","title":"Future possibilities"},{"location":"grin-rfcs/text/0011-security-team/#references","text":"[0] https://github.com/mimblewimble/grin-rfcs/blob/master/text/0002-grin-governance.md#teams [1] https://github.com/mimblewimble/grin-rfcs/blob/master/text/0003-security-process.md","title":"References"},{"location":"grin-rfcs/text/0012-compact-slates/","text":"Title: Slate V4 (Compact Slates) Authors: Michael Cordner Start date: April 3, 2020 RFC PR: mimblewimble/grin-rfcs#49 Tracking issue: mimblewimble/grin-wallet#317 Summary This RFC describes the changes between version 3 and version 4 of the Slate transaction exchange format, which had the goal of reducing the contents of the Slate to be as minimal as possible. Motivation Previously, the definition of Slate versions up to V3 had been put together with no regard for its size or/and redundant/irrelevant content. In order to facilitate future exchange method possibilities, it's desirable to ensure the Slate is as compact as possible, particularly on the 'first leg' of a transaction exchange which only actually requires minimal information from the transaction initiator. This RFC aims to define the contents of a streamlined \"compact\" slate by: Removing all redundant or unnecessary Slate fields Shortening the names of many Slate fields Reducing the size of the Slate to at all phases of a transaction Defining an optional highly-minimized binary format for Slate output Although this RFC doesn't address any particular transaction exchange methods that might be facilitated by this streamlining, one could envisage possibilities such as: An exchange placing the entire initial slate in a QR code Encoding the initial slate as an easily-cut-and-paste chunk Community-level explanation There are two basic transaction workflows in a two-party Grin transaction: In the Basic workflow, a sender adds their inputs and change outputs to a transaction, and sends them, along with the fee, the amount and their signature data to the recipient. The recipient adds a output for the amount to the transaction, adds their signature data and returns to the sender, who completes the transaction and posts. In the Invoice workflow, the invoice creator adds a new output to a transaction, and sends the amount and signature data to the payer. The payer adds their inputs and change outputs to the transaction along with their signature data and fee information, then returns to the invoicer, who completes the transaction and posts. Although previous versions of the Slate included every party's complete inputs and outputs at every stage of the transaction, it is not technically necessary for the initiator to provide their inputs and outputs to the other party. It suffices for the initiator to store the input/output listing in their local transaction context, and only provide the amount, fee, excess and signature data to the other party. Recognising this, it is possible to ensure that the 'first-leg' of a transaction stage is extremely compact. For instance, version 3 of the Slate on transaction initiation may have looked something like the following: { \"version_info\": { \"version\": 3, \"orig_version\": 3, \"block_header_version\": 2 }, \"num_participants\": 2, \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"tx\": { \"offset\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"body\": { \"inputs\": [ { \"features\": \"Coinbase\", \"commit\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"features\": \"Coinbase\", \"commit\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ], \"outputs\": [ { \"features\": \"Plain\", \"commit\": \"0812276cc788e6870612296d926cba9f0e7b9810670710b5a6e6f1ba006d395774\", \"proof\": \"dcff6175390c602bfa92c2ffd1a9b2d84dcc9ea941f6f317bdd0f875244ef23e696fd17c71df79760ce5ce1a96aab1d15dd057358dc835e972febeb86d50ccec0dad7cfe0246d742eb753cf7b88c045d15bc7123f8cf7155647ccf663fca92a83c9a65d0ed756ea7ebffd2cac90c380a102ed9caaa355d175ed0bf58d3ac2f5e909d6c447dfc6b605e04925c2b17c33ebd1908c965a5541ea5d2ed45a0958e6402f89d7a56df1992e036d836e74017e73ccad5cb3a82b8e139e309792a31b15f3ffd72ed033253428c156c2b9799458a25c1da65b719780a22de7fe7f437ae2fccd22cf7ea357ab5aa66a5ef7d71fb0dc64aa0b5761f68278062bb39bb296c787e4cabc5e2a2933a416ce1c9a9696160386449c437e9120f7bb26e5b0e74d1f2e7d5bcd7aafb2a92b87d1548f1f911fb06af7bd6cc13cee29f7c9cb79021aed18186272af0e9d189ec107c81a8a3aeb4782b0d950e4881aa51b776bb6844b25bce97035b48a9bdb2aea3608687bcdd479d4fa998b5a839ff88558e4a29dff0ed13b55900abb5d439b70793d902ae9ad34587b18c919f6b875c91d14deeb1c373f5e76570d59a6549758f655f1128a54f162dfe8868e1587028e26ad91e528c5ae7ee9335fa58fb59022b5de29d80f0764a9917390d46db899acc6a5b416e25ecc9dccb7153646addcc81cadb5f0078febc7e05d7735aba494f39ef05697bbcc9b47b2ccc79595d75fc13c80678b5e237edce58d731f34c05b1ddcaa649acf2d865bbbc3ceda10508bcdd29d0496744644bf1c3516f6687dfeef5649c7dff90627d642739a59d91a8d1d0c4dc55d74a949e1074427664b467992c9e0f7d3af9d6ea79513e8946ddc0d356bac49878e64e6a95b0a30214214faf2ce317fa622ff3266b32a816e10a18e6d789a5da1f23e67b4f970a68a7bcd9e18825ee274b0483896a40\" } ], \"kernels\": [ { \"features\": \"Plain\", \"fee\": \"7000000\", \"lock_height\": \"0\", \"excess\": \"000000000000000000000000000000000000000000000000000000000000000000\", \"excess_sig\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } ] } }, \"amount\": \"60000000000\", \"fee\": \"7000000\", \"height\": \"5\", \"lock_height\": \"0\", \"ttl_cutoff_height\": null, \"payment_proof\": null, \"participant_data\": [ { \"id\": \"0\", \"public_blind_excess\": \"033ac2158fa0077f087de60c19d8e431753baa5b63b6e1477f05a2a6e7190d4592\", \"public_nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part_sig\": null, \"message\": null, \"message_sig\": null } ] } In version 4 of the Slate format, the initial Slate now looks like the following: { \"ver\": \"4:2\" \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"amt\": \"6000000000\", \"fee\": \"8000000\", \"sigs\": [ { \"xs\": \"023878ce845727f3a4ec76ca3f3db4b38a2d05d636b8c3632108b857fed63c96de\" \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ], } While a \"return\" slate might look something like the following: { \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S2\", \"off\": \"a4052c9200000001a6052c9200000002ed564fab50b75fc5ea32ce052fc9bebf\", \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part\": \"8f07ddd5e9f5179cff19486034181ed76505baaad53e5d994064127b56c5841b54735cb9ed2f59fb457144f7b1c8226d08b54cbdd0eb7e6492950751b0bb54f9\" } ], \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" } ] } The 'return' slate from the recipient to the originator is expected to be larger, as it must include the recipient's outputs/inputs and proofs (as the party who posts the transaction needs all of this information). However, compacting the slate at each stage of its journey allows for future possibilities that may have been more difficult in previous iterations of the slate format. For instance, an initiator taking Grin payments might be expected to be better equipped to receive Grin transactions. They could present the payer with an invoice transaction for the amount compacted to the size of a QR code, which the payer could scan, accept, and then post back to the invoicer's listening wallet infrastructure. Compacting the slate also acts as a minor privacy-enhancer by hiding the initiator's outputs from the other party. Reference-level explanation Slate Definition - JSON Entries prefixed with // denote fields that may be omitted, as well as their default assumed values. # denotes a comment for the purposes of illustration. Field ordering is canonical. { # These fields are always present \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", # These fields may or may not be present //\"num_parts: 2, //\"fee\": \"8000000\", //\"amt\": \"1000000000\", //\"feat\": 0, //\"ttl\": null, # Sigs is always present with at least one entry \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", // \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ] # These structs may or may not be present //\"coms\": null, //\"proof\": null, //\"feat_args\": null } A description of all fields and their meanings is as follows: Top-Level Slate Struct Fields - Always present ver - The slate version and supported block header version, separated by a : id - The slate's UUID, standard hex-string encoding for UUIDs sta - 2 character String representing the current stage of the the transaction. See Status Codes off - The running transaction offset total, hex-string encoded. All parties select a random offset at the beginning of the transaction and subtract their offset from the excess value of their outputs. They then subtract the value of the inputs from the offset when committing to inputs, updating the total offset before sending to the next stage. Fields - Optional, depending on State and transaction options num_parts - The number of participants in the transaction, assumed to be 2 if omitted amt - The transaction amount as a string parseable as a u64. May be omitted on a return journey. fee - The transaction fee as a string parseable as a u64. May be omitted on a return journey, except during an invoice transaction. feat - Kernel Features ID. If omitted, kernel is assumed to be Plain (0). If set to 1 or otherwise, any arguments required for a particular kernel feature set will be found in the feat_args struct. ttl - Time to Live, or block height beyond which wallets should refuse to further process the transaction. Assumed 0 (no ttl) if omitted from the slate. Structs - Always present sigs - An array of signature data containing the signature information of the last participant. See Signature Data Structs - Optional, depending on state of transaction proof - An optional payment proof request. See Payment Proof Data coms - The Transaction ; is removed from the slate in favour of including this top-level Slate field that can be used to reconstruction the transaction object as expected by the Grin node. See Transaction Object Fields feat_args - Optional arguments for Kernel features. Status Codes Valid values of the sta field and their meanings are: S1 - Standard (payer to payee) transaction flow, new transaction that incorporates the sender's inputs and change output(s), if any. Sender's signature nonce, excess (with kernel offset) is included and ready for sending to recipient. S2 - Standard transaction flow, recipient has created their outputs(s) and supplied their excess, nonce and partial signature, ready to return to recipient for completion. S3 - Standard transaction flow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting I1 - Invoice (payee to payer) transaction flow, new transaction that incorporates the Invoicer's output(s). Invoicer's signature nonce and excess (with kernel offset) is included and ready for sending to Invoicee. I2 - Invoice workflow, Invoicee has added their inputs and change output(s). Invoicee's signature, nonce and excess is included and ready for sending back to the invoicer. I3 - Invoice workflow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting Signature Data An entry in the sigs array is as follows: { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } The sigs struct contains is comprised of an array of participant signature data, with each entry comprising: * xs - Hex string encoded short form public key on the secp256k1 curve representing the public blind excess for the participants outputs subtracted from each party's part of the offset. * part - Hex string encoded Aggregated (Schnorr) secp2561k signature represeting the participant's partial sig. May be omitted if the participant does not yet have enough data to create it * nonce - Hex string encoded The public key of the nonce chosen by the participant for their partial signature The other party's sig entry is removed from the slate before sending it back to the transaction initiator during the S2 and I2 phases. Payment Proof Data If included, the proof structure is: \"proof\": { \"saddr\": \"7e008eb593ba17d116e282d6267a3c6aad87b910933ad34dfa4d7d2c92b6ba31\", // \"rsig\": null, \"raddr\": \"3a425bd5da5f0f78593251ede7fad0ecf7a95679d84b2cb405255d97ce068234\" } The proof struct is an optional payment proof request that must be filled out by the recipient if requested (only valid for basic transaction flow). Its fields are as follows: saddr - Hex string encoded short-form public key on the ed25519 curve, representing the sender's wallet address (see the payment proofs rfc for details. raddr - Hex string encoded short-form public key on the ed25519 curve represnting the recipient's wallet address rsig - Hex string encoded EdDSA ed25519 signature representing the recipient's payment-proof signature. Can be omitted if this has not yet been filled out Transaction Object Fields The V4 Version of the Slate contains its own separate representation of Grin's internal Transaction object. (Grin's internal transaction struct definition can be found here: Transaction ). Internally, the wallet will transform its representation into the format expected by the node while posting the transaction. The tx struct in a V4 Slate is removed, and is replaced instead by the following Top-Level fields. Wallets recreate the transaction object as expected by the Grin node from these fields before posting. coms is an array containing the outputs and inputs that have been added to the slate. These will appear during the I1 or S2 phases of a transaction. Each entry includes: f : The output features, assumed to be 'Plain' if omitted. 0 denotes Plain, 1 denotes Coinbase c : The output/input commitment, hex string Encoded p : The output's range proof, hex string Encoded. If this is included, the entry is assumed to be an output. If not, it is an input. When rebuilding the transaction kernel for the Node (done during the S3 or I3 phases,) the kernel is assumed to be 'Plain' unless the top-level feat field is non-zero. In this case, the kernel features are filled accordingly with any needed values from the feat_args struct. In a typical S3 phase, these fields may look something like: \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" }, { \"c\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"c\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ], Feature arguments Depending on the chosen Kernel Feature set, feat_args may be populated with arguments specific to the kernel. The exact arguments that will be present here depend on the value of feat . Currently, the only supported kernel is HeightLocked (value 1) which has the arguments: \"feat_args\": { \"lock_hgt\": \"2343234\" // For HeightLocked kernels (1) } Changes from existing V3 Slate Top-Level Slate Struct The version_info struct is removed, and is replaced with ver , which has the format \"[version]:[block header version]\" sta is added, with possible values S1|S2|S3|I1|I2|I3|NA num_participants is renamed to num_parts num_parts may be omitted from the slate. If omitted its value is assumed to be 2. amount is renamed to amt amt may be removed from the slate on the S2 phase of a transaction. fee may be removed from the slate on the S2 phase of a transaction. It may also be omitted when initiating an I1 transaction, and added during the I2 phase. lock_height is removed feat is added to the slate denoting the Kernel feature set. May be omitted from the slate if kernel is plain ttl_cutoff_height is renamed to ttl ttl may be omitted from the slate. If omitted its value is assumed to be 0 (no TTL). The participant_data struct is renamed to sigs tx is removed The coms (commitments) array is added, from which the final transaction object can be reconstructed The payment_proof struct is renamed to proof The feat_args struct is added, which may be populated for non-Plain kernels proof may be omitted from the slate if it is None (null), offset is added, which keeps track of the running offset total as it's modified by the participants Participant Data ( sigs ) public_blind_excess is renamed to xs public_nonce is renamed to nonce part_sig is renamed to part part may be omitted if it has not yet been filled out message is removed message_sig is removed id is removed. Parties can identify themselves via the keys stored in their transaction context Payment Proof Data ( proof ) The sender_address field is renamed to saddr The receiver_address field is renamed to raddr The receiver_signature field is renamed to rsig rsig may be omitted if it has not yet been filled out Pretty-Printing The examples above are pretty-printed for reference, but all Slates should remove all whitespace before sending to other parties. The whitespace and formatting can be re-added anywhere the Slate needs to be presented for debugging. Slate Definition - Binary While the JSON slate remains the first-order slate definition, and should be accepted by all wallets and APIs, wallets should also have the ability to transform slates between the JSON format and a reduced binary format suitable for armoring or direct transfer. The definition of the V4 binary slate format follows. All integer values are Big-Endian. Slate V4 Field type len notes ver.slate_version u16 2 ver.block_header_version u16 2 id Uuid 16 binary Uuid representation sta u8 1 See Status Byte offset BlindingFactor 32 Optional field status u8 1 See Optional Field Status num_parts u8 (1) If present amt u64 (8) If present fee u64 (8) If present feat u8 (1) If present ttl u64 (8) If present sigs entries struct varies See Sigs Entries Optional struct status u8 1 See Optional Struct Status coms entries struct (varies) If present. See Coms Entries proof struct (varies) If present. See Proof feat_args entries struct (varies) If present. See Feature Args Status Byte Encodes slate status ( sta ) field, mapped as follows: State value NA (Unknown) 0 S1 1 S2 2 S3 3 I1 4 I2 5 I3 6 Optional Field Status A bit field that denotes the presence or absence of the optional slate fields. Each bit is mapped to particular slate field as follows: Bit 7 6 5 4 3 2 1 0 field ttl feat fee amt num_parts If the corresponding field for a bit is 1, the field is present and must be read accordingly. Sigs Entries Sigs Entries contains a length-prefixed array of entries corresponding to the sigs struct. Field type len notes length u8 1 entries struct varies array of entries, see below Each Sigs Entry is structured as follows: Field type len notes complete flag u8 1 If non-zero, entry contains part xs secp256k1 Public Key 33 nonce secp256k1 Public Key 33 part secp256k1 AggSig (64) If present Optional Struct Status A bit field that denotes the presence or absence of the optional slate structures. Each bit is mapped to particular slate structure as follows: Bit 7 6 5 4 3 2 1 0 struct proof coms If the corresponding field for a struct is 1, the struct is present and must be read accordingly. Coms Entries Coms Entries contains a length-prefixed array of entries corresponding to the coms struct. Field type len notes length u16 2 entries struct varies array of entries, see below Each Coms Entry is structured as follows: Field type len notes output flag u8 1 If non-zero, entry is output and contains p (proof) f u8 1 features (1 = Coinbase, 0 = Plain) c Commitment 33 p Rangeproof 675 If present Proof Optional Payment proof, with fields as follows Proof Field type len notes saddr ed25519 Public Key 32 raddr ed25519 Public Key 32 rsig flag u8 1 If non-zero, rsig field is present rsig ed25519 EDCSA Sig (64) If present Feature Args Optional feature args, presence or absence of which should be determined by the value of the feat field. Currently only present if feat is 2. Field type len notes lock_hgt u64 8 Lock height, present if feat is 2 Unresolved questions Is block header version needed? Nerd Kernels need to be included Future possibilities This RFC is envisaged as a necessary first step for all slate-exchange possibilities that would benefit from compactness, e.g: Slatepack QR Code encoding of slates Armored slates","title":"0012 compact-slates"},{"location":"grin-rfcs/text/0012-compact-slates/#summary","text":"This RFC describes the changes between version 3 and version 4 of the Slate transaction exchange format, which had the goal of reducing the contents of the Slate to be as minimal as possible.","title":"Summary"},{"location":"grin-rfcs/text/0012-compact-slates/#motivation","text":"Previously, the definition of Slate versions up to V3 had been put together with no regard for its size or/and redundant/irrelevant content. In order to facilitate future exchange method possibilities, it's desirable to ensure the Slate is as compact as possible, particularly on the 'first leg' of a transaction exchange which only actually requires minimal information from the transaction initiator. This RFC aims to define the contents of a streamlined \"compact\" slate by: Removing all redundant or unnecessary Slate fields Shortening the names of many Slate fields Reducing the size of the Slate to at all phases of a transaction Defining an optional highly-minimized binary format for Slate output Although this RFC doesn't address any particular transaction exchange methods that might be facilitated by this streamlining, one could envisage possibilities such as: An exchange placing the entire initial slate in a QR code Encoding the initial slate as an easily-cut-and-paste chunk","title":"Motivation"},{"location":"grin-rfcs/text/0012-compact-slates/#community-level-explanation","text":"There are two basic transaction workflows in a two-party Grin transaction: In the Basic workflow, a sender adds their inputs and change outputs to a transaction, and sends them, along with the fee, the amount and their signature data to the recipient. The recipient adds a output for the amount to the transaction, adds their signature data and returns to the sender, who completes the transaction and posts. In the Invoice workflow, the invoice creator adds a new output to a transaction, and sends the amount and signature data to the payer. The payer adds their inputs and change outputs to the transaction along with their signature data and fee information, then returns to the invoicer, who completes the transaction and posts. Although previous versions of the Slate included every party's complete inputs and outputs at every stage of the transaction, it is not technically necessary for the initiator to provide their inputs and outputs to the other party. It suffices for the initiator to store the input/output listing in their local transaction context, and only provide the amount, fee, excess and signature data to the other party. Recognising this, it is possible to ensure that the 'first-leg' of a transaction stage is extremely compact. For instance, version 3 of the Slate on transaction initiation may have looked something like the following: { \"version_info\": { \"version\": 3, \"orig_version\": 3, \"block_header_version\": 2 }, \"num_participants\": 2, \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"tx\": { \"offset\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"body\": { \"inputs\": [ { \"features\": \"Coinbase\", \"commit\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"features\": \"Coinbase\", \"commit\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ], \"outputs\": [ { \"features\": \"Plain\", \"commit\": \"0812276cc788e6870612296d926cba9f0e7b9810670710b5a6e6f1ba006d395774\", \"proof\": \"dcff6175390c602bfa92c2ffd1a9b2d84dcc9ea941f6f317bdd0f875244ef23e696fd17c71df79760ce5ce1a96aab1d15dd057358dc835e972febeb86d50ccec0dad7cfe0246d742eb753cf7b88c045d15bc7123f8cf7155647ccf663fca92a83c9a65d0ed756ea7ebffd2cac90c380a102ed9caaa355d175ed0bf58d3ac2f5e909d6c447dfc6b605e04925c2b17c33ebd1908c965a5541ea5d2ed45a0958e6402f89d7a56df1992e036d836e74017e73ccad5cb3a82b8e139e309792a31b15f3ffd72ed033253428c156c2b9799458a25c1da65b719780a22de7fe7f437ae2fccd22cf7ea357ab5aa66a5ef7d71fb0dc64aa0b5761f68278062bb39bb296c787e4cabc5e2a2933a416ce1c9a9696160386449c437e9120f7bb26e5b0e74d1f2e7d5bcd7aafb2a92b87d1548f1f911fb06af7bd6cc13cee29f7c9cb79021aed18186272af0e9d189ec107c81a8a3aeb4782b0d950e4881aa51b776bb6844b25bce97035b48a9bdb2aea3608687bcdd479d4fa998b5a839ff88558e4a29dff0ed13b55900abb5d439b70793d902ae9ad34587b18c919f6b875c91d14deeb1c373f5e76570d59a6549758f655f1128a54f162dfe8868e1587028e26ad91e528c5ae7ee9335fa58fb59022b5de29d80f0764a9917390d46db899acc6a5b416e25ecc9dccb7153646addcc81cadb5f0078febc7e05d7735aba494f39ef05697bbcc9b47b2ccc79595d75fc13c80678b5e237edce58d731f34c05b1ddcaa649acf2d865bbbc3ceda10508bcdd29d0496744644bf1c3516f6687dfeef5649c7dff90627d642739a59d91a8d1d0c4dc55d74a949e1074427664b467992c9e0f7d3af9d6ea79513e8946ddc0d356bac49878e64e6a95b0a30214214faf2ce317fa622ff3266b32a816e10a18e6d789a5da1f23e67b4f970a68a7bcd9e18825ee274b0483896a40\" } ], \"kernels\": [ { \"features\": \"Plain\", \"fee\": \"7000000\", \"lock_height\": \"0\", \"excess\": \"000000000000000000000000000000000000000000000000000000000000000000\", \"excess_sig\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } ] } }, \"amount\": \"60000000000\", \"fee\": \"7000000\", \"height\": \"5\", \"lock_height\": \"0\", \"ttl_cutoff_height\": null, \"payment_proof\": null, \"participant_data\": [ { \"id\": \"0\", \"public_blind_excess\": \"033ac2158fa0077f087de60c19d8e431753baa5b63b6e1477f05a2a6e7190d4592\", \"public_nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part_sig\": null, \"message\": null, \"message_sig\": null } ] } In version 4 of the Slate format, the initial Slate now looks like the following: { \"ver\": \"4:2\" \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"amt\": \"6000000000\", \"fee\": \"8000000\", \"sigs\": [ { \"xs\": \"023878ce845727f3a4ec76ca3f3db4b38a2d05d636b8c3632108b857fed63c96de\" \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ], } While a \"return\" slate might look something like the following: { \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S2\", \"off\": \"a4052c9200000001a6052c9200000002ed564fab50b75fc5ea32ce052fc9bebf\", \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part\": \"8f07ddd5e9f5179cff19486034181ed76505baaad53e5d994064127b56c5841b54735cb9ed2f59fb457144f7b1c8226d08b54cbdd0eb7e6492950751b0bb54f9\" } ], \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" } ] } The 'return' slate from the recipient to the originator is expected to be larger, as it must include the recipient's outputs/inputs and proofs (as the party who posts the transaction needs all of this information). However, compacting the slate at each stage of its journey allows for future possibilities that may have been more difficult in previous iterations of the slate format. For instance, an initiator taking Grin payments might be expected to be better equipped to receive Grin transactions. They could present the payer with an invoice transaction for the amount compacted to the size of a QR code, which the payer could scan, accept, and then post back to the invoicer's listening wallet infrastructure. Compacting the slate also acts as a minor privacy-enhancer by hiding the initiator's outputs from the other party.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0012-compact-slates/#reference-level-explanation","text":"","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0012-compact-slates/#slate-definition-json","text":"Entries prefixed with // denote fields that may be omitted, as well as their default assumed values. # denotes a comment for the purposes of illustration. Field ordering is canonical. { # These fields are always present \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", # These fields may or may not be present //\"num_parts: 2, //\"fee\": \"8000000\", //\"amt\": \"1000000000\", //\"feat\": 0, //\"ttl\": null, # Sigs is always present with at least one entry \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", // \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ] # These structs may or may not be present //\"coms\": null, //\"proof\": null, //\"feat_args\": null } A description of all fields and their meanings is as follows:","title":"Slate Definition - JSON"},{"location":"grin-rfcs/text/0012-compact-slates/#top-level-slate-struct","text":"","title":"Top-Level Slate Struct"},{"location":"grin-rfcs/text/0012-compact-slates/#fields-always-present","text":"ver - The slate version and supported block header version, separated by a : id - The slate's UUID, standard hex-string encoding for UUIDs sta - 2 character String representing the current stage of the the transaction. See Status Codes off - The running transaction offset total, hex-string encoded. All parties select a random offset at the beginning of the transaction and subtract their offset from the excess value of their outputs. They then subtract the value of the inputs from the offset when committing to inputs, updating the total offset before sending to the next stage.","title":"Fields - Always present"},{"location":"grin-rfcs/text/0012-compact-slates/#fields-optional-depending-on-state-and-transaction-options","text":"num_parts - The number of participants in the transaction, assumed to be 2 if omitted amt - The transaction amount as a string parseable as a u64. May be omitted on a return journey. fee - The transaction fee as a string parseable as a u64. May be omitted on a return journey, except during an invoice transaction. feat - Kernel Features ID. If omitted, kernel is assumed to be Plain (0). If set to 1 or otherwise, any arguments required for a particular kernel feature set will be found in the feat_args struct. ttl - Time to Live, or block height beyond which wallets should refuse to further process the transaction. Assumed 0 (no ttl) if omitted from the slate.","title":"Fields - Optional, depending on State and transaction options"},{"location":"grin-rfcs/text/0012-compact-slates/#structs-always-present","text":"sigs - An array of signature data containing the signature information of the last participant. See Signature Data","title":"Structs - Always present"},{"location":"grin-rfcs/text/0012-compact-slates/#structs-optional-depending-on-state-of-transaction","text":"proof - An optional payment proof request. See Payment Proof Data coms - The Transaction ; is removed from the slate in favour of including this top-level Slate field that can be used to reconstruction the transaction object as expected by the Grin node. See Transaction Object Fields feat_args - Optional arguments for Kernel features.","title":"Structs - Optional, depending on state of transaction"},{"location":"grin-rfcs/text/0012-compact-slates/#status-codes","text":"Valid values of the sta field and their meanings are: S1 - Standard (payer to payee) transaction flow, new transaction that incorporates the sender's inputs and change output(s), if any. Sender's signature nonce, excess (with kernel offset) is included and ready for sending to recipient. S2 - Standard transaction flow, recipient has created their outputs(s) and supplied their excess, nonce and partial signature, ready to return to recipient for completion. S3 - Standard transaction flow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting I1 - Invoice (payee to payer) transaction flow, new transaction that incorporates the Invoicer's output(s). Invoicer's signature nonce and excess (with kernel offset) is included and ready for sending to Invoicee. I2 - Invoice workflow, Invoicee has added their inputs and change output(s). Invoicee's signature, nonce and excess is included and ready for sending back to the invoicer. I3 - Invoice workflow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting","title":"Status Codes"},{"location":"grin-rfcs/text/0012-compact-slates/#signature-data","text":"An entry in the sigs array is as follows: { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } The sigs struct contains is comprised of an array of participant signature data, with each entry comprising: * xs - Hex string encoded short form public key on the secp256k1 curve representing the public blind excess for the participants outputs subtracted from each party's part of the offset. * part - Hex string encoded Aggregated (Schnorr) secp2561k signature represeting the participant's partial sig. May be omitted if the participant does not yet have enough data to create it * nonce - Hex string encoded The public key of the nonce chosen by the participant for their partial signature The other party's sig entry is removed from the slate before sending it back to the transaction initiator during the S2 and I2 phases.","title":"Signature Data"},{"location":"grin-rfcs/text/0012-compact-slates/#payment-proof-data","text":"If included, the proof structure is: \"proof\": { \"saddr\": \"7e008eb593ba17d116e282d6267a3c6aad87b910933ad34dfa4d7d2c92b6ba31\", // \"rsig\": null, \"raddr\": \"3a425bd5da5f0f78593251ede7fad0ecf7a95679d84b2cb405255d97ce068234\" } The proof struct is an optional payment proof request that must be filled out by the recipient if requested (only valid for basic transaction flow). Its fields are as follows: saddr - Hex string encoded short-form public key on the ed25519 curve, representing the sender's wallet address (see the payment proofs rfc for details. raddr - Hex string encoded short-form public key on the ed25519 curve represnting the recipient's wallet address rsig - Hex string encoded EdDSA ed25519 signature representing the recipient's payment-proof signature. Can be omitted if this has not yet been filled out","title":"Payment Proof Data"},{"location":"grin-rfcs/text/0012-compact-slates/#transaction-object-fields","text":"The V4 Version of the Slate contains its own separate representation of Grin's internal Transaction object. (Grin's internal transaction struct definition can be found here: Transaction ). Internally, the wallet will transform its representation into the format expected by the node while posting the transaction. The tx struct in a V4 Slate is removed, and is replaced instead by the following Top-Level fields. Wallets recreate the transaction object as expected by the Grin node from these fields before posting. coms is an array containing the outputs and inputs that have been added to the slate. These will appear during the I1 or S2 phases of a transaction. Each entry includes: f : The output features, assumed to be 'Plain' if omitted. 0 denotes Plain, 1 denotes Coinbase c : The output/input commitment, hex string Encoded p : The output's range proof, hex string Encoded. If this is included, the entry is assumed to be an output. If not, it is an input. When rebuilding the transaction kernel for the Node (done during the S3 or I3 phases,) the kernel is assumed to be 'Plain' unless the top-level feat field is non-zero. In this case, the kernel features are filled accordingly with any needed values from the feat_args struct. In a typical S3 phase, these fields may look something like: \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" }, { \"c\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"c\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ],","title":"Transaction Object Fields"},{"location":"grin-rfcs/text/0012-compact-slates/#feature-arguments","text":"Depending on the chosen Kernel Feature set, feat_args may be populated with arguments specific to the kernel. The exact arguments that will be present here depend on the value of feat . Currently, the only supported kernel is HeightLocked (value 1) which has the arguments: \"feat_args\": { \"lock_hgt\": \"2343234\" // For HeightLocked kernels (1) }","title":"Feature arguments"},{"location":"grin-rfcs/text/0012-compact-slates/#changes-from-existing-v3-slate","text":"","title":"Changes from existing V3 Slate"},{"location":"grin-rfcs/text/0012-compact-slates/#top-level-slate-struct_1","text":"The version_info struct is removed, and is replaced with ver , which has the format \"[version]:[block header version]\" sta is added, with possible values S1|S2|S3|I1|I2|I3|NA num_participants is renamed to num_parts num_parts may be omitted from the slate. If omitted its value is assumed to be 2. amount is renamed to amt amt may be removed from the slate on the S2 phase of a transaction. fee may be removed from the slate on the S2 phase of a transaction. It may also be omitted when initiating an I1 transaction, and added during the I2 phase. lock_height is removed feat is added to the slate denoting the Kernel feature set. May be omitted from the slate if kernel is plain ttl_cutoff_height is renamed to ttl ttl may be omitted from the slate. If omitted its value is assumed to be 0 (no TTL). The participant_data struct is renamed to sigs tx is removed The coms (commitments) array is added, from which the final transaction object can be reconstructed The payment_proof struct is renamed to proof The feat_args struct is added, which may be populated for non-Plain kernels proof may be omitted from the slate if it is None (null), offset is added, which keeps track of the running offset total as it's modified by the participants","title":"Top-Level Slate Struct"},{"location":"grin-rfcs/text/0012-compact-slates/#participant-data-sigs","text":"public_blind_excess is renamed to xs public_nonce is renamed to nonce part_sig is renamed to part part may be omitted if it has not yet been filled out message is removed message_sig is removed id is removed. Parties can identify themselves via the keys stored in their transaction context","title":"Participant Data (sigs)"},{"location":"grin-rfcs/text/0012-compact-slates/#payment-proof-data-proof","text":"The sender_address field is renamed to saddr The receiver_address field is renamed to raddr The receiver_signature field is renamed to rsig rsig may be omitted if it has not yet been filled out","title":"Payment Proof Data (proof)"},{"location":"grin-rfcs/text/0012-compact-slates/#pretty-printing","text":"The examples above are pretty-printed for reference, but all Slates should remove all whitespace before sending to other parties. The whitespace and formatting can be re-added anywhere the Slate needs to be presented for debugging.","title":"Pretty-Printing"},{"location":"grin-rfcs/text/0012-compact-slates/#slate-definition-binary","text":"While the JSON slate remains the first-order slate definition, and should be accepted by all wallets and APIs, wallets should also have the ability to transform slates between the JSON format and a reduced binary format suitable for armoring or direct transfer. The definition of the V4 binary slate format follows. All integer values are Big-Endian. Slate V4 Field type len notes ver.slate_version u16 2 ver.block_header_version u16 2 id Uuid 16 binary Uuid representation sta u8 1 See Status Byte offset BlindingFactor 32 Optional field status u8 1 See Optional Field Status num_parts u8 (1) If present amt u64 (8) If present fee u64 (8) If present feat u8 (1) If present ttl u64 (8) If present sigs entries struct varies See Sigs Entries Optional struct status u8 1 See Optional Struct Status coms entries struct (varies) If present. See Coms Entries proof struct (varies) If present. See Proof feat_args entries struct (varies) If present. See Feature Args","title":"Slate Definition - Binary"},{"location":"grin-rfcs/text/0012-compact-slates/#status-byte","text":"Encodes slate status ( sta ) field, mapped as follows: State value NA (Unknown) 0 S1 1 S2 2 S3 3 I1 4 I2 5 I3 6","title":"Status Byte"},{"location":"grin-rfcs/text/0012-compact-slates/#optional-field-status","text":"A bit field that denotes the presence or absence of the optional slate fields. Each bit is mapped to particular slate field as follows: Bit 7 6 5 4 3 2 1 0 field ttl feat fee amt num_parts If the corresponding field for a bit is 1, the field is present and must be read accordingly.","title":"Optional Field Status"},{"location":"grin-rfcs/text/0012-compact-slates/#sigs-entries","text":"Sigs Entries contains a length-prefixed array of entries corresponding to the sigs struct. Field type len notes length u8 1 entries struct varies array of entries, see below Each Sigs Entry is structured as follows: Field type len notes complete flag u8 1 If non-zero, entry contains part xs secp256k1 Public Key 33 nonce secp256k1 Public Key 33 part secp256k1 AggSig (64) If present","title":"Sigs Entries"},{"location":"grin-rfcs/text/0012-compact-slates/#optional-struct-status","text":"A bit field that denotes the presence or absence of the optional slate structures. Each bit is mapped to particular slate structure as follows: Bit 7 6 5 4 3 2 1 0 struct proof coms If the corresponding field for a struct is 1, the struct is present and must be read accordingly.","title":"Optional Struct Status"},{"location":"grin-rfcs/text/0012-compact-slates/#coms-entries","text":"Coms Entries contains a length-prefixed array of entries corresponding to the coms struct. Field type len notes length u16 2 entries struct varies array of entries, see below Each Coms Entry is structured as follows: Field type len notes output flag u8 1 If non-zero, entry is output and contains p (proof) f u8 1 features (1 = Coinbase, 0 = Plain) c Commitment 33 p Rangeproof 675 If present","title":"Coms Entries"},{"location":"grin-rfcs/text/0012-compact-slates/#proof","text":"Optional Payment proof, with fields as follows Proof Field type len notes saddr ed25519 Public Key 32 raddr ed25519 Public Key 32 rsig flag u8 1 If non-zero, rsig field is present rsig ed25519 EDCSA Sig (64) If present","title":"Proof"},{"location":"grin-rfcs/text/0012-compact-slates/#feature-args","text":"Optional feature args, presence or absence of which should be determined by the value of the feat field. Currently only present if feat is 2. Field type len notes lock_hgt u64 8 Lock height, present if feat is 2","title":"Feature Args"},{"location":"grin-rfcs/text/0012-compact-slates/#unresolved-questions","text":"Is block header version needed? Nerd Kernels need to be included","title":"Unresolved questions"},{"location":"grin-rfcs/text/0012-compact-slates/#future-possibilities","text":"This RFC is envisaged as a necessary first step for all slate-exchange possibilities that would benefit from compactness, e.g: Slatepack QR Code encoding of slates Armored slates","title":"Future possibilities"},{"location":"grin-rfcs/text/0013-nrd-kernels/","text":"Title: nrd-kernels Authors: Antioch Peverell Start date: Mar 24, 2020 RFC PR: Edit if merged: mimblewimble/grin-rfcs#47 Tracking issue: mimblewimble/grin#3288 Summary Grin supports a limited implementation of \"relative timelocks\" with \"No Recent Duplicate\" (NRD) transaction kernels. Transactions can be constructed such that they share duplicate kernels. An NRD kernel instance is not valid within a specified number of blocks relative to a prior duplicate instance of the kernel. A minimum height difference must therefore exist between two instances of an NRD kernel. This provides the relative height lock between transactions. Motivation Relative timelocks are a prerequisite for robust payment channels. NRD kernels can be used to implement a revocable channel close mechanism. A mandatory revocation period can be introduced through a relative timelock between two transactions. Any attempt to close an old invalid channel state can be safely revoked during the revocation period. Recently, Ruben Somsen announced a design for Succinct Atomic Swaps (SAS) reducing the number of on-chain transactions required to implement the swap. This design uses a combination of relative locks and adaptor signatures . SAS would appear to be compatible with Grin/MW but with some caveats, namely the need for an additional transaction kernel as the NRD lock and the adaptor signature cannot co-exist on the same kernel. This is discussed in Unresolved questions below. Community-level explanation A minimum distance in block height is enforced between successive duplicate instances of a given NRD kernel. This can be used to enforce a relative lock height between two transactions. A transaction containing an NRD kernel will not be accepted as valid within the specified block height relative to any prior instance of the NRD kernel. Transactions can be constructed around an existing transaction kernel by introducing either an additional kernel or in some cases by simply adjusting the kernel offset. This allows NRD kernels to be used across any pair of transactions. The NRD kernel implementation aims for simplicity and a minimal approach to solving the problem of \"relative locks\". Grin does not support a general solution for arbitrary length locks between arbitrary kernels. The implementation is limited in scope to avoid adversely impacting performance and scalability. References between duplicate kernels are implicit , avoiding the need to store kernel references. Locks are limited in length to recent history, avoiding the need to inspect the full historical kernel set during verification. Reference-level explanation An NRD kernel is not valid within a specified number of blocks of a previous duplicate instance of the same NRD kernel. We define duplicate here as two NRD kernels sharing the same public excess commitment. NRD kernels with different excess commitments are not treated as duplicates. An NRD kernel and a non-NRD kernel (plain kernel, coinbase kernel etc.) sharing the same excess commitment are not treated as duplicates. An NRD kernel has an associated relative lock height. For a block B containing this kernel to be valid, no duplicate instance of the kernel can exist in the last RH blocks (up to and including B ), where RH is the relative lock height. For example, a transaction containing an NRD kernel with relative lock height 1440 (24 hours) is included in a block at height 1000000. This block is only valid if no duplicate instance of this kernel exists in any block from height 998561 (h-1439) to height 1000000 (h-0) inclusive. A duplicate instance is permitted at height 998560 (h-1440), with the transaction seen as valid. If no duplicate instance of the kernel exists within this range then the lock criteria is met. A kernel can be delayed by the existence of a previous kernel. The non-existence of a previous kernel has no impact on the lock criteria. Note that this implies the first singular occurrence of any NRD kernel meets the lock criteria trivially as it cannot, by definition, be locked by a previous kernel. Thus, the relative lock defaults to \"fail open\" semantics. Each node maintains an index of recent NRD kernels to enable efficient checking of NRD relative lock heights. Note we only need to index NRD locks and we only need to index those within recent history. Relative locks longer than 7 days are not valid. This is believed to be sufficient to cover all proposed use cases. The minimum value for a relative lock height is 1 meaning a prior instance of the kernel can exist in the previous block for the lock criteria to be met. An instance of the NRD kernel in the same block will invalidate the block as the lock criteria will not be met. NRD lock heights of 0 are invalid and it is never valid for two duplicate instances of the same NRD kernel to exist in the same block. It follows that two transactions containing duplicate instances of the same NRD kernel cannot be accepted as valid in the transaction pool concurrently. Current txpool behavior is \"first one wins\" semantics when receiving transactions and this will also apply to transactions containing NRD kernels. We plan to revisit this in a future \"fee\" RFC and plan to investigate the feasibility of introducing \"replace by fee\" semantics at that time. Grin supports \"rewind\" back through recent history to handle fork and chain reorg scenarios. 1 week of full blocks are maintained on each node and up to 10080 blocks can be rewound. To support relative lock heights each node must maintain an index over sufficient kernel history for an additional 10080 blocks beyond this rewind horizon. Each node should maintain 2 weeks of kernel history in the local NRD kernel index. This will cover the pathological case of a 1 week rewind and the validation of a 1 week long relative lock beyond that. The primary use case is for revocable payment channel close operations. We believe a 7 day period is more than sufficient for this. We do not require long, extended revocation periods and limiting this to a few days is preferable to keep the cost of verification low. The need for these revocable transactions to be included on chain should be low as these are only required in a non-cooperative situation but where required we want to minimize the cost of verification which must be performed across all nodes. The following kernel variants are supported in Grin - Plain Coinbase HeightLocked NoRecentDuplicate These are implemented as kernel \"feature\" variants - pub enum KernelFeatures { /// Plain kernel (default for Grin txs). Plain = 0, /// A coinbase kernel. Coinbase = 1, /// A kernel with an explicit absolute lock height. HeightLocked = 2, /// A relative height locked NRD kernel. NoRecentDuplicate = 3, } Each kernel variant includes feature specific data - # Plain { \"fee\": 8 } # Coinbase { # empty } # Height Locked { \"fee\": 8, \"lock_height\": 295800 } # No Recent Duplicate (NRD) { \"fee\": 8, \"relative_height\": 1440, } Note that NRD kernels require no additional data beyond that required for absolute height locked kernels. The reference to the previous kernel is implicit and based on a duplicate NRD kernel excess commitment. The maximum supported NRD relative_height is 10080 (7 days) and the relative height can be safely and conveniently represented as a u16 (2 bytes). This differs from absolute lock heights where u64 (8 bytes) is necessary to specify the lock height. The minimum supported NRD relative_height is 1 and a value of 0 is not valid. Two duplicate instances of a given NRD kernel cannot exist simultaneously in the same block. There must be a relative height of at least 1 block between them. Nodes on the Grin network currently support two serialization versions for transaction kernels - V1 \"fixed size kernels\" In V1 all kernels are serialized to the same \"fixed\" number of bytes: feature ( 1 byte ) | fee ( 8 bytes ) | additional_data ( 8 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 01 f7 8 a 40 | 00 00 00 00 00 00 05 A0 | 08 b1 ... 22 d8 | 33 11 ... b9 69 NRD kernels use the last 2 bytes of feature specific data for the relative lock height as big-endian u16. The first 6 bytes of feature specific data must be all zero: 00 00 00 00 00 00 05 A0 Note: absolute lock height (u64) and relative lock height (u16) have identical serialization in practice. V1 is supported for backward compatibility with nodes that do not support V2 \"variable size kernels\". V2 \"variable size kernels\" V2 kernels have been supported since Grin v2.1.0 and V2 supports the notion of \"variable size\" kernels. See RFC-0005 \"Varible Size Kernels\" for details of this. NRD kernels include 8 bytes for the fee as big-endian u64 and 2 bytes for the relative lock height: feature ( 1 byte ) | fee ( 8 bytes ) | relative_height ( 2 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 00 6 a cf c0 | 05 A0 | 09 4 d ... bb 9 a | 09 c7 ... bd 54 In V2 relative lock height is 2 bytes as big-endian u16: 05 A0 Note: the serialization strategy is used for both network \"on the wire\" serialization of both transactions and full blocks, and local storage, both the database for full blocks and the kernel MMR backend files. Version negotiation occurs during the initial peer connection setup process and determines which version is used for p2p message serialization. If a node uses V2 serialization for the kernel MMR backend file then it will provide a V2 txhashset based on these underlying files. Kernel Signature Message Every kernel contains a signature proving the excess commitment is a commitment to zero. The message being signed includes the features, fee and other associated data to prevent malleability of the transaction kernel and the overall transaction. The transaction fee cannot be modified after signing, for example. For NRD kernels the message being signed is constructed as follows with the relative lock height serialized as 2 bytes. Hash(feature | fee | relative_height) Hash(03 | 00 00 00 00 01 f7 8a 40 | 05 A0) No additional data is introduced with NRD kernels beyond the 2 bytes representing the relative lock height. There is no opportunity to include arbitrary data. Any additional kernel included in a transaction is itself still a fully valid kernel. There is no explicit reference necessary that could be misused to include arbitrary data. An additional NRD kernel in a transaction will increase the \"weight\" of the transaction by this single additional kernel and allows for a simple way to deal with additional fees. A transaction with an additional kernel must provide additional fees to cover the additional \"weight\". NRD kernels cannot be added for free. Note that in some limited situations it is possible to replace a kernel with an NRD kernel. If the NRD lock can be introduced without adding an additional kernel then the fee does not have to be increased and the lock is effectively added for free. A transaction kernel consists of an excess commitment and an associated signature showing this excess is indeed a commitment to 0. A transaction with a single kernel can always be represented as a transaction with multiple kernels, provided the kernels excess commitments sum to the correct total excess. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment - rG + 0H This transaction can be represented as a pair of kernels with excess commitments - rG + 0H = (r'G + 0H) + (r-r'G + 0H) We take advantage of this to allow an arbitrary NRD kernel to be included in any transaction at construction time. Additionally the kernel offset included in each transaction can be used in certain situations to allow the replacement of a single transaction kernel with an NRD kernel without needing to introduce an additional kernel. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment and kernel offset - rG + 0H, o This transaction can be rewritten to use the NRD kernel - r'G + 0H, (o+r-r') These two \"degrees of freedom\", introducing multiple kernels and adjusting the kernel offset, allowing for flexibility to introduce an NRD kernel in a variety of ways. Introduce NRD kernel to transaction, compensate with additional kernel. Introduce NRD kernel to transaction, compensate with kernel offset. Payment Channel Implementation NRD kernels can be used to delay alternate \"branches\" of conflicting transactions, enabling a payment channel implementation. A payment channel is represented as a single multi-party output. Each channel state transition is represented as a pair of \"close\" and \"settle\" transactions with an NRD kernel enforcing a delay between them. Funds are held in an intermediate multi-party output while delayed. The NRD kernel is reused across both transactions by adjusting kernel offsets. X -> Y, K nrd_a \\ Y -> [Z a , Z b ], K nrd_a Alice closes the channel X with their \"close\" transaction. After a delay Alice can \"settle\" the funds out to Alice and Bob. Attribution of \"close\" and \"settle\" transactions for each channel state is provided through endpoint specific NRD kernels. This allows the other party to \"revoke\" old invalid state without the NRD delay. Each channel state transition involves a new pair of \"close\" and \"settle\" transactions for each participant along with a shared \"revoke\" transaction. The \"revoke\" transaction simply spends funds back to the channel output and a plain kernel suffices. [Z a , Z b ] -> X, K rev Alice attempts to close old invalid state ( Y 1 ): X -> Y 1 , K nrd_a1 Bob can immediately revoke and close current state ( Y 1 -> Y 2 ): Y 1 -> ~[Z a , Z b ]~, K nrd_b1 \\ ~[Z a , Z b ]~ -> X , K rev_1 \\ X -> Y 2 , K nrd_b2 \\ => Y 1 -> Y 2 , [K nrd_b1 , K rev_1 , K nrd_b2 ] Bob publishes only the final cut-through multi-kernel transaction ( Y 1 -> Y 2 ). Bob's individual settle transaction is not revealed. Neither party can self-revoke without introducing the NRD delay. The other party always has the opportunity to revoke first. Self-revocation cannot be used to lock funds up indefinitely. Rollout/Deployment (HF3) The following rules will be enforced during rollout as part of HF3 - Assumptions: HF3 will occur at height 786,240. Blocks at height >= 786,240 will have block version >= 4. Block Specific Rules: A block containing NRD kernel(s) is only be valid if block version >= 4. A block containing NRD kernel(s) is only valid if all defined relative lock height rules are met. Two duplicate NRD kernel instances cannot exist in the same block. Transaction Specific Rules: A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless chain head version >= 4. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless chain head version >= 4. A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless it meets the defined relative lock height rule in the next block. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless it meets the defined relative lock height rule in the next block. Two duplicate NRD kernel instances cannot exist in the txpool/stempool concurrently. Weights & Fees For the purpose of block weight calculations, each kernel is treated as 3 \"weight units\" where each unit is approximately 32 bytes. This covers the excess commitment and the associated signature common across all kernel variants. The additional 2 bytes of \"relative height\" on NRD kernels are ignored for the purposes of calculating block weight. For the purpose of minimum transaction relay fees all kernels are treated as 1 \"fee unit\" with each unit being 1 milligrin. We plan to revisit the entire transaction fee structure in a future RFC. Kernel variants may affect the transaction fee calculations differently in the future. Drawbacks NRD kernels are a limited and restricted form of \"relative locks\" between kernels. These locks are limited to a period of 7 days and \"fail open\" beyond that window. This approach meets the requirements for limited revocable payment channel operations but there are likely to be use cases where this approach is not sufficient or unsuitable. While it would be nice to provide a fully general purpose solution that would allow arbitrary locks to be implemented, it does appear to be hard, if not impossible, to do this in Grin/MW. Rationale and alternatives Referencing historical data in Grin and in Mimblewimble in general is difficult due to the possibility of pruning historical data. It is not possible to reference old outputs once they are spent. Historical validators must have access to any referenced data to validate consensus rules. This leaves transaction kernels as the only available data to be referenced. While arbitrary historical kernels can be referenced this is not desirable as we do not want to impose additional constraints on nodes, requiring them to maintain historical data that would otherwise be prunable. An earlier design iteration was \"No Such Kernel Recently\" (NSKR) locks. Where NRD references were implicit, with duplicate kernel excess commitments, NSKR kernels referenced prior kernels explicitly. These explicit references were problematic for several reasons - Additional overhead, both local storage and network traffic due to the explicit references. Optimization by referencing prior kernel based on MMR position introduced a dependency on external data (kernels can no longer be validated in isolation). Permitting non-existence of references due to limited window of history, opened up a vector for \"spam\" where arbitrary data could be used in place of a valid reference. To prevent \"spam\" a signature can be used to verify the reference was indeed a valid commitment. By including a signature along with the commitment, the reference is effectively a full transaction kernel. The idea of using Merkle proofs to verify inclusion of a historical referenced kernel in the kernel MMR was also considered. This gets expensive both in terms of transaction size and increased verification cost. There is also the problem of position not yet being known at transaction creation time, necessitating Merkle proof generation at block creation time by miners which adds complexity. Prior art Bitcoin allows transaction inputs to be \"encumbered\" with a relative locktime based on the sequence number field. This restricts an input from spending the associated output until a certain number of blocks have passed. BIP112 describes the CHECKSEQUENCEVERIFY opcode in Bitcoin and BIP68 describes the underlying consensus changes around the sequence number field. Timelock#CheckSequenceVerify (bitcoin wiki) CheckSequenceVerify (bitcoin wiki) Bitcoin BIP-0068 Bitcoin BIP-0112 Note that relative locks in Bitcoin are based on transaction inputs and outputs , with inputs only able to spend outputs once confirmed beneath a certain number of blocks. We cannot do this in Grin due to the pruning of old data. Spent outputs will eventually be removed and cannot be relied upon as part of the validation process. Bitcoin encumbers individual outputs whereas in Grin we encumber transactions via the constituent transaction kernels. Unresolved questions Some investigation is still needed around the conditions necessary to allow a kernel to simply be reused with an adjustment to the kernel offset and where an additional kernel is necessary. An adjustment to the kernel offset will expose the private excess under certain conditions and cannot be done safely for all transactions. One outstanding question is what use cases are not covered by NRD kernels. We believe them to be sufficient for the revocable payment channel close mechanism. But they may not be sufficient for all use cases. Succinct Atomic Swaps (SAS) describes the use of both relative locks and adaptor signatures to implement atomic swaps with only two on-chain transactions. The secret associated with the adaptor signature is swapped to allow funds to be claimed while the relative lock locks funds prior to a refund being claimed. We note that NRD kernels and adaptor signatures are not directly compatible as a prior instance of an NRD kernel would have revealed the secret associated with the adaptor signature. That said we can produce transactions with multiple kernels and we can use this to isolate the adaptor signature on a separate kernel alongside an NRD kernel. It is an unresolved question if there is a way to modify the SAS protocol and avoid the need for these additional kernels in Grin/MW. References Original \"triggers\" mailing list post by Ruben Somsen \"No Such Kernel Recently\" post by John Tromp \"Duplicate Kernels\" post by Antioch \"NRD based payment channel\" post by John Tromp Earlier NSKR based payment channel design) Timelock#CheckSequenceVerify (bitcoin wiki) CheckSequenceVerify (bitcoin wiki) Bitcoin BIP-0068 Bitcoin BIP-0112 Succinct Atomic Swaps by Ruben Somsen Scriptless Scripts RFC-0005 \"Variable Size Kernels\"","title":"0013 nrd-kernels"},{"location":"grin-rfcs/text/0013-nrd-kernels/#summary","text":"Grin supports a limited implementation of \"relative timelocks\" with \"No Recent Duplicate\" (NRD) transaction kernels. Transactions can be constructed such that they share duplicate kernels. An NRD kernel instance is not valid within a specified number of blocks relative to a prior duplicate instance of the kernel. A minimum height difference must therefore exist between two instances of an NRD kernel. This provides the relative height lock between transactions.","title":"Summary"},{"location":"grin-rfcs/text/0013-nrd-kernels/#motivation","text":"Relative timelocks are a prerequisite for robust payment channels. NRD kernels can be used to implement a revocable channel close mechanism. A mandatory revocation period can be introduced through a relative timelock between two transactions. Any attempt to close an old invalid channel state can be safely revoked during the revocation period. Recently, Ruben Somsen announced a design for Succinct Atomic Swaps (SAS) reducing the number of on-chain transactions required to implement the swap. This design uses a combination of relative locks and adaptor signatures . SAS would appear to be compatible with Grin/MW but with some caveats, namely the need for an additional transaction kernel as the NRD lock and the adaptor signature cannot co-exist on the same kernel. This is discussed in Unresolved questions below.","title":"Motivation"},{"location":"grin-rfcs/text/0013-nrd-kernels/#community-level-explanation","text":"A minimum distance in block height is enforced between successive duplicate instances of a given NRD kernel. This can be used to enforce a relative lock height between two transactions. A transaction containing an NRD kernel will not be accepted as valid within the specified block height relative to any prior instance of the NRD kernel. Transactions can be constructed around an existing transaction kernel by introducing either an additional kernel or in some cases by simply adjusting the kernel offset. This allows NRD kernels to be used across any pair of transactions. The NRD kernel implementation aims for simplicity and a minimal approach to solving the problem of \"relative locks\". Grin does not support a general solution for arbitrary length locks between arbitrary kernels. The implementation is limited in scope to avoid adversely impacting performance and scalability. References between duplicate kernels are implicit , avoiding the need to store kernel references. Locks are limited in length to recent history, avoiding the need to inspect the full historical kernel set during verification.","title":"Community-level explanation"},{"location":"grin-rfcs/text/0013-nrd-kernels/#reference-level-explanation","text":"An NRD kernel is not valid within a specified number of blocks of a previous duplicate instance of the same NRD kernel. We define duplicate here as two NRD kernels sharing the same public excess commitment. NRD kernels with different excess commitments are not treated as duplicates. An NRD kernel and a non-NRD kernel (plain kernel, coinbase kernel etc.) sharing the same excess commitment are not treated as duplicates. An NRD kernel has an associated relative lock height. For a block B containing this kernel to be valid, no duplicate instance of the kernel can exist in the last RH blocks (up to and including B ), where RH is the relative lock height. For example, a transaction containing an NRD kernel with relative lock height 1440 (24 hours) is included in a block at height 1000000. This block is only valid if no duplicate instance of this kernel exists in any block from height 998561 (h-1439) to height 1000000 (h-0) inclusive. A duplicate instance is permitted at height 998560 (h-1440), with the transaction seen as valid. If no duplicate instance of the kernel exists within this range then the lock criteria is met. A kernel can be delayed by the existence of a previous kernel. The non-existence of a previous kernel has no impact on the lock criteria. Note that this implies the first singular occurrence of any NRD kernel meets the lock criteria trivially as it cannot, by definition, be locked by a previous kernel. Thus, the relative lock defaults to \"fail open\" semantics. Each node maintains an index of recent NRD kernels to enable efficient checking of NRD relative lock heights. Note we only need to index NRD locks and we only need to index those within recent history. Relative locks longer than 7 days are not valid. This is believed to be sufficient to cover all proposed use cases. The minimum value for a relative lock height is 1 meaning a prior instance of the kernel can exist in the previous block for the lock criteria to be met. An instance of the NRD kernel in the same block will invalidate the block as the lock criteria will not be met. NRD lock heights of 0 are invalid and it is never valid for two duplicate instances of the same NRD kernel to exist in the same block. It follows that two transactions containing duplicate instances of the same NRD kernel cannot be accepted as valid in the transaction pool concurrently. Current txpool behavior is \"first one wins\" semantics when receiving transactions and this will also apply to transactions containing NRD kernels. We plan to revisit this in a future \"fee\" RFC and plan to investigate the feasibility of introducing \"replace by fee\" semantics at that time. Grin supports \"rewind\" back through recent history to handle fork and chain reorg scenarios. 1 week of full blocks are maintained on each node and up to 10080 blocks can be rewound. To support relative lock heights each node must maintain an index over sufficient kernel history for an additional 10080 blocks beyond this rewind horizon. Each node should maintain 2 weeks of kernel history in the local NRD kernel index. This will cover the pathological case of a 1 week rewind and the validation of a 1 week long relative lock beyond that. The primary use case is for revocable payment channel close operations. We believe a 7 day period is more than sufficient for this. We do not require long, extended revocation periods and limiting this to a few days is preferable to keep the cost of verification low. The need for these revocable transactions to be included on chain should be low as these are only required in a non-cooperative situation but where required we want to minimize the cost of verification which must be performed across all nodes. The following kernel variants are supported in Grin - Plain Coinbase HeightLocked NoRecentDuplicate These are implemented as kernel \"feature\" variants - pub enum KernelFeatures { /// Plain kernel (default for Grin txs). Plain = 0, /// A coinbase kernel. Coinbase = 1, /// A kernel with an explicit absolute lock height. HeightLocked = 2, /// A relative height locked NRD kernel. NoRecentDuplicate = 3, } Each kernel variant includes feature specific data - # Plain { \"fee\": 8 } # Coinbase { # empty } # Height Locked { \"fee\": 8, \"lock_height\": 295800 } # No Recent Duplicate (NRD) { \"fee\": 8, \"relative_height\": 1440, } Note that NRD kernels require no additional data beyond that required for absolute height locked kernels. The reference to the previous kernel is implicit and based on a duplicate NRD kernel excess commitment. The maximum supported NRD relative_height is 10080 (7 days) and the relative height can be safely and conveniently represented as a u16 (2 bytes). This differs from absolute lock heights where u64 (8 bytes) is necessary to specify the lock height. The minimum supported NRD relative_height is 1 and a value of 0 is not valid. Two duplicate instances of a given NRD kernel cannot exist simultaneously in the same block. There must be a relative height of at least 1 block between them. Nodes on the Grin network currently support two serialization versions for transaction kernels - V1 \"fixed size kernels\" In V1 all kernels are serialized to the same \"fixed\" number of bytes: feature ( 1 byte ) | fee ( 8 bytes ) | additional_data ( 8 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 01 f7 8 a 40 | 00 00 00 00 00 00 05 A0 | 08 b1 ... 22 d8 | 33 11 ... b9 69 NRD kernels use the last 2 bytes of feature specific data for the relative lock height as big-endian u16. The first 6 bytes of feature specific data must be all zero: 00 00 00 00 00 00 05 A0 Note: absolute lock height (u64) and relative lock height (u16) have identical serialization in practice. V1 is supported for backward compatibility with nodes that do not support V2 \"variable size kernels\". V2 \"variable size kernels\" V2 kernels have been supported since Grin v2.1.0 and V2 supports the notion of \"variable size\" kernels. See RFC-0005 \"Varible Size Kernels\" for details of this. NRD kernels include 8 bytes for the fee as big-endian u64 and 2 bytes for the relative lock height: feature ( 1 byte ) | fee ( 8 bytes ) | relative_height ( 2 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 00 6 a cf c0 | 05 A0 | 09 4 d ... bb 9 a | 09 c7 ... bd 54 In V2 relative lock height is 2 bytes as big-endian u16: 05 A0 Note: the serialization strategy is used for both network \"on the wire\" serialization of both transactions and full blocks, and local storage, both the database for full blocks and the kernel MMR backend files. Version negotiation occurs during the initial peer connection setup process and determines which version is used for p2p message serialization. If a node uses V2 serialization for the kernel MMR backend file then it will provide a V2 txhashset based on these underlying files. Kernel Signature Message Every kernel contains a signature proving the excess commitment is a commitment to zero. The message being signed includes the features, fee and other associated data to prevent malleability of the transaction kernel and the overall transaction. The transaction fee cannot be modified after signing, for example. For NRD kernels the message being signed is constructed as follows with the relative lock height serialized as 2 bytes. Hash(feature | fee | relative_height) Hash(03 | 00 00 00 00 01 f7 8a 40 | 05 A0) No additional data is introduced with NRD kernels beyond the 2 bytes representing the relative lock height. There is no opportunity to include arbitrary data. Any additional kernel included in a transaction is itself still a fully valid kernel. There is no explicit reference necessary that could be misused to include arbitrary data. An additional NRD kernel in a transaction will increase the \"weight\" of the transaction by this single additional kernel and allows for a simple way to deal with additional fees. A transaction with an additional kernel must provide additional fees to cover the additional \"weight\". NRD kernels cannot be added for free. Note that in some limited situations it is possible to replace a kernel with an NRD kernel. If the NRD lock can be introduced without adding an additional kernel then the fee does not have to be increased and the lock is effectively added for free. A transaction kernel consists of an excess commitment and an associated signature showing this excess is indeed a commitment to 0. A transaction with a single kernel can always be represented as a transaction with multiple kernels, provided the kernels excess commitments sum to the correct total excess. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment - rG + 0H This transaction can be represented as a pair of kernels with excess commitments - rG + 0H = (r'G + 0H) + (r-r'G + 0H) We take advantage of this to allow an arbitrary NRD kernel to be included in any transaction at construction time. Additionally the kernel offset included in each transaction can be used in certain situations to allow the replacement of a single transaction kernel with an NRD kernel without needing to introduce an additional kernel. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment and kernel offset - rG + 0H, o This transaction can be rewritten to use the NRD kernel - r'G + 0H, (o+r-r') These two \"degrees of freedom\", introducing multiple kernels and adjusting the kernel offset, allowing for flexibility to introduce an NRD kernel in a variety of ways. Introduce NRD kernel to transaction, compensate with additional kernel. Introduce NRD kernel to transaction, compensate with kernel offset.","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0013-nrd-kernels/#payment-channel-implementation","text":"NRD kernels can be used to delay alternate \"branches\" of conflicting transactions, enabling a payment channel implementation. A payment channel is represented as a single multi-party output. Each channel state transition is represented as a pair of \"close\" and \"settle\" transactions with an NRD kernel enforcing a delay between them. Funds are held in an intermediate multi-party output while delayed. The NRD kernel is reused across both transactions by adjusting kernel offsets. X -> Y, K nrd_a \\ Y -> [Z a , Z b ], K nrd_a Alice closes the channel X with their \"close\" transaction. After a delay Alice can \"settle\" the funds out to Alice and Bob. Attribution of \"close\" and \"settle\" transactions for each channel state is provided through endpoint specific NRD kernels. This allows the other party to \"revoke\" old invalid state without the NRD delay. Each channel state transition involves a new pair of \"close\" and \"settle\" transactions for each participant along with a shared \"revoke\" transaction. The \"revoke\" transaction simply spends funds back to the channel output and a plain kernel suffices. [Z a , Z b ] -> X, K rev Alice attempts to close old invalid state ( Y 1 ): X -> Y 1 , K nrd_a1 Bob can immediately revoke and close current state ( Y 1 -> Y 2 ): Y 1 -> ~[Z a , Z b ]~, K nrd_b1 \\ ~[Z a , Z b ]~ -> X , K rev_1 \\ X -> Y 2 , K nrd_b2 \\ => Y 1 -> Y 2 , [K nrd_b1 , K rev_1 , K nrd_b2 ] Bob publishes only the final cut-through multi-kernel transaction ( Y 1 -> Y 2 ). Bob's individual settle transaction is not revealed. Neither party can self-revoke without introducing the NRD delay. The other party always has the opportunity to revoke first. Self-revocation cannot be used to lock funds up indefinitely.","title":"Payment Channel Implementation"},{"location":"grin-rfcs/text/0013-nrd-kernels/#rolloutdeployment-hf3","text":"The following rules will be enforced during rollout as part of HF3 - Assumptions: HF3 will occur at height 786,240. Blocks at height >= 786,240 will have block version >= 4. Block Specific Rules: A block containing NRD kernel(s) is only be valid if block version >= 4. A block containing NRD kernel(s) is only valid if all defined relative lock height rules are met. Two duplicate NRD kernel instances cannot exist in the same block. Transaction Specific Rules: A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless chain head version >= 4. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless chain head version >= 4. A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless it meets the defined relative lock height rule in the next block. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless it meets the defined relative lock height rule in the next block. Two duplicate NRD kernel instances cannot exist in the txpool/stempool concurrently.","title":"Rollout/Deployment (HF3)"},{"location":"grin-rfcs/text/0013-nrd-kernels/#weights-fees","text":"For the purpose of block weight calculations, each kernel is treated as 3 \"weight units\" where each unit is approximately 32 bytes. This covers the excess commitment and the associated signature common across all kernel variants. The additional 2 bytes of \"relative height\" on NRD kernels are ignored for the purposes of calculating block weight. For the purpose of minimum transaction relay fees all kernels are treated as 1 \"fee unit\" with each unit being 1 milligrin. We plan to revisit the entire transaction fee structure in a future RFC. Kernel variants may affect the transaction fee calculations differently in the future.","title":"Weights &amp; Fees"},{"location":"grin-rfcs/text/0013-nrd-kernels/#drawbacks","text":"NRD kernels are a limited and restricted form of \"relative locks\" between kernels. These locks are limited to a period of 7 days and \"fail open\" beyond that window. This approach meets the requirements for limited revocable payment channel operations but there are likely to be use cases where this approach is not sufficient or unsuitable. While it would be nice to provide a fully general purpose solution that would allow arbitrary locks to be implemented, it does appear to be hard, if not impossible, to do this in Grin/MW.","title":"Drawbacks"},{"location":"grin-rfcs/text/0013-nrd-kernels/#rationale-and-alternatives","text":"Referencing historical data in Grin and in Mimblewimble in general is difficult due to the possibility of pruning historical data. It is not possible to reference old outputs once they are spent. Historical validators must have access to any referenced data to validate consensus rules. This leaves transaction kernels as the only available data to be referenced. While arbitrary historical kernels can be referenced this is not desirable as we do not want to impose additional constraints on nodes, requiring them to maintain historical data that would otherwise be prunable. An earlier design iteration was \"No Such Kernel Recently\" (NSKR) locks. Where NRD references were implicit, with duplicate kernel excess commitments, NSKR kernels referenced prior kernels explicitly. These explicit references were problematic for several reasons - Additional overhead, both local storage and network traffic due to the explicit references. Optimization by referencing prior kernel based on MMR position introduced a dependency on external data (kernels can no longer be validated in isolation). Permitting non-existence of references due to limited window of history, opened up a vector for \"spam\" where arbitrary data could be used in place of a valid reference. To prevent \"spam\" a signature can be used to verify the reference was indeed a valid commitment. By including a signature along with the commitment, the reference is effectively a full transaction kernel. The idea of using Merkle proofs to verify inclusion of a historical referenced kernel in the kernel MMR was also considered. This gets expensive both in terms of transaction size and increased verification cost. There is also the problem of position not yet being known at transaction creation time, necessitating Merkle proof generation at block creation time by miners which adds complexity.","title":"Rationale and alternatives"},{"location":"grin-rfcs/text/0013-nrd-kernels/#prior-art","text":"Bitcoin allows transaction inputs to be \"encumbered\" with a relative locktime based on the sequence number field. This restricts an input from spending the associated output until a certain number of blocks have passed. BIP112 describes the CHECKSEQUENCEVERIFY opcode in Bitcoin and BIP68 describes the underlying consensus changes around the sequence number field. Timelock#CheckSequenceVerify (bitcoin wiki) CheckSequenceVerify (bitcoin wiki) Bitcoin BIP-0068 Bitcoin BIP-0112 Note that relative locks in Bitcoin are based on transaction inputs and outputs , with inputs only able to spend outputs once confirmed beneath a certain number of blocks. We cannot do this in Grin due to the pruning of old data. Spent outputs will eventually be removed and cannot be relied upon as part of the validation process. Bitcoin encumbers individual outputs whereas in Grin we encumber transactions via the constituent transaction kernels.","title":"Prior art"},{"location":"grin-rfcs/text/0013-nrd-kernels/#unresolved-questions","text":"Some investigation is still needed around the conditions necessary to allow a kernel to simply be reused with an adjustment to the kernel offset and where an additional kernel is necessary. An adjustment to the kernel offset will expose the private excess under certain conditions and cannot be done safely for all transactions. One outstanding question is what use cases are not covered by NRD kernels. We believe them to be sufficient for the revocable payment channel close mechanism. But they may not be sufficient for all use cases. Succinct Atomic Swaps (SAS) describes the use of both relative locks and adaptor signatures to implement atomic swaps with only two on-chain transactions. The secret associated with the adaptor signature is swapped to allow funds to be claimed while the relative lock locks funds prior to a refund being claimed. We note that NRD kernels and adaptor signatures are not directly compatible as a prior instance of an NRD kernel would have revealed the secret associated with the adaptor signature. That said we can produce transactions with multiple kernels and we can use this to isolate the adaptor signature on a separate kernel alongside an NRD kernel. It is an unresolved question if there is a way to modify the SAS protocol and avoid the need for these additional kernels in Grin/MW.","title":"Unresolved questions"},{"location":"grin-rfcs/text/0013-nrd-kernels/#references","text":"Original \"triggers\" mailing list post by Ruben Somsen \"No Such Kernel Recently\" post by John Tromp \"Duplicate Kernels\" post by Antioch \"NRD based payment channel\" post by John Tromp Earlier NSKR based payment channel design) Timelock#CheckSequenceVerify (bitcoin wiki) CheckSequenceVerify (bitcoin wiki) Bitcoin BIP-0068 Bitcoin BIP-0112 Succinct Atomic Swaps by Ruben Somsen Scriptless Scripts RFC-0005 \"Variable Size Kernels\"","title":"References"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/","text":"Title: general-fund-guidelines Authors: Yeastplume Start date: Feb 07, 2020 RFC PR: Edit if merged: mimblewimble/grin-rfcs#41 Tracking issue: N/A Summary This RFC establishes a set of guidelines for spending the Grin Development Fund, the procedure via which funding requests can be made, and a set of procedures for managing and reporting on the fund. Motivation Previously there were no clear guidelines on how the Grin Development Fund could be spent and what types of activities could and could not be financed from the fund. This RFC presents a set of non-exhaustive guidelines intended to ensure that: Donators have a clear understanding of how their donations are likely to be spent. Those with funding ideas have a clear reference point to understand what types of proposals are likely to be considered for funding. Those with funding ideas have a specific process through which they can apply for funding. The team making spending decisions has clear, community-established guidelines against which to consider new funding requests. The decision-making process through which funding requests are granted is as fair, consistent and transparent as it can reasonably be. The wider community understands how the fund is managed and that transparency is evident. Note that this document does not establish hard-and-fast rules for how the fund's contents can be spent. It is meant to be an indicative focal point for the community, and is intended to evolve with the needs of the project. Community-level explanation Appropriate and inappropriate uses of the Grin Development Fund Although spending decisions will always be made on a case-by-case basis, it is understood that the Grin Development Fund is to be used mainly to finance the development needs of the Grin project and the advancement of Grin/Mimblewimble as a whole. There is scope for interpretation as to what this actually means, but the following presents (non-exhaustive) guidelines as to the types of activities that would be considered appropriate to finance from the fund. Activities related to the continuing development needs of the Grin code-base and related projects under the GitHub mimblewimble organization. This can include: Fixed-term development or project-management contracts Infrastructure and other incidental costs Security audit costs Costs incurred for any legal matters that may arise for either the project or individual contributors arising directly from their work in good faith on the Grin project Running budgets for Grin teams (with funds spent at their own discretion) Technological research in areas that may be relevant to Grin in the future Cryptographic research related to Grin or Mimblewimble in general Fully open-sourced community-based projects that enhance the Grin ecosystem Supporting non-profit, community-driven and inclusive promotional efforts for the Grin Project (e.g. Grincon) Charitable donations toward important causes relevant to the Grin or cryptocurrency communities as a whole While the guidelines above give plenty of flexibility in how funds can be employed toward the advancement of the Grin project, certain types of funding requests will not be considered: Marketing or promotional 'offers' where a party is taking a profit or gains some financial benefit to promote Grin (regardless of how the 'opportunity' is presented) Cryptocurrency speculation or any kind of investment Request for Funding Process All requests for funding should be made in the Governance Section of the Grin forum. Topics should be clearly titled \"Request for Funding: \" followed by a short description of the request. There is no set template for what the contents of the funding request should include, however a better reception can be attained by including: The exact amount requested, what the funding covers and for what time period (if applicable) A clear description of what will be provided to the Grin project in return, including: Details of any work or research that will be performed during the period The expected deliverable, if applicable (for a research project, for instance) Background information on the person making the request Amounts should be stated using fiat currency equivalents with the exact Cryptocurrency amount determined by the rate at the time of transfer. To assist others with conceptualizing the amounts, fiat currencies used should be reasonably global, e.g. USD, EUR, CNY, GBP. All community discussion on the funding request should be made within the forum thread itself, and the final decision on the request will be made by members of the core team at a public governance meeting , to take place at least one week after the request is made. The community is encouraged to display their support (or lack thereof) of a funding request at these Governance meetings, however the decision rests with the core team. It should also be noted that decisions should never be considered final. Those making funding requests are encouraged to revise or refine proposals based on whatever feedback is given during the request process and submit them for consideration again. Decision Process While everyone and anyone is encouraged to create a funding request, those making requests should understand that not all funding decisions will be approved simply on the basis of them conforming to the guidelines above. Many other factors will be considered for each request, including (but not limited to): How well known in the community is the person making the funding request? Have too many similar requests been funded recently? How tangible is the value proposition to Grin? How much risk is involved relative to the size of the ask and the potential return. Does a prioritization call need to be made due to a limited balance in the General Fund? Everyone is welcome to weigh in on the merits of a funding request in the forum thread and during the public governance meeting where the funding request is finalized. The core team will strive to ensure there's a community consensus for each request, however the final decision rests with the core team. Other Grin teams who have been allocated budgets can spend funds at their own discretion, but are strongly encouraged to consider the guidelines in this RFC during their decision making process. Tips on effective proposals You proposal is likely to be better received if you're already known to the Grin community or the wider cryptocurrency community. Even more so if you've already contributed to Grin in some meaningful way. It might be better to keep your initial funding request small and focused, particularly if your idea is something new and radical, or if you're unknown to the Grin community. Be specific, professional and thorough with your proposal. Be respectful and professional in your response to any feedback and criticism on the proposal thread Payout Process At the time of payout, the approved funding amount is converted to the equivalent in cryptocurrency and paid out to an address provided by the funding requestor only. The payout address should be provided to the core team by the requestor via a secure, verifiable channel (with cryptographic proof of identity if deemed necessary). Any conversion rate between the currency of the funding request and the currency that is paid out from the general fund is determined by the prevailing exchange rate at the time of the funding transaction, without exception. To minimize the effects of currency fluctuations on accounting transparency, all payments should be performed at pre-arranged \"signing parties\" in which mu-sig holders sample the current exchange rate. The transaction should be created, signed and broadcast as quickly as possible, with the transaction and rate reported back to the core team for tracking. Mu-sig holders will verify the address provided by the funding requestor several times during transaction creation and broadcasting. However, the core team is not responsible for errors or incorrect addresses provided by the requestor. Reporting The result of all funding decisions will be published in the meeting notes found in the Grin Project Management repository. The core team is obliged to publish a detailed spending log of all transactions made in and out of the fund, as well as quarterly transparency reports summarizing all income and spending. This and other financial reporting can be found in the /grin-pm repository. Unresolved questions This RFC is put together on the understanding that the fundamental question of 'who appoints the core team' is still outstanding. This point should be discussed separately and this RFC assumes there is an acceptable answer in place. Future possibilities Ideas to further improve the funding process include creating a community funding website, where proposals can be made and vetted by the community, and support for particular ideas can be shown. Contributions towards funding could be made by community individuals and be matched with contributions from the general fund. References https://grin.mw/fund https://github.com/mimblewimble/grin-pm/","title":"0014 general-fund-guidelines"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#summary","text":"This RFC establishes a set of guidelines for spending the Grin Development Fund, the procedure via which funding requests can be made, and a set of procedures for managing and reporting on the fund.","title":"Summary"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#motivation","text":"Previously there were no clear guidelines on how the Grin Development Fund could be spent and what types of activities could and could not be financed from the fund. This RFC presents a set of non-exhaustive guidelines intended to ensure that: Donators have a clear understanding of how their donations are likely to be spent. Those with funding ideas have a clear reference point to understand what types of proposals are likely to be considered for funding. Those with funding ideas have a specific process through which they can apply for funding. The team making spending decisions has clear, community-established guidelines against which to consider new funding requests. The decision-making process through which funding requests are granted is as fair, consistent and transparent as it can reasonably be. The wider community understands how the fund is managed and that transparency is evident. Note that this document does not establish hard-and-fast rules for how the fund's contents can be spent. It is meant to be an indicative focal point for the community, and is intended to evolve with the needs of the project.","title":"Motivation"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#community-level-explanation","text":"","title":"Community-level explanation"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#appropriate-and-inappropriate-uses-of-the-grin-development-fund","text":"Although spending decisions will always be made on a case-by-case basis, it is understood that the Grin Development Fund is to be used mainly to finance the development needs of the Grin project and the advancement of Grin/Mimblewimble as a whole. There is scope for interpretation as to what this actually means, but the following presents (non-exhaustive) guidelines as to the types of activities that would be considered appropriate to finance from the fund. Activities related to the continuing development needs of the Grin code-base and related projects under the GitHub mimblewimble organization. This can include: Fixed-term development or project-management contracts Infrastructure and other incidental costs Security audit costs Costs incurred for any legal matters that may arise for either the project or individual contributors arising directly from their work in good faith on the Grin project Running budgets for Grin teams (with funds spent at their own discretion) Technological research in areas that may be relevant to Grin in the future Cryptographic research related to Grin or Mimblewimble in general Fully open-sourced community-based projects that enhance the Grin ecosystem Supporting non-profit, community-driven and inclusive promotional efforts for the Grin Project (e.g. Grincon) Charitable donations toward important causes relevant to the Grin or cryptocurrency communities as a whole While the guidelines above give plenty of flexibility in how funds can be employed toward the advancement of the Grin project, certain types of funding requests will not be considered: Marketing or promotional 'offers' where a party is taking a profit or gains some financial benefit to promote Grin (regardless of how the 'opportunity' is presented) Cryptocurrency speculation or any kind of investment","title":"Appropriate and inappropriate uses of the Grin Development Fund"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#request-for-funding-process","text":"All requests for funding should be made in the Governance Section of the Grin forum. Topics should be clearly titled \"Request for Funding: \" followed by a short description of the request. There is no set template for what the contents of the funding request should include, however a better reception can be attained by including: The exact amount requested, what the funding covers and for what time period (if applicable) A clear description of what will be provided to the Grin project in return, including: Details of any work or research that will be performed during the period The expected deliverable, if applicable (for a research project, for instance) Background information on the person making the request Amounts should be stated using fiat currency equivalents with the exact Cryptocurrency amount determined by the rate at the time of transfer. To assist others with conceptualizing the amounts, fiat currencies used should be reasonably global, e.g. USD, EUR, CNY, GBP. All community discussion on the funding request should be made within the forum thread itself, and the final decision on the request will be made by members of the core team at a public governance meeting , to take place at least one week after the request is made. The community is encouraged to display their support (or lack thereof) of a funding request at these Governance meetings, however the decision rests with the core team. It should also be noted that decisions should never be considered final. Those making funding requests are encouraged to revise or refine proposals based on whatever feedback is given during the request process and submit them for consideration again.","title":"Request for Funding Process"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#decision-process","text":"While everyone and anyone is encouraged to create a funding request, those making requests should understand that not all funding decisions will be approved simply on the basis of them conforming to the guidelines above. Many other factors will be considered for each request, including (but not limited to): How well known in the community is the person making the funding request? Have too many similar requests been funded recently? How tangible is the value proposition to Grin? How much risk is involved relative to the size of the ask and the potential return. Does a prioritization call need to be made due to a limited balance in the General Fund? Everyone is welcome to weigh in on the merits of a funding request in the forum thread and during the public governance meeting where the funding request is finalized. The core team will strive to ensure there's a community consensus for each request, however the final decision rests with the core team. Other Grin teams who have been allocated budgets can spend funds at their own discretion, but are strongly encouraged to consider the guidelines in this RFC during their decision making process.","title":"Decision Process"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#tips-on-effective-proposals","text":"You proposal is likely to be better received if you're already known to the Grin community or the wider cryptocurrency community. Even more so if you've already contributed to Grin in some meaningful way. It might be better to keep your initial funding request small and focused, particularly if your idea is something new and radical, or if you're unknown to the Grin community. Be specific, professional and thorough with your proposal. Be respectful and professional in your response to any feedback and criticism on the proposal thread","title":"Tips on effective proposals"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#payout-process","text":"At the time of payout, the approved funding amount is converted to the equivalent in cryptocurrency and paid out to an address provided by the funding requestor only. The payout address should be provided to the core team by the requestor via a secure, verifiable channel (with cryptographic proof of identity if deemed necessary). Any conversion rate between the currency of the funding request and the currency that is paid out from the general fund is determined by the prevailing exchange rate at the time of the funding transaction, without exception. To minimize the effects of currency fluctuations on accounting transparency, all payments should be performed at pre-arranged \"signing parties\" in which mu-sig holders sample the current exchange rate. The transaction should be created, signed and broadcast as quickly as possible, with the transaction and rate reported back to the core team for tracking. Mu-sig holders will verify the address provided by the funding requestor several times during transaction creation and broadcasting. However, the core team is not responsible for errors or incorrect addresses provided by the requestor.","title":"Payout Process"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#reporting","text":"The result of all funding decisions will be published in the meeting notes found in the Grin Project Management repository. The core team is obliged to publish a detailed spending log of all transactions made in and out of the fund, as well as quarterly transparency reports summarizing all income and spending. This and other financial reporting can be found in the /grin-pm repository.","title":"Reporting"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#unresolved-questions","text":"This RFC is put together on the understanding that the fundamental question of 'who appoints the core team' is still outstanding. This point should be discussed separately and this RFC assumes there is an acceptable answer in place.","title":"Unresolved questions"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#future-possibilities","text":"Ideas to further improve the funding process include creating a community funding website, where proposals can be made and vetted by the community, and support for particular ideas can be shown. Contributions towards funding could be made by community individuals and be matched with contributions from the general fund.","title":"Future possibilities"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#references","text":"https://grin.mw/fund https://github.com/mimblewimble/grin-pm/","title":"References"},{"location":"grin-rfcs/text/0015-slatepack/","text":"Title: Slatepack Authors: joltz Start date: May 07 2020 RFC PR: mimblewimble/grin-rfcs#55 Tracking issue: mimblewimble/grin-wallet#406 Summary Slatepack is a universal transaction standard for Grin. It is designed to provide a single coherent transaction building framework to improve both the user and developer experiences in the Grin ecosystem. All wallets and services are expected to fully support the Slatepack standard by the last scheduled hard fork in January 2021 to remain compatible. This document specifies the required components of the Slatepack standard and introduces them in the context of existing methods for transaction building in Grin. It assumes that Slatepack is the default supported transaction standard for Grin and is intended to operate under all conditions and edge cases. Slatepack is intended to be compatible with the objects and serialization methods defined in the Slate V4/Compact Slates RFC. This RFC is meant to replace the Slate Serialization , Armored Slates and Encrypted Slates RFCs. Motivation Without a comprehensive transaction building flow, users and services are left to make their own complicated decisions about firewalls, file handling and compatibility, risking their security, privacy and sanity. The objective of this RFC is to converge on a simple, universal, adoptable, secure and privacy preserving workflow standard for Grin transactions: Slatepack. Community-level explanation Slatepack changes the existing transaction building process in Grin in a few ways: Users, developers and services are no longer required to choose between many possible transaction methods to use and support: Slatepack is a universal Grin transaction standard The transport method decision now occurs automatically for the user by following the Slatepack standard There is only one synchronous method and one asynchronous method supported by default to keep things simple for developers and support workers Tor is the only synchronous transaction transport method that is currently supported in the Slatepack standard This happens \"under the hood\" by the wallet and the user only has to keep track of a SlatepackAddress for their counterparty If Tor is not successful, the transaction process automatically falls back to using an encrypted copy and pastable SlatepackMessage string to complete the transaction asynchronously The asynchronous method by default is now a copy and pastable SlatepackMessage string instead of a file SlatepackMessage is an ascii-armor string that supports encryption of its payload with a SlatepackAddress An encrypted SlatepackMessage is not meaningfully larger than a plain text SlatepackMessage with regard to transportability as proposed here The difference between synchronous and asynchronous transaction methods is abstracted away from the end user with the Slatepack standard grin-wallet send -d SlatepackAddress 1.337 will first try to send the Grin synchronously via Tor to the SlatepackAddress If that fails it will fall back to outputting an armored encrypted SlatepackMessage string for manual copy and paste transport Example SlatepackAddress : grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x Asynchronous transactions are now encrypted by default by knowing the SlatepackAddress of your counterparty(s) If a counterparty is unwilling or unable to provide a SlatepackAddress , a plain text SlatepackMessage can still be exchanged Sending a mobile Grin transaction should be as easy as scanning a simple QR encoded from a bech32 SlatepackAddress Or as easy as pasting the SlatepackAddress of your counterparty into your wallet for any other device Or if Tor is not accessible, or the receiving party is not online, as easy as copying and pasting a couple of SlatepackMessage strings with a counterparty in an alternative communication channel (email, forum, social media, instant messenger, generic web text box, carrier pigeon etc.) Reference-level explanation The Slatepack standard defines the three primary components: SlatepackAddress , SlatepackMessage and SlatepackWorkflow . The SlatepackAddress is a shareable bech32 encoded ed25519 public key that can be used both to route synchronous transactions and to encrypt asynchronous transactions . The SlatepackMessage is an easily copy and pastable ascii-armor string that contains an encrypted slate payload by default and is used in asynchronous transactions. The SlatepackWorkflow specifies how both of these components interact in a universally adoptable transaction standard for Grin. SlatepackAddress A SlatepackAddress is a bech32 encoded ed25519 public key and when shared with other parties is used to represent the ability to receive Grin transactions. grin-wallet already handles ed25519 keys for the v3 onion addresses in Tor transactions. These keys can be extended to be a general SlatepackAddress to allow a universal key format for both transport and encryption that is error-checked, QR friendly and easily human identifiable. Existing ed25519 public keys from the wallet are bech32 encoded with grin as the human-readable part to build a SlatepackAddress tgrin is the HRP for a floonet SlatepackAddress A SlatepackAddress can be decoded to its ed25519 public key which can then be mapped to an x25519 public key to be used for encryption By default, all wallets should generate a new SlatepackAddress for each transaction for improved user privacy and security. Wallets can optionally support the ability for a static, reusable receiving SlatepackAddress with a warning about the privacy risks of reusing these addresses. The exact proposal for the implementation of simulatenous active SlatepackAddresses to enforce address uniqueness by default according to this standard is left as an implementation detail to wallets to ensure that wallets can interactively receive Grin across many SlatepackAddresses simulataneously and efficiently. ed25519 keys are bech32 encoded as SlatepackAddresses rather than x25519 keys because the mapping from ed25519 to x25519 is more straightforward (x25519 public keys do not carry a v coordinate so they can map to two possible ed25519 public keys- this is solvable but using the ed25519 as the first order key avoids a potentially complex solution). Key Generation Keys used in SlatepackAddresses are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys used to derive Tor onion addresses. ed25519 keys used for a SlatepackAddress are derived from this second derivation path of the master seed. SlatepackAddress keys may be derived in parallel to the blinding factor derivation path such that a unique SlatepackAddress is derived each time a new blinding factor is derived for a transaction to satisfy the requirement for a unique SlatepackAddress to be used for each transaction by default. In a future update it may be desirable to encode the derivation path for the SlatepackAddress for a given encrypted SlatepackMessage somewhere so that the x25519 decryption keys can be derived without grinding down the path to find the right key to use. Example SlatepackAddress grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x SlatepackMessage A SlatepackMessage requires multiple layers of data and encoding. Serialization Grin slates are serialized as first order JSON objects. Binary serialization is done on those JSON objects. Before Slatepack, users could use both binary and JSON serialization for asynchronous transactions. With the Slatepack standard, all asynchronous transactions serialize the slate JSON objects as binary. JSON serialization for synchronous transactions (Tor) is still used as before. The Slatepack standard serialization choices are only relevant for asynchronous transaction methods. The details for the binary serialization of the most recent slates at the time of this writing can be found in the Slate V4 (Compact Slates) RFC. Future variations in slate binary serialization should be referenced in an RFC and may require the update of this document. Plain Text Metadata Plain text metadata is included with Slatepack messages to indicate how to handle the encryption if any for the slate data in addition to tracking versions for compatibility. It can be expanded in future versions with new fields that are safe to include as plain text. These fields are neither encrypted nor authenticated. \"slatepack\": [Major, Minor] Where [Major, Minor] are positive fixnum ints representing the Slatepack version used to build the SlatepackMessage \"mode\": int Where int is a positive fixnum int indicating the type of SlatepackMessage 0 == plain text 1 == encrypted Extendable to future new modes (e.g. multiparty) Indicates which additional metadata fields should be expected to follow \"sender\": SlatepackAddress Only used here where mode == 0 , otherwise this field is encrypted as described below Where SlatepackAddress is a bech32 encoded ed25519 public key generated by the sender's wallet For Slatepacks where the user does not wish to provide any SlatepackAddress a 0 value is used This value is used in the SlatepackWorkflow to attempt to complete the transaction via Tor and to otherwise encrypt a slate for asynchronous transport Encrypted Metadata Encrypted metadata is included with an encrypted SlatepackMessage to improve privacy for the sender of a Slatepack transaction in cases where Tor is not available. It is a basic structure containing the sender SlatepackAddress and potential recipients_list field for multiparty use to be encrypted by age. If these fields are included as plain text metadata, they would require an additional MAC field for authentication and reveal data that would be desirable to keep private. Note that recipients_list does not gain the same privacy advantages of the sender field because the values can be derived from the plain text data included in the age header with a bit of work. \"sender\": SlatepackAddress Used to complete the SlatepackWorkflow \"recipients_list\": vec<SlatepackAddress> Only included in multiparty encrypted mode for use in future versions Array of recipients such that each recipients SlatepackAddress in recipients_list matches their associated epk and emk by index in the age encryption header of the encrypted payload E.g. \"recipients_list\": [grin1a, grin1b] , \"age_header_recipients\": [(X25519, EPKa, EMKa), (X25519, EPKb, EMKb)] grin1a and (X25519, EPKa, EMKa) both belong to the same party as they are both at index 0 grin1b and (X25519, EPKb, EMKb) both belong to the same party as they are both at index 1 Encryption Slatepack encryption adheres to the cryptography decisions made by age . It supports a conversion from the ed25519 signing key type that grin-wallet already uses for Tor to a x25519 encryption key type that age uses for encryption. This allows us to avoid having to make new cryptography decisions to support encrypted slates with keys already used in grin-wallet. While Slatepack adheres to the cryptography decisions and payload structure choices made by age in its encrypted payloads, this data alone is not sufficient to handle all possible SlatepackWorkflow steps (because the age recipient header data contains x25519 keys, we want ed25519 keys for the workflow as key mapping in the other direction is not desirable). It should also be noted that a SlatepackAddress could be used to do generic age encryption by decoding the bech32 to the ed25519 public key and mapping that to its corresponding x25519 public key used in age. An age Address could also be used as a SlatepackAddress with some extra effort: bech32 decode to the x25519 public key and then follow Signal's lead to attempt to solve the problem of an x25519 key mapping to two ed25519 keys to give a single ed25519 public key to be used to build a SlatepackAddress by bech32 encoding with slatepack as the HRP. Payload (age Encryption) A binary serialized slate and associated Encrypted Metadata fields are concatenated and encrypted according to the age encryption specification. The steps taken here follow age as closely as possible to avoid losing any security properties. A fairly well-reviewed age library in rust is available to use for implementation. Any deviations in Slatepack encryption from the exact cryptography steps and decisions made in age are unintentional and should be corrected unless they are explicitly stated as a deviation from the cryptography decisions made by age. An encrypted Slatepack payload is built with the same steps as an encrypted age payload, where the X25519 keys are derived from a participants SlatepackAddress . E.g. age_encrypt(sender + slate_binary) where mode == 1 and sender is a valid SlatepackAddress Armor The payload that will be armored is an optionally encrypted, binary serialized Slatepack JSON object and any associated encrypted metadata. Armor is Framing wrapped around a SimpleBase58Check encoded Payload . Framing Armor uses specific Headers , Footers and Periods as Framing to contain its Payload . Header Supported Headers: BEGINSLATEPACK Regex: ^[>\\n\\r\\t ]*BEGINSLATEPACK[>\\n\\r\\t ]*$ Footer Supported Footers ENDSLATEPACK Regex: ^[>\\n\\r\\t ]*ENDSLATEPACK[>\\n\\r\\t ]*$ Periods All data of an armored slate up to the first . is the framing header All data after the first . and before the second . is the SimpleBase58Check encoded payload which contains the slate data All data after the second . and before the third . is the framing footer Any data after the third . is ignored SimpleBase58Check Encoding SlatepackMessage armor payloads are encoded similar to legacy bitcoin addresses, with the primary differences being that the SimpleBase58Check used here does not include version bytes and includes the error checking code at the beginning of the payload instead of at the end. SHA256(SHA256(SLATEPACK_MESSAGE_BINARY)) First four bytes from previous step are ERROR_CHECK_CODE Concatenate ERROR_CHECK_CODE + SLATEPACK_MESSAGE_BINARY Base58 encode the output from the previous step to complete the armor Payload It should be noted that the ERROR_CHECK_CODE does not have a robust error checking ability because a double sha256 hash is not a proper error check code and the encoding scheme itself was meant to be used for bitcoin addresses which are much smaller than slate payloads. A more robust error correction option was not chosen here because the consequences of the failure to detect an error are not as severe as they would be for a bitcoin address as further validation would need to occur for Grin. The purpose is to catch some characters being accidentally added or lost during armor transport rather than preventing a spend to an address we don't know the key to spend from. Formatting WORD_LENGTH : 15 Number of SimpleBase58Check encoded characters per word; chosen for human readability across device screen sizes LINE_BREAK : 200 words Number of words of WORD_LENGTH to include before inserting a newline; chosen for user friendliness in terminals and messaging applications MAX_STRING_SIZE : 1MB Maximum size for an armored SlatepackMessage string without requiring a file container If a SlatepackMessage exceeds this value it must be handled as a .slatepack file instead of a string This parameter chosen to cover as many cases as possible and still be supported by most clipboards WORD_LENGTH and LINE_BREAK parameters are adjustable as a formatting convenience. MAX_STRING_SIZE is fixed and cannot be exceeded without wrapping the armored SlatepackMessage in a .slatepack file. Edge Case: Large Slates (>1MB) Some slate payloads may be so large that they cannot be reliably handled across all clipboards. To handle these edge cases, a SlatepackMessage will be expected to be passed in a .slatepack file format in cases where Tor is unsuccessful and the armored SlatepackMessage string output would exceed 1MB. A file format was chosen as opposed to a multi-part message approach because messages are already written to file by default by grin-wallet and they are potentially simpler to handle from an implementation perspective. While wallets must support handling these edge cases to avoid all possible cases where a wallet cannot spend or receive a valid transaction, it would be reasonable for services and exchanges to support the Slatepack standard without the requirement of handling the rare file edge case. Example Slatepack JSON Object Mode 0: Plain Text In this plain text example, neither the sender nor the receiver wish to share a SlatepackAddress { \"slatepack\": [1, 0], \"mode\": 0, \"sender\": \"0\", \"payload\": <binary serialized slate> } Mode 1: Encrypted { \"slatepack\": [1, 0], \"mode\": 1, \"payload\": <age encrypted binary: sender slatepack address + binary serialized slate>, } Example SlatepackMessage BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv pcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY GWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx wNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK. SlatepackWorkflow Adoption of the Slatepack standard allows for a unified workflow that can still function without knowledge of a SlatepackAddress from a counterparty. With a SlatepackAddress grin-wallet send -d grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x 1.337 Sender wallet derives an onion v3 address from grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x and attempts to complete the transaction synchronously via Tor (Fallback) If the synchronous transaction fails, a SlatepackMessage string is encrypted to the SlatepackAddress and output for manual asynchronous transport by the user Without a SlatepackAddress grin-wallet send 1.337 A SlatepackMessage string is output for manual asynchronous transport by the user With QR Codes A QR-based SlatepackWorkflow will always begin with a standard QR size because they are encoded directly from a bech32 SlatepackAddress . This encoding simultaneously provides a derivable onion address to attempt a synchronous transaction ( bech32 -> ed25519 -> onionv3 ) and a derivable encryption key ( bech32 -> ed25519 -> x25519 ) to return an encrypted Slatepack string to complete the transaction asynchronously as a fallback. As a consequence, a SlatepackAddress must be revealed by the party producing a QR code in the SlatepackWorkflow . Receiver shares SlatepackAddress via QR Sender scans QR code and the transaction is completed synchronously via Tor by deriving the recipient's onion v3 address from their SlatepackAddress (Fallback) If the synchronous transaction fails, a SlatepackMessage string is output for manual asynchronous transport by the user With Three or More Parties Some possible future Slatepack transactions may require more than two parties to successfully build. These cases should not require any breaking changes to the core Slatepack standard workflow. The exact flow order (round-robin etc) will be defined by the accompanying RFCs that define the possible future multiple party slates themselves. In some cases, new slate versions may require (non-breaking) updates to this RFC. From there, the same standard Slatepack standard workflow of attempting to exchange the data via Tor first with an ascii armor fallback is still valid. For example, a future Slatepack version will add support for an array containing a SlatepackAddress for each party in the order desired to finish building the transaction. The wallet of each subsequent party will attempt to establish a connection with the next via Tor. In the event of a Tor failure it would be the responsibility of the most recent party to manually transport it to the next. In cases with many parties, the fallback method of the Slatepack standard could quickly become cumbersome if, for example, every third participant fails to achieve a Tor connection. Implementation Timeline Initial Slatepack implementation introduced with the July 2020 hard fork May or may not support encryption by default yet The proposed Slatepack standard is fully implemented and adopted as a universal transaction standard in last hard fork (Jan 2021) Slatepack is the default transaction standard in all wallets and services Drawbacks This puts a lot of eggs in one basket (if Slatepack fails there will likely be confusion returning to old methods) This may be a bit rushed to have where we want it before HF schedule Deprecating HTTP(S) is already a major change- by requiring the adoption of this completely new standard in addition we risk putting a lot of effort on the shoulders of existing services in the Grin ecosystem Rationale and alternatives By adding new options without simplifying the workflow for users we risk confusion and friction We could just add an option for copy and pastable slates instead of introducing an entirely new universal transaction flow standard Prior art Note that while previous asynchronous Mimblewimble transaction solutions require a relatively short TTL for a counterparty to successfully connect to their respective network before transactions fail (currently 72 hours for Tari DHT Network, 24 hours for Beam SBBS), Grin Slatepack transactions can remain valid indefinitely without spamming the network when using the ascii armor fallback. Tari Tari uses the Tari DHT Network to support asynchronous Mimblewimble transactions. This approach is comprehensive and comprises of the entire peer to peer messaging network, including both nodes and wallets. This is distinct from Slatepack which is strictly an approach to transaction building between wallet software, not general protocol messaging. Similar to Slatepack, Tari users derive a public key from their master seed (which is represented to users as emojis instead of bech32) and is used to look up peers in peer databases (as opposed to directly routing to a traditional Tor hidden service as in Slatepack). By default, Tari, like Slatepack, uses Tor for communication. While Slatepack and Tari both have addresses that decode to public keys used to find and communicate with counterparty wallets via Tor, they both handle the Tor failure case differently. Tari seems to rely on its custom DHT network to gracefully handle this at the cost of the complexity of a custom DHT layer. Slatepack falls back to an unopinionated, encrypted ascii armor string for the user to transport \"outside of the Grin network\" to complete the transaction. The advantage for Slatepack is significantly reduced complexity by using Tor directly with an unopinionated fallback mode. The disadvantage for Slatepack is that transactions don't \"magically\" just work if Tor communication is failing- they still require some effort from the user to transport the ascii armor themselves. Note that these details were taken from early documentation and not code- transactions in Tari may behave differently in practice. Beam Beam uses the SBBS gossip protocol to support asynchronous mimblewimble transactions. SBBS adds a nontrivial amount of complexity and attack surface to the core Beam software. In exchange, Beam receives a somewhat user-friendly mechanism for users to build transactions asynchronously. The asynchronous fallback method for Slatepack transactions is a simple ascii armor string that does not contain an opinion about a particular protocol with which to exchange the data. The advantage with the Slatepack method is that much less code is required to support these transactions which can improve the overall stability and security of the codebase running the Grin network. The disadvantage of this for Slatepack is that asynchronous transactions don't \"magically\" work- they still need to be between users via an outside channel (instant message, text box, email etc). Slatepack makes the tradeoff of slightly more work for the end user in exchange for a simpler and potentially more secure network for Grin. Unresolved questions How to handle key derivation harmoniously? What are unmentioned security considerations for using the same base key to both map to an onion address and map to an encryption key used in transactions? Related, what are unmentioned security considerations to SlatepackAddress reuse? Should we still use double-sha256 in SimpleBase58Check or take the opportunity to use a BCH or CRC code which may be more appropriate for error detection on slatepack messages? Is additional engineering desired here if there will always be further validation of the slate payload before a spend can occur? If addresses are not reused by default and since wallets need to be able to conduct multiple transactions in parallel, they need the ability to listen on all \"active\" addresses at the same time Future possibilities Extended to support future modes (payment channel, payjoin, multiple counterparties etc) An entirely different standard could be adopted in the future if non-interactive transactions become the default, eliminating the need for Slatepack It might be possible for a new standard to remain compatible with the existing SlatepackAddress to allow a more generic GrinAddress References https://en.bitcoin.it/wiki/BIP_0173 https://docs.google.com/document/d/11yHom20CrsuX8KQJXBBw04s80Unjv8zCg_A7sPAX_9Y/preview# https://github.com/str4d/rage/blob/master/age https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/ https://libsodium.gitbook.io/doc/advanced/ed25519-curve25519 https://blog.filippo.io/using-ed25519-keys-for-encryption/ https://github.com/mimblewimble/grin-rfcs/pull/53 https://saltpack.org https://github.com/mimblewimble/grin-rfcs/pull/50 https://gitweb.torproject.org/torspec.git/tree/rend-spec-v3.txt https://signal.org/docs/specifications/xeddsa/ https://www.tari.com/lessons/02_how_tari_works.html https://github.com/BeamMW/beam/wiki/Secure-bulletin-board-system-(SBBS)","title":"0015 slatepack"},{"location":"grin-rfcs/text/0015-slatepack/#summary","text":"Slatepack is a universal transaction standard for Grin. It is designed to provide a single coherent transaction building framework to improve both the user and developer experiences in the Grin ecosystem. All wallets and services are expected to fully support the Slatepack standard by the last scheduled hard fork in January 2021 to remain compatible. This document specifies the required components of the Slatepack standard and introduces them in the context of existing methods for transaction building in Grin. It assumes that Slatepack is the default supported transaction standard for Grin and is intended to operate under all conditions and edge cases. Slatepack is intended to be compatible with the objects and serialization methods defined in the Slate V4/Compact Slates RFC. This RFC is meant to replace the Slate Serialization , Armored Slates and Encrypted Slates RFCs.","title":"Summary"},{"location":"grin-rfcs/text/0015-slatepack/#motivation","text":"Without a comprehensive transaction building flow, users and services are left to make their own complicated decisions about firewalls, file handling and compatibility, risking their security, privacy and sanity. The objective of this RFC is to converge on a simple, universal, adoptable, secure and privacy preserving workflow standard for Grin transactions: Slatepack.","title":"Motivation"},{"location":"grin-rfcs/text/0015-slatepack/#community-level-explanation","text":"Slatepack changes the existing transaction building process in Grin in a few ways: Users, developers and services are no longer required to choose between many possible transaction methods to use and support: Slatepack is a universal Grin transaction standard The transport method decision now occurs automatically for the user by following the Slatepack standard There is only one synchronous method and one asynchronous method supported by default to keep things simple for developers and support workers Tor is the only synchronous transaction transport method that is currently supported in the Slatepack standard This happens \"under the hood\" by the wallet and the user only has to keep track of a SlatepackAddress for their counterparty If Tor is not successful, the transaction process automatically falls back to using an encrypted copy and pastable SlatepackMessage string to complete the transaction asynchronously The asynchronous method by default is now a copy and pastable SlatepackMessage string instead of a file SlatepackMessage is an ascii-armor string that supports encryption of its payload with a SlatepackAddress An encrypted SlatepackMessage is not meaningfully larger than a plain text SlatepackMessage with regard to transportability as proposed here The difference between synchronous and asynchronous transaction methods is abstracted away from the end user with the Slatepack standard grin-wallet send -d SlatepackAddress 1.337 will first try to send the Grin synchronously via Tor to the SlatepackAddress If that fails it will fall back to outputting an armored encrypted SlatepackMessage string for manual copy and paste transport Example SlatepackAddress : grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x Asynchronous transactions are now encrypted by default by knowing the SlatepackAddress of your counterparty(s) If a counterparty is unwilling or unable to provide a SlatepackAddress , a plain text SlatepackMessage can still be exchanged Sending a mobile Grin transaction should be as easy as scanning a simple QR encoded from a bech32 SlatepackAddress Or as easy as pasting the SlatepackAddress of your counterparty into your wallet for any other device Or if Tor is not accessible, or the receiving party is not online, as easy as copying and pasting a couple of SlatepackMessage strings with a counterparty in an alternative communication channel (email, forum, social media, instant messenger, generic web text box, carrier pigeon etc.)","title":"Community-level explanation"},{"location":"grin-rfcs/text/0015-slatepack/#reference-level-explanation","text":"The Slatepack standard defines the three primary components: SlatepackAddress , SlatepackMessage and SlatepackWorkflow . The SlatepackAddress is a shareable bech32 encoded ed25519 public key that can be used both to route synchronous transactions and to encrypt asynchronous transactions . The SlatepackMessage is an easily copy and pastable ascii-armor string that contains an encrypted slate payload by default and is used in asynchronous transactions. The SlatepackWorkflow specifies how both of these components interact in a universally adoptable transaction standard for Grin.","title":"Reference-level explanation"},{"location":"grin-rfcs/text/0015-slatepack/#slatepackaddress","text":"A SlatepackAddress is a bech32 encoded ed25519 public key and when shared with other parties is used to represent the ability to receive Grin transactions. grin-wallet already handles ed25519 keys for the v3 onion addresses in Tor transactions. These keys can be extended to be a general SlatepackAddress to allow a universal key format for both transport and encryption that is error-checked, QR friendly and easily human identifiable. Existing ed25519 public keys from the wallet are bech32 encoded with grin as the human-readable part to build a SlatepackAddress tgrin is the HRP for a floonet SlatepackAddress A SlatepackAddress can be decoded to its ed25519 public key which can then be mapped to an x25519 public key to be used for encryption By default, all wallets should generate a new SlatepackAddress for each transaction for improved user privacy and security. Wallets can optionally support the ability for a static, reusable receiving SlatepackAddress with a warning about the privacy risks of reusing these addresses. The exact proposal for the implementation of simulatenous active SlatepackAddresses to enforce address uniqueness by default according to this standard is left as an implementation detail to wallets to ensure that wallets can interactively receive Grin across many SlatepackAddresses simulataneously and efficiently. ed25519 keys are bech32 encoded as SlatepackAddresses rather than x25519 keys because the mapping from ed25519 to x25519 is more straightforward (x25519 public keys do not carry a v coordinate so they can map to two possible ed25519 public keys- this is solvable but using the ed25519 as the first order key avoids a potentially complex solution).","title":"SlatepackAddress"},{"location":"grin-rfcs/text/0015-slatepack/#key-generation","text":"Keys used in SlatepackAddresses are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys used to derive Tor onion addresses. ed25519 keys used for a SlatepackAddress are derived from this second derivation path of the master seed. SlatepackAddress keys may be derived in parallel to the blinding factor derivation path such that a unique SlatepackAddress is derived each time a new blinding factor is derived for a transaction to satisfy the requirement for a unique SlatepackAddress to be used for each transaction by default. In a future update it may be desirable to encode the derivation path for the SlatepackAddress for a given encrypted SlatepackMessage somewhere so that the x25519 decryption keys can be derived without grinding down the path to find the right key to use.","title":"Key Generation"},{"location":"grin-rfcs/text/0015-slatepack/#example-slatepackaddress","text":"grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x","title":"Example SlatepackAddress"},{"location":"grin-rfcs/text/0015-slatepack/#slatepackmessage","text":"A SlatepackMessage requires multiple layers of data and encoding.","title":"SlatepackMessage"},{"location":"grin-rfcs/text/0015-slatepack/#serialization","text":"Grin slates are serialized as first order JSON objects. Binary serialization is done on those JSON objects. Before Slatepack, users could use both binary and JSON serialization for asynchronous transactions. With the Slatepack standard, all asynchronous transactions serialize the slate JSON objects as binary. JSON serialization for synchronous transactions (Tor) is still used as before. The Slatepack standard serialization choices are only relevant for asynchronous transaction methods. The details for the binary serialization of the most recent slates at the time of this writing can be found in the Slate V4 (Compact Slates) RFC. Future variations in slate binary serialization should be referenced in an RFC and may require the update of this document.","title":"Serialization"},{"location":"grin-rfcs/text/0015-slatepack/#plain-text-metadata","text":"Plain text metadata is included with Slatepack messages to indicate how to handle the encryption if any for the slate data in addition to tracking versions for compatibility. It can be expanded in future versions with new fields that are safe to include as plain text. These fields are neither encrypted nor authenticated. \"slatepack\": [Major, Minor] Where [Major, Minor] are positive fixnum ints representing the Slatepack version used to build the SlatepackMessage \"mode\": int Where int is a positive fixnum int indicating the type of SlatepackMessage 0 == plain text 1 == encrypted Extendable to future new modes (e.g. multiparty) Indicates which additional metadata fields should be expected to follow \"sender\": SlatepackAddress Only used here where mode == 0 , otherwise this field is encrypted as described below Where SlatepackAddress is a bech32 encoded ed25519 public key generated by the sender's wallet For Slatepacks where the user does not wish to provide any SlatepackAddress a 0 value is used This value is used in the SlatepackWorkflow to attempt to complete the transaction via Tor and to otherwise encrypt a slate for asynchronous transport","title":"Plain Text Metadata"},{"location":"grin-rfcs/text/0015-slatepack/#encrypted-metadata","text":"Encrypted metadata is included with an encrypted SlatepackMessage to improve privacy for the sender of a Slatepack transaction in cases where Tor is not available. It is a basic structure containing the sender SlatepackAddress and potential recipients_list field for multiparty use to be encrypted by age. If these fields are included as plain text metadata, they would require an additional MAC field for authentication and reveal data that would be desirable to keep private. Note that recipients_list does not gain the same privacy advantages of the sender field because the values can be derived from the plain text data included in the age header with a bit of work. \"sender\": SlatepackAddress Used to complete the SlatepackWorkflow \"recipients_list\": vec<SlatepackAddress> Only included in multiparty encrypted mode for use in future versions Array of recipients such that each recipients SlatepackAddress in recipients_list matches their associated epk and emk by index in the age encryption header of the encrypted payload E.g. \"recipients_list\": [grin1a, grin1b] , \"age_header_recipients\": [(X25519, EPKa, EMKa), (X25519, EPKb, EMKb)] grin1a and (X25519, EPKa, EMKa) both belong to the same party as they are both at index 0 grin1b and (X25519, EPKb, EMKb) both belong to the same party as they are both at index 1","title":"Encrypted Metadata"},{"location":"grin-rfcs/text/0015-slatepack/#encryption","text":"Slatepack encryption adheres to the cryptography decisions made by age . It supports a conversion from the ed25519 signing key type that grin-wallet already uses for Tor to a x25519 encryption key type that age uses for encryption. This allows us to avoid having to make new cryptography decisions to support encrypted slates with keys already used in grin-wallet. While Slatepack adheres to the cryptography decisions and payload structure choices made by age in its encrypted payloads, this data alone is not sufficient to handle all possible SlatepackWorkflow steps (because the age recipient header data contains x25519 keys, we want ed25519 keys for the workflow as key mapping in the other direction is not desirable). It should also be noted that a SlatepackAddress could be used to do generic age encryption by decoding the bech32 to the ed25519 public key and mapping that to its corresponding x25519 public key used in age. An age Address could also be used as a SlatepackAddress with some extra effort: bech32 decode to the x25519 public key and then follow Signal's lead to attempt to solve the problem of an x25519 key mapping to two ed25519 keys to give a single ed25519 public key to be used to build a SlatepackAddress by bech32 encoding with slatepack as the HRP.","title":"Encryption"},{"location":"grin-rfcs/text/0015-slatepack/#payload-age-encryption","text":"A binary serialized slate and associated Encrypted Metadata fields are concatenated and encrypted according to the age encryption specification. The steps taken here follow age as closely as possible to avoid losing any security properties. A fairly well-reviewed age library in rust is available to use for implementation. Any deviations in Slatepack encryption from the exact cryptography steps and decisions made in age are unintentional and should be corrected unless they are explicitly stated as a deviation from the cryptography decisions made by age. An encrypted Slatepack payload is built with the same steps as an encrypted age payload, where the X25519 keys are derived from a participants SlatepackAddress . E.g. age_encrypt(sender + slate_binary) where mode == 1 and sender is a valid SlatepackAddress","title":"Payload (age Encryption)"},{"location":"grin-rfcs/text/0015-slatepack/#armor","text":"The payload that will be armored is an optionally encrypted, binary serialized Slatepack JSON object and any associated encrypted metadata. Armor is Framing wrapped around a SimpleBase58Check encoded Payload .","title":"Armor"},{"location":"grin-rfcs/text/0015-slatepack/#framing","text":"Armor uses specific Headers , Footers and Periods as Framing to contain its Payload . Header Supported Headers: BEGINSLATEPACK Regex: ^[>\\n\\r\\t ]*BEGINSLATEPACK[>\\n\\r\\t ]*$ Footer Supported Footers ENDSLATEPACK Regex: ^[>\\n\\r\\t ]*ENDSLATEPACK[>\\n\\r\\t ]*$ Periods All data of an armored slate up to the first . is the framing header All data after the first . and before the second . is the SimpleBase58Check encoded payload which contains the slate data All data after the second . and before the third . is the framing footer Any data after the third . is ignored","title":"Framing"},{"location":"grin-rfcs/text/0015-slatepack/#simplebase58check-encoding","text":"SlatepackMessage armor payloads are encoded similar to legacy bitcoin addresses, with the primary differences being that the SimpleBase58Check used here does not include version bytes and includes the error checking code at the beginning of the payload instead of at the end. SHA256(SHA256(SLATEPACK_MESSAGE_BINARY)) First four bytes from previous step are ERROR_CHECK_CODE Concatenate ERROR_CHECK_CODE + SLATEPACK_MESSAGE_BINARY Base58 encode the output from the previous step to complete the armor Payload It should be noted that the ERROR_CHECK_CODE does not have a robust error checking ability because a double sha256 hash is not a proper error check code and the encoding scheme itself was meant to be used for bitcoin addresses which are much smaller than slate payloads. A more robust error correction option was not chosen here because the consequences of the failure to detect an error are not as severe as they would be for a bitcoin address as further validation would need to occur for Grin. The purpose is to catch some characters being accidentally added or lost during armor transport rather than preventing a spend to an address we don't know the key to spend from.","title":"SimpleBase58Check Encoding"},{"location":"grin-rfcs/text/0015-slatepack/#formatting","text":"WORD_LENGTH : 15 Number of SimpleBase58Check encoded characters per word; chosen for human readability across device screen sizes LINE_BREAK : 200 words Number of words of WORD_LENGTH to include before inserting a newline; chosen for user friendliness in terminals and messaging applications MAX_STRING_SIZE : 1MB Maximum size for an armored SlatepackMessage string without requiring a file container If a SlatepackMessage exceeds this value it must be handled as a .slatepack file instead of a string This parameter chosen to cover as many cases as possible and still be supported by most clipboards WORD_LENGTH and LINE_BREAK parameters are adjustable as a formatting convenience. MAX_STRING_SIZE is fixed and cannot be exceeded without wrapping the armored SlatepackMessage in a .slatepack file.","title":"Formatting"},{"location":"grin-rfcs/text/0015-slatepack/#edge-case-large-slates-1mb","text":"Some slate payloads may be so large that they cannot be reliably handled across all clipboards. To handle these edge cases, a SlatepackMessage will be expected to be passed in a .slatepack file format in cases where Tor is unsuccessful and the armored SlatepackMessage string output would exceed 1MB. A file format was chosen as opposed to a multi-part message approach because messages are already written to file by default by grin-wallet and they are potentially simpler to handle from an implementation perspective. While wallets must support handling these edge cases to avoid all possible cases where a wallet cannot spend or receive a valid transaction, it would be reasonable for services and exchanges to support the Slatepack standard without the requirement of handling the rare file edge case.","title":"Edge Case: Large Slates (&gt;1MB)"},{"location":"grin-rfcs/text/0015-slatepack/#example-slatepack-json-object","text":"","title":"Example Slatepack JSON Object"},{"location":"grin-rfcs/text/0015-slatepack/#mode-0-plain-text","text":"In this plain text example, neither the sender nor the receiver wish to share a SlatepackAddress { \"slatepack\": [1, 0], \"mode\": 0, \"sender\": \"0\", \"payload\": <binary serialized slate> }","title":"Mode 0: Plain Text"},{"location":"grin-rfcs/text/0015-slatepack/#mode-1-encrypted","text":"{ \"slatepack\": [1, 0], \"mode\": 1, \"payload\": <age encrypted binary: sender slatepack address + binary serialized slate>, }","title":"Mode 1: Encrypted"},{"location":"grin-rfcs/text/0015-slatepack/#example-slatepackmessage","text":"BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv pcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY GWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx wNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK.","title":"Example SlatepackMessage"},{"location":"grin-rfcs/text/0015-slatepack/#slatepackworkflow","text":"Adoption of the Slatepack standard allows for a unified workflow that can still function without knowledge of a SlatepackAddress from a counterparty.","title":"SlatepackWorkflow"},{"location":"grin-rfcs/text/0015-slatepack/#with-a-slatepackaddress","text":"grin-wallet send -d grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x 1.337 Sender wallet derives an onion v3 address from grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x and attempts to complete the transaction synchronously via Tor (Fallback) If the synchronous transaction fails, a SlatepackMessage string is encrypted to the SlatepackAddress and output for manual asynchronous transport by the user","title":"With a SlatepackAddress"},{"location":"grin-rfcs/text/0015-slatepack/#without-a-slatepackaddress","text":"grin-wallet send 1.337 A SlatepackMessage string is output for manual asynchronous transport by the user","title":"Without a SlatepackAddress"},{"location":"grin-rfcs/text/0015-slatepack/#with-qr-codes","text":"A QR-based SlatepackWorkflow will always begin with a standard QR size because they are encoded directly from a bech32 SlatepackAddress . This encoding simultaneously provides a derivable onion address to attempt a synchronous transaction ( bech32 -> ed25519 -> onionv3 ) and a derivable encryption key ( bech32 -> ed25519 -> x25519 ) to return an encrypted Slatepack string to complete the transaction asynchronously as a fallback. As a consequence, a SlatepackAddress must be revealed by the party producing a QR code in the SlatepackWorkflow . Receiver shares SlatepackAddress via QR Sender scans QR code and the transaction is completed synchronously via Tor by deriving the recipient's onion v3 address from their SlatepackAddress (Fallback) If the synchronous transaction fails, a SlatepackMessage string is output for manual asynchronous transport by the user","title":"With QR Codes"},{"location":"grin-rfcs/text/0015-slatepack/#with-three-or-more-parties","text":"Some possible future Slatepack transactions may require more than two parties to successfully build. These cases should not require any breaking changes to the core Slatepack standard workflow. The exact flow order (round-robin etc) will be defined by the accompanying RFCs that define the possible future multiple party slates themselves. In some cases, new slate versions may require (non-breaking) updates to this RFC. From there, the same standard Slatepack standard workflow of attempting to exchange the data via Tor first with an ascii armor fallback is still valid. For example, a future Slatepack version will add support for an array containing a SlatepackAddress for each party in the order desired to finish building the transaction. The wallet of each subsequent party will attempt to establish a connection with the next via Tor. In the event of a Tor failure it would be the responsibility of the most recent party to manually transport it to the next. In cases with many parties, the fallback method of the Slatepack standard could quickly become cumbersome if, for example, every third participant fails to achieve a Tor connection.","title":"With Three or More Parties"},{"location":"grin-rfcs/text/0015-slatepack/#implementation-timeline","text":"Initial Slatepack implementation introduced with the July 2020 hard fork May or may not support encryption by default yet The proposed Slatepack standard is fully implemented and adopted as a universal transaction standard in last hard fork (Jan 2021) Slatepack is the default transaction standard in all wallets and services","title":"Implementation Timeline"},{"location":"grin-rfcs/text/0015-slatepack/#drawbacks","text":"This puts a lot of eggs in one basket (if Slatepack fails there will likely be confusion returning to old methods) This may be a bit rushed to have where we want it before HF schedule Deprecating HTTP(S) is already a major change- by requiring the adoption of this completely new standard in addition we risk putting a lot of effort on the shoulders of existing services in the Grin ecosystem","title":"Drawbacks"},{"location":"grin-rfcs/text/0015-slatepack/#rationale-and-alternatives","text":"By adding new options without simplifying the workflow for users we risk confusion and friction We could just add an option for copy and pastable slates instead of introducing an entirely new universal transaction flow standard","title":"Rationale and alternatives"},{"location":"grin-rfcs/text/0015-slatepack/#prior-art","text":"Note that while previous asynchronous Mimblewimble transaction solutions require a relatively short TTL for a counterparty to successfully connect to their respective network before transactions fail (currently 72 hours for Tari DHT Network, 24 hours for Beam SBBS), Grin Slatepack transactions can remain valid indefinitely without spamming the network when using the ascii armor fallback.","title":"Prior art"},{"location":"grin-rfcs/text/0015-slatepack/#tari","text":"Tari uses the Tari DHT Network to support asynchronous Mimblewimble transactions. This approach is comprehensive and comprises of the entire peer to peer messaging network, including both nodes and wallets. This is distinct from Slatepack which is strictly an approach to transaction building between wallet software, not general protocol messaging. Similar to Slatepack, Tari users derive a public key from their master seed (which is represented to users as emojis instead of bech32) and is used to look up peers in peer databases (as opposed to directly routing to a traditional Tor hidden service as in Slatepack). By default, Tari, like Slatepack, uses Tor for communication. While Slatepack and Tari both have addresses that decode to public keys used to find and communicate with counterparty wallets via Tor, they both handle the Tor failure case differently. Tari seems to rely on its custom DHT network to gracefully handle this at the cost of the complexity of a custom DHT layer. Slatepack falls back to an unopinionated, encrypted ascii armor string for the user to transport \"outside of the Grin network\" to complete the transaction. The advantage for Slatepack is significantly reduced complexity by using Tor directly with an unopinionated fallback mode. The disadvantage for Slatepack is that transactions don't \"magically\" just work if Tor communication is failing- they still require some effort from the user to transport the ascii armor themselves. Note that these details were taken from early documentation and not code- transactions in Tari may behave differently in practice.","title":"Tari"},{"location":"grin-rfcs/text/0015-slatepack/#beam","text":"Beam uses the SBBS gossip protocol to support asynchronous mimblewimble transactions. SBBS adds a nontrivial amount of complexity and attack surface to the core Beam software. In exchange, Beam receives a somewhat user-friendly mechanism for users to build transactions asynchronously. The asynchronous fallback method for Slatepack transactions is a simple ascii armor string that does not contain an opinion about a particular protocol with which to exchange the data. The advantage with the Slatepack method is that much less code is required to support these transactions which can improve the overall stability and security of the codebase running the Grin network. The disadvantage of this for Slatepack is that asynchronous transactions don't \"magically\" work- they still need to be between users via an outside channel (instant message, text box, email etc). Slatepack makes the tradeoff of slightly more work for the end user in exchange for a simpler and potentially more secure network for Grin.","title":"Beam"},{"location":"grin-rfcs/text/0015-slatepack/#unresolved-questions","text":"How to handle key derivation harmoniously? What are unmentioned security considerations for using the same base key to both map to an onion address and map to an encryption key used in transactions? Related, what are unmentioned security considerations to SlatepackAddress reuse? Should we still use double-sha256 in SimpleBase58Check or take the opportunity to use a BCH or CRC code which may be more appropriate for error detection on slatepack messages? Is additional engineering desired here if there will always be further validation of the slate payload before a spend can occur? If addresses are not reused by default and since wallets need to be able to conduct multiple transactions in parallel, they need the ability to listen on all \"active\" addresses at the same time","title":"Unresolved questions"},{"location":"grin-rfcs/text/0015-slatepack/#future-possibilities","text":"Extended to support future modes (payment channel, payjoin, multiple counterparties etc) An entirely different standard could be adopted in the future if non-interactive transactions become the default, eliminating the need for Slatepack It might be possible for a new standard to remain compatible with the existing SlatepackAddress to allow a more generic GrinAddress","title":"Future possibilities"},{"location":"grin-rfcs/text/0015-slatepack/#references","text":"https://en.bitcoin.it/wiki/BIP_0173 https://docs.google.com/document/d/11yHom20CrsuX8KQJXBBw04s80Unjv8zCg_A7sPAX_9Y/preview# https://github.com/str4d/rage/blob/master/age https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/ https://libsodium.gitbook.io/doc/advanced/ed25519-curve25519 https://blog.filippo.io/using-ed25519-keys-for-encryption/ https://github.com/mimblewimble/grin-rfcs/pull/53 https://saltpack.org https://github.com/mimblewimble/grin-rfcs/pull/50 https://gitweb.torproject.org/torspec.git/tree/rend-spec-v3.txt https://signal.org/docs/specifications/xeddsa/ https://www.tari.com/lessons/02_how_tari_works.html https://github.com/BeamMW/beam/wiki/Secure-bulletin-board-system-(SBBS)","title":"References"},{"location":"wiki/resources/","text":"Resources More Documents Build and run automation Run a node on google cloud for free How to mine with grin-miner Monetary policy Talks Playlists grincon0 grinconUS(0) grinAmsterdam grincon1 Other Mimblewimble, Scaling Bitcoin'16 Mimblewimble, SF Bitcoin Developers`16 Mimblewimble, BPASE'17 Mimblewimble & Scriptless Scripts, RWC'18 A View on Grin, HCPP'19 , Slides Forum How to store Grin in cold storage? Raspberry Pi 4 - Standalone Grin-Node PoC by Grinnode.live How to open port 3414 (and why) Coinbase outputs as regular outputs Use of NRD kernels in payment channels Emission Rate Thread , #2 , #3 Transaction Aggregation TX Graph Confidentality Response to Reavealing TX Graph Some Thoughts on Privacy How to open port 3414 (and why) Scheduled PoW upgrades proposal Choice of ASIC Resistant PoW for GPU miners Put later phase-outs on hold proposal All about C31 fade out, the C29 scale and C32 Genesis block message Queries about transaction aggregation Aggregate merkle proofs Unique kernels thread #73 Sending a transaction to more parties than originally intended Reasoning behind block weight limit Hardforks on Grin v5.0.0 and beyond Play attacks and possible mitigations Replay attacks and possible mitigations Grin transactions user interactivity Eliminate finalize step On Igno's absence Being ASIC resistant or not Is there a potential hidden inflation problem Eliminating finalize step Integrated payment proofs and round minimization Pep talk for one sided transactions Dismantling the core team and governance structure Medium Grin's Mythical Fair Launch Grin Money Explained Grin Transactions Explained, Step-by-Step What\u2019s inside a Grin Transaction File? Breaking Mimblewimble\u2019s Privacy Model Factual inaccuracies of \u201cBreaking Mimblewimble\u2019s Privacy Model\u201d Mimblewimble Without the Scary Math Behind Mimblewimble An Introduction to Grin Proof-of-Work Podcasts [Bitcoin Wednesday] Introducing Mimblewimble and Grin @jaspervdm [Unchained] Grin: A More Private, Lighter Bitcoin @lehnberg @yeastplume [The Crypto Show] Mimblewimble with Andrew Poelstra and Peter Wuillie [What Bitcoin Did] Grin's Mimblewimble Implementation @yeastplume [Zero Knowledge] Grin @lehnberg [Captain Crypto Show] Grin @yeastplume [Let's Talk Bitcoin] Privacy with Mimblewimble @yeastplume @andreas @adam.b.levine Miscellaneous [Launchpad] Mimblewimble Mailing List Archive [Reddit] Mimblewimble introduced to r/bitcoin [Youtube] Aantonop Bitcoin Q&A: Mimblewimble and Dandelion [Coindesk] Harry Potter Characters Join Mimblewimble 2016 [Github] Meeting Notes [Reddit] On Grin's Privacy [Launchpad] Scripting observations and Lightning Network implementation [GitHub] Grin difficulty, C29, C31 fade out and C32 [GitHub] Fees in Mining [Google] Replay Attacks Summary [Blog] A Relatively Easy to Understand Primer on ECC RFCs [Github] All Accepted RFCs [Github] All Pending RFCs Papers Confidential Assets OWAS Bulletproofs Cuckoo Cycle","title":"Resources"},{"location":"wiki/resources/#resources","text":"","title":"Resources"},{"location":"wiki/resources/#more-documents","text":"Build and run automation Run a node on google cloud for free How to mine with grin-miner Monetary policy","title":"More Documents"},{"location":"wiki/resources/#talks","text":"","title":"Talks"},{"location":"wiki/resources/#playlists","text":"grincon0 grinconUS(0) grinAmsterdam grincon1","title":"Playlists"},{"location":"wiki/resources/#other","text":"Mimblewimble, Scaling Bitcoin'16 Mimblewimble, SF Bitcoin Developers`16 Mimblewimble, BPASE'17 Mimblewimble & Scriptless Scripts, RWC'18 A View on Grin, HCPP'19 , Slides","title":"Other"},{"location":"wiki/resources/#forum","text":"How to store Grin in cold storage? Raspberry Pi 4 - Standalone Grin-Node PoC by Grinnode.live How to open port 3414 (and why) Coinbase outputs as regular outputs Use of NRD kernels in payment channels Emission Rate Thread , #2 , #3 Transaction Aggregation TX Graph Confidentality Response to Reavealing TX Graph Some Thoughts on Privacy How to open port 3414 (and why) Scheduled PoW upgrades proposal Choice of ASIC Resistant PoW for GPU miners Put later phase-outs on hold proposal All about C31 fade out, the C29 scale and C32 Genesis block message Queries about transaction aggregation Aggregate merkle proofs Unique kernels thread #73 Sending a transaction to more parties than originally intended Reasoning behind block weight limit Hardforks on Grin v5.0.0 and beyond Play attacks and possible mitigations Replay attacks and possible mitigations Grin transactions user interactivity Eliminate finalize step On Igno's absence Being ASIC resistant or not Is there a potential hidden inflation problem Eliminating finalize step Integrated payment proofs and round minimization Pep talk for one sided transactions Dismantling the core team and governance structure","title":"Forum"},{"location":"wiki/resources/#medium","text":"Grin's Mythical Fair Launch Grin Money Explained Grin Transactions Explained, Step-by-Step What\u2019s inside a Grin Transaction File? Breaking Mimblewimble\u2019s Privacy Model Factual inaccuracies of \u201cBreaking Mimblewimble\u2019s Privacy Model\u201d Mimblewimble Without the Scary Math Behind Mimblewimble An Introduction to Grin Proof-of-Work","title":"Medium"},{"location":"wiki/resources/#podcasts","text":"[Bitcoin Wednesday] Introducing Mimblewimble and Grin @jaspervdm [Unchained] Grin: A More Private, Lighter Bitcoin @lehnberg @yeastplume [The Crypto Show] Mimblewimble with Andrew Poelstra and Peter Wuillie [What Bitcoin Did] Grin's Mimblewimble Implementation @yeastplume [Zero Knowledge] Grin @lehnberg [Captain Crypto Show] Grin @yeastplume [Let's Talk Bitcoin] Privacy with Mimblewimble @yeastplume @andreas @adam.b.levine","title":"Podcasts"},{"location":"wiki/resources/#miscellaneous","text":"[Launchpad] Mimblewimble Mailing List Archive [Reddit] Mimblewimble introduced to r/bitcoin [Youtube] Aantonop Bitcoin Q&A: Mimblewimble and Dandelion [Coindesk] Harry Potter Characters Join Mimblewimble 2016 [Github] Meeting Notes [Reddit] On Grin's Privacy [Launchpad] Scripting observations and Lightning Network implementation [GitHub] Grin difficulty, C29, C31 fade out and C32 [GitHub] Fees in Mining [Google] Replay Attacks Summary [Blog] A Relatively Easy to Understand Primer on ECC","title":"Miscellaneous"},{"location":"wiki/resources/#rfcs","text":"[Github] All Accepted RFCs [Github] All Pending RFCs","title":"RFCs"},{"location":"wiki/resources/#papers","text":"Confidential Assets OWAS Bulletproofs Cuckoo Cycle","title":"Papers"},{"location":"wiki/table-of-contents/","text":"Table of Contents This wiki contains an high level technical overview of Grin. For more details about the implentation, please look at the Grin documentation on docs.rs grin: api , core , chain , util , store , keychain , p2p , pool , config , servers . grin_wallet: wallet_api , wallet . Introduction Grin for Bitcoiners - Explaining Grin from a Bitcoiner's perspective Mimblewimble - A technical introduction to Mimblewimble Elliptic Curves Commitments Mimblewimble Transactions Slates Slatepack Payment Proofs Contracts Blocks Header Body Fees & Weight Chain State Merkle Mountain Ranges State & Pruning Chain Sync Miscellaneous Cuckoo Cycle Dandelion Switch Commitments Coinbase Maturity Rule NRD Kernels API Node API Wallet API Stratum RPC Security Process Grin's Security Process Security Team Code Audits Services List of Services Slatepack Integration Guide More Resources","title":"Table of Contents"},{"location":"wiki/table-of-contents/#table-of-contents","text":"This wiki contains an high level technical overview of Grin. For more details about the implentation, please look at the Grin documentation on docs.rs grin: api , core , chain , util , store , keychain , p2p , pool , config , servers . grin_wallet: wallet_api , wallet .","title":"Table of Contents"},{"location":"wiki/table-of-contents/#introduction","text":"Grin for Bitcoiners - Explaining Grin from a Bitcoiner's perspective Mimblewimble - A technical introduction to Mimblewimble Elliptic Curves Commitments Mimblewimble","title":"Introduction"},{"location":"wiki/table-of-contents/#transactions","text":"Slates Slatepack Payment Proofs Contracts","title":"Transactions"},{"location":"wiki/table-of-contents/#blocks","text":"Header Body Fees & Weight","title":"Blocks"},{"location":"wiki/table-of-contents/#chain-state","text":"Merkle Mountain Ranges State & Pruning Chain Sync","title":"Chain State"},{"location":"wiki/table-of-contents/#miscellaneous","text":"Cuckoo Cycle Dandelion Switch Commitments Coinbase Maturity Rule NRD Kernels","title":"Miscellaneous"},{"location":"wiki/table-of-contents/#api","text":"Node API Wallet API Stratum RPC","title":"API"},{"location":"wiki/table-of-contents/#security-process","text":"Grin's Security Process Security Team Code Audits","title":"Security Process"},{"location":"wiki/table-of-contents/#services","text":"List of Services Slatepack Integration Guide","title":"Services"},{"location":"wiki/table-of-contents/#more","text":"Resources","title":"More"},{"location":"wiki/api/node-api/","text":"Node API The API is used to query a node about various information on the blockchain, networks and peers. By default, the API will listen on localhost:3413 . The API is started at the same time as the grin node. This endpoint requires, by default, basic authentication . The username is grin . Node API v2 This API version uses JSON-RPC for its requests. It is split up into a foreign API and an owner API. The documentation for these endpoints is automatically generated: Owner API Foreign API Basic auth passwords can be found in .api_secret / .foreign_api_secret files respectively. Postman A complete Postman collection for the Grin Node API can be found here . Node API v1 Note: version 1 of the API will be deprecated in v4.0.0 and subsequently removed in v5.0.0. Users of this API are encouraged to upgrade to API v2. This API uses REST for its requests. To learn about what specific calls can be made read the node API v1 doc . Basic auth password can be found in .api_secret","title":"Node API"},{"location":"wiki/api/node-api/#node-api","text":"The API is used to query a node about various information on the blockchain, networks and peers. By default, the API will listen on localhost:3413 . The API is started at the same time as the grin node. This endpoint requires, by default, basic authentication . The username is grin .","title":"Node API"},{"location":"wiki/api/node-api/#node-api-v2","text":"This API version uses JSON-RPC for its requests. It is split up into a foreign API and an owner API. The documentation for these endpoints is automatically generated: Owner API Foreign API Basic auth passwords can be found in .api_secret / .foreign_api_secret files respectively. Postman A complete Postman collection for the Grin Node API can be found here .","title":"Node API v2"},{"location":"wiki/api/node-api/#node-api-v1","text":"Note: version 1 of the API will be deprecated in v4.0.0 and subsequently removed in v5.0.0. Users of this API are encouraged to upgrade to API v2. This API uses REST for its requests. To learn about what specific calls can be made read the node API v1 doc . Basic auth password can be found in .api_secret","title":"Node API v1"},{"location":"wiki/api/stratum-rpc/","text":"Stratum RPC Protocol Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . This document describes the current Stratum RPC protocol implemented in Grin. Messages In this section, we detail each message and the potential response. getjobtemplate A message initiated by the miner. Miner can request a job with this message. Request Field Content id ID of the request jsonrpc \"2.0\" method \"getjobtemplate\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"params\" : null } The response can be of two types: OK response Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"result\" :{ \"difficulty\" : 1 , \"height\" : 13726 , \"job_id\" : 4 , \"pre_pow\" : \"00010000000000003c4d0171369781424b39c81eb39de10cdf4a7cc27bbc6769203c7c9bc02cc6a1dfc6000000005b50f8210000000000395f123c6856055aab2369fe325c3d709b129dee5c96f2db60cdbc0dc123a80cb0b89e883ae2614f8dbd169888a95c0513b1ac7e069de82e5d479cf838281f7838b4bf75ea7c9222a1ad7406a4cab29af4e018c402f70dc8e9ef3d085169391c78741c656ec0f11f62d41b463c82737970afaa431c5cabb9b759cdfa52d761ac451276084366d1ba9efff2db9ed07eec1bcd8da352b32227f452dfa987ad249f689d9780000000000000b9e00000000000009954\" } } Error response If the node is syncing, it will send the following message: Field Content id ID of the request jsonrpc \"2.0\" method \"getjobtemplate\" error Example: { \"id\" : \"10\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"error\" :{ \"code\" : -32000 , \"message\" : \"Node is syncing - Please wait\" } } job A message initiated by the Stratum server. Stratum server will send job automatically to connected miners. The miner SHOULD interrupt current job if job_id = 0, and SHOULD replace the current job with this one after the current graph is complete. Request Field Content id ID of the request jsonrpc \"2.0\" method \"job\" params Int difficulty , height , job_id and string pre_pow Example: { \"id\" : \"Stratum\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"job\" , \"params\" :{ \"difficulty\" : 1 , \"height\" : 16375 , \"job_id\" : 5 , \"pre_pow\" : \"00010000000000003ff723bc8c987b0c594794a0487e52260c5343288749c7e288de95a80afa558c5fb8000000005b51f15f00000000003cadef6a45edf92d2520bf45cbd4f36b5ef283c53d8266bbe9aa1b8daaa1458ce5578fcb0978b3995dd00e3bfc5a9277190bb9407a30d66aec26ff55a2b50214b22cdc1f3894f27374f568b2fe94d857b6b3808124888dd5eff7e8de7e451ac805a4ebd6551fa7a529a1b9f35f761719ed41bfef6ab081defc45a64a374dfd8321feac083741f29207b044071d93904986fa322df610e210c543c2f95522c9bdaef5f598000000000000c184000000000000a0cf\" } } Response No response is required for this message. keepalive A message initiated by the miner in order to keep the connection alive. Request Field Content id ID of the request jsonrpc \"2.0\" method \"keepalive\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"keepalive\" , \"params\" : null } Response Field Content id ID of the request jsonrpc \"2.0\" method \"keepalive\" result \"ok\" error null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"keepalive\" , \"result\" : \"ok\" , \"error\" : null } login A message initiated by the miner. Miner can log in on a Grin Stratum server with a login, password and agent (usually statically set by the miner program). Request Field Content id ID of the request jsonrpc \"2.0\" method \"login\" params Strings: login, pass and agent Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"login\" , \"params\" :{ \"login\" : \"login\" , \"pass\" : \"password\" , \"agent\" : \"grin-miner\" } } The response can be of two types: OK response Field Content id ID of the request jsonrpc \"2.0\" method \"login\" result \"ok\" error null Example: { \"id\" : \"1\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"login\" , \"result\" : \"ok\" , \"error\" : null } Error response Not yet implemented. Should return error -32500 \"Login first\" when login is required. status A message initiated by the miner. This message allows a miner to get the status of its current worker and the network. Request Field Content id ID of the request jsonrpc \"2.0\" method \"status\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"status\" , \"params\" : null } Response The response is the following: Field Content id ID of the request jsonrpc \"2.0\" method \"status\" result String id . Integers height , difficulty , accepted , rejected and stale error null Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"status\" , \"result\" :{ \"id\" : \"5\" , \"height\" : 13726 , \"difficulty\" : 1 , \"accepted\" : 0 , \"rejected\" : 0 , \"stale\" : 0 }, \"error\" : null } submit A message initiated by the miner. When a miner find a share, it will submit it to the node. Request The miner submit a solution to a job to the Stratum server. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" params Int edge_bits , nonce , height , job_id and array of integers pow Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"params\" :{ \"edge_bits\" : 29 , \"height\" : 16419 , \"job_id\" : 0 , \"nonce\" : 8895699060858340771 , \"pow\" :[ 4210040 , 10141596 , 13269632 , 24291934 , 28079062 , 84254573 , 84493890 , 100560174 , 100657333 , 120128285 , 130518226 , 140371663 , 142109188 , 159800646 , 163323737 , 171019100 , 176840047 , 191220010 , 192245584 , 198941444 , 209276164 , 216952635 , 217795152 , 225662613 , 230166736 , 231315079 , 248639876 , 263910393 , 293995691 , 298361937 , 326412694 , 330363619 , 414572127 , 424798984 , 426489226 , 466671748 , 466924466 , 490048497 , 495035248 , 496623057 , 502828197 , 532838434 ] } } The response can be of three types. OK response The share is accepted by the Stratum but is not a valid cuck(at)oo solution at the network target difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" result \"ok\" error null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"result\" : \"ok\" , \"error\" : null } Blockfound response The share is accepted by the Stratum and is a valid cuck(at)oo solution at the network target difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" result \"block - \" + hash of the block error null Example: { \"id\" : \"6\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"result\" : \"blockfound - 23025af9032de812d15228121d5e4b0e977d30ad8036ab07131104787b9dcf10\" , \"error\" : null } Error response The error response can be of two types: stale and rejected. Stale share error response The share is a valid solution to a previous job not the current one. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32503 , \"message\" : \"Solution submitted too late\" } } Rejected share error responses Two possibilities: the solution cannot be validated or the solution is of too low difficulty. Failed to validate solution error The submitted solution cannot be validated. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32502 , \"message\" : \"Failed to validate solution\" } } Share rejected due to low difficulty error The submitted solution is of too low difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32501 , \"message\" : \"Share rejected due to low difficulty\" } } Error Messages Grin Stratum protocol implementation contains the following error message: Error code Error Message -32000 Node is syncing - please wait -32500 Login first -32501 Share rejected due to low difficulty -32502 Failed to validate solution -32503 Solution Submitted too late -32600 Invalid Request -32601 Method not found Miner behavior Miners SHOULD, MAY or MUST respect the following rules: Miners SHOULD randomize the job nonce before starting Miners MUST continue mining the same job until the server sends a new one, though a miner MAY request a new job at any time Miners MUST NOT send an rpc response to a job request from the server Miners MAY set the RPC \"id\" and expect responses to have that same id Miners MAY send a keepalive message Miners MAY send a login request (to identify which miner finds shares / solutions in the logs), the login request MUST have all 3 params. Miners MUST return the supplied job_id with submit messages. Reference Implementation The current reference implementation is available at mimblewimble/grin-miner .","title":"Stratum RPC"},{"location":"wiki/api/stratum-rpc/#stratum-rpc-protocol","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . This document describes the current Stratum RPC protocol implemented in Grin.","title":"Stratum RPC Protocol"},{"location":"wiki/api/stratum-rpc/#messages","text":"In this section, we detail each message and the potential response.","title":"Messages"},{"location":"wiki/api/stratum-rpc/#getjobtemplate","text":"A message initiated by the miner. Miner can request a job with this message.","title":"getjobtemplate"},{"location":"wiki/api/stratum-rpc/#request","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"getjobtemplate\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"params\" : null } The response can be of two types:","title":"Request"},{"location":"wiki/api/stratum-rpc/#ok-response","text":"Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"result\" :{ \"difficulty\" : 1 , \"height\" : 13726 , \"job_id\" : 4 , \"pre_pow\" : \"00010000000000003c4d0171369781424b39c81eb39de10cdf4a7cc27bbc6769203c7c9bc02cc6a1dfc6000000005b50f8210000000000395f123c6856055aab2369fe325c3d709b129dee5c96f2db60cdbc0dc123a80cb0b89e883ae2614f8dbd169888a95c0513b1ac7e069de82e5d479cf838281f7838b4bf75ea7c9222a1ad7406a4cab29af4e018c402f70dc8e9ef3d085169391c78741c656ec0f11f62d41b463c82737970afaa431c5cabb9b759cdfa52d761ac451276084366d1ba9efff2db9ed07eec1bcd8da352b32227f452dfa987ad249f689d9780000000000000b9e00000000000009954\" } }","title":"OK response"},{"location":"wiki/api/stratum-rpc/#error-response","text":"If the node is syncing, it will send the following message: Field Content id ID of the request jsonrpc \"2.0\" method \"getjobtemplate\" error Example: { \"id\" : \"10\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"error\" :{ \"code\" : -32000 , \"message\" : \"Node is syncing - Please wait\" } }","title":"Error response"},{"location":"wiki/api/stratum-rpc/#job","text":"A message initiated by the Stratum server. Stratum server will send job automatically to connected miners. The miner SHOULD interrupt current job if job_id = 0, and SHOULD replace the current job with this one after the current graph is complete.","title":"job"},{"location":"wiki/api/stratum-rpc/#request_1","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"job\" params Int difficulty , height , job_id and string pre_pow Example: { \"id\" : \"Stratum\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"job\" , \"params\" :{ \"difficulty\" : 1 , \"height\" : 16375 , \"job_id\" : 5 , \"pre_pow\" : \"00010000000000003ff723bc8c987b0c594794a0487e52260c5343288749c7e288de95a80afa558c5fb8000000005b51f15f00000000003cadef6a45edf92d2520bf45cbd4f36b5ef283c53d8266bbe9aa1b8daaa1458ce5578fcb0978b3995dd00e3bfc5a9277190bb9407a30d66aec26ff55a2b50214b22cdc1f3894f27374f568b2fe94d857b6b3808124888dd5eff7e8de7e451ac805a4ebd6551fa7a529a1b9f35f761719ed41bfef6ab081defc45a64a374dfd8321feac083741f29207b044071d93904986fa322df610e210c543c2f95522c9bdaef5f598000000000000c184000000000000a0cf\" } }","title":"Request"},{"location":"wiki/api/stratum-rpc/#response","text":"No response is required for this message.","title":"Response"},{"location":"wiki/api/stratum-rpc/#keepalive","text":"A message initiated by the miner in order to keep the connection alive.","title":"keepalive"},{"location":"wiki/api/stratum-rpc/#request_2","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"keepalive\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"keepalive\" , \"params\" : null }","title":"Request"},{"location":"wiki/api/stratum-rpc/#response_1","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"keepalive\" result \"ok\" error null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"keepalive\" , \"result\" : \"ok\" , \"error\" : null }","title":"Response"},{"location":"wiki/api/stratum-rpc/#login","text":"A message initiated by the miner. Miner can log in on a Grin Stratum server with a login, password and agent (usually statically set by the miner program).","title":"login"},{"location":"wiki/api/stratum-rpc/#request_3","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"login\" params Strings: login, pass and agent Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"login\" , \"params\" :{ \"login\" : \"login\" , \"pass\" : \"password\" , \"agent\" : \"grin-miner\" } } The response can be of two types:","title":"Request"},{"location":"wiki/api/stratum-rpc/#ok-response_1","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"login\" result \"ok\" error null Example: { \"id\" : \"1\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"login\" , \"result\" : \"ok\" , \"error\" : null }","title":"OK response"},{"location":"wiki/api/stratum-rpc/#error-response_1","text":"Not yet implemented. Should return error -32500 \"Login first\" when login is required.","title":"Error response"},{"location":"wiki/api/stratum-rpc/#status","text":"A message initiated by the miner. This message allows a miner to get the status of its current worker and the network.","title":"status"},{"location":"wiki/api/stratum-rpc/#request_4","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"status\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"status\" , \"params\" : null }","title":"Request"},{"location":"wiki/api/stratum-rpc/#response_2","text":"The response is the following: Field Content id ID of the request jsonrpc \"2.0\" method \"status\" result String id . Integers height , difficulty , accepted , rejected and stale error null Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"status\" , \"result\" :{ \"id\" : \"5\" , \"height\" : 13726 , \"difficulty\" : 1 , \"accepted\" : 0 , \"rejected\" : 0 , \"stale\" : 0 }, \"error\" : null }","title":"Response"},{"location":"wiki/api/stratum-rpc/#submit","text":"A message initiated by the miner. When a miner find a share, it will submit it to the node.","title":"submit"},{"location":"wiki/api/stratum-rpc/#request_5","text":"The miner submit a solution to a job to the Stratum server. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" params Int edge_bits , nonce , height , job_id and array of integers pow Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"params\" :{ \"edge_bits\" : 29 , \"height\" : 16419 , \"job_id\" : 0 , \"nonce\" : 8895699060858340771 , \"pow\" :[ 4210040 , 10141596 , 13269632 , 24291934 , 28079062 , 84254573 , 84493890 , 100560174 , 100657333 , 120128285 , 130518226 , 140371663 , 142109188 , 159800646 , 163323737 , 171019100 , 176840047 , 191220010 , 192245584 , 198941444 , 209276164 , 216952635 , 217795152 , 225662613 , 230166736 , 231315079 , 248639876 , 263910393 , 293995691 , 298361937 , 326412694 , 330363619 , 414572127 , 424798984 , 426489226 , 466671748 , 466924466 , 490048497 , 495035248 , 496623057 , 502828197 , 532838434 ] } } The response can be of three types.","title":"Request"},{"location":"wiki/api/stratum-rpc/#ok-response_2","text":"The share is accepted by the Stratum but is not a valid cuck(at)oo solution at the network target difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" result \"ok\" error null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"result\" : \"ok\" , \"error\" : null }","title":"OK response"},{"location":"wiki/api/stratum-rpc/#blockfound-response","text":"The share is accepted by the Stratum and is a valid cuck(at)oo solution at the network target difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" result \"block - \" + hash of the block error null Example: { \"id\" : \"6\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"result\" : \"blockfound - 23025af9032de812d15228121d5e4b0e977d30ad8036ab07131104787b9dcf10\" , \"error\" : null }","title":"Blockfound response"},{"location":"wiki/api/stratum-rpc/#error-response_2","text":"The error response can be of two types: stale and rejected. Stale share error response The share is a valid solution to a previous job not the current one. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32503 , \"message\" : \"Solution submitted too late\" } } Rejected share error responses Two possibilities: the solution cannot be validated or the solution is of too low difficulty. Failed to validate solution error The submitted solution cannot be validated. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32502 , \"message\" : \"Failed to validate solution\" } } Share rejected due to low difficulty error The submitted solution is of too low difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32501 , \"message\" : \"Share rejected due to low difficulty\" } }","title":"Error response"},{"location":"wiki/api/stratum-rpc/#error-messages","text":"Grin Stratum protocol implementation contains the following error message: Error code Error Message -32000 Node is syncing - please wait -32500 Login first -32501 Share rejected due to low difficulty -32502 Failed to validate solution -32503 Solution Submitted too late -32600 Invalid Request -32601 Method not found","title":"Error Messages"},{"location":"wiki/api/stratum-rpc/#miner-behavior","text":"Miners SHOULD, MAY or MUST respect the following rules: Miners SHOULD randomize the job nonce before starting Miners MUST continue mining the same job until the server sends a new one, though a miner MAY request a new job at any time Miners MUST NOT send an rpc response to a job request from the server Miners MAY set the RPC \"id\" and expect responses to have that same id Miners MAY send a keepalive message Miners MAY send a login request (to identify which miner finds shares / solutions in the logs), the login request MUST have all 3 params. Miners MUST return the supplied job_id with submit messages.","title":"Miner behavior"},{"location":"wiki/api/stratum-rpc/#reference-implementation","text":"The current reference implementation is available at mimblewimble/grin-miner .","title":"Reference Implementation"},{"location":"wiki/api/wallet-api/","text":"Wallet API The wallet API uses JSON-RPC requests and is split into two separate blocks of functionality: Owner API Foreign API Basic auth passwords can be found in .api_secret .","title":"Wallet API"},{"location":"wiki/api/wallet-api/#wallet-api","text":"The wallet API uses JSON-RPC requests and is split into two separate blocks of functionality: Owner API Foreign API Basic auth passwords can be found in .api_secret .","title":"Wallet API"},{"location":"wiki/blocks/block-body/","text":"","title":"Body"},{"location":"wiki/blocks/block-header/","text":"Block Header General format of a Block Header in a Mimblewimble/Grin: Field Description Size version Version of the block 2 bytes height Height of this block since the genesis block (height 0) 8 bytes timestamp Timestamp at which the block was built 8 bytes prev_hash Hash of the block previous to this in the chain 32 bytes prev_root Root hash of the header MMR at the previous header 32 bytes output_root Merkle root of all the commitments in the TxHashSet 32 bytes range_proof_root Merkle root of all range proofs in the TxHashSet 32 bytes kernel_root Merkle root of all transaction kernels in the TxHashSet 32 bytes total_kernel_offset Total accumulated sum of kernel offsets since genesis block. 32 bytes output_mmr_size Total size of the output MMR after applying this block. 8 bytes kernel_mmr_size Total size of the kernel MMR after applying this block. 8 bytes Sub-Total: 226 bytes - - - pow Proof of work data For cuck(AR)oo 29: 174 bytes. For cuck(AT)oo 32: 189 bytes. Total: 400 bytes for C29 or 415 bytes for C32 PoW General format of a Proof Of Work in a Mimblewimble/Grin: Field Description Size total_difficulty Total accumulated difficulty since genesis block 8 bytes secondary_scaling Variable difficulty scaling factor for secondary proof of work 4 bytes nonce Nonce increment used to mine this block. 8 bytes proof Proof of work data cuckoo_size: 1byte cuckoo_solution of C29: 42\u221729 bits=153 bytes cuckoo_solution of C32: 42\u221732 bits=168 bytes Sub-Total: 174 bytes for C29 and 189 bytes for C32 Example Here is a principle example of a Mimblewimble/Grin block header. The related block is included in Mainnet chain block: 1869 . Offset Field Hex Value 0 version 0001 2 height 000000000000074d 10 timestamp 000000005c3ff107 18 prev_hash 00001915c97bfad5bf9bb30a1035771446770502a937bd16a8c8a8f1fc6db730 50 prev_root 2eb356e36c03f16796dd4a6eef8cbcbeabaade84eecf013516367b376d646db7 82 output_root b56ccc990181d04d57585d3f0163b4f636fe3208a024596d14221bfa7739e693 114 range_proof_root a341b87862f430f9dda5fd0b88be175b6cc81b5e84bf6882d98cc31750b5001a 146 kernel_root b3e9708378ef256d479c6b166ba0a56c26d1b2e985c5e48065dbaa8a1fa6e606 178 total_kernel_offset 0755f37fa67bc3d3f0a7eddec7117013be42afff3602e7480d7271fff92763f1 210 output_mmr_size 0000000000001445 218 kernel_mmr_size 0000000000001130 226 total_difficulty 00000108e24af3bb 234 secondary_scaling 00000473 238 nonce 712493895227b883 246 edge_bits 1d 247 edge_nonces 43c8d2e098ba28f4f3748aab7d8be1aab3353259e6c6d4c046293f1c2f92afe7c5868bc5007fc51bae789ab3776d7efefb71547144b70ae8e764921bad8cb821a0c5d2adb455e1c406e1b2e39a2db51d7c552e4c1dd78bde1eea91f0843da6b3f1cb86e4ccb93371452b66c0ab292cd42525bcbf832fe358a3b22bcf7615e8397516ad8135a709213a77347cf4de104df5585984df0246fa03 400","title":"Header"},{"location":"wiki/blocks/block-header/#block-header","text":"General format of a Block Header in a Mimblewimble/Grin: Field Description Size version Version of the block 2 bytes height Height of this block since the genesis block (height 0) 8 bytes timestamp Timestamp at which the block was built 8 bytes prev_hash Hash of the block previous to this in the chain 32 bytes prev_root Root hash of the header MMR at the previous header 32 bytes output_root Merkle root of all the commitments in the TxHashSet 32 bytes range_proof_root Merkle root of all range proofs in the TxHashSet 32 bytes kernel_root Merkle root of all transaction kernels in the TxHashSet 32 bytes total_kernel_offset Total accumulated sum of kernel offsets since genesis block. 32 bytes output_mmr_size Total size of the output MMR after applying this block. 8 bytes kernel_mmr_size Total size of the kernel MMR after applying this block. 8 bytes Sub-Total: 226 bytes - - - pow Proof of work data For cuck(AR)oo 29: 174 bytes. For cuck(AT)oo 32: 189 bytes. Total: 400 bytes for C29 or 415 bytes for C32","title":"Block Header"},{"location":"wiki/blocks/block-header/#pow","text":"General format of a Proof Of Work in a Mimblewimble/Grin: Field Description Size total_difficulty Total accumulated difficulty since genesis block 8 bytes secondary_scaling Variable difficulty scaling factor for secondary proof of work 4 bytes nonce Nonce increment used to mine this block. 8 bytes proof Proof of work data cuckoo_size: 1byte cuckoo_solution of C29: 42\u221729 bits=153 bytes cuckoo_solution of C32: 42\u221732 bits=168 bytes Sub-Total: 174 bytes for C29 and 189 bytes for C32","title":"PoW"},{"location":"wiki/blocks/block-header/#example","text":"Here is a principle example of a Mimblewimble/Grin block header. The related block is included in Mainnet chain block: 1869 . Offset Field Hex Value 0 version 0001 2 height 000000000000074d 10 timestamp 000000005c3ff107 18 prev_hash 00001915c97bfad5bf9bb30a1035771446770502a937bd16a8c8a8f1fc6db730 50 prev_root 2eb356e36c03f16796dd4a6eef8cbcbeabaade84eecf013516367b376d646db7 82 output_root b56ccc990181d04d57585d3f0163b4f636fe3208a024596d14221bfa7739e693 114 range_proof_root a341b87862f430f9dda5fd0b88be175b6cc81b5e84bf6882d98cc31750b5001a 146 kernel_root b3e9708378ef256d479c6b166ba0a56c26d1b2e985c5e48065dbaa8a1fa6e606 178 total_kernel_offset 0755f37fa67bc3d3f0a7eddec7117013be42afff3602e7480d7271fff92763f1 210 output_mmr_size 0000000000001445 218 kernel_mmr_size 0000000000001130 226 total_difficulty 00000108e24af3bb 234 secondary_scaling 00000473 238 nonce 712493895227b883 246 edge_bits 1d 247 edge_nonces 43c8d2e098ba28f4f3748aab7d8be1aab3353259e6c6d4c046293f1c2f92afe7c5868bc5007fc51bae789ab3776d7efefb71547144b70ae8e764921bad8cb821a0c5d2adb455e1c406e1b2e39a2db51d7c552e4c1dd78bde1eea91f0843da6b3f1cb86e4ccb93371452b66c0ab292cd42525bcbf832fe358a3b22bcf7615e8397516ad8135a709213a77347cf4de104df5585984df0246fa03 400","title":"Example"},{"location":"wiki/blocks/fees-and-weight/","text":"Economic Policy: Fees and Mining Reward (there are several mentions oh weight and fees, one of them the document below written by igno in 2016, by you should probably wait until they're revisited (tromp rfc) before the last hard fork). WORK IN PROGRESS** Considerations Most cryptocurrencies rely on 2 important parameters: fees dictating the cost of transacting and block rewards compensating miners for securing the chain. Rewards also play the important role of being the only source of new money creation: the total amount of tokens in existence is the sum of every reward since the genesis block. No cryptocurrency so far has established a fee market that would allow to fully compensate for block rewards. Even bitcoin, with its fees significantly raising (as of Oct. 2016), is still far from reaching that goal. Given the current block space supply, bitcoin fees would have to raise by at least an order of magnitude, reaching $4 USD. Even then, the stability of the currency when mining is only paid out in fee is questionable 1 . We also note that the security provided by a large hashrate is desirable to all participants in a cryptocurrency's economy, and not only to active transactors. For all these reasons we favor a constant reward over time, remarking that it asymptotically leads to zero dilution 2 . However, any cryptocurrency needs to protect itself against malicious spamming attacks that would flood the network and bloat storage. Proof of work is an efficient and elegant way to do so but difficult to adopt due to the complex computing ecosystem a cryptocurrency evolves in (from mobile wallets to cheap super-computing). So transaction fees remain the simplest way to protect a blockchain against malicious spam. By acknowledging that transaction fees only act as spam prevention we gain a framework to gauge how they should be priced: proportionately to the cost incurred by the network when accepting and safekeeping the transaction. Fee Levels and Incentives Given that block reward is the only way new currency is introduced, and supply greatly influences value, it makes sense to price fees based on how much supply is injected in the system. It also makes sense to study this for Grin, to establish a fee baseline. We introduce the notion of fees per reward per minute. For example in Bitcoin, at this time the reward per minute is 1.25BTC. Transaction fees average 70 satoshis per byte for a fast confirmation, putting the average transaction price around 16,000 with a median transaction size of 230 bytes. So the fees for a transaction are priced at 0.00128% of the reward per minute. In Ethereum, factoring in the current gas price, the transaction fees are priced around 0.0028% of the reward per minute. It may come as a surprise that this number would be higher for Ethereum than Bitcoin, but keep in mind that it only factors supply and not demand. It also only reflects how fast supply is injected, not how much total supply is currently in existence. Nonetheless, these 2 numbers are surprisingly close, giving us a good baseline. http://randomwalker.info/publications/mining_CCS.pdf \u21a9 By introducing new currency, each block reward dilutes all existing participants, \u21a9","title":"Fees & Weight"},{"location":"wiki/blocks/fees-and-weight/#economic-policy-fees-and-mining-reward","text":"(there are several mentions oh weight and fees, one of them the document below written by igno in 2016, by you should probably wait until they're revisited (tromp rfc) before the last hard fork). WORK IN PROGRESS**","title":"Economic Policy: Fees and Mining Reward"},{"location":"wiki/blocks/fees-and-weight/#considerations","text":"Most cryptocurrencies rely on 2 important parameters: fees dictating the cost of transacting and block rewards compensating miners for securing the chain. Rewards also play the important role of being the only source of new money creation: the total amount of tokens in existence is the sum of every reward since the genesis block. No cryptocurrency so far has established a fee market that would allow to fully compensate for block rewards. Even bitcoin, with its fees significantly raising (as of Oct. 2016), is still far from reaching that goal. Given the current block space supply, bitcoin fees would have to raise by at least an order of magnitude, reaching $4 USD. Even then, the stability of the currency when mining is only paid out in fee is questionable 1 . We also note that the security provided by a large hashrate is desirable to all participants in a cryptocurrency's economy, and not only to active transactors. For all these reasons we favor a constant reward over time, remarking that it asymptotically leads to zero dilution 2 . However, any cryptocurrency needs to protect itself against malicious spamming attacks that would flood the network and bloat storage. Proof of work is an efficient and elegant way to do so but difficult to adopt due to the complex computing ecosystem a cryptocurrency evolves in (from mobile wallets to cheap super-computing). So transaction fees remain the simplest way to protect a blockchain against malicious spam. By acknowledging that transaction fees only act as spam prevention we gain a framework to gauge how they should be priced: proportionately to the cost incurred by the network when accepting and safekeeping the transaction. Fee Levels and Incentives Given that block reward is the only way new currency is introduced, and supply greatly influences value, it makes sense to price fees based on how much supply is injected in the system. It also makes sense to study this for Grin, to establish a fee baseline. We introduce the notion of fees per reward per minute. For example in Bitcoin, at this time the reward per minute is 1.25BTC. Transaction fees average 70 satoshis per byte for a fast confirmation, putting the average transaction price around 16,000 with a median transaction size of 230 bytes. So the fees for a transaction are priced at 0.00128% of the reward per minute. In Ethereum, factoring in the current gas price, the transaction fees are priced around 0.0028% of the reward per minute. It may come as a surprise that this number would be higher for Ethereum than Bitcoin, but keep in mind that it only factors supply and not demand. It also only reflects how fast supply is injected, not how much total supply is currently in existence. Nonetheless, these 2 numbers are surprisingly close, giving us a good baseline. http://randomwalker.info/publications/mining_CCS.pdf \u21a9 By introducing new currency, each block reward dilutes all existing participants, \u21a9","title":"Considerations"},{"location":"wiki/chain-state/chain-sync/","text":"Chain Sync Read (part of) this in other languages: Korean . Read about fast sync in other languages: Espa\u00f1ol , Korean , \u7b80\u4f53\u4e2d\u6587 . We describe here the different methods used by a new node when joining the network to catch up with the latest chain state. We start with reminding the reader of the following assumptions, which are all characteristics of Grin or Mimblewimble: All block headers include the root hash of all unspent outputs in the chain at the time of that block. Inputs or outputs cannot be tampered with or forged without invalidating the whole block state. We intentionally only focus on major node types and high level algorithms that may impact the security model. Detailed heuristics that can provide some additional improvements (like header first), while useful, will not be mentioned in this document. Full History Syncing This model is the one used by full nodes on most major public blockchains. The new node has prior knowledge of the genesis block. It connects to other peers in the network and starts asking for blocks until it reaches the latest block known to its peers. The security model here is similar to Bitcoin. We're able to verify the whole chain, the total work, the validity of each block, their full content, etc. In addition, with Mimblewimble and full UTXO set commitments, even more integrity validation can be performed. We do not try to do any space or bandwidth optimization in this mode (for example, once validated the range proofs could possibly be deleted). The point here is to provide history archival and allow later checks and verifications to be made. However, such full history sync, also called Initial Block Download (IBD), is unnecessary for a new node to fully validate the Grin chain history, as most blocks may be only partially downloaded. Fast Sync We call fast sync the process of synchronizing a new node, or a node that hasn't been keeping up with the chain for a while, and bringing it up to the latest known most-worked block. In this model we try to optimize for very fast syncing while sacrificing as little security assumptions as possible. As a matter of fact, the security model is almost identical as a full history sync, despite requiring orders of magnitude less data to download. At a high level, a fast-sync goes through the following process: Sync all block headers on the most worked chain as advertized by other nodes. Also, pick a header sufficiently back from the chain head. This is called the node horizon as it's the furthest a node can reorganize its chain on a new fork if it were to occur without triggering another new full sync. Once all headers have are synced, Download the full state as it was at the horizon, including the unspent output, range proof and kernel data, as well as all corresponding MMRs. This is just one large zip file named txhashset . Validate the full state. Download full blocks since the horizon to reach the chain head. A new node is pre-configured with a horizon Z , which is a distance in number of blocks from the head. For example, if horizon Z=5000 and the head is at height H=23000 , the block at horizon is the block at height h=18000 on the most worked chain. The new node also has prior knowledge of the genesis block. It connects to other peers and learns about the head of the most worked chain. It asks for the block header at the horizon block, requiring peer agreement. If consensus is not reached at h = H - Z , the node gradually increases the horizon Z , moving h backward until consensus is reached. Then it gets the full UTXO set at the horizon block. With this information it can verify: The total difficulty on that chain (present in all block headers). The sum of all UTXO commitments equals the expected money supply. The root hash of all UTXOs match the root hash in the block header. Once the validation is done, the peer can download and validate the blocks content from the horizon up to the head. While this algorithm still works for very low values of Z (or in the extreme case where Z=1 ), low values may be problematic due to the normal forking activity that can occur on any blockchain. To prevent those problems and to increase the amount of locally validated work, we recommend values of Z of at least a few days worth of blocks, up to a few weeks. Security Discussion While this sync mode is simple to describe, it may seem non-obvious how it still can be secure. We describe here some possible attacks, how they're defeated and other possible failure scenarios. An attacker tries to forge the state at horizon This range of attacks attempt to have a node believe it is properly synchronized with the network when it's actually is in a forged state. Multiple strategies can be attempted: Completely fake but valid horizon state (including header and proof of work). Assuming at least one honest peer, neither the UTXO set root hash nor the block hash will match other peers' horizon states. Valid block header but faked UTXO set. The UTXO set root hash from the header will not match what the node calculates from the received UTXO set itself. Completely valid block with fake total difficulty, which could lead the node down a fake fork. The block hash changes if the total difficulty is changed, no honest peer will produce a valid head for that hash. A fork occurs that's older than the local UTXO history Our node downloaded the full UTXO set at horizon height. If a fork occurs on a block at an older horizon H+delta, the UTXO set can't be validated. In this situation the node has no choice but to put itself back in sync mode with a new horizon of Z'=Z+delta . Note that an alternate fork at Z+delta that has less work than our current head can safely be ignored, only a winning fork of total work greater than our head would. To do this resolution, every block header includes the total chain difficulty up to that block. The chain is permanently forked If a hard fork occurs, the network may become split, forcing new nodes to always push their horizon back to when the hard fork occurred. While this is not a problem for short-term hard forks, it may become an issue for long-term or permanent forks. To prevent this situation, peers should always be checked for hard fork related capabilities (a bitmask of features a peer exposes) on connection. Several nodes continuously give fake horizon blocks If a peer can't reach consensus on the header at h, it gradually moves back. In the degenerate case, rogue peers could force all new peers to always become full nodes (move back until genesis) by systematically preventing consensus and feeding fake headers. While this is a valid issue, several mitigation strategies exist: Peers must still provide valid block headers at horizon Z . This includes the proof of work. A group of block headers around the horizon could be asked to increase the cost of the attack. Differing block headers providing a proof of work significantly lower could be rejected. The user or node operator may be asked to confirm a block hash. In last resort, if none of the above strategies are effective, checkpoints could be used.","title":"Chain Sync"},{"location":"wiki/chain-state/chain-sync/#chain-sync","text":"Read (part of) this in other languages: Korean . Read about fast sync in other languages: Espa\u00f1ol , Korean , \u7b80\u4f53\u4e2d\u6587 . We describe here the different methods used by a new node when joining the network to catch up with the latest chain state. We start with reminding the reader of the following assumptions, which are all characteristics of Grin or Mimblewimble: All block headers include the root hash of all unspent outputs in the chain at the time of that block. Inputs or outputs cannot be tampered with or forged without invalidating the whole block state. We intentionally only focus on major node types and high level algorithms that may impact the security model. Detailed heuristics that can provide some additional improvements (like header first), while useful, will not be mentioned in this document.","title":"Chain Sync"},{"location":"wiki/chain-state/chain-sync/#full-history-syncing","text":"This model is the one used by full nodes on most major public blockchains. The new node has prior knowledge of the genesis block. It connects to other peers in the network and starts asking for blocks until it reaches the latest block known to its peers. The security model here is similar to Bitcoin. We're able to verify the whole chain, the total work, the validity of each block, their full content, etc. In addition, with Mimblewimble and full UTXO set commitments, even more integrity validation can be performed. We do not try to do any space or bandwidth optimization in this mode (for example, once validated the range proofs could possibly be deleted). The point here is to provide history archival and allow later checks and verifications to be made. However, such full history sync, also called Initial Block Download (IBD), is unnecessary for a new node to fully validate the Grin chain history, as most blocks may be only partially downloaded.","title":"Full History Syncing"},{"location":"wiki/chain-state/chain-sync/#fast-sync","text":"We call fast sync the process of synchronizing a new node, or a node that hasn't been keeping up with the chain for a while, and bringing it up to the latest known most-worked block. In this model we try to optimize for very fast syncing while sacrificing as little security assumptions as possible. As a matter of fact, the security model is almost identical as a full history sync, despite requiring orders of magnitude less data to download. At a high level, a fast-sync goes through the following process: Sync all block headers on the most worked chain as advertized by other nodes. Also, pick a header sufficiently back from the chain head. This is called the node horizon as it's the furthest a node can reorganize its chain on a new fork if it were to occur without triggering another new full sync. Once all headers have are synced, Download the full state as it was at the horizon, including the unspent output, range proof and kernel data, as well as all corresponding MMRs. This is just one large zip file named txhashset . Validate the full state. Download full blocks since the horizon to reach the chain head. A new node is pre-configured with a horizon Z , which is a distance in number of blocks from the head. For example, if horizon Z=5000 and the head is at height H=23000 , the block at horizon is the block at height h=18000 on the most worked chain. The new node also has prior knowledge of the genesis block. It connects to other peers and learns about the head of the most worked chain. It asks for the block header at the horizon block, requiring peer agreement. If consensus is not reached at h = H - Z , the node gradually increases the horizon Z , moving h backward until consensus is reached. Then it gets the full UTXO set at the horizon block. With this information it can verify: The total difficulty on that chain (present in all block headers). The sum of all UTXO commitments equals the expected money supply. The root hash of all UTXOs match the root hash in the block header. Once the validation is done, the peer can download and validate the blocks content from the horizon up to the head. While this algorithm still works for very low values of Z (or in the extreme case where Z=1 ), low values may be problematic due to the normal forking activity that can occur on any blockchain. To prevent those problems and to increase the amount of locally validated work, we recommend values of Z of at least a few days worth of blocks, up to a few weeks.","title":"Fast Sync"},{"location":"wiki/chain-state/chain-sync/#security-discussion","text":"While this sync mode is simple to describe, it may seem non-obvious how it still can be secure. We describe here some possible attacks, how they're defeated and other possible failure scenarios.","title":"Security Discussion"},{"location":"wiki/chain-state/chain-sync/#an-attacker-tries-to-forge-the-state-at-horizon","text":"This range of attacks attempt to have a node believe it is properly synchronized with the network when it's actually is in a forged state. Multiple strategies can be attempted: Completely fake but valid horizon state (including header and proof of work). Assuming at least one honest peer, neither the UTXO set root hash nor the block hash will match other peers' horizon states. Valid block header but faked UTXO set. The UTXO set root hash from the header will not match what the node calculates from the received UTXO set itself. Completely valid block with fake total difficulty, which could lead the node down a fake fork. The block hash changes if the total difficulty is changed, no honest peer will produce a valid head for that hash.","title":"An attacker tries to forge the state at horizon"},{"location":"wiki/chain-state/chain-sync/#a-fork-occurs-thats-older-than-the-local-utxo-history","text":"Our node downloaded the full UTXO set at horizon height. If a fork occurs on a block at an older horizon H+delta, the UTXO set can't be validated. In this situation the node has no choice but to put itself back in sync mode with a new horizon of Z'=Z+delta . Note that an alternate fork at Z+delta that has less work than our current head can safely be ignored, only a winning fork of total work greater than our head would. To do this resolution, every block header includes the total chain difficulty up to that block.","title":"A fork occurs that's older than the local UTXO history"},{"location":"wiki/chain-state/chain-sync/#the-chain-is-permanently-forked","text":"If a hard fork occurs, the network may become split, forcing new nodes to always push their horizon back to when the hard fork occurred. While this is not a problem for short-term hard forks, it may become an issue for long-term or permanent forks. To prevent this situation, peers should always be checked for hard fork related capabilities (a bitmask of features a peer exposes) on connection.","title":"The chain is permanently forked"},{"location":"wiki/chain-state/chain-sync/#several-nodes-continuously-give-fake-horizon-blocks","text":"If a peer can't reach consensus on the header at h, it gradually moves back. In the degenerate case, rogue peers could force all new peers to always become full nodes (move back until genesis) by systematically preventing consensus and feeding fake headers. While this is a valid issue, several mitigation strategies exist: Peers must still provide valid block headers at horizon Z . This includes the proof of work. A group of block headers around the horizon could be asked to increase the cost of the attack. Differing block headers providing a proof of work significantly lower could be rejected. The user or node operator may be asked to confirm a block hash. In last resort, if none of the above strategies are effective, checkpoints could be used.","title":"Several nodes continuously give fake horizon blocks"},{"location":"wiki/chain-state/merkle-mountain-range/","text":"Merkle Mountain Ranges (MMR) Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . Structure For the original document describing the motivation for choosing MMR as the merkle structure for Grin, read here . Merkle Mountain Ranges 1 are an alternative to Merkle trees 2 . While the latter relies on perfectly balanced binary trees, the former can be seen either as list of perfectly balance binary trees or a single binary tree that would have been truncated from the top right. A Merkle Mountain Range (MMR) is strictly append-only: elements are added from the left to the right, adding a parent as soon as 2 children exist, filling up the range accordingly. Grin employs MMR to stores kernels, outputs and rangeproofs, each in its own dedicated tree. Let's illustrates a range with 11 inserted leaves and total size 19, where each node is annotated with its order of insertion. Height 3 14 / \\ / \\ / \\ / \\ 2 6 13 / \\ / \\ 1 2 5 9 12 17 / \\ / \\ / \\ / \\ / \\ 0 0 1 3 4 7 8 10 11 15 16 18 This can be represented as a flat list, here storing the height of each node at their position of insertion: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 0 0 1 0 0 1 2 0 0 1 0 0 1 2 3 0 0 1 0 The structure can be fully described simply from its size (19). It's also fairly simple, using fast binary operations, to navigate within a MMR. Given a node's position n , we can compute its height, the position of its parent, its siblings, etc. Hashing and Bagging Just like with Merkle trees, parent nodes in a MMR have for value the hash of their 2 children. Grin uses the Blake2b hash function throughout, and always prepends the node's position in the MMR before hashing to avoid collisions. So for a leaf l at index n storing data D (in the case of an output, the data is its Pedersen commitment, for example), we have: Node(l) = Blake2b(n | D) And for any parent p at index m : Node(p) = Blake2b(m | Node(left_child(p)) | Node(right_child(p))) Contrarily to a Merkle tree, a MMR generally has no single root by construction so we need a method to compute one (otherwise it would defeat the purpose of using a hash tree). This process is called \"bagging the peaks\" 1 . First, we identify the peaks of the MMR; we will define one method of doing so here. We first write another small example MMR but with the indexes written as binary (instead of decimal), starting from 1: Height 2 111 / \\ 1 11 110 1010 / \\ / \\ / \\ 0 1 10 100 101 1000 1001 1011 This MMR has 11 nodes and its peaks are at position 111 (7), 1010 (10) and 1011 (11). We first notice how the first leftmost peak is always going to be the highest and always \"all ones\" when expressed in binary. Therefore that peak will have a position of the form 2^n - 1 and will always be the largest such position that is inside the MMR (its position is lesser than the total size). We process iteratively for a MMR of size 11: 2^0 - 1 = 0, and 0 < 11 2^1 - 1 = 1, and 1 < 11 2^2 - 1 = 3, and 3 < 11 2^3 - 1 = 7, and 7 < 11 2^4 - 1 = 15, and 15 is not < 11 (This can also be calculated non-iteratively as 2^(binary logarithm of size + 1) - 1 Therefore the first peak is 7. To find the next peak, we then need to \"jump\" to its right sibling. If that node is not in the MMR (and it won't), take its left child. If that child is not in the MMR either, keep taking its left child until we have a node that exists in our MMR. Once we find that next peak, keep repeating the process until we're at the last node. All these operations are very simple. Jumping to the right sibling of a node at height h is adding 2^(h+1) - 1 to its position. Taking its left child is subtracting 2^h . Finally, once all the positions of the peaks are known, \"bagging\" the peaks consists of hashing them iteratively from the right, using the total size of the MMR as prefix. For a MMR of size N with 3 peaks p1, p2 and p3 we get the final top peak: P = Blake2b(N | Blake2b(N | Node(p3) | Node(p2)) | Node(p1)) Pruning In Grin, a lot of the data that gets hashed and stored in MMRs can eventually be removed. As this happens, the presence of some leaf hashes in the corresponding MMRs become unnecessary and their hash can be removed. When enough leaves are removed, the presence of their parents may become unnecessary as well. We can therefore prune a significant part of a MMR from the removal of its leaves. Pruning a MMR relies on a simple iterative process. X is first initialized as the leaf we wish to prune. Prune X . If X has a sibling, stop here. If 'X' has no sibling, assign the parent of X as X . To visualize the result, starting from our first MMR example and removing leaves [0, 3, 4, 8, 16] leads to the following pruned MMR: Height 3 14 / \\ / \\ / \\ / \\ 2 6 13 / / \\ 1 2 9 12 17 \\ / / \\ / 0 1 7 10 11 15 18 Merkle Proof In the example above, the leaf nodes are 1, 2, 4, 5, 8, 9, 11, 12. Only these nodes hash actual data, while non-leaf nodes are simply hashes of their children. Output Set MMR Let's define the functionality of generating a Merkle proof for a given entry, OutX , in the total output set MMR. A Merkle proof consists of the following: Hash of the leaf node representing OutX . Hash of the overall root of the tree. A list of hashes representing all the MMR peaks (they match the overall root when hashed together). A list of sibling hashes to construct branch from node outX to its peak. A list of sibling positions (left/right) to allow the branch to be reconstructed correctly. A Merkle proof allows us to: Prove inclusion of the node beneath its peak. Prove the peaks combine to form the overall root hash. Prove inclusion of an (unspent) output for a given block_header by verifying the utxo_root matches the root of the Merkle proof If an output is unspent at a given block header, then it is at least as old as that block. Coinbase Output The wallet maintains a Merkle proof (and corresponding block hash) for each unspent coinbase output. Spending a coinbase output requires the block hash and Merkle proof to be provided in the input. these are used to verify coinbase maturity (without requiring full block data for verification) merkle-mountain-range , Peter Todd \u21a9 \u21a9 Merkle Tree , Wikipedia \u21a9","title":"Merkle Mountain Ranges"},{"location":"wiki/chain-state/merkle-mountain-range/#merkle-mountain-ranges-mmr","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 .","title":"Merkle Mountain Ranges (MMR)"},{"location":"wiki/chain-state/merkle-mountain-range/#structure","text":"For the original document describing the motivation for choosing MMR as the merkle structure for Grin, read here . Merkle Mountain Ranges 1 are an alternative to Merkle trees 2 . While the latter relies on perfectly balanced binary trees, the former can be seen either as list of perfectly balance binary trees or a single binary tree that would have been truncated from the top right. A Merkle Mountain Range (MMR) is strictly append-only: elements are added from the left to the right, adding a parent as soon as 2 children exist, filling up the range accordingly. Grin employs MMR to stores kernels, outputs and rangeproofs, each in its own dedicated tree. Let's illustrates a range with 11 inserted leaves and total size 19, where each node is annotated with its order of insertion. Height 3 14 / \\ / \\ / \\ / \\ 2 6 13 / \\ / \\ 1 2 5 9 12 17 / \\ / \\ / \\ / \\ / \\ 0 0 1 3 4 7 8 10 11 15 16 18 This can be represented as a flat list, here storing the height of each node at their position of insertion: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 0 0 1 0 0 1 2 0 0 1 0 0 1 2 3 0 0 1 0 The structure can be fully described simply from its size (19). It's also fairly simple, using fast binary operations, to navigate within a MMR. Given a node's position n , we can compute its height, the position of its parent, its siblings, etc.","title":"Structure"},{"location":"wiki/chain-state/merkle-mountain-range/#hashing-and-bagging","text":"Just like with Merkle trees, parent nodes in a MMR have for value the hash of their 2 children. Grin uses the Blake2b hash function throughout, and always prepends the node's position in the MMR before hashing to avoid collisions. So for a leaf l at index n storing data D (in the case of an output, the data is its Pedersen commitment, for example), we have: Node(l) = Blake2b(n | D) And for any parent p at index m : Node(p) = Blake2b(m | Node(left_child(p)) | Node(right_child(p))) Contrarily to a Merkle tree, a MMR generally has no single root by construction so we need a method to compute one (otherwise it would defeat the purpose of using a hash tree). This process is called \"bagging the peaks\" 1 . First, we identify the peaks of the MMR; we will define one method of doing so here. We first write another small example MMR but with the indexes written as binary (instead of decimal), starting from 1: Height 2 111 / \\ 1 11 110 1010 / \\ / \\ / \\ 0 1 10 100 101 1000 1001 1011 This MMR has 11 nodes and its peaks are at position 111 (7), 1010 (10) and 1011 (11). We first notice how the first leftmost peak is always going to be the highest and always \"all ones\" when expressed in binary. Therefore that peak will have a position of the form 2^n - 1 and will always be the largest such position that is inside the MMR (its position is lesser than the total size). We process iteratively for a MMR of size 11: 2^0 - 1 = 0, and 0 < 11 2^1 - 1 = 1, and 1 < 11 2^2 - 1 = 3, and 3 < 11 2^3 - 1 = 7, and 7 < 11 2^4 - 1 = 15, and 15 is not < 11 (This can also be calculated non-iteratively as 2^(binary logarithm of size + 1) - 1 Therefore the first peak is 7. To find the next peak, we then need to \"jump\" to its right sibling. If that node is not in the MMR (and it won't), take its left child. If that child is not in the MMR either, keep taking its left child until we have a node that exists in our MMR. Once we find that next peak, keep repeating the process until we're at the last node. All these operations are very simple. Jumping to the right sibling of a node at height h is adding 2^(h+1) - 1 to its position. Taking its left child is subtracting 2^h . Finally, once all the positions of the peaks are known, \"bagging\" the peaks consists of hashing them iteratively from the right, using the total size of the MMR as prefix. For a MMR of size N with 3 peaks p1, p2 and p3 we get the final top peak: P = Blake2b(N | Blake2b(N | Node(p3) | Node(p2)) | Node(p1))","title":"Hashing and Bagging"},{"location":"wiki/chain-state/merkle-mountain-range/#pruning","text":"In Grin, a lot of the data that gets hashed and stored in MMRs can eventually be removed. As this happens, the presence of some leaf hashes in the corresponding MMRs become unnecessary and their hash can be removed. When enough leaves are removed, the presence of their parents may become unnecessary as well. We can therefore prune a significant part of a MMR from the removal of its leaves. Pruning a MMR relies on a simple iterative process. X is first initialized as the leaf we wish to prune. Prune X . If X has a sibling, stop here. If 'X' has no sibling, assign the parent of X as X . To visualize the result, starting from our first MMR example and removing leaves [0, 3, 4, 8, 16] leads to the following pruned MMR: Height 3 14 / \\ / \\ / \\ / \\ 2 6 13 / / \\ 1 2 9 12 17 \\ / / \\ / 0 1 7 10 11 15 18","title":"Pruning"},{"location":"wiki/chain-state/merkle-mountain-range/#merkle-proof","text":"In the example above, the leaf nodes are 1, 2, 4, 5, 8, 9, 11, 12. Only these nodes hash actual data, while non-leaf nodes are simply hashes of their children.","title":"Merkle Proof"},{"location":"wiki/chain-state/merkle-mountain-range/#output-set-mmr","text":"Let's define the functionality of generating a Merkle proof for a given entry, OutX , in the total output set MMR. A Merkle proof consists of the following: Hash of the leaf node representing OutX . Hash of the overall root of the tree. A list of hashes representing all the MMR peaks (they match the overall root when hashed together). A list of sibling hashes to construct branch from node outX to its peak. A list of sibling positions (left/right) to allow the branch to be reconstructed correctly. A Merkle proof allows us to: Prove inclusion of the node beneath its peak. Prove the peaks combine to form the overall root hash. Prove inclusion of an (unspent) output for a given block_header by verifying the utxo_root matches the root of the Merkle proof If an output is unspent at a given block header, then it is at least as old as that block. Coinbase Output The wallet maintains a Merkle proof (and corresponding block hash) for each unspent coinbase output. Spending a coinbase output requires the block hash and Merkle proof to be provided in the input. these are used to verify coinbase maturity (without requiring full block data for verification) merkle-mountain-range , Peter Todd \u21a9 \u21a9 Merkle Tree , Wikipedia \u21a9","title":"Output Set MMR"},{"location":"wiki/chain-state/merkle-structures%28old%29/","text":"Merkle Structures Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . Mimblewimble is designed for users to verify the state of the system given only pruned data. To achieve this goal, all transaction data is committed to the blockchain by means of Merkle trees which should support efficient updates and serialization even when pruned. Also, almost all transaction data (inputs, outputs, excesses and excess proofs) have the ability to be summed in some way, so it makes sense to treat Merkle sum trees as the default option, and address the sums here. A design goal of Grin is that all structures be as easy to implement and as simple as possible. Mimblewimble introduces a lot of new cryptography so it should be made as easy to understand as possible. Its validation rules are simple to specify (no scripts) and Grin is written in a language with very explicit semantics, so simplicity is also good to achieve well-understood consensus rules. Merkle Trees There are four Merkle trees committed to by each block: Total Output Set Each object is one of two things: a commitment indicating an unspent output or a NULL marker indicating a spent one. It is a sum-tree over all unspent outputs (spent ones contribute nothing to the sum). The output set should reflect the state of the chain after the current block has taken effect. The root sum should be equal to the sum of all excesses since the genesis. Design requirements: Efficient additions and updating from unspent to spent. Efficient proofs that a specific output was spent. Efficient storage of diffs between UTXO roots. Efficient tree storage even with missing data, even with millions of entries. If a node commits to NULL, it has no unspent children and its data should eventually be able to be dropped forever. Support for serialization and efficient merging of pruned trees from partial archival nodes. Output witnesses This tree mirrors the total output set but has rangeproofs in place of commitments. It is never updated, only appended to, and does not sum over anything. When an output is spent it is sufficient to prune its rangeproof from the tree rather than deleting it. Design requirements: Support for serialization and efficient merging of pruned trees from partial archival nodes. Inputs and Outputs Each object is one of two things: an input (unambiguous reference to an old transaction output), or an output (a (commitment, rangeproof) pair). It is a sum-tree over the commitments of outputs, and the negatives of the commitments of inputs. Input references are hashes of old commitments. It is a consensus rule that all unspent outputs must be unique. The root sum should be equal to the sum of excesses for this block. See the next section. In general, validators will see either 100% of this Merkle tree or 0% of it, so it is compatible with any design. Design requirements: Efficient inclusion proofs, for proof-of-publication. Excesses Each object is of the form (excess, signature). It is a sum tree over the excesses. In general, validators will always see 100% of this tree, so it is not even necessary to have a Merkle structure at all. However, to support partial archival nodes in the future we want to support efficient pruning. Design requirements: Support for serialization and efficient merging of pruned trees from partial archival nodes. Proposed Merkle Structure The following design is proposed for all trees: a sum-MMR where every node sums a count of its children as well as the data it is supposed to sum. The result is that every node commits to the count of all its children. MMRs, or Merkle Mountain Ranges The six design criteria for the output set are: Efficient insert/updates Immediate (as is proof-of-inclusion). This is true for any balanced Merkle tree design. Efficient proof-of-spentness Grin itself does not need proof-of-spentness but it is a good thing to support in the future for SPV clients. The children-counts imply an index of each object in the tree, which does not change because insertions happen only at the far right of the tree. This allows permanent proof-of-spentness, even if an identical output is later added to the tree, and prevents false proofs even for identical outputs. These properties are hard to achieve for a non-insertion-ordered tree. Efficient storage of diffs Storing complete blocks should be sufficient for this. Updates are obviously as easy to undo as they are to do, and since blocks are always processed in order, rewinding them during reorgs is as simple as removing a contiguous set of outputs from the right of the tree. (This should be even faster than repeated deletions in a tree designed to support deletions.) Efficient tree storage even with missing data To update the root hash when random outputs are spent, we do not want to need to store or compute the entire tree. Instead we can store only the hashes at depth 20, say, of which there will be at most a million. Then each update only needs to recompute hashes above this depth (Bitcoin has less than 2^29 outputs in its history, so this means computing a tree of size 2^9 = 512 for each update) and after all updates are done, the root hash can be recomputed. This depth is configurable and may be changed as the output set grows, or depending on available disk space. This is doable for any Merkle tree but may be complicated by PATRICIA trees or other prefix trees, depending how depth is computed. Dropping spent coins Since coins never go from spent to unspent, the data on spent coins is not needed for any more updates or lookups. Efficient serialization of pruned trees Since every node has a count of its children, validators can determine the structure of the tree without needing all the hashes, and can determine which nodes are siblings, and so on. In the output set each node also commits to a sum of its unspent children, so a validator knows if it is missing data on unspent coins by checking whether or not this sum on a pruned node is zero. Algorithms (To appear alongside an implementation.) Storage The sum tree data structure allows the efficient storage of the output set and output witnesses while allowing immediate retrieval of a root hash or root sum (when applicable). However, the tree must contain every output commitment and witness hash in the system. This data is too big to be permanently stored in memory and too costly to be rebuilt from scratch at every restart, even if we consider pruning (at this time, Bitcoin has over 50M UTXOs which would require at least 3.2GB, assuming a couple hashes per UTXO). So we need an efficient way to store this data structure on disk. Another limitation of a hash tree is that, given a key (i.e. an output commitment), it's impossible to find the leaf in the tree associated with that key. We can't walk down the tree from the root in any meaningful way. So an additional index over the whole key space is required. As an MMR is an append only binary tree, we can find a key in the tree by its insertion position. So a full index of keys inserted in the tree (i.e. an output commitment) to their insertion positions is also required.","title":"Merkle Structures"},{"location":"wiki/chain-state/merkle-structures%28old%29/#merkle-structures","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . Mimblewimble is designed for users to verify the state of the system given only pruned data. To achieve this goal, all transaction data is committed to the blockchain by means of Merkle trees which should support efficient updates and serialization even when pruned. Also, almost all transaction data (inputs, outputs, excesses and excess proofs) have the ability to be summed in some way, so it makes sense to treat Merkle sum trees as the default option, and address the sums here. A design goal of Grin is that all structures be as easy to implement and as simple as possible. Mimblewimble introduces a lot of new cryptography so it should be made as easy to understand as possible. Its validation rules are simple to specify (no scripts) and Grin is written in a language with very explicit semantics, so simplicity is also good to achieve well-understood consensus rules.","title":"Merkle Structures"},{"location":"wiki/chain-state/merkle-structures%28old%29/#merkle-trees","text":"There are four Merkle trees committed to by each block:","title":"Merkle Trees"},{"location":"wiki/chain-state/merkle-structures%28old%29/#total-output-set","text":"Each object is one of two things: a commitment indicating an unspent output or a NULL marker indicating a spent one. It is a sum-tree over all unspent outputs (spent ones contribute nothing to the sum). The output set should reflect the state of the chain after the current block has taken effect. The root sum should be equal to the sum of all excesses since the genesis. Design requirements: Efficient additions and updating from unspent to spent. Efficient proofs that a specific output was spent. Efficient storage of diffs between UTXO roots. Efficient tree storage even with missing data, even with millions of entries. If a node commits to NULL, it has no unspent children and its data should eventually be able to be dropped forever. Support for serialization and efficient merging of pruned trees from partial archival nodes.","title":"Total Output Set"},{"location":"wiki/chain-state/merkle-structures%28old%29/#output-witnesses","text":"This tree mirrors the total output set but has rangeproofs in place of commitments. It is never updated, only appended to, and does not sum over anything. When an output is spent it is sufficient to prune its rangeproof from the tree rather than deleting it. Design requirements: Support for serialization and efficient merging of pruned trees from partial archival nodes.","title":"Output witnesses"},{"location":"wiki/chain-state/merkle-structures%28old%29/#inputs-and-outputs","text":"Each object is one of two things: an input (unambiguous reference to an old transaction output), or an output (a (commitment, rangeproof) pair). It is a sum-tree over the commitments of outputs, and the negatives of the commitments of inputs. Input references are hashes of old commitments. It is a consensus rule that all unspent outputs must be unique. The root sum should be equal to the sum of excesses for this block. See the next section. In general, validators will see either 100% of this Merkle tree or 0% of it, so it is compatible with any design. Design requirements: Efficient inclusion proofs, for proof-of-publication.","title":"Inputs and Outputs"},{"location":"wiki/chain-state/merkle-structures%28old%29/#excesses","text":"Each object is of the form (excess, signature). It is a sum tree over the excesses. In general, validators will always see 100% of this tree, so it is not even necessary to have a Merkle structure at all. However, to support partial archival nodes in the future we want to support efficient pruning. Design requirements: Support for serialization and efficient merging of pruned trees from partial archival nodes.","title":"Excesses"},{"location":"wiki/chain-state/merkle-structures%28old%29/#proposed-merkle-structure","text":"The following design is proposed for all trees: a sum-MMR where every node sums a count of its children as well as the data it is supposed to sum. The result is that every node commits to the count of all its children. MMRs, or Merkle Mountain Ranges The six design criteria for the output set are:","title":"Proposed Merkle Structure"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-insertupdates","text":"Immediate (as is proof-of-inclusion). This is true for any balanced Merkle tree design.","title":"Efficient insert/updates"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-proof-of-spentness","text":"Grin itself does not need proof-of-spentness but it is a good thing to support in the future for SPV clients. The children-counts imply an index of each object in the tree, which does not change because insertions happen only at the far right of the tree. This allows permanent proof-of-spentness, even if an identical output is later added to the tree, and prevents false proofs even for identical outputs. These properties are hard to achieve for a non-insertion-ordered tree.","title":"Efficient proof-of-spentness"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-storage-of-diffs","text":"Storing complete blocks should be sufficient for this. Updates are obviously as easy to undo as they are to do, and since blocks are always processed in order, rewinding them during reorgs is as simple as removing a contiguous set of outputs from the right of the tree. (This should be even faster than repeated deletions in a tree designed to support deletions.)","title":"Efficient storage of diffs"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-tree-storage-even-with-missing-data","text":"To update the root hash when random outputs are spent, we do not want to need to store or compute the entire tree. Instead we can store only the hashes at depth 20, say, of which there will be at most a million. Then each update only needs to recompute hashes above this depth (Bitcoin has less than 2^29 outputs in its history, so this means computing a tree of size 2^9 = 512 for each update) and after all updates are done, the root hash can be recomputed. This depth is configurable and may be changed as the output set grows, or depending on available disk space. This is doable for any Merkle tree but may be complicated by PATRICIA trees or other prefix trees, depending how depth is computed.","title":"Efficient tree storage even with missing data"},{"location":"wiki/chain-state/merkle-structures%28old%29/#dropping-spent-coins","text":"Since coins never go from spent to unspent, the data on spent coins is not needed for any more updates or lookups.","title":"Dropping spent coins"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-serialization-of-pruned-trees","text":"Since every node has a count of its children, validators can determine the structure of the tree without needing all the hashes, and can determine which nodes are siblings, and so on. In the output set each node also commits to a sum of its unspent children, so a validator knows if it is missing data on unspent coins by checking whether or not this sum on a pruned node is zero.","title":"Efficient serialization of pruned trees"},{"location":"wiki/chain-state/merkle-structures%28old%29/#algorithms","text":"(To appear alongside an implementation.)","title":"Algorithms"},{"location":"wiki/chain-state/merkle-structures%28old%29/#storage","text":"The sum tree data structure allows the efficient storage of the output set and output witnesses while allowing immediate retrieval of a root hash or root sum (when applicable). However, the tree must contain every output commitment and witness hash in the system. This data is too big to be permanently stored in memory and too costly to be rebuilt from scratch at every restart, even if we consider pruning (at this time, Bitcoin has over 50M UTXOs which would require at least 3.2GB, assuming a couple hashes per UTXO). So we need an efficient way to store this data structure on disk. Another limitation of a hash tree is that, given a key (i.e. an output commitment), it's impossible to find the leaf in the tree associated with that key. We can't walk down the tree from the root in any meaningful way. So an additional index over the whole key space is required. As an MMR is an append only binary tree, we can find a key in the tree by its insertion position. So a full index of keys inserted in the tree (i.e. an output commitment) to their insertion positions is also required.","title":"Storage"},{"location":"wiki/chain-state/state-and-pruning/","text":"State and Pruning Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . State Storage Recall that the Grin chain includes the following data: Outputs, which include for each output: A Pedersen commitment (33 bytes). A range proof (640KB). Inputs, which are just output references (32 bytes). Transaction kernels, which include for each transaction: The excess commitment sum for the transaction (33 bytes). A signature generated with the excess (~70 bytes). A block header with a valid proof of work and roots of the Merkle trees. Each node maintains 3 MMRs: An output set MMR. Rangeproofs MMR. Transaction kernels MMR. All outputs, rangeproofs and kernels are added in their respective MMRs in the order they occur in each block (recall that block data is required to be sorted). Pruning As outputs get spent, both their commitment and rangeproof data can be removed. In addition, the corresponding output and range proof MMRs can be pruned of their hash entires. PMMR A pruned MMR is referred to as a PMMR. Following pruning, the full state of the chain consists of the following data: The unspent output set (UTXO). A rangeproof for each unspent output. All transaction kernels. In addition, all block headers are required to anchor the above state with a valid proof of work (the state corresponds to the most worked chain). Validation Pruning removes as much data as possible while keeping all the guarantees of a full Mimblewimble-style validation. This is necessary to keep a pruning node state's sane, but also on first fast sync, where only the minimum amount of data is sent to a new node. The full validation of the chain state requires that: All kernel signatures verify against their public keys (excess commitments). The sum of all UTXO commitments minus the supply is a valid public key. The sum of all kernel public keys equals the above public key (sum of UTXO commitments minus supply). The root hashes of the UTXO PMMR, the range proofs PMMR and the kernels MMR match a block header with a valid proof of work chain. All range proofs are valid. While not necessary to validate the full chain state, accepting and validating new blocks also requires the output features (coinbase or plain), making the full output data necessary for all UTXOs. At minimum, this requires the following data: The block headers chain. All kernels, in order of inclusion in the chain. This also allows the reconstruction of the kernel MMR. All unspent outputs. The UTXO MMR and the range proof MMR (to learn the hashes of pruned data).","title":"State & Pruning"},{"location":"wiki/chain-state/state-and-pruning/#state-and-pruning","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 .","title":"State and Pruning"},{"location":"wiki/chain-state/state-and-pruning/#state-storage","text":"Recall that the Grin chain includes the following data: Outputs, which include for each output: A Pedersen commitment (33 bytes). A range proof (640KB). Inputs, which are just output references (32 bytes). Transaction kernels, which include for each transaction: The excess commitment sum for the transaction (33 bytes). A signature generated with the excess (~70 bytes). A block header with a valid proof of work and roots of the Merkle trees. Each node maintains 3 MMRs: An output set MMR. Rangeproofs MMR. Transaction kernels MMR. All outputs, rangeproofs and kernels are added in their respective MMRs in the order they occur in each block (recall that block data is required to be sorted).","title":"State Storage"},{"location":"wiki/chain-state/state-and-pruning/#pruning","text":"As outputs get spent, both their commitment and rangeproof data can be removed. In addition, the corresponding output and range proof MMRs can be pruned of their hash entires. PMMR A pruned MMR is referred to as a PMMR. Following pruning, the full state of the chain consists of the following data: The unspent output set (UTXO). A rangeproof for each unspent output. All transaction kernels. In addition, all block headers are required to anchor the above state with a valid proof of work (the state corresponds to the most worked chain).","title":"Pruning"},{"location":"wiki/chain-state/state-and-pruning/#validation","text":"Pruning removes as much data as possible while keeping all the guarantees of a full Mimblewimble-style validation. This is necessary to keep a pruning node state's sane, but also on first fast sync, where only the minimum amount of data is sent to a new node. The full validation of the chain state requires that: All kernel signatures verify against their public keys (excess commitments). The sum of all UTXO commitments minus the supply is a valid public key. The sum of all kernel public keys equals the above public key (sum of UTXO commitments minus supply). The root hashes of the UTXO PMMR, the range proofs PMMR and the kernels MMR match a block header with a valid proof of work chain. All range proofs are valid. While not necessary to validate the full chain state, accepting and validating new blocks also requires the output features (coinbase or plain), making the full output data necessary for all UTXOs. At minimum, this requires the following data: The block headers chain. All kernels, in order of inclusion in the chain. This also allows the reconstruction of the kernel MMR. All unspent outputs. The UTXO MMR and the range proof MMR (to learn the hashes of pruned data).","title":"Validation"},{"location":"wiki/extra-documents/build-run-automation/","text":"Build and Run Automation To get an automated build of grin and run the server, pull changes from Github, compile and restart, then run grin as a service. Tested on both Ubuntu 16.04 and Fedora 28. Build and run manually the first time Follow the instructions in the build docs to build a binary or download the grin release binary . You should end up with a .grin directory in your home folder. Set up grin as a service Disable the TUI before setting up grin as a service by updating the following line in ~/.grin/main/grin-server.toml to false : run_tui = false Then create a service file for grin: sudo nano /etc/systemd/system/grin.service Paste the following content into the file. Ensure you update it with your own user, group, working directory, and path where you placed the grin binary. [Unit] Description=grin node After=network.target [Service] WorkingDirectory=/home/alice/.grin/ User=alice Group=alice PrivateDevices=yes Type=simple ExecReload=/bin/kill -HUP $MAINPID KillMode=mixed KillSignal=SIGTERM TimeoutStopSec=60 ExecStart=/home/alice/mimblewimble/grin/target/release/grin Restart=on-failure RestartSec=30 [Install] WantedBy=multi-user.target Alias=grin.service Tell systemd to reload (you need to do that every time you edit this file): systemctl daemon-reload Now try to start the node: sudo systemctl start grin And check to see if it's running: ps aux | grep grin That should give you two lines of output like this: alice 19175 0 .4 0 .6 188040 54208 ? Ssl 17 :45 0 :07 /home/alice/mimblewimble/grin/target/release/grin alice 27481 0 .0 0 .0 12944 1028 pts/0 S+ 18 :11 0 :00 grep --color = auto grin SELinux If you use SELinux in Enforcing mode, the first time you are going to run grin via systemd is going to fail with permission errors. You can grab a profile of those permission errors using audit2allow , create a SELinux policy module for grin, and add that module in SELinux's policies. # capture grin AVC denials in a file ( sudo audit2allow -w -a | ausearch -c grin ) > denials.log # create a policy module out of the captured denials # avoid piping audit2allow to itself due to https://bugs.centos.org/view.php?id=14220 cat denials.log | audit2allow -M grin # set the module in SELinux's policies sudo semodule -i grin.pp There is an additional thread in grin named peer_connect that also gets denied certain access so it's more likely that you will need to repeat the above process for it as well. Create an update script Copy this text into a nightly-update.sh script in the same directory as the above: #!/bin/sh cd /home/alice/mimblewimble/grin git pull git checkout master git fetch --tags latestTag = $( git describe --tags ` git rev-list --tags --max-count = 1 ` ) git checkout $latestTag cargo build --release sudo systemctl restart grin If you want to be pedantic and build from scratch every time, you can also insert cargo clean before cargo build --release . Set up a cron job You can set up cron jobs for you the current user by executing: crontab -e This will open an editor and let you edit the cron file of the current user. Paste this onto the bottom of the file: 0 2 * * * /home/alice/mimblewimble/nightly-update.sh 1> /home/alice/mimblewimble/nightly-update.log 2> /home/alice/mimblewimble/nightly-update.log The above puts either success or fail debug output into a file in your main directory. Alternatively, if mail is enabled on your host, you can also have the results emailed to you: 0 2 * * * /home/alice/mimblewimble/nightly-update.sh 2>&1 | mail -s \"grin update FAIL\" you@yourdomain.com This runs the script from the previous step at 2 am UTC. Please adjust this time with some randomness so your node does not restart at the same time as everyone else. Check that it worked Later, after your chosen time of day has passed, you can check that all is working as expected. If you run ps aux | grep grin , you should get one output line that is something like: alice 13065 0.5 1.0 206492 85232 ? Ssl 02:00 5:30 /home/alice/mimblewimble/grin/target/release/grin That means the server is running. Now also check that the latest version was built by running: ls -l ~/mimblewimble/grin/target/release/grin That should make it all set to compile and restart every night. Enjoy!","title":"Build and Run Automation"},{"location":"wiki/extra-documents/build-run-automation/#build-and-run-automation","text":"To get an automated build of grin and run the server, pull changes from Github, compile and restart, then run grin as a service. Tested on both Ubuntu 16.04 and Fedora 28.","title":"Build and Run Automation"},{"location":"wiki/extra-documents/build-run-automation/#build-and-run-manually-the-first-time","text":"Follow the instructions in the build docs to build a binary or download the grin release binary . You should end up with a .grin directory in your home folder.","title":"Build and run manually the first time"},{"location":"wiki/extra-documents/build-run-automation/#set-up-grin-as-a-service","text":"Disable the TUI before setting up grin as a service by updating the following line in ~/.grin/main/grin-server.toml to false : run_tui = false Then create a service file for grin: sudo nano /etc/systemd/system/grin.service Paste the following content into the file. Ensure you update it with your own user, group, working directory, and path where you placed the grin binary. [Unit] Description=grin node After=network.target [Service] WorkingDirectory=/home/alice/.grin/ User=alice Group=alice PrivateDevices=yes Type=simple ExecReload=/bin/kill -HUP $MAINPID KillMode=mixed KillSignal=SIGTERM TimeoutStopSec=60 ExecStart=/home/alice/mimblewimble/grin/target/release/grin Restart=on-failure RestartSec=30 [Install] WantedBy=multi-user.target Alias=grin.service Tell systemd to reload (you need to do that every time you edit this file): systemctl daemon-reload Now try to start the node: sudo systemctl start grin And check to see if it's running: ps aux | grep grin That should give you two lines of output like this: alice 19175 0 .4 0 .6 188040 54208 ? Ssl 17 :45 0 :07 /home/alice/mimblewimble/grin/target/release/grin alice 27481 0 .0 0 .0 12944 1028 pts/0 S+ 18 :11 0 :00 grep --color = auto grin SELinux If you use SELinux in Enforcing mode, the first time you are going to run grin via systemd is going to fail with permission errors. You can grab a profile of those permission errors using audit2allow , create a SELinux policy module for grin, and add that module in SELinux's policies. # capture grin AVC denials in a file ( sudo audit2allow -w -a | ausearch -c grin ) > denials.log # create a policy module out of the captured denials # avoid piping audit2allow to itself due to https://bugs.centos.org/view.php?id=14220 cat denials.log | audit2allow -M grin # set the module in SELinux's policies sudo semodule -i grin.pp There is an additional thread in grin named peer_connect that also gets denied certain access so it's more likely that you will need to repeat the above process for it as well.","title":"Set up grin as a service"},{"location":"wiki/extra-documents/build-run-automation/#create-an-update-script","text":"Copy this text into a nightly-update.sh script in the same directory as the above: #!/bin/sh cd /home/alice/mimblewimble/grin git pull git checkout master git fetch --tags latestTag = $( git describe --tags ` git rev-list --tags --max-count = 1 ` ) git checkout $latestTag cargo build --release sudo systemctl restart grin If you want to be pedantic and build from scratch every time, you can also insert cargo clean before cargo build --release .","title":"Create an update script"},{"location":"wiki/extra-documents/build-run-automation/#set-up-a-cron-job","text":"You can set up cron jobs for you the current user by executing: crontab -e This will open an editor and let you edit the cron file of the current user. Paste this onto the bottom of the file: 0 2 * * * /home/alice/mimblewimble/nightly-update.sh 1> /home/alice/mimblewimble/nightly-update.log 2> /home/alice/mimblewimble/nightly-update.log The above puts either success or fail debug output into a file in your main directory. Alternatively, if mail is enabled on your host, you can also have the results emailed to you: 0 2 * * * /home/alice/mimblewimble/nightly-update.sh 2>&1 | mail -s \"grin update FAIL\" you@yourdomain.com This runs the script from the previous step at 2 am UTC. Please adjust this time with some randomness so your node does not restart at the same time as everyone else.","title":"Set up a cron job"},{"location":"wiki/extra-documents/build-run-automation/#check-that-it-worked","text":"Later, after your chosen time of day has passed, you can check that all is working as expected. If you run ps aux | grep grin , you should get one output line that is something like: alice 13065 0.5 1.0 206492 85232 ? Ssl 02:00 5:30 /home/alice/mimblewimble/grin/target/release/grin That means the server is running. Now also check that the latest version was built by running: ls -l ~/mimblewimble/grin/target/release/grin That should make it all set to compile and restart every night. Enjoy!","title":"Check that it worked"},{"location":"wiki/extra-documents/google-cloud-node/","text":"Grin node on Google Cloud (for free) Thanks to Google Cloud's Always Free program, it's possible to create an instance on Cloud Compute that runs a full Grin node, 24/7, without it costing you anything. This is a cheap (free!) and fool-proof way to get a node up and running since it: Is not dependent on the compatibility of your computer or OS; Does not require you to open up ports on your network; Starts you off from a clean instance; and Allows you to follow instructions that are replicable. The only requirement is that you are willing to sign up for a Google Cloud account and that you have a valid credit or debit card (which will not be charged). NOTE: This is for testing purposes only. The node is free to run, but if you make mistakes in the configuration you may incur charges. Make sure you monitor your account and billing status regularly whilst running your instance to avoid any unpleasant surprises. Google Cloud Set up Visit http://cloud.google.com and set up an account as an individual. This will require a debit or credit card, they do a $1 reserve charge on your card to ensure it's valid. As part of signing up you also get $300 in free trial credit to spend within 12 months. In order to qualify for Always Free you need to have an upgraded account. So ensure you upgrade . Note that this means that you will start to be charged automatically if your spend beyond the $300 in free trial credit. As you will not exceed the Always Free limits here, this point is moot, but keep it in mind for any other projects you use this account for. Launch a Cloud Shell console from your browser, or install the Google Cloud SDK to run Cloud Shell from your local terminal. Provisioning an instance From the cloud shell, run the following command to create grin-node1 , an always free-compatible instance running Linux Debian 10: gcloud beta compute instances create grin-node1 --zone = us-east1-b --machine-type = f1-micro --tags = grin-node --image = debian-10-buster-v20191210 --image-project = debian-cloud --boot-disk-size = 30GB --boot-disk-type = pd-standard --boot-disk-device-name = grin-disk1 Building Your newly created grin-node1 should now be visible in your list of Cloud Compute Instances . From there, open an SSH session in your browser by clicking the SSH button, or SSH to the instance through your own terminal . As always, first update your system: sudo apt-get update Install some tools: git pkg-config nano, a simple text editor tmux, which will allow you to run multiple terminal sessions and keep your node running on your instance once you disconnect remotely. See gentle intro and cheatsheet . sudo apt-get install git nano tmux pkg-config You can now enter a tmux session by tmux and at any time you can close down your connection by CTRL+b and then d as in detach, and then return to it later by tmux a as in attach. Next install all dependencies: sudo apt-get install clang cmake libncurses5-dev libncursesw5-dev zlib1g-dev libssl-dev tor Install rust: curl https://sh.rustup.rs -sSf | sh ; source $HOME /.cargo/env Clone grin and build a release version git clone https://github.com/mimblewimble/grin.git cd grin git checkout v4.0.2 cargo build --release Building takes ~90 minutes on the grin-node1 instance. Slow, but it's free. Good time for a coffee break. Alternatively, you can skip the build process by downloading the latest Grin binary from here . Clone grin-wallet and build a release version cd ~ git clone https://github.com/mimblewimble/grin-wallet.git cd grin-wallet cargo build --release Building takes ~60 minutes on the grin-node1 instance. Slow, but it's free. Good time for a coffee break. Alternatively, you can skip the build process by downloading the latest Grin binary from here . Syncing a Grin node When the build has completed, create a new tmux session and launch your Grin node in it: tmux new -s main cd target/release ./grin The node should automatically connect to peers and begin syncing. This might also take a while, so you might want to go for another break. Once completed, the node should be at the same block height as https://grinscan.net/ . We can now detach from the tmux session running the node by pressing ctrl+b , then d . This will allow us to continue interfacing with the gcloud instance command line, with the node running in the background. If you want to check in on the node at a later time, you can attach back into it's tmux session with tmux a -t main Optionally, from the cloud shell, open up your node's p2p port so it can receive inbound connections: gcloud compute firewall-rules create main-p2p-port --direction = INGRESS --action = ALLOW --rules = tcp:3414 --target-tags = grin-node1 Connecting to Google Grin node from local wallet This will allow you to use your wallet quickly and easily without the need to wait for your local node to sync! Follow instructions for setting up a Grin node as above. Once built and synched continue below. To enable external api calls to your Grin node, edit your ~/.grin/main/grin-server.toml configuration file on your Google instance: nano grin-server.toml set api_http_addr to 0.0.0.0:3413 and host to 0.0.0.0 : api_http_addr = \"0.0.0.0:3413\" host = \"0.0.0.0\" open up your node's api port so it can receive inbound connections gcloud compute firewall-rules create main-api-port --direction = INGRESS --action = ALLOW --rules = tcp:3413 --target-tags = grin-node1 your ~/.grin/main/grin-server.toml file on your Google instance will have an api_secret_path field (ex: ~/.grin/main/.api_secret unless changed.) Copy the value in the file and save this for later as you will need to provide this to your local wallet. on your local machine, create a new file for storing the api secret from the previous step (ex: ~/.grin/main/.remote_api_secret , but can be any location). Save file with key value copied in previous step. now update your local wallet configuration file: set node_api_secret_path to the path of the file created in the previous step (ex: ~/.grin/main/.remote_api_secret ) and update check_node_api_http_addr with IP address of your Google instance: api_secret_path = \"~/.grin/main/.remote_api_secret\" check_node_api_http_addr = \"http://{YourGoogleCloudIP}:3413\" Restart your node to update configuration changes. Once started, you can run wallet commands which will use your new external node. No need to start your local node and wait for synchronization on each start! ./grin-wallet info Password: ____ Wallet Summary Info - Account 'default' as of height 235438 ____ Confirmed Total | 0 .000000000 Awaiting Confirmation ( < 10 ) | 0 .000000000 Awaiting Finalization | 0 .000000000 Locked by previous transaction | 0 .000000000 -------------------------------- | ------------- Currently Spendable | 0 .000000000 Command 'info' completed successfully Future work Updating your node Connecting to Grin-Pool","title":"Grin node on Google Cloud (for free)"},{"location":"wiki/extra-documents/google-cloud-node/#grin-node-on-google-cloud-for-free","text":"Thanks to Google Cloud's Always Free program, it's possible to create an instance on Cloud Compute that runs a full Grin node, 24/7, without it costing you anything. This is a cheap (free!) and fool-proof way to get a node up and running since it: Is not dependent on the compatibility of your computer or OS; Does not require you to open up ports on your network; Starts you off from a clean instance; and Allows you to follow instructions that are replicable. The only requirement is that you are willing to sign up for a Google Cloud account and that you have a valid credit or debit card (which will not be charged). NOTE: This is for testing purposes only. The node is free to run, but if you make mistakes in the configuration you may incur charges. Make sure you monitor your account and billing status regularly whilst running your instance to avoid any unpleasant surprises.","title":"Grin node on Google Cloud (for free)"},{"location":"wiki/extra-documents/google-cloud-node/#google-cloud-set-up","text":"Visit http://cloud.google.com and set up an account as an individual. This will require a debit or credit card, they do a $1 reserve charge on your card to ensure it's valid. As part of signing up you also get $300 in free trial credit to spend within 12 months. In order to qualify for Always Free you need to have an upgraded account. So ensure you upgrade . Note that this means that you will start to be charged automatically if your spend beyond the $300 in free trial credit. As you will not exceed the Always Free limits here, this point is moot, but keep it in mind for any other projects you use this account for. Launch a Cloud Shell console from your browser, or install the Google Cloud SDK to run Cloud Shell from your local terminal.","title":"Google Cloud Set up"},{"location":"wiki/extra-documents/google-cloud-node/#provisioning-an-instance","text":"From the cloud shell, run the following command to create grin-node1 , an always free-compatible instance running Linux Debian 10: gcloud beta compute instances create grin-node1 --zone = us-east1-b --machine-type = f1-micro --tags = grin-node --image = debian-10-buster-v20191210 --image-project = debian-cloud --boot-disk-size = 30GB --boot-disk-type = pd-standard --boot-disk-device-name = grin-disk1","title":"Provisioning an instance"},{"location":"wiki/extra-documents/google-cloud-node/#building","text":"Your newly created grin-node1 should now be visible in your list of Cloud Compute Instances . From there, open an SSH session in your browser by clicking the SSH button, or SSH to the instance through your own terminal . As always, first update your system: sudo apt-get update Install some tools: git pkg-config nano, a simple text editor tmux, which will allow you to run multiple terminal sessions and keep your node running on your instance once you disconnect remotely. See gentle intro and cheatsheet . sudo apt-get install git nano tmux pkg-config You can now enter a tmux session by tmux and at any time you can close down your connection by CTRL+b and then d as in detach, and then return to it later by tmux a as in attach. Next install all dependencies: sudo apt-get install clang cmake libncurses5-dev libncursesw5-dev zlib1g-dev libssl-dev tor Install rust: curl https://sh.rustup.rs -sSf | sh ; source $HOME /.cargo/env Clone grin and build a release version git clone https://github.com/mimblewimble/grin.git cd grin git checkout v4.0.2 cargo build --release Building takes ~90 minutes on the grin-node1 instance. Slow, but it's free. Good time for a coffee break. Alternatively, you can skip the build process by downloading the latest Grin binary from here . Clone grin-wallet and build a release version cd ~ git clone https://github.com/mimblewimble/grin-wallet.git cd grin-wallet cargo build --release Building takes ~60 minutes on the grin-node1 instance. Slow, but it's free. Good time for a coffee break. Alternatively, you can skip the build process by downloading the latest Grin binary from here .","title":"Building"},{"location":"wiki/extra-documents/google-cloud-node/#syncing-a-grin-node","text":"When the build has completed, create a new tmux session and launch your Grin node in it: tmux new -s main cd target/release ./grin The node should automatically connect to peers and begin syncing. This might also take a while, so you might want to go for another break. Once completed, the node should be at the same block height as https://grinscan.net/ . We can now detach from the tmux session running the node by pressing ctrl+b , then d . This will allow us to continue interfacing with the gcloud instance command line, with the node running in the background. If you want to check in on the node at a later time, you can attach back into it's tmux session with tmux a -t main Optionally, from the cloud shell, open up your node's p2p port so it can receive inbound connections: gcloud compute firewall-rules create main-p2p-port --direction = INGRESS --action = ALLOW --rules = tcp:3414 --target-tags = grin-node1","title":"Syncing a Grin node"},{"location":"wiki/extra-documents/google-cloud-node/#connecting-to-google-grin-node-from-local-wallet","text":"This will allow you to use your wallet quickly and easily without the need to wait for your local node to sync! Follow instructions for setting up a Grin node as above. Once built and synched continue below. To enable external api calls to your Grin node, edit your ~/.grin/main/grin-server.toml configuration file on your Google instance: nano grin-server.toml set api_http_addr to 0.0.0.0:3413 and host to 0.0.0.0 : api_http_addr = \"0.0.0.0:3413\" host = \"0.0.0.0\" open up your node's api port so it can receive inbound connections gcloud compute firewall-rules create main-api-port --direction = INGRESS --action = ALLOW --rules = tcp:3413 --target-tags = grin-node1 your ~/.grin/main/grin-server.toml file on your Google instance will have an api_secret_path field (ex: ~/.grin/main/.api_secret unless changed.) Copy the value in the file and save this for later as you will need to provide this to your local wallet. on your local machine, create a new file for storing the api secret from the previous step (ex: ~/.grin/main/.remote_api_secret , but can be any location). Save file with key value copied in previous step. now update your local wallet configuration file: set node_api_secret_path to the path of the file created in the previous step (ex: ~/.grin/main/.remote_api_secret ) and update check_node_api_http_addr with IP address of your Google instance: api_secret_path = \"~/.grin/main/.remote_api_secret\" check_node_api_http_addr = \"http://{YourGoogleCloudIP}:3413\" Restart your node to update configuration changes. Once started, you can run wallet commands which will use your new external node. No need to start your local node and wait for synchronization on each start! ./grin-wallet info Password: ____ Wallet Summary Info - Account 'default' as of height 235438 ____ Confirmed Total | 0 .000000000 Awaiting Confirmation ( < 10 ) | 0 .000000000 Awaiting Finalization | 0 .000000000 Locked by previous transaction | 0 .000000000 -------------------------------- | ------------- Currently Spendable | 0 .000000000 Command 'info' completed successfully","title":"Connecting to Google Grin node from local wallet"},{"location":"wiki/extra-documents/google-cloud-node/#future-work","text":"Updating your node Connecting to Grin-Pool","title":"Future work"},{"location":"wiki/extra-documents/how-to-mine/","text":"How to mine with grin-miner Prerequisites Linux or MacOS (Windows is not currently supported by grin-miner, though there are some possible alternatives. A relatively recent CPU For mainnet mining, a Recent GPU with 6GB minimum for Cuckaroo29. Nvidia 1080/2080/ti series are known to work well. Support for AMD cards via OpenCL exists but is a recent development. These instructions also assume you've downloaded and installed the Grin software, are running a synced node , and have initialized and are comfortable with running a wallet . Grin POW Basics Grin accepts 2 Proofs-of-Work. Both are variants of a concept called 'Cuckoo Cycle'. CuckARoo (or ASIC Resistant) is intended to be mined by GPUs. It can be mined using a 6GB+ GPU. CuckAToo (or ASIC Targeted) is intended to be mined by ASICs in the future. It can also be mined using 11GB+ GPUs. Cuckoo family solvers use something called Graph Size as a parameter. This determines how much memory is needed to mine. CuckARoo uses graphs with 2^29 edges, while CuckAToo uses graphs with 2^31+ edges, hence the different memory requirements. Cuckoo uses number of graphs searched per second, or GPS, to determine how fast someone is mining. You will generally see the term GPS as opposed to Hashrate when using Grin. The terms are used somewhat interchangeably, but GPS is more correct. At launch, Grin will adjust to target 90% of blocks be GPU mined, and 10% ASIC mined. Under current plans, this will gradually change to 0% GPU and 100% ASIC over 2 years. Downloading the grin-miner Software The latest Grin-miner release can be found on the project Release Page . Binaries are currently provided for Linux and OSX. Distribution-specific releases will likely appear over time, and will be listed here. Installation Linux (all distributions) Download the zipped binary to your machine, and unzip it using the terminal. This will unzip into a directory called grin-miner which contains the grin-miner binary, GPU and CPU mining plugins, and the main configuration file, grin-miner.toml . For now, we'd recommend placing this somewhere relative to your home directory, and editing your path environment variable to ensure the grin-miner executable is available from wherever you run it. All of this can be done by running the following commands in the directory to which you downloaded grin-miner (substituting the grin-miner version number where necessary). tar -C ~/ xzf grin-miner-v1.0.2-480780316-linux-amd64.tgz echo 'export PATH=~/grin-miner-v1.0.2:$PATH' >> ~/.bashrc source ~/.bashrc Running Grin in Mining Mode Configure Grin's stratum (mining) server In the file ~/.grin/main/grin-server.toml , change: enable_stratum_server = false to enable_stratum_server = true Run Grin wallet listener and Node In one terminal window, run the wallet listener (entering your wallet password when prompted) grin-wallet listen In another, run your Grin node: grin Configure grin-miner All configuration options for the mining plugins can be found, fully documented, in grin-miner.toml . The following steps should work to get most people up and running: Setting up grin-miner for CPU mining CPU Mining is Enabled by default in the configuration file. You may wish to use the cuckaroo_cpu_avx2_29 plugin rather than the default if you have a relatively recent CPU. Setting up grin-miner for GPU Mining (Nvidia) ALWAYS ensure your nvidia drivers are up to date In this section, we will edit the grin-miner settings to mine with your Nvidia GPU. First go to the CUCKAROO (i.e. GPU-Friendly) MINER PLUGIN CONFIGURATION part. Comment out the CPU plugin configuration as follows (by adding # in front of each line): #[[mining.miner_plugin_config]] #plugin_name = \"cuckaroo_cpu_compat_29\" #[mining.miner_plugin_config.parameters] #nthreads = 1 Then, uncomment the following lines (remove the #in front of each line): [[mining.miner_plugin_config]] plugin_name = \"cuckaroo_cuda_29\" [mining.miner_plugin_config.parameters] device = 0 If you have multiple GPUs you\u2019ll need to copy those four lines for each device and change the device number. You may want to use device numbers in the same PCI Bus ID enumeration order as used by non-CUDA programs like nvidia-smi. To do this set the CUDA_\u200bDEVICE_\u200bORDER environment variable to PCI_BUS_ID in your shell. The default value of this variable is FASTEST_FIRST. More info on this can be found here . Note that this is available only in CUDA 7 and later. Setting up grin-miner for GPU Mining (AMD) In this section, we will edit the grin-miner settings to mine with your AMD GPU. First go to the CUCKAROO (i.e. GPU-Friendly) MINER PLUGIN CONFIGURATION part and comment the following lines (by adding # in front of each line): #[[mining.miner_plugin_config]] #plugin_name = \"cuckaroo_cpu_compat_29\" #[mining.miner_plugin_config.parameters] #nthreads = 1 Then go to the CUCKAROO (i.e. ASIC-Resistent) MINER PLUGIN CONFIGURATION part and uncomment the following lines (remove the #in front of each line): [[mining.miner_plugin_config]] plugin_name = \"ocl_cuckaroo\" [mining.miner_plugin_config.parameters] platform = 0 device = 0 If you have multiple GPUs you\u2019ll need to copy these 5 lines for each device and change the device number. Running grin-miner Ensure that your Grin node and wallet are running (see Running Grin in Mining Mode ), then, from your grin-miner-vx.x.x installation directory: ./grin-miner grin-miner's Test User Interface should appear and display stats for all configured cards. grin-miner Stats Solutions Found is the number of valid cuckoo solutions you have found. Note that this is not the same as finding a block. Only solutions that pass a further difficulty check, (as tested by the Grin stratum server) can be used to solve a block. Accepted is the number of solutions your miners found that were accepted by the stratum server as valid shares (or contributions to the pool,). Again, this does not correspond to number of solved blocks or mining rewards. Rejected is the number of rejected shares. This should be 0, otherwise there is something wrong with your mining plugin or in server communication. Stale is the number of solutions that were found to late (someone else on the network solved the block before the solution was submit). Blocks found is the actual number of blocks that you've solved, that is to say valid cuckoo solutions that passed the difficulty check and were also accepted by the network. If you're mining solo (which you are if you're following this guide,) the rewards in your wallet should be 60 Grins for each block solved. Mining CuckAToo If you have an 11GB+ GPU. It should be possible to configure your plugins to solve CuckAToo (ASIC-Friendly) blocks at graph size 2^31. As an example: [[mining.miner_plugin_config]] plugin_name = \"cuckatoo_mean_cuda_rtx_31\" [mining.miner_plugin_config.parameters] device = 0 expand = 2 cpuload = 1 You will need to set expand = 2 to allow the solutions to be performed with the available GPU memory. Refer to the documentation in grin-miner.toml for further information on how to mine using Cuckatoo31. This Forum Topic discusses chosing between the two PoWs. cpuload parameter The cpuload parameter configurable in each CUDA GPU solver reduces the amount of work your CPU has to do during a solve at the expense of solve times. cpuload = 0 (default) will solve more slowly but free up more of your CPU cpuload = 1 will generally solve faster at the expense of CPU load It's recommended to manually set cpuload = 1 for each CUDA solver, unless your encounter specific slowdown issues with your solve times. Mining Pools Once you're comfortable with mining grin, you may want to try a mining pool , of which there are several. Note that the Grin Project doesn't run or endorse any of these pools. Please refer to the individual pool's instructions to set up grin-miner.","title":"How to mine with grin-miner"},{"location":"wiki/extra-documents/how-to-mine/#how-to-mine-with-grin-miner","text":"","title":"How to mine with grin-miner"},{"location":"wiki/extra-documents/how-to-mine/#prerequisites","text":"Linux or MacOS (Windows is not currently supported by grin-miner, though there are some possible alternatives. A relatively recent CPU For mainnet mining, a Recent GPU with 6GB minimum for Cuckaroo29. Nvidia 1080/2080/ti series are known to work well. Support for AMD cards via OpenCL exists but is a recent development. These instructions also assume you've downloaded and installed the Grin software, are running a synced node , and have initialized and are comfortable with running a wallet .","title":"Prerequisites"},{"location":"wiki/extra-documents/how-to-mine/#grin-pow-basics","text":"Grin accepts 2 Proofs-of-Work. Both are variants of a concept called 'Cuckoo Cycle'. CuckARoo (or ASIC Resistant) is intended to be mined by GPUs. It can be mined using a 6GB+ GPU. CuckAToo (or ASIC Targeted) is intended to be mined by ASICs in the future. It can also be mined using 11GB+ GPUs. Cuckoo family solvers use something called Graph Size as a parameter. This determines how much memory is needed to mine. CuckARoo uses graphs with 2^29 edges, while CuckAToo uses graphs with 2^31+ edges, hence the different memory requirements. Cuckoo uses number of graphs searched per second, or GPS, to determine how fast someone is mining. You will generally see the term GPS as opposed to Hashrate when using Grin. The terms are used somewhat interchangeably, but GPS is more correct. At launch, Grin will adjust to target 90% of blocks be GPU mined, and 10% ASIC mined. Under current plans, this will gradually change to 0% GPU and 100% ASIC over 2 years.","title":"Grin POW Basics"},{"location":"wiki/extra-documents/how-to-mine/#downloading-the-grin-miner-software","text":"The latest Grin-miner release can be found on the project Release Page . Binaries are currently provided for Linux and OSX. Distribution-specific releases will likely appear over time, and will be listed here.","title":"Downloading the grin-miner Software"},{"location":"wiki/extra-documents/how-to-mine/#installation","text":"","title":"Installation"},{"location":"wiki/extra-documents/how-to-mine/#linux-all-distributions","text":"Download the zipped binary to your machine, and unzip it using the terminal. This will unzip into a directory called grin-miner which contains the grin-miner binary, GPU and CPU mining plugins, and the main configuration file, grin-miner.toml . For now, we'd recommend placing this somewhere relative to your home directory, and editing your path environment variable to ensure the grin-miner executable is available from wherever you run it. All of this can be done by running the following commands in the directory to which you downloaded grin-miner (substituting the grin-miner version number where necessary). tar -C ~/ xzf grin-miner-v1.0.2-480780316-linux-amd64.tgz echo 'export PATH=~/grin-miner-v1.0.2:$PATH' >> ~/.bashrc source ~/.bashrc","title":"Linux (all distributions)"},{"location":"wiki/extra-documents/how-to-mine/#running-grin-in-mining-mode","text":"","title":"Running Grin in Mining Mode"},{"location":"wiki/extra-documents/how-to-mine/#configure-grins-stratum-mining-server","text":"In the file ~/.grin/main/grin-server.toml , change: enable_stratum_server = false to enable_stratum_server = true","title":"Configure Grin's stratum (mining) server"},{"location":"wiki/extra-documents/how-to-mine/#run-grin-wallet-listener-and-node","text":"In one terminal window, run the wallet listener (entering your wallet password when prompted) grin-wallet listen In another, run your Grin node: grin","title":"Run Grin wallet listener and Node"},{"location":"wiki/extra-documents/how-to-mine/#configure-grin-miner","text":"All configuration options for the mining plugins can be found, fully documented, in grin-miner.toml . The following steps should work to get most people up and running:","title":"Configure grin-miner"},{"location":"wiki/extra-documents/how-to-mine/#setting-up-grin-miner-for-cpu-mining","text":"CPU Mining is Enabled by default in the configuration file. You may wish to use the cuckaroo_cpu_avx2_29 plugin rather than the default if you have a relatively recent CPU.","title":"Setting up grin-miner for CPU mining"},{"location":"wiki/extra-documents/how-to-mine/#setting-up-grin-miner-for-gpu-mining-nvidia","text":"ALWAYS ensure your nvidia drivers are up to date In this section, we will edit the grin-miner settings to mine with your Nvidia GPU. First go to the CUCKAROO (i.e. GPU-Friendly) MINER PLUGIN CONFIGURATION part. Comment out the CPU plugin configuration as follows (by adding # in front of each line): #[[mining.miner_plugin_config]] #plugin_name = \"cuckaroo_cpu_compat_29\" #[mining.miner_plugin_config.parameters] #nthreads = 1 Then, uncomment the following lines (remove the #in front of each line): [[mining.miner_plugin_config]] plugin_name = \"cuckaroo_cuda_29\" [mining.miner_plugin_config.parameters] device = 0 If you have multiple GPUs you\u2019ll need to copy those four lines for each device and change the device number. You may want to use device numbers in the same PCI Bus ID enumeration order as used by non-CUDA programs like nvidia-smi. To do this set the CUDA_\u200bDEVICE_\u200bORDER environment variable to PCI_BUS_ID in your shell. The default value of this variable is FASTEST_FIRST. More info on this can be found here . Note that this is available only in CUDA 7 and later.","title":"Setting up grin-miner for GPU Mining (Nvidia)"},{"location":"wiki/extra-documents/how-to-mine/#setting-up-grin-miner-for-gpu-mining-amd","text":"In this section, we will edit the grin-miner settings to mine with your AMD GPU. First go to the CUCKAROO (i.e. GPU-Friendly) MINER PLUGIN CONFIGURATION part and comment the following lines (by adding # in front of each line): #[[mining.miner_plugin_config]] #plugin_name = \"cuckaroo_cpu_compat_29\" #[mining.miner_plugin_config.parameters] #nthreads = 1 Then go to the CUCKAROO (i.e. ASIC-Resistent) MINER PLUGIN CONFIGURATION part and uncomment the following lines (remove the #in front of each line): [[mining.miner_plugin_config]] plugin_name = \"ocl_cuckaroo\" [mining.miner_plugin_config.parameters] platform = 0 device = 0 If you have multiple GPUs you\u2019ll need to copy these 5 lines for each device and change the device number.","title":"Setting up grin-miner for GPU Mining (AMD)"},{"location":"wiki/extra-documents/how-to-mine/#running-grin-miner","text":"Ensure that your Grin node and wallet are running (see Running Grin in Mining Mode ), then, from your grin-miner-vx.x.x installation directory: ./grin-miner grin-miner's Test User Interface should appear and display stats for all configured cards.","title":"Running grin-miner"},{"location":"wiki/extra-documents/how-to-mine/#grin-miner-stats","text":"Solutions Found is the number of valid cuckoo solutions you have found. Note that this is not the same as finding a block. Only solutions that pass a further difficulty check, (as tested by the Grin stratum server) can be used to solve a block. Accepted is the number of solutions your miners found that were accepted by the stratum server as valid shares (or contributions to the pool,). Again, this does not correspond to number of solved blocks or mining rewards. Rejected is the number of rejected shares. This should be 0, otherwise there is something wrong with your mining plugin or in server communication. Stale is the number of solutions that were found to late (someone else on the network solved the block before the solution was submit). Blocks found is the actual number of blocks that you've solved, that is to say valid cuckoo solutions that passed the difficulty check and were also accepted by the network. If you're mining solo (which you are if you're following this guide,) the rewards in your wallet should be 60 Grins for each block solved.","title":"grin-miner Stats"},{"location":"wiki/extra-documents/how-to-mine/#mining-cuckatoo","text":"If you have an 11GB+ GPU. It should be possible to configure your plugins to solve CuckAToo (ASIC-Friendly) blocks at graph size 2^31. As an example: [[mining.miner_plugin_config]] plugin_name = \"cuckatoo_mean_cuda_rtx_31\" [mining.miner_plugin_config.parameters] device = 0 expand = 2 cpuload = 1 You will need to set expand = 2 to allow the solutions to be performed with the available GPU memory. Refer to the documentation in grin-miner.toml for further information on how to mine using Cuckatoo31. This Forum Topic discusses chosing between the two PoWs.","title":"Mining CuckAToo"},{"location":"wiki/extra-documents/how-to-mine/#cpuload-parameter","text":"The cpuload parameter configurable in each CUDA GPU solver reduces the amount of work your CPU has to do during a solve at the expense of solve times. cpuload = 0 (default) will solve more slowly but free up more of your CPU cpuload = 1 will generally solve faster at the expense of CPU load It's recommended to manually set cpuload = 1 for each CUDA solver, unless your encounter specific slowdown issues with your solve times.","title":"cpuload parameter"},{"location":"wiki/extra-documents/how-to-mine/#mining-pools","text":"Once you're comfortable with mining grin, you may want to try a mining pool , of which there are several. Note that the Grin Project doesn't run or endorse any of these pools. Please refer to the individual pool's instructions to set up grin-miner.","title":"Mining Pools"},{"location":"wiki/extra-documents/monetary-policy/","text":"Monetary Policy Currently, a new grin is emitted every second, and it's likely to stay that way forever, meaning that the supply inflation rate stays constant. Why? Consider the following points. It's very close to Bitcoin in the first decade The first four years of Bitcoin emission rate are identical to the first four of Grin. Bitcoin had a full reward for 4 years, followed by half that for the following 4 years. So compared to a constant supply, after 8 years, the total amount of coins emitted is only 25% less. Compare that to daily price fluctuations. It's more similar to Ethereum Ethereum's reward stayed at 5 ether per block until late 2017. It then changed to 3 ether per block, with plan to 2 ether per block after Constantinople upgrade. It's even more similar to gold Gold has historically had a linear emission, like Grin. See this graph comparing Bitcoin, Grin, and gold emissions. New supply falls below 10% after 10 years Every year that passes makes the overall dilution smaller. After 10 years, this falls below 10%. After 20, below 5%. After 25 years Grin will have 4% supply inflation, the same as Bitcoin 10 years after its genesis (2018). It's highly likely that at least 2% of coins get lost per year Multiple studies have shown that a considerable amount of coins get lost, burnt and generally disappear from circulation with no chance to get them back. The rate at which coins get lost has been conservatively estimated at 2%, but is likely slightly higher. Tail emission may be required for long term stability Currencies with set supply are extremely experimental. Miners likely need incentives to secure the chain beyond only fees. Sound money has more to do with transparent emission than a capped supply One of the pitfalls of monetary inflation in fiat currencies is governments can inflate the monetary supply on a whim. This has been used to disastrous effect throughout history. A non-sovereign, open source, consensus based currency solves this issue by making the emission policy well known ahead of time, and makes it difficult if not impossible to change. Based on this definition of soundness, Grin is just as much \"sound money\" as Bitcoin. Removing central authorities with arbitrary control is much more what makes Bitcoin important than the arbitrary amount of its capped supply. Nick Szabo commented on Bitcoin's fixed supply: a wide variety of supply algos would have worked, as long as they are predictable. [\u2026] Security/trust minimization is responsible for more of the value. There are plenty of cryptocurrencies identical to Bitcoin but with smaller capped supplies, how many of them can you name? Inflation may make price more stable As an experimental hypothesis, Grin's inflation rate may discourage hoarding early on, improving its distribution. Inflation disincentivizes \"whales,\" who have an inordinate amount of control over the price of an asset, and should act to downplay speculative bubbles and price swings. Early adopters get just as much out of grin as those who adopt later. This argument is discussed at length in Bitcoins are not digital greenbacks , in which Wei Dai himself considers \"Bitcoin to have failed with regard to its monetary policy\". Grin is aiming for as equal access and utility as possible for all users, now and in the future. Constant emission could provide enhanced supply/demand certainty for all types of users, and allow transparent and natural pricing. Note: Bitcoin becoming widely usable as a method of exchange versus a strict store of value depends on the concept of \" Keynesian beauty contests. \" The experiment is ongoing. There are already better store of values or \"get rich quick\" coins Grin is focused on privacy, scalability and fairness. If groups or individuals \"get rich quick,\" they will have power to influence the entire grin economy more than others. Grin is not for creating technocrats, but for providing private digital cash to as many people as possible. Hoarding is a huge centralization pressure, and grin emission policy hopes to mitigate this. The idea is to use grin like you use your bicycle, to get you around and make you more efficient, not to store in your garage hoping its value goes up. It will get forked into a \"get rich quick\" coin Fine. But the keyword in \"get rich quick\" is quick . Moderate yearly variations in supply are fairly slow in comparison. Grin isn't for getting rich quick. Confidential Assets allow parallel monetary policies to be soft-forked in later If the current monetary policy is keeping you from contributing to Grin, you should still stick around. Confidential Assets , an invention by early Mimblewimble contributor Andrew Poelstra, allow alternative assets (with differing cryptography, emission rates, and more; including coins pegged to other assets/blockchains) to be added to Grin later on via soft fork. These assets add very little to the chain size, make all other assets (like the native grin token) more private, and can be embraced or ignored as one wishes without compromising any other asset (grin or otherwise) on the chain. Grin is a minimal Mimblewimble implementation, but it will grow and evolve. Mimblewimble is nimble. We are in the early days of cryptoeconomics Experiments in transparent, collaborative monetary policies are very immature. Bitcoin is only ten years old and the experiment is still going strong. The time is ripe not for copycat experiments, but novel variations. Only time will tell, but the sooner we start running alternative monetary policy experiments the sooner we get useful data. There are only ~28 million Bitcoin wallets today (many of them not in active use, or secondary wallets for single users). That means less than one-half of one percent of the global population has their own wallet. Because you are here means you care about the entire premise of cryptocurrencies, it is important to be open minded when things are so new and uncertain. Onward. Further discussion There is a long discussion regarding Grin's monetary policy in the community forum . Igno's thoughts on soliciting productive feedback: With respect to this whole thread and future ones, if you want to provide constructive criticisms on the emission curve, at least give it some decent thoughts. Repeating what you read on Reddit doesn\u2019t count. To be more specific: At a minimum consider the loss rate when building supply curve. Ever wondered at which point 50% of those 21M bitcoins will have disappeared, for example? Compare with other slow emission coins. After 8 years, grin only has 25% more supply than bitcoin or, to pick something more recent, zcash. Argue why this matters (or not). Compare with fast emissions coins. Monero had over half emitted in 17 months. How does that affect long term adoption? How about use? Rich lists and coin decentralization. What affects them. Analyze average crypto user and investor behavior. How does multi-year emission curves, fast or slow, influence them? What are the real adoption drivers, both long and short term? Do not use econ101 in your arguments. That can be used to argue anything and its opposite equally well. And before telling us we don\u2019t understand economics, convince Nouriel. Then maybe I\u2019ll listen. Consider different strategies and how they can play the strengths or weaknesses of various blockchains. What is the effect on Ethereum when daily supply is hard forked for example? Facts and real research. Unsubstantiated opinions are a nanogrin a dozen. The grin team is earnest, if you can provide well substantiated real research that shows a different supply curve would be be better for grin, we will most definitely listen. But don\u2019t think you can flyby post your knee-jerk reaction 5 min after having heard of grin, which we\u2019ve spent the last 2 years building, and expect us to listen to you. Informed ideas are more than welcome!","title":"Monetary Policy"},{"location":"wiki/extra-documents/monetary-policy/#monetary-policy","text":"Currently, a new grin is emitted every second, and it's likely to stay that way forever, meaning that the supply inflation rate stays constant. Why? Consider the following points.","title":"Monetary Policy"},{"location":"wiki/extra-documents/monetary-policy/#its-very-close-to-bitcoin-in-the-first-decade","text":"The first four years of Bitcoin emission rate are identical to the first four of Grin. Bitcoin had a full reward for 4 years, followed by half that for the following 4 years. So compared to a constant supply, after 8 years, the total amount of coins emitted is only 25% less. Compare that to daily price fluctuations.","title":"It's very close to Bitcoin in the first decade"},{"location":"wiki/extra-documents/monetary-policy/#its-more-similar-to-ethereum","text":"Ethereum's reward stayed at 5 ether per block until late 2017. It then changed to 3 ether per block, with plan to 2 ether per block after Constantinople upgrade.","title":"It's more similar to Ethereum"},{"location":"wiki/extra-documents/monetary-policy/#its-even-more-similar-to-gold","text":"Gold has historically had a linear emission, like Grin. See this graph comparing Bitcoin, Grin, and gold emissions.","title":"It's even more similar to gold"},{"location":"wiki/extra-documents/monetary-policy/#new-supply-falls-below-10-after-10-years","text":"Every year that passes makes the overall dilution smaller. After 10 years, this falls below 10%. After 20, below 5%. After 25 years Grin will have 4% supply inflation, the same as Bitcoin 10 years after its genesis (2018).","title":"New supply falls below 10% after 10 years"},{"location":"wiki/extra-documents/monetary-policy/#its-highly-likely-that-at-least-2-of-coins-get-lost-per-year","text":"Multiple studies have shown that a considerable amount of coins get lost, burnt and generally disappear from circulation with no chance to get them back. The rate at which coins get lost has been conservatively estimated at 2%, but is likely slightly higher.","title":"It's highly likely that at least 2% of coins get lost per year"},{"location":"wiki/extra-documents/monetary-policy/#tail-emission-may-be-required-for-long-term-stability","text":"Currencies with set supply are extremely experimental. Miners likely need incentives to secure the chain beyond only fees.","title":"Tail emission may be required for long term stability"},{"location":"wiki/extra-documents/monetary-policy/#sound-money-has-more-to-do-with-transparent-emission-than-a-capped-supply","text":"One of the pitfalls of monetary inflation in fiat currencies is governments can inflate the monetary supply on a whim. This has been used to disastrous effect throughout history. A non-sovereign, open source, consensus based currency solves this issue by making the emission policy well known ahead of time, and makes it difficult if not impossible to change. Based on this definition of soundness, Grin is just as much \"sound money\" as Bitcoin. Removing central authorities with arbitrary control is much more what makes Bitcoin important than the arbitrary amount of its capped supply. Nick Szabo commented on Bitcoin's fixed supply: a wide variety of supply algos would have worked, as long as they are predictable. [\u2026] Security/trust minimization is responsible for more of the value. There are plenty of cryptocurrencies identical to Bitcoin but with smaller capped supplies, how many of them can you name?","title":"Sound money has more to do with transparent emission than a capped supply"},{"location":"wiki/extra-documents/monetary-policy/#inflation-may-make-price-more-stable","text":"As an experimental hypothesis, Grin's inflation rate may discourage hoarding early on, improving its distribution. Inflation disincentivizes \"whales,\" who have an inordinate amount of control over the price of an asset, and should act to downplay speculative bubbles and price swings. Early adopters get just as much out of grin as those who adopt later. This argument is discussed at length in Bitcoins are not digital greenbacks , in which Wei Dai himself considers \"Bitcoin to have failed with regard to its monetary policy\". Grin is aiming for as equal access and utility as possible for all users, now and in the future. Constant emission could provide enhanced supply/demand certainty for all types of users, and allow transparent and natural pricing. Note: Bitcoin becoming widely usable as a method of exchange versus a strict store of value depends on the concept of \" Keynesian beauty contests. \" The experiment is ongoing.","title":"Inflation may make price more stable"},{"location":"wiki/extra-documents/monetary-policy/#there-are-already-better-store-of-values-or-get-rich-quick-coins","text":"Grin is focused on privacy, scalability and fairness. If groups or individuals \"get rich quick,\" they will have power to influence the entire grin economy more than others. Grin is not for creating technocrats, but for providing private digital cash to as many people as possible. Hoarding is a huge centralization pressure, and grin emission policy hopes to mitigate this. The idea is to use grin like you use your bicycle, to get you around and make you more efficient, not to store in your garage hoping its value goes up.","title":"There are already better store of values or \"get rich quick\" coins"},{"location":"wiki/extra-documents/monetary-policy/#it-will-get-forked-into-a-get-rich-quick-coin","text":"Fine. But the keyword in \"get rich quick\" is quick . Moderate yearly variations in supply are fairly slow in comparison. Grin isn't for getting rich quick.","title":"It will get forked into a \"get rich quick\" coin"},{"location":"wiki/extra-documents/monetary-policy/#confidential-assets-allow-parallel-monetary-policies-to-be-soft-forked-in-later","text":"If the current monetary policy is keeping you from contributing to Grin, you should still stick around. Confidential Assets , an invention by early Mimblewimble contributor Andrew Poelstra, allow alternative assets (with differing cryptography, emission rates, and more; including coins pegged to other assets/blockchains) to be added to Grin later on via soft fork. These assets add very little to the chain size, make all other assets (like the native grin token) more private, and can be embraced or ignored as one wishes without compromising any other asset (grin or otherwise) on the chain. Grin is a minimal Mimblewimble implementation, but it will grow and evolve. Mimblewimble is nimble.","title":"Confidential Assets allow parallel monetary policies to be soft-forked in later"},{"location":"wiki/extra-documents/monetary-policy/#we-are-in-the-early-days-of-cryptoeconomics","text":"Experiments in transparent, collaborative monetary policies are very immature. Bitcoin is only ten years old and the experiment is still going strong. The time is ripe not for copycat experiments, but novel variations. Only time will tell, but the sooner we start running alternative monetary policy experiments the sooner we get useful data. There are only ~28 million Bitcoin wallets today (many of them not in active use, or secondary wallets for single users). That means less than one-half of one percent of the global population has their own wallet. Because you are here means you care about the entire premise of cryptocurrencies, it is important to be open minded when things are so new and uncertain. Onward.","title":"We are in the early days of cryptoeconomics"},{"location":"wiki/extra-documents/monetary-policy/#further-discussion","text":"There is a long discussion regarding Grin's monetary policy in the community forum . Igno's thoughts on soliciting productive feedback: With respect to this whole thread and future ones, if you want to provide constructive criticisms on the emission curve, at least give it some decent thoughts. Repeating what you read on Reddit doesn\u2019t count. To be more specific: At a minimum consider the loss rate when building supply curve. Ever wondered at which point 50% of those 21M bitcoins will have disappeared, for example? Compare with other slow emission coins. After 8 years, grin only has 25% more supply than bitcoin or, to pick something more recent, zcash. Argue why this matters (or not). Compare with fast emissions coins. Monero had over half emitted in 17 months. How does that affect long term adoption? How about use? Rich lists and coin decentralization. What affects them. Analyze average crypto user and investor behavior. How does multi-year emission curves, fast or slow, influence them? What are the real adoption drivers, both long and short term? Do not use econ101 in your arguments. That can be used to argue anything and its opposite equally well. And before telling us we don\u2019t understand economics, convince Nouriel. Then maybe I\u2019ll listen. Consider different strategies and how they can play the strengths or weaknesses of various blockchains. What is the effect on Ethereum when daily supply is hard forked for example? Facts and real research. Unsubstantiated opinions are a nanogrin a dozen. The grin team is earnest, if you can provide well substantiated real research that shows a different supply curve would be be better for grin, we will most definitely listen. But don\u2019t think you can flyby post your knee-jerk reaction 5 min after having heard of grin, which we\u2019ve spent the last 2 years building, and expect us to listen to you. Informed ideas are more than welcome!","title":"Further discussion"},{"location":"wiki/extra-documents/nomenclature-bs/","text":"Nomenclature BS By 0xb100d , Oct 8 2018 \"It's like a finger pointing away to the moon. Do not concentrate on the finger or you will miss all of the heavenly glory!\" Bruce Lee. The technology is cool, and that's what this project is about, THE WAY is nameless, as they say. Words obfuscate and obstruct, so why not embrace that reality by maintaining a nomenclature of quirky wizard/witch vibes, shrouded in a light and funky aloofness? I think packaging up what aims to be a key to international freedom in a somewhat silly package is like a spoonful of sugar to help the medicine go down. Funny names are an invisibility cloak. If it weren't explicitly useful (in my opinion) to name things unconventionally, and if there was not already a magical-theme happening within the project, it would not be worth pursuing. But as we have already stepped in it, so to speak, there are many things we can do to \"unBrand\" the project in an effective way. We obviously don't want to cross the line into copyright infringement. There are plenty of historical and wizardly themes to choos from that are not strictly inspired by modern novels. Some discussion: https://www.grin-forum.org/t/meeting-notes-governance-aug-15-2018/644/2?u=0-x https://www.grin-forum.org/t/technomity-new-members/635/2?u=0-x GRIN (GOBLINS' Righteous Intergalactic Network) Council Name What do we call the \"technomity\" aka the Council of Grin, given it certainly doesn't matter, and there are so many fun witchy things to choose from? This group will be cited by name when future upgrades, discussions, and decisions arise. Some ideas: The GAMUT (GOBLINs Adhocratic Magical Undertakings Thing) (Who runs the GAMUT? https://en.wiktionary.org/wiki/run_the_gamut) https://en.wikipedia.org/wiki/Thing_(assembly) also referencet to supreme wizard court in harry potter, the Wizengamot. https://en.wikipedia.org/wiki/Adhocracy Prefects or pr\u00e6fectus/praefectus/praefectii- leadership, appear in harry potter books as upperclassmen. Spontaneous Order of GOBLINS GOBLINS (GRIN's Own Beaurocracy of Laborers, Improvers, Nurturers and Scientists or GRIN's Own Beurocracy of Learned Integrators Negotiators and Scientists) Ministry of Mages Coven of Alchemical Liason Maintainance (CALM... keep CALM and carry wands). The Spontaneous Order of Unknown Leaders (SOUL, https://en.wikipedia.org/wiki/Spontaneous_order#Markets ) The Stygmergic Syzygy Institute of Broom and Wand Design Magical Undertakings of Money (MUMs the word!) P.O.W.O.W. (which could stand for The POWOW Order of Wizards Ongoing Work\u2026 which has that nice nested GNU thing\u2026 and actually we\u2019ve already been calling it the powow\u2026 plus the connotations for proof of work, POW, and pain, OW\u2026 but is probably incensitive to native americans) Sobornost (\u201cthe combination of freedom and unity of many persons on the basis of their common love for the same absolute values.\u201d, https://en.wikipedia.org/wiki/Sobornost) Synod (church council) Conventicle (https://en.wikipedia.org/wiki/Conventicle) Conciliabulum (https://en.wikipedia.org/wiki/Conciliabulum) navem civitatis - ship of state (platos coinage of philosopher king) technicorum magorum\u2122 - technocracy of magi Ministry of Magi (MOM said!) Convention of Wizards (COW goes MU (Mimblewimble Undertakings)) Chamber of Intermagical Affairs, aka the CIA? Assembly of Seers? Seer Association? Seers, Robust & Company? Wallet/Miner Names These are all totally free to use for any efforts. Wink Nod Smirk Mascot Names Cuthru Langlock Alice (https://tmgox.com/product/alice-embroidered-womens-polo-shirt/) Chesire Cat (immensely cool and in public domain: https://upload.wikimedia.org/wikipedia/commons/8/8a/Arthur_Rackham_Cheshire_Cat.jpeg) Currency name [Solved] In what units do we measure the grin currency? grins (milli, micro, etc). Winks and Nods? Currency Symbol Discussion: https://www.grin-forum.org/t/currency-symbol-other-bs/484 we could do something absolutely evil and comandeer the symbol for generic currency... \u00a4 ... \u00a4333 .... https://en.wikipedia.org/wiki/Currency_sign_(typography) it is the universal ISO symbol for money............................... i feel like i've peekend inside pandora's box. GOODNESS I like this one. It's like a glitch in the matrix.... and very philosophicala symbolic. Roman Czyborra writes in his Good ole' ASCII that \"the socialist countries managed to substitute the international currency sign \u00a4 for ASCII's capitalist dollar sign $ in the the first international reference version ISO-646-IRV\". However, the international currency symbol \u00a4 was proposed for inclusion in the international standard character code in place of the dollar or pound sign by the Italian delegation to the CCITT, not by the socialist countries. In a later vote, Italy, Portugal, Switzerland, and the USSR favored the use of the \u00a4 character; Canada, France, Germany, the Netherlands, Sweden, and the United Kingdom preferred to standardize the $ and \u00a3 signs. Sources: CCITT Working Group on Alphabets, October 6-9, 1964, CBI 67, box 3, folder 3; ISO TC 97/SC 2 and CCITT/GM ALP joint meeting, April 26-28, 1966, NMAH 310, box 5. and now some other resources I've found... and some symbols that stand out. There are lots of options and I am 100% of the belief that the perfect one can jump out at us like a mystical epiphany, and that bikeshedding isn't as arduous and arbitrary as it always seems to be. From this document: http://bora.uib.no/bitstream/handle/1956/10699/MUFI-Alphabetic-4-0.pdf?sequence=9&isAllowed=y \uead0 &grlig; EAD0 PUA-1 LATIN SMALL LIGATURE GR doesnt show These are very good old English... very in the style of. http://www.wikiwand.com/en/Insular_G \u1d79 &gins; 1D79 PhonExt LATIN SMALL LETTER INSULAR G \ua77d &Gins; A77D LatExtD LATIN CAPITAL LETTER INSULAR G \ua77f &ginsturn; A77F LatExtD LATIN SMALL LETTER TURNED INSULAR G \ua77e &Ginsturn; A77E LatExtD LATIN CAPITAL LETTER TURNED INSULAR G \ua7ff &M5leg; A7FF LatExtD LATIN EPIGRAPHIC LETTER ARCHAIC M 199\ua7ff aka \ua7ff aka mimblewimble. that one is confusing and cool \u00f8 \u00f8 00F8 Lat1Suppl LATIN SMALL LETTER O WITH STROKE \u00d8 \u00d8 00D8 Lat1Suppl LATIN CAPITAL LETTER O WITH STROKE 243\u00d8 for a piece of bread a symbolic cut-through... the $ sign is pretty abstract, ours needn't be a G at all. looks like a zero though, not great. \u0289 &ubar; 0289 IPAExt LATIN SMALL LETTER U BAR 777\u0289 its like the S with a line through it $, but its a u, kind of like a little smile with a cuthru \u1efd &vwelsh; 1EFD LatExtAdd LATIN SMALL LETTER MIDDLE-WELSH V looks kind of like a G when rendered differently \u02e3 &xmod; 02E3 SpModLet MODIFIER LETTER SMALL X 420\u02e3 to pay the bills \u25cc\u035c\u25cc &combdblbrevebl; 035C CombDiaMk COMBINING DOUBLE BREVE BELOW this one not sure if it shows but its like a fallen over right parenthesis... looks like a grin... pretty awesome! literally you write the number of grin syou have and underline it with a little grin, ha! \u221e \u221e 221E MathOp INFINITY 42\u221e worth of wine please! \u23d1 &metrshort; 23D1 MiscTech METRICAL BREVE its the cutest little grin 55\u23d1 \uf717 &metrbrevedblac; F717 PUA-10 METRICAL SYMBOL BREVE WITH DOUBLE doesnt show but its a smiley The spesmilo character, called spesmilsigno in Esperanto (like monero's use of esperanto) https://en.wikipedia.org/wiki/Spesmilo looks like an S with a little m in it. The mill or ( \u20a5 ) an m with a cuthru https://en.wikipedia.org/wiki/Mill_(currency) of course unicode alchemical symbols would be appropriate too https://en.wikipedia.org/wiki/Alchemical_symbol https://www.unicode.org/charts/PDF/U1F700.pdf 500\ud83d\udf50 looks like a magic wand \u263a its just a little unicode smiley face, this would be perfect \u267e its like an infinity symbol in a circle.. looks kind of like a smiley... and is the symbol for acid free p aper I need 699\u267e! Grin, that acid free paper currency!!! also means PERMANENT PAPER... which is a good symbol for a cashlike currency probably. \u2639 this one is hilarious, its like a big sad face \u2604 looks like a harry potter golden snitch 900\u2604 please! now from https://www.unicode.org/charts/PDF/U2600.pdf \u26a1like harry potters lightning bolt \u26c0 i think thats supposed to be a coin \u2652 mw looking \u2687 a partial smiley \u2639\u263a.. first is a sad face second is a smiley... for some reason the sad one is bigger \ud83d\ude42... slightly smiling face... that one renders really well \ue231* \ud83d\ude41 slightly frowning \u263b ooh this one is good... its the dark version of the smiley \u262f yin yang... mimble wimble \u231a a little watch... time is money 1\u231a /second \u231b hourglas... time is still money... 9,000\u231b please! \ud83c\udf1e *wow! * sun with face... that one is pretty good. feeling more and more like picking something simple like the letter G is the wrong choice. what fun to have so much creative freedom...and people may be writing it on checks and the tip line of receipts! \u2620 skull and cross bones... theres a grin in there somewhere \ud83d\udd71 another render, supposed to be b lack \u0fca a tibetan symbol \ud83d\ude36 *WOW symbol for face without a mouth!!!!!! \u269d a little bit wizardly.. the pentagram... \u26e5 \u26e4 just a white rectangle \u25ad 900\u25ad \u29de infinity negated with a vertical bar \u26b2 neuter symbol \u26bf squared key \u26d1 helmet \u26d3 those are supposed to be chains... that's kind of cool you know, blockchain. \u26b5 looks like a magic wand some more here: https://commons.wikimedia.org/wiki/Category:Alchemical_symbols though they are not easily accessible unicode https://commons.wikimedia.org/wiki/Category:Mercury_symbols mercury is a communication symbol... money is a very pure form of communication some good ones in there. almost entirely sure that using something as ancient as a latin letter would be a missed opportunity. why wouldnt the currency of the future have an emoji as a symbol????? I mean of course it would. We are desinging the ultimate cash for the digital age, it should look like a product of the internet in every way right? someone on reddit said the MW-Eyed smiley logo looks too much like a meme... but that is what we are making right, an infectious meme. currency itself is a meme! will never forgive myself now if we don't pick something great.","title":"Nomenclature BS"},{"location":"wiki/extra-documents/nomenclature-bs/#nomenclature-bs","text":"By 0xb100d , Oct 8 2018 \"It's like a finger pointing away to the moon. Do not concentrate on the finger or you will miss all of the heavenly glory!\" Bruce Lee. The technology is cool, and that's what this project is about, THE WAY is nameless, as they say. Words obfuscate and obstruct, so why not embrace that reality by maintaining a nomenclature of quirky wizard/witch vibes, shrouded in a light and funky aloofness? I think packaging up what aims to be a key to international freedom in a somewhat silly package is like a spoonful of sugar to help the medicine go down. Funny names are an invisibility cloak. If it weren't explicitly useful (in my opinion) to name things unconventionally, and if there was not already a magical-theme happening within the project, it would not be worth pursuing. But as we have already stepped in it, so to speak, there are many things we can do to \"unBrand\" the project in an effective way. We obviously don't want to cross the line into copyright infringement. There are plenty of historical and wizardly themes to choos from that are not strictly inspired by modern novels. Some discussion: https://www.grin-forum.org/t/meeting-notes-governance-aug-15-2018/644/2?u=0-x https://www.grin-forum.org/t/technomity-new-members/635/2?u=0-x GRIN (GOBLINS' Righteous Intergalactic Network)","title":"Nomenclature BS"},{"location":"wiki/extra-documents/nomenclature-bs/#council-name","text":"What do we call the \"technomity\" aka the Council of Grin, given it certainly doesn't matter, and there are so many fun witchy things to choose from? This group will be cited by name when future upgrades, discussions, and decisions arise. Some ideas: The GAMUT (GOBLINs Adhocratic Magical Undertakings Thing) (Who runs the GAMUT? https://en.wiktionary.org/wiki/run_the_gamut) https://en.wikipedia.org/wiki/Thing_(assembly) also referencet to supreme wizard court in harry potter, the Wizengamot. https://en.wikipedia.org/wiki/Adhocracy Prefects or pr\u00e6fectus/praefectus/praefectii- leadership, appear in harry potter books as upperclassmen. Spontaneous Order of GOBLINS GOBLINS (GRIN's Own Beaurocracy of Laborers, Improvers, Nurturers and Scientists or GRIN's Own Beurocracy of Learned Integrators Negotiators and Scientists) Ministry of Mages Coven of Alchemical Liason Maintainance (CALM... keep CALM and carry wands). The Spontaneous Order of Unknown Leaders (SOUL, https://en.wikipedia.org/wiki/Spontaneous_order#Markets ) The Stygmergic Syzygy Institute of Broom and Wand Design Magical Undertakings of Money (MUMs the word!) P.O.W.O.W. (which could stand for The POWOW Order of Wizards Ongoing Work\u2026 which has that nice nested GNU thing\u2026 and actually we\u2019ve already been calling it the powow\u2026 plus the connotations for proof of work, POW, and pain, OW\u2026 but is probably incensitive to native americans) Sobornost (\u201cthe combination of freedom and unity of many persons on the basis of their common love for the same absolute values.\u201d, https://en.wikipedia.org/wiki/Sobornost) Synod (church council) Conventicle (https://en.wikipedia.org/wiki/Conventicle) Conciliabulum (https://en.wikipedia.org/wiki/Conciliabulum) navem civitatis - ship of state (platos coinage of philosopher king) technicorum magorum\u2122 - technocracy of magi Ministry of Magi (MOM said!) Convention of Wizards (COW goes MU (Mimblewimble Undertakings)) Chamber of Intermagical Affairs, aka the CIA? Assembly of Seers? Seer Association? Seers, Robust & Company?","title":"Council Name"},{"location":"wiki/extra-documents/nomenclature-bs/#walletminer-names","text":"These are all totally free to use for any efforts. Wink Nod Smirk","title":"Wallet/Miner Names"},{"location":"wiki/extra-documents/nomenclature-bs/#mascot-names","text":"Cuthru Langlock Alice (https://tmgox.com/product/alice-embroidered-womens-polo-shirt/) Chesire Cat (immensely cool and in public domain: https://upload.wikimedia.org/wikipedia/commons/8/8a/Arthur_Rackham_Cheshire_Cat.jpeg)","title":"Mascot Names"},{"location":"wiki/extra-documents/nomenclature-bs/#currency-name-solved","text":"In what units do we measure the grin currency? grins (milli, micro, etc). Winks and Nods?","title":"Currency name [Solved]"},{"location":"wiki/extra-documents/nomenclature-bs/#currency-symbol","text":"Discussion: https://www.grin-forum.org/t/currency-symbol-other-bs/484 we could do something absolutely evil and comandeer the symbol for generic currency... \u00a4 ... \u00a4333 .... https://en.wikipedia.org/wiki/Currency_sign_(typography) it is the universal ISO symbol for money............................... i feel like i've peekend inside pandora's box. GOODNESS I like this one. It's like a glitch in the matrix.... and very philosophicala symbolic. Roman Czyborra writes in his Good ole' ASCII that \"the socialist countries managed to substitute the international currency sign \u00a4 for ASCII's capitalist dollar sign $ in the the first international reference version ISO-646-IRV\". However, the international currency symbol \u00a4 was proposed for inclusion in the international standard character code in place of the dollar or pound sign by the Italian delegation to the CCITT, not by the socialist countries. In a later vote, Italy, Portugal, Switzerland, and the USSR favored the use of the \u00a4 character; Canada, France, Germany, the Netherlands, Sweden, and the United Kingdom preferred to standardize the $ and \u00a3 signs. Sources: CCITT Working Group on Alphabets, October 6-9, 1964, CBI 67, box 3, folder 3; ISO TC 97/SC 2 and CCITT/GM ALP joint meeting, April 26-28, 1966, NMAH 310, box 5. and now some other resources I've found... and some symbols that stand out. There are lots of options and I am 100% of the belief that the perfect one can jump out at us like a mystical epiphany, and that bikeshedding isn't as arduous and arbitrary as it always seems to be. From this document: http://bora.uib.no/bitstream/handle/1956/10699/MUFI-Alphabetic-4-0.pdf?sequence=9&isAllowed=y \uead0 &grlig; EAD0 PUA-1 LATIN SMALL LIGATURE GR doesnt show These are very good old English... very in the style of. http://www.wikiwand.com/en/Insular_G \u1d79 &gins; 1D79 PhonExt LATIN SMALL LETTER INSULAR G \ua77d &Gins; A77D LatExtD LATIN CAPITAL LETTER INSULAR G \ua77f &ginsturn; A77F LatExtD LATIN SMALL LETTER TURNED INSULAR G \ua77e &Ginsturn; A77E LatExtD LATIN CAPITAL LETTER TURNED INSULAR G \ua7ff &M5leg; A7FF LatExtD LATIN EPIGRAPHIC LETTER ARCHAIC M 199\ua7ff aka \ua7ff aka mimblewimble. that one is confusing and cool \u00f8 \u00f8 00F8 Lat1Suppl LATIN SMALL LETTER O WITH STROKE \u00d8 \u00d8 00D8 Lat1Suppl LATIN CAPITAL LETTER O WITH STROKE 243\u00d8 for a piece of bread a symbolic cut-through... the $ sign is pretty abstract, ours needn't be a G at all. looks like a zero though, not great. \u0289 &ubar; 0289 IPAExt LATIN SMALL LETTER U BAR 777\u0289 its like the S with a line through it $, but its a u, kind of like a little smile with a cuthru \u1efd &vwelsh; 1EFD LatExtAdd LATIN SMALL LETTER MIDDLE-WELSH V looks kind of like a G when rendered differently \u02e3 &xmod; 02E3 SpModLet MODIFIER LETTER SMALL X 420\u02e3 to pay the bills \u25cc\u035c\u25cc &combdblbrevebl; 035C CombDiaMk COMBINING DOUBLE BREVE BELOW this one not sure if it shows but its like a fallen over right parenthesis... looks like a grin... pretty awesome! literally you write the number of grin syou have and underline it with a little grin, ha! \u221e \u221e 221E MathOp INFINITY 42\u221e worth of wine please! \u23d1 &metrshort; 23D1 MiscTech METRICAL BREVE its the cutest little grin 55\u23d1 \uf717 &metrbrevedblac; F717 PUA-10 METRICAL SYMBOL BREVE WITH DOUBLE doesnt show but its a smiley The spesmilo character, called spesmilsigno in Esperanto (like monero's use of esperanto) https://en.wikipedia.org/wiki/Spesmilo looks like an S with a little m in it. The mill or ( \u20a5 ) an m with a cuthru https://en.wikipedia.org/wiki/Mill_(currency) of course unicode alchemical symbols would be appropriate too https://en.wikipedia.org/wiki/Alchemical_symbol https://www.unicode.org/charts/PDF/U1F700.pdf 500\ud83d\udf50 looks like a magic wand \u263a its just a little unicode smiley face, this would be perfect \u267e its like an infinity symbol in a circle.. looks kind of like a smiley... and is the symbol for acid free p aper I need 699\u267e! Grin, that acid free paper currency!!! also means PERMANENT PAPER... which is a good symbol for a cashlike currency probably. \u2639 this one is hilarious, its like a big sad face \u2604 looks like a harry potter golden snitch 900\u2604 please! now from https://www.unicode.org/charts/PDF/U2600.pdf \u26a1like harry potters lightning bolt \u26c0 i think thats supposed to be a coin \u2652 mw looking \u2687 a partial smiley \u2639\u263a.. first is a sad face second is a smiley... for some reason the sad one is bigger \ud83d\ude42... slightly smiling face... that one renders really well \ue231* \ud83d\ude41 slightly frowning \u263b ooh this one is good... its the dark version of the smiley \u262f yin yang... mimble wimble \u231a a little watch... time is money 1\u231a /second \u231b hourglas... time is still money... 9,000\u231b please! \ud83c\udf1e *wow! * sun with face... that one is pretty good. feeling more and more like picking something simple like the letter G is the wrong choice. what fun to have so much creative freedom...and people may be writing it on checks and the tip line of receipts! \u2620 skull and cross bones... theres a grin in there somewhere \ud83d\udd71 another render, supposed to be b lack \u0fca a tibetan symbol \ud83d\ude36 *WOW symbol for face without a mouth!!!!!! \u269d a little bit wizardly.. the pentagram... \u26e5 \u26e4 just a white rectangle \u25ad 900\u25ad \u29de infinity negated with a vertical bar \u26b2 neuter symbol \u26bf squared key \u26d1 helmet \u26d3 those are supposed to be chains... that's kind of cool you know, blockchain. \u26b5 looks like a magic wand some more here: https://commons.wikimedia.org/wiki/Category:Alchemical_symbols though they are not easily accessible unicode https://commons.wikimedia.org/wiki/Category:Mercury_symbols mercury is a communication symbol... money is a very pure form of communication some good ones in there. almost entirely sure that using something as ancient as a latin letter would be a missed opportunity. why wouldnt the currency of the future have an emoji as a symbol????? I mean of course it would. We are desinging the ultimate cash for the digital age, it should look like a product of the internet in every way right? someone on reddit said the MW-Eyed smiley logo looks too much like a meme... but that is what we are making right, an infectious meme. currency itself is a meme! will never forgive myself now if we don't pick something great.","title":"Currency Symbol"},{"location":"wiki/extra-documents/regarding-foundations/","text":"Regarding Foundations Introduction Official Foundations are sometimes seen as an obvious 'must-have' requirement for any serious cryptocurrency project. The purpose of this document is to evaluate whether there's just cause for such a foundation in the context of the Grin project. Experiences from other crypto projects are considered, followed by identifying the potential use cases a foundation is supposed to solve for. Each of these are then discussed in the context of a foundation, and what the alternative to that could be. It should be pointed out that it's not possible or intended to prevent foundations from being set up. Any individual, group, or other entity may freely decide to set up a foundation, as is it within their right. What's being evaluated is rather whether a foundation in \"official\" capacity can be mandated or not. Current status September 13, 2018: There are no current or future plans to create an official Grin Foundation. Other entities wishing to set up foundations or other organisations with intentions to support the project are welcomed. Selected experiences of other projects Bitcoin Foundation has been mired in controversies regarding its leadership and received cease and desist letters from US institutions. The Tezos Foundation ended up in a vicious legal dispute with the project founders whilst some $400m in funds at the time were locked. The Monero community opted not to create a foundation in the first place, this post sums up some of the thinking behind this. Aragon has announced that they seek to work towards decentralising their foundation and reducing its responsibilities. Zcash Foundation has published results from their Governance process , which sheds light into some of their activities, challenges, and feedback from their community. Their mission statement identify Community, Protocol/Governance, and Science as the three key pillars of the foundation. A recently expressed goal by the Foundation board was to \"exist long enough to become irrelevant / unnecessary\" . MakerDAO have announced a a foundation proposal as part of their Maker Governance Framework. As part of their proposal, 'gradual decentralisation' is to be realised through the work of the foundation. Cardano Foundation representative's issue . Possible Foundation Use Cases To own/manage assets. Owning assets that are valuable to the community, such as domain names, trademarks, IP, Login info, account privileges, art & media assets etc. To act as official representative. A spokesperson of sorts for the project. For PR & media related enquiries. Issuing \"official\" statements. To offer legal protection. Assume legal liability for the project in order to deflect and protect developers and others in the community from being sued or targeted for legal prosecution. To offer legal advice. Legal counsel used to offer advice to community members and support in the event of legal conflicts. To accept charitable donations. A destination for community members to send donations to that can then be used to promote the project's interests. To fund development projects and research. Using donations and foundation resources to fund development efforts that are important for the project. Fund research efforts. To educate, lobby, network. To educate authorities about what the protocol does and doesn't do, to make arguments to politicians about why they should not try to ban privacy coins, to demonstrate how the project is compliant with a local regulation, to participate in alliances with other charitable organisations that value privacy, etc. To nurture and grow the community. Community building exercises, conferences, symposiums, supporting meet ups, hosting speakers, etc. To make protocol/governance related decisions . Contentious topic. Some foundations explicitly avoid taking an active role in governance. Others seem more active and responsible in \"steering\" the community and offering advice in times of hard forks and protocol conflicts. Weighing different approaches Using a foundation Not using a foundation To own/manage assets Straight forward. Does not ensure assets are managed the right way. Can act as a deterrent for abuse/infringement. What are the assets that have to be owned by a central entity? Are there alternatives? Trademarks and IP will be difficult to protect and enforce and requires active defending. Does the project need to own trademarks? Redundancy for account access, privileges, etc. might possible to be handled in the community. How can domains be owned without a central entity? Do they need to be? To act as official representative Might make marketing/pr easier. Does it make sense to have a central entity speaking for the entire project? Does a central, official representative make an easy target for harassment by law enforcement? Opting not to have an official representative can be a deliberate design decision. If the community really feel that a spokesperson is important, this can be appointed without the need for a foundation. Similarly, statements can also be drafted and issued through a community effort. To offer legal protection Will require significant legal effort to draft air-tight defence. To what extent would a foundation then need to have authority over the project? Is that in conflict with governance models? Does it make the project centralised? What is the real risk for developers and community members? Can a foundation prevent individuals from being targeted? To offer legal advice How likely is there that the foundation will employ permanent counsel? By not avoiding a central organisation, can legal risk be reduced? Fundraising by the community could support developers who get into legal trouble. This would allow legal advice to be better tailored to the needs of the individual and the circumstance. To accept charitable donations Does it make sense to raise funds without stating explicitly how they are to be spent? Can the overhead of a foundation be justified? There may be tax benefits by registering as a charitable foundation. There is real risk for misappropriation of funds. Community 'slush funds' can still be organised. Setting this up as a decentralised entity can be a challenge. Who decides how funds are spent? To fund development projects and research Who decides what projects to fund? Can the overhead of a foundation be justified for this? What does it mean in terms of centralisation? Monero's FFS model is an example of community funding without a centralised foundation structure. There are also other alternatives for funding open source projects. To educate, lobby, network There's a logic for why a central, official, organisation will have greater chance of success in these efforts. Community efforts will be harder to get focused and organised around specific causes. Nothing is preventing interest organisations from forming around specific causes and missions, including the Grin project itself. These can lobby and influence as required. But would not do so in any official capacity of the foundation. To nurture and grow the community A foundation can designate resources to be responsible for this on a continuous basis. Paying for professionals to work on this might lead to more professional activities and increase performance. It may also centralise decision making around the direction the community should grow in and introduce bias. It seems intuitive to expect the community to take care of itself in a decentralised project. This however also assumes the community is engaged and committed to put in the effort required. On the other hand, if the community is not, then a centralised community management function will have little impact either way. To make protocol/governance related decisions A foundation can be the \"last resort\", ready to step in to take responsibility in times of crisis or extra-ordinary events. Can ensure that there is proper planning, and that the project is progressing. Can suffer from legitimacy issues. Might struggle to make decisions that are in line with the will of the community, and therefore lead to friction or forks. The community can make these decisions, assuming a governance model is in place that functions and is seen as legitimate by the community. Easier said than done correctly, though. Concluding remarks There are many use cases where foundations may be useful. In general, it seems however that a foundation is not a prerequisite to solve for these, and that they also can be solved on a per case basis via an engaged and committed community. It's not clear that a foundation will do a better job. Having a foundation creates overhead and centralises power and authority into a physical legal entity. For a project that strives to be decentralised, this seems contradictory. On the other hand, there are efficiency and accountability benefits that can be realised with a professionally run foundation compared to community efforts carried out ad-hoc, which may or may not be done properly. There's a real trade-off there and the community should decide what is valued most.","title":"Regarding Foundations"},{"location":"wiki/extra-documents/regarding-foundations/#regarding-foundations","text":"","title":"Regarding Foundations"},{"location":"wiki/extra-documents/regarding-foundations/#introduction","text":"Official Foundations are sometimes seen as an obvious 'must-have' requirement for any serious cryptocurrency project. The purpose of this document is to evaluate whether there's just cause for such a foundation in the context of the Grin project. Experiences from other crypto projects are considered, followed by identifying the potential use cases a foundation is supposed to solve for. Each of these are then discussed in the context of a foundation, and what the alternative to that could be. It should be pointed out that it's not possible or intended to prevent foundations from being set up. Any individual, group, or other entity may freely decide to set up a foundation, as is it within their right. What's being evaluated is rather whether a foundation in \"official\" capacity can be mandated or not.","title":"Introduction"},{"location":"wiki/extra-documents/regarding-foundations/#current-status","text":"September 13, 2018: There are no current or future plans to create an official Grin Foundation. Other entities wishing to set up foundations or other organisations with intentions to support the project are welcomed.","title":"Current status"},{"location":"wiki/extra-documents/regarding-foundations/#selected-experiences-of-other-projects","text":"Bitcoin Foundation has been mired in controversies regarding its leadership and received cease and desist letters from US institutions. The Tezos Foundation ended up in a vicious legal dispute with the project founders whilst some $400m in funds at the time were locked. The Monero community opted not to create a foundation in the first place, this post sums up some of the thinking behind this. Aragon has announced that they seek to work towards decentralising their foundation and reducing its responsibilities. Zcash Foundation has published results from their Governance process , which sheds light into some of their activities, challenges, and feedback from their community. Their mission statement identify Community, Protocol/Governance, and Science as the three key pillars of the foundation. A recently expressed goal by the Foundation board was to \"exist long enough to become irrelevant / unnecessary\" . MakerDAO have announced a a foundation proposal as part of their Maker Governance Framework. As part of their proposal, 'gradual decentralisation' is to be realised through the work of the foundation. Cardano Foundation representative's issue .","title":"Selected experiences of other projects"},{"location":"wiki/extra-documents/regarding-foundations/#possible-foundation-use-cases","text":"To own/manage assets. Owning assets that are valuable to the community, such as domain names, trademarks, IP, Login info, account privileges, art & media assets etc. To act as official representative. A spokesperson of sorts for the project. For PR & media related enquiries. Issuing \"official\" statements. To offer legal protection. Assume legal liability for the project in order to deflect and protect developers and others in the community from being sued or targeted for legal prosecution. To offer legal advice. Legal counsel used to offer advice to community members and support in the event of legal conflicts. To accept charitable donations. A destination for community members to send donations to that can then be used to promote the project's interests. To fund development projects and research. Using donations and foundation resources to fund development efforts that are important for the project. Fund research efforts. To educate, lobby, network. To educate authorities about what the protocol does and doesn't do, to make arguments to politicians about why they should not try to ban privacy coins, to demonstrate how the project is compliant with a local regulation, to participate in alliances with other charitable organisations that value privacy, etc. To nurture and grow the community. Community building exercises, conferences, symposiums, supporting meet ups, hosting speakers, etc. To make protocol/governance related decisions . Contentious topic. Some foundations explicitly avoid taking an active role in governance. Others seem more active and responsible in \"steering\" the community and offering advice in times of hard forks and protocol conflicts.","title":"Possible Foundation Use Cases"},{"location":"wiki/extra-documents/regarding-foundations/#weighing-different-approaches","text":"Using a foundation Not using a foundation To own/manage assets Straight forward. Does not ensure assets are managed the right way. Can act as a deterrent for abuse/infringement. What are the assets that have to be owned by a central entity? Are there alternatives? Trademarks and IP will be difficult to protect and enforce and requires active defending. Does the project need to own trademarks? Redundancy for account access, privileges, etc. might possible to be handled in the community. How can domains be owned without a central entity? Do they need to be? To act as official representative Might make marketing/pr easier. Does it make sense to have a central entity speaking for the entire project? Does a central, official representative make an easy target for harassment by law enforcement? Opting not to have an official representative can be a deliberate design decision. If the community really feel that a spokesperson is important, this can be appointed without the need for a foundation. Similarly, statements can also be drafted and issued through a community effort. To offer legal protection Will require significant legal effort to draft air-tight defence. To what extent would a foundation then need to have authority over the project? Is that in conflict with governance models? Does it make the project centralised? What is the real risk for developers and community members? Can a foundation prevent individuals from being targeted? To offer legal advice How likely is there that the foundation will employ permanent counsel? By not avoiding a central organisation, can legal risk be reduced? Fundraising by the community could support developers who get into legal trouble. This would allow legal advice to be better tailored to the needs of the individual and the circumstance. To accept charitable donations Does it make sense to raise funds without stating explicitly how they are to be spent? Can the overhead of a foundation be justified? There may be tax benefits by registering as a charitable foundation. There is real risk for misappropriation of funds. Community 'slush funds' can still be organised. Setting this up as a decentralised entity can be a challenge. Who decides how funds are spent? To fund development projects and research Who decides what projects to fund? Can the overhead of a foundation be justified for this? What does it mean in terms of centralisation? Monero's FFS model is an example of community funding without a centralised foundation structure. There are also other alternatives for funding open source projects. To educate, lobby, network There's a logic for why a central, official, organisation will have greater chance of success in these efforts. Community efforts will be harder to get focused and organised around specific causes. Nothing is preventing interest organisations from forming around specific causes and missions, including the Grin project itself. These can lobby and influence as required. But would not do so in any official capacity of the foundation. To nurture and grow the community A foundation can designate resources to be responsible for this on a continuous basis. Paying for professionals to work on this might lead to more professional activities and increase performance. It may also centralise decision making around the direction the community should grow in and introduce bias. It seems intuitive to expect the community to take care of itself in a decentralised project. This however also assumes the community is engaged and committed to put in the effort required. On the other hand, if the community is not, then a centralised community management function will have little impact either way. To make protocol/governance related decisions A foundation can be the \"last resort\", ready to step in to take responsibility in times of crisis or extra-ordinary events. Can ensure that there is proper planning, and that the project is progressing. Can suffer from legitimacy issues. Might struggle to make decisions that are in line with the will of the community, and therefore lead to friction or forks. The community can make these decisions, assuming a governance model is in place that functions and is seen as legitimate by the community. Easier said than done correctly, though.","title":"Weighing different approaches"},{"location":"wiki/extra-documents/regarding-foundations/#concluding-remarks","text":"There are many use cases where foundations may be useful. In general, it seems however that a foundation is not a prerequisite to solve for these, and that they also can be solved on a per case basis via an engaged and committed community. It's not clear that a foundation will do a better job. Having a foundation creates overhead and centralises power and authority into a physical legal entity. For a project that strives to be decentralised, this seems contradictory. On the other hand, there are efficiency and accountability benefits that can be realised with a professionally run foundation compared to community efforts carried out ad-hoc, which may or may not be done properly. There's a real trade-off there and the community should decide what is valued most.","title":"Concluding remarks"},{"location":"wiki/extra-documents/story-of-distribution/","text":"Story of Distribution Stories are important ; We often commemorate them, and they broadly impact our perception. Bitcoin's story of inception cannot be matched in its perfection. Its story of distribution however, will remain flawed, gradually turning into a bigger stain with each passing year. Aside from its clear financial implications, it presents an unwelcoming & discouraging narrative to new adopters, as if they are valued less than the previous ones. Grin's decision to set itself apart in its story of distribution is controversial, but nevertheless an invaluable distinguishing factor in forming a more positive and welcoming narrative for Grin in its future. Stories never die. A story of fairness & moderation contrasted with that of quick enrichment for early users will remain rewarding for Grin, as it seeks to claim relevance for years to come.","title":"Story of Distribution"},{"location":"wiki/extra-documents/story-of-distribution/#story-of-distribution","text":"Stories are important ; We often commemorate them, and they broadly impact our perception. Bitcoin's story of inception cannot be matched in its perfection. Its story of distribution however, will remain flawed, gradually turning into a bigger stain with each passing year. Aside from its clear financial implications, it presents an unwelcoming & discouraging narrative to new adopters, as if they are valued less than the previous ones. Grin's decision to set itself apart in its story of distribution is controversial, but nevertheless an invaluable distinguishing factor in forming a more positive and welcoming narrative for Grin in its future. Stories never die. A story of fairness & moderation contrasted with that of quick enrichment for early users will remain rewarding for Grin, as it seeks to claim relevance for years to come.","title":"Story of Distribution"},{"location":"wiki/extra-documents/user-stories-use-cases/","text":"User Stories Use Cases By sesam , Jun 29 2018 Or, how non-developers are expected to use and abuse the grin software. In #750 we're calling for help with a user guide. Users often want to get started trying things out, instead of reading instructions. The now modern on-boarding screens/animations that just take seconds to click through are often ignored or furiously clicked at to make them go away. For users, the nicest option is to just pick out the software and start using it. Then, the best guide is perhaps one that follows the user and suggests what the user can do next, without forcing the user to do anything special. git is an example of a hard-to-understand blockchain-ish transaction-ish application that gives its users small hints on correcting user mistakes and getting good configuration settings where good defaults are not an option. How will the first non-crypto fans be able to use grin? Sym the gym coach Background story: As a coach, things not on the mobile phone are not usable. Sym only uses the web wallet to spend and earn grins with some friends who are also testing this out. One of them installed grin on the gym hall's reception computer, so it's mining some grins and helps heating the space during the winter months. Use cases: Open the web wallet on mobile. Look at the wallet balance. Send some of the mined coins to Roe (who in turn brings bottled drinks that the gym then can sell to its customers) Accept payments for drinks in grin, with the web wallet emitting different sounds for different incoming transactions (Example: \"cheers!\" for each incoming drink payment, or \"eet smakelijk\" for sandwich payments), making it possible for Sym to both work with customers and keep an eye and ear on the almost automated snacks bar side-business. Pat the internet caf\u00e9 attendant somewhere in Asia The cafe's computers, when idle, run a \"screen saver\" that activates the grin-goldminer, ensuring the investment in good gaming computers is never cooling down too much. The caf\u00e9 customers like it warm and toasty. Whether not trusting its multiple ISP uplinks or wanting to save on bandwidth, the caf\u00e9 maintains its own local mining pool. That pool connects to 4 full grin nodes on different continents, making sure that even the worst possible internet weather and cut under-sea cables can't interrupt the continuous flow of grin blocks. Misty the museum owner As a somewhat idealistic person, Misty accepts entrance fee payments in just about any Mimblewimble coin and most testnet coins. On a glass shell in the corner stands a great though aged open computer case with a name tag \"The Yeastmonster\" subtexted \"The First Great Grin Miner\". Most visitors feel its importance and snap a photo before moving along to the graphical user interfaces exhibition hall, but only those with testnet grins can pay to the monster directly to get it to start up its text UI and mine for one minute.","title":"User Stories Use Cases"},{"location":"wiki/extra-documents/user-stories-use-cases/#user-stories-use-cases","text":"By sesam , Jun 29 2018 Or, how non-developers are expected to use and abuse the grin software. In #750 we're calling for help with a user guide. Users often want to get started trying things out, instead of reading instructions. The now modern on-boarding screens/animations that just take seconds to click through are often ignored or furiously clicked at to make them go away. For users, the nicest option is to just pick out the software and start using it. Then, the best guide is perhaps one that follows the user and suggests what the user can do next, without forcing the user to do anything special. git is an example of a hard-to-understand blockchain-ish transaction-ish application that gives its users small hints on correcting user mistakes and getting good configuration settings where good defaults are not an option.","title":"User Stories Use Cases"},{"location":"wiki/extra-documents/user-stories-use-cases/#how-will-the-first-non-crypto-fans-be-able-to-use-grin","text":"","title":"How will the first non-crypto fans be able to use grin?"},{"location":"wiki/extra-documents/user-stories-use-cases/#sym-the-gym-coach","text":"Background story: As a coach, things not on the mobile phone are not usable. Sym only uses the web wallet to spend and earn grins with some friends who are also testing this out. One of them installed grin on the gym hall's reception computer, so it's mining some grins and helps heating the space during the winter months. Use cases: Open the web wallet on mobile. Look at the wallet balance. Send some of the mined coins to Roe (who in turn brings bottled drinks that the gym then can sell to its customers) Accept payments for drinks in grin, with the web wallet emitting different sounds for different incoming transactions (Example: \"cheers!\" for each incoming drink payment, or \"eet smakelijk\" for sandwich payments), making it possible for Sym to both work with customers and keep an eye and ear on the almost automated snacks bar side-business.","title":"Sym the gym coach"},{"location":"wiki/extra-documents/user-stories-use-cases/#pat-the-internet-cafe-attendant-somewhere-in-asia","text":"The cafe's computers, when idle, run a \"screen saver\" that activates the grin-goldminer, ensuring the investment in good gaming computers is never cooling down too much. The caf\u00e9 customers like it warm and toasty. Whether not trusting its multiple ISP uplinks or wanting to save on bandwidth, the caf\u00e9 maintains its own local mining pool. That pool connects to 4 full grin nodes on different continents, making sure that even the worst possible internet weather and cut under-sea cables can't interrupt the continuous flow of grin blocks.","title":"Pat the internet caf\u00e9 attendant somewhere in Asia"},{"location":"wiki/extra-documents/user-stories-use-cases/#misty-the-museum-owner","text":"As a somewhat idealistic person, Misty accepts entrance fee payments in just about any Mimblewimble coin and most testnet coins. On a glass shell in the corner stands a great though aged open computer case with a name tag \"The Yeastmonster\" subtexted \"The First Great Grin Miner\". Most visitors feel its importance and snap a photo before moving along to the graphical user interfaces exhibition hall, but only those with testnet grins can pay to the monster directly to get it to start up its text UI and mine for one minute.","title":"Misty the museum owner"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/","text":"Technical Introduction to Mimblewimble Tongue Tying for Everyone This document is targeted at readers with a good understanding of blockchains and basic cryptography. With that in mind, we attempt to explain the technical buildup of Mimblewimble and how it's applied in Grin. We hope this document is understandable to most technically-minded readers. Our objective is to encourage you to get interested in Grin and contribute in any way possible. To achieve this objective, we will introduce the main concepts required for a good understanding of Grin as a Mimblewimble implementation. We will start with a brief description of some relevant properties of Elliptic Curve Cryptography (ECC) to lay the foundation on which Grin is based and then describe all the key elements of a Mimblewimble blockchain's transactions and blocks. Tiny Bits of Elliptic Curves We start with a brief primer on Elliptic Curve Cryptography, reviewing just the properties necessary to understand how Mimblewimble works and without delving too much into the intricacies of ECC. For readers who would want to dive deeper into those assumptions, there are other opportunities to learn more . An Elliptic Curve for the purpose of cryptography is simply a large set of points that we will call C . These points can be added, subtracted, or multiplied by integers (also called scalars). Given such a point H , an integer k and using the scalar multiplication operation we can compute k*H , which is also a point on curve C . Given another integer j we can also calculate (k+j)*H , which equals k*H + j*H . The addition and scalar multiplication operations on an elliptic curve maintain the commutative and associative properties of addition and multiplication: (k+j)*H = k*H + j*H In ECC, if we pick a very large number k as a private key, k*H is considered the corresponding public key. Even if one knows the value of the public key k*H , deducing k is close to impossible (or said differently, while multiplication is trivial, \"division\" by curve points is extremely difficult). The previous formula (k+j)*H = k*H + j*H , with k and j both private keys, demonstrates that a public key obtained from the addition of two private keys ( (k+j)*H ) is identical to the addition of the public keys for each of those two private keys ( k*H + j*H ). In the Bitcoin blockchain, Hierarchical Deterministic wallets heavily rely on this principle. Mimblewimble and the Grin implementation do as well. Transacting with Mimblewimble The structure of transactions demonstrates a crucial tenet of Mimblewimble: strong privacy and confidentiality guarantees. The validation of Mimblewimble transactions relies on two basic properties: Verification of zero sums. The sum of outputs minus inputs always equals zero, proving that the transaction did not create new funds, without revealing the actual amounts . Possession of private keys. Like with most other cryptocurrencies, ownership of transaction outputs is guaranteed by the possession of ECC private keys. However, the proof that an entity owns those private keys is not achieved by directly signing the transaction. The next sections on balance, ownership, change and proofs details how those two fundamental properties are achieved. Balance Building upon the properties of ECC we described above, one can obscure the values in a transaction. If v is the value of a transaction input or output and H a point on the elliptic curve C , we can simply embed v*H instead of v in a transaction. This works because using the ECC operations, we can still validate that the sum of the outputs of a transaction equals the sum of inputs: v1 + v2 = v3 => v1*H + v2*H = v3*H Verifying this property on every transaction allows the protocol to verify that a transaction doesn't create money out of thin air, without knowing what the actual values are. However, there are a finite number of usable values (transaction amounts) and one could try every single one of them to guess the value of the transaction. In addition, knowing v1 (from a previous transaction for example) and the resulting v1*H reveals all outputs with value v1 across the blockchain. For these reasons, we introduce a second point G on the same elliptic curve (practically G is just another generator point on the same curve group as H ) and a private key r used as a blinding factor . An input or output value in a transaction can then be expressed as: r*G + v*H Where: r is a private key used as a blinding factor, G is a point on the elliptic curve C and their product r*G is the public key for r (using G as generator point). v is the value of an input or output and H is another point on the elliptic curve C , together producing another public key v*H (using H as generator point). Neither v nor r can be deduced, leveraging the fundamental properties of Elliptic Curve Cryptography. r*G + v*H is called a Pedersen Commitment . As an example, let's assume we want to build a transaction with two inputs and one output. We have (ignoring fees): vi1 and vi2 as input values. vo3 as output value. Such that: vi1 + vi2 = vo3 Generating a private key as a blinding factor for each input value and replacing each value with their respective Pedersen Commitments in the previous equation, we obtain: (ri1*G + vi1*H) + (ri2*G + vi2*H) = (ro3*G + vo3*H) Which as a consequence requires that: ri1 + ri2 = ro3 This is the first pillar of Mimblewimble: the arithmetic required to validate a transaction can be done without knowing any of the values. As a final note, this idea is actually derived from Greg Maxwell's Confidential Transactions , which is itself derived from an Adam Back proposal for homomorphic values applied to Bitcoin. Ownership In the previous section we introduced a private key as a blinding factor to obscure the transaction's values. The second insight of Mimblewimble is that this private key can be leveraged to prove ownership of the value. Alice sends you 3 coins and to obscure that amount, you chose 28 as your blinding factor (note that in practice, the blinding factor being a private key, it's an extremely large number). Somewhere on the blockchain, the following output appears and should only be spendable by you: X = 28*G + 3*H X , the result of the addition, is visible by everyone. The value 3 is only known to you and Alice, and 28 is only known to you. To transfer those 3 coins again, the protocol requires 28 to be known somehow. To demonstrate how this works, let's say you want to transfer those 3 same coins to Carol. You need to build a simple transaction such that: Xi => Y Where Xi is an input that spends your X output and Y is Carol's output. There is no way to build such a transaction and balance it without knowing your private key of 28. Indeed, if Carol is to balance this transaction, she needs to know both the value sent and your private key so that: Y - Xi = (28*G + 3*H) - (28*G + 3*H) = 0*G + 0*H By checking that everything has been zeroed out, we can again make sure that no new money has been created. Wait! Stop! Now you know the private key in Carol's output (which, in this case, must be the same as yours to balance out) and so you could steal the money back from Carol! To solve this, Carol uses a private key of her choosing. She picks 113 say, and what ends up on the blockchain is: Y - Xi = (113*G + 3*H) - (28*G + 3*H) = 85*G + 0*H Now the transaction no longer sums to zero and we have an excess value (85), which is the result of the summation of all blinding factors. Because 85*G is a valid public key for the generator point G the input and output values must sum to zero and the transaction is thus valid, since x*G + y*H is a valid public key for generator point G if and only if y = 0 . So all the protocol needs to verify is that ( Y - Xi ) is a valid public key for generator point G and that the transacting parties collectively can produce its private key (85 in the above example). The simplest way to do so is to require a signature built with the excess value (85), which then ensures that: The transacting parties collectively can produce the private key (the excess value) The sum of the outputs minus the inputs are zero (because only a valid public key will check against the signature). This signature, attached to every transaction, together with some additional data (like mining fees), is called a transaction kernel and is checked by all validators. Some Finer Points This section elaborates on the building of transactions by discussing how change is introduced and the requirement for range proofs so all values are proven to be non-negative. Neither of these are absolutely required to understand Mimblewimble and Grin, so if you're in a hurry, feel free to jump straight to Putting It All Together . Change Let's say you only want to send 2 coins to Carol from the 3 you received from Alice. To do this you would send the remaining 1 coin back to yourself as change. You generate another private key (say 12) as a blinding factor to protect your change output. Carol uses her own private key as before. Change output: 12*G + 1*H Carol's output: 113*G + 2*H What ends up on the blockchain is something very similar to before. And the signature is again built with the excess value, 97 in this example. (12*G + 1*H) + (113*G + 2*H) - (28*G + 3*H) = 97*G + 0*H Range Proofs In all the above calculations, we rely on the transaction values to always be positive. The introduction of negative amounts would be extremely problematic as one could create new funds in every transaction. For example, one could create a transaction with an input of 2 and outputs of 5 and -3 and still obtain a well-balanced transaction. This can't be easily detected because even if x is negative, the corresponding point x*H on the curve looks like any other. To solve this problem, Mimblewimble leverages another cryptographic concept (also coming from Confidential Transactions) called range proofs: a proof that a number falls within a given range, without revealing the number. We won't elaborate on the range proof, but you just need to know that for any r*G + v*H we can build a proof that will show that v is greater than zero and does not overflow. It's also important to note that range proofs for both the blinding factor and the values are needed. The reason for this is that it prevents a censoring attack where a third party would be able to lock UTXOs without knowing their private keys by creating a transaction such as the following: Carol's UTXO: 113*G + 2*H Attacker's output: (113 + 99)*G + 2*H which can be signed by the attacker because Carol's blinding factor cancels out in the equation Y - Xi : Y - Xi = ((113 + 99)*G + 2*H) - (113*G + 2*H) = 99*G This output ( (113 + 99)*G + 2*H ) requires that both the numbers 113 and 99 are known in order to be spent; the attacker would thus have successfully locked Carol's UTXO. The requirement for a range proof for the blinding factor prevents this because the attacker doesn't know the number 113 and thus neither (113 + 99). A more detailed description of range proofs is further detailed in the range proof paper . Putting It All Together A Mimblewimble transaction includes the following: A set of inputs, that reference and spend a set of previous outputs. A set of new outputs that include: A value and a blinding factor (which is just a new private key) multiplied on a curve and summed to be r*G + v*H . A range proof that among other things shows that v is non-negative. An transaction fee in cleartext. A signature whose private key is computed by taking the excess value (the sum of all output values plus the fee, minus the input values). Blocks and Chain State We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create money and proof of ownership is established through private keys. The Mimblewimble block format builds on this by introducing one additional concept: cut-through . With this addition, a Mimblewimble chain gains: Extremely good scalability, as the great majority of transaction data can be eliminated over time, without compromising security. Further anonymity by mixing and removing transaction data. Transaction Aggregation Recall that a transaction consists of the following: a set of inputs that reference and spent a set of previous outputs a set of new outputs a transaction kernel consisting of: kernel excess (the public key of the excess value) transaction signature whose public key is the kernel excess A transaction is validated by determining that the kernel excess is a valid public key: (42*G + 1*H) + (99*G + 2*H) - (113*G + 3*H) = 28*G + 0*H The public key in this example is 28*G . We can say the following is true for any valid transaction (ignoring fees for simplicity): sum(outputs) - sum(inputs) = kernel_excess The same holds true for blocks themselves once we realize a block is simply a set of aggregated inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs from it and equating the resulting Pedersen commitment to the sum of the kernel excesses: sum(outputs) - sum(inputs) = sum(kernel_excess) Simplifying slightly, (again ignoring transaction fees) we can say that Mimblewimble blocks can be treated exactly as Mimblewimble transactions. Kernel Offsets There is a subtle problem with Mimblewimble blocks and transactions as described above. It is possible (and in some cases trivial) to reconstruct the constituent transactions in a block. This is clearly bad for privacy. This is the \"subset\" problem: given a set of inputs, outputs, and transaction kernels a subset of these will recombine to reconstruct a valid transaction. Consider the following two transactions: (in1, in2) -> (out1), (kern1) (in3) -> (out2), (kern2) We can aggregate them into the following block (or aggregate transaction): (in1, in2, in3) -> (out1, out2), (kern1, kern2) It is trivially easy to try all possible permutations to recover one of the transactions (where it successfully sums to zero): (in1, in2) -> (out1), (kern1) We also know that everything remaining can be used to reconstruct the other valid transaction: (in3) -> (out2), (kern2) Remember that the kernel excess r*G simply is the public key of the excess value r . To mitigate this we redefine the kernel excess from r*G to (r-kernel_offset)*G and distribute the kernel offset to be included with every transaction kernel. The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the commitments sum to zero: sum(outputs) - sum(inputs) = r*G = (r-kernel_offset)*G + kernel_offset*G or alternatively sum(outputs) - sum(inputs) = kernel_excess + kernel_offset*G For a commitment r*G + 0*H with the offset a , the transaction is signed with (r-a) and a is published so that r*G can be calculated in order to verify the validity of the transaction. During block construction all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block. The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved. sum(outputs) - sum(inputs) = sum(kernel_excess) + kernel_offset*G Cut-through Blocks let miners assemble multiple transactions into a single set that's added to the chain. In the following block representations, containing 3 transactions, we only show inputs and outputs of transactions. Inputs reference outputs they spend. An output included in a previous block is marked with a lower-case x. I1 ( x1 ) --- O1 |- O2 I2 ( x2 ) --- O3 I3 ( O2 ) -| I4 ( O3 ) --- O4 |- O5 We notice the two following properties: Within this block, some outputs are directly spent by following inputs ( I3 spends O2 and I4 spends O3 ). The structure of each transaction does not actually matter. Since all transactions individually sum to zero, the sum of all transaction inputs and outputs must be zero. Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels ) and that the whole block did not create any coins (other than what's allowed as the mining reward). Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block: I1(x1) | O1 I2(x2) | O4 | O5 Note that all transaction structure has been eliminated and the order of inputs and outputs does not matter anymore. However, the sum of all inputs and outputs is still guaranteed to be zero. A block is simply built from: A block header. The list of inputs remaining after cut-through. The list of outputs remaining after cut-through. A single kernel offset to cover the full block. The transaction kernels containing, for each transaction: The public key r*G obtained from the summation of all inputs and outputs. The signatures generated using the excess value. The mining fee. When structured this way, a Mimblewimble block offers extremely good privacy guarantees: Intermediate (cut-through) transactions will be represented only by their transaction kernels. All outputs look the same: very large numbers that are impossible to meaningfully differentiate from one another. If someone wants to exclude a specific output, they'd have to exclude all. All transaction structure has been removed, making it impossible to tell which inputs and outputs match. And yet, it all still validates! Cut-through All The Way Going back to the previous example block, outputs x1 and x2 , spent by I1 and I2 , must have appeared previously in the blockchain. So after the addition of this block, those outputs as well as I1 and I2 can also be removed from the blockchain as they now are intermediate transactions. We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information: The total amount of coins created by mining in the chain. The complete set of unspent outputs. The transactions kernels for each transaction. The first piece of information can be deduced just using the block height. Both the UTXOs and the transaction kernels are extremely compact. This has two important consequences: The blockchain a node needs to maintain is very small (on the order of a few gigabytes for a bitcoin-sized blockchain, and potentially optimizable to a few hundreds of megabytes). When a new node joins the network the amount of information that needs to be transferred is very small. In addition, the UTXO set cannot be tampered with. Adding or removing even one input or output would change the sum of the transactions to be something other than zero. Conclusion In this document we covered the basic principles that underlie a Mimblewimble blockchain. By using the addition properties of Elliptic Curve Cryptography, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers.","title":"Technical Introduction to Mimblewimble"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#technical-introduction-to-mimblewimble","text":"","title":"Technical Introduction to Mimblewimble"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#tongue-tying-for-everyone","text":"This document is targeted at readers with a good understanding of blockchains and basic cryptography. With that in mind, we attempt to explain the technical buildup of Mimblewimble and how it's applied in Grin. We hope this document is understandable to most technically-minded readers. Our objective is to encourage you to get interested in Grin and contribute in any way possible. To achieve this objective, we will introduce the main concepts required for a good understanding of Grin as a Mimblewimble implementation. We will start with a brief description of some relevant properties of Elliptic Curve Cryptography (ECC) to lay the foundation on which Grin is based and then describe all the key elements of a Mimblewimble blockchain's transactions and blocks.","title":"Tongue Tying for Everyone"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#tiny-bits-of-elliptic-curves","text":"We start with a brief primer on Elliptic Curve Cryptography, reviewing just the properties necessary to understand how Mimblewimble works and without delving too much into the intricacies of ECC. For readers who would want to dive deeper into those assumptions, there are other opportunities to learn more . An Elliptic Curve for the purpose of cryptography is simply a large set of points that we will call C . These points can be added, subtracted, or multiplied by integers (also called scalars). Given such a point H , an integer k and using the scalar multiplication operation we can compute k*H , which is also a point on curve C . Given another integer j we can also calculate (k+j)*H , which equals k*H + j*H . The addition and scalar multiplication operations on an elliptic curve maintain the commutative and associative properties of addition and multiplication: (k+j)*H = k*H + j*H In ECC, if we pick a very large number k as a private key, k*H is considered the corresponding public key. Even if one knows the value of the public key k*H , deducing k is close to impossible (or said differently, while multiplication is trivial, \"division\" by curve points is extremely difficult). The previous formula (k+j)*H = k*H + j*H , with k and j both private keys, demonstrates that a public key obtained from the addition of two private keys ( (k+j)*H ) is identical to the addition of the public keys for each of those two private keys ( k*H + j*H ). In the Bitcoin blockchain, Hierarchical Deterministic wallets heavily rely on this principle. Mimblewimble and the Grin implementation do as well.","title":"Tiny Bits of Elliptic Curves"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#transacting-with-mimblewimble","text":"The structure of transactions demonstrates a crucial tenet of Mimblewimble: strong privacy and confidentiality guarantees. The validation of Mimblewimble transactions relies on two basic properties: Verification of zero sums. The sum of outputs minus inputs always equals zero, proving that the transaction did not create new funds, without revealing the actual amounts . Possession of private keys. Like with most other cryptocurrencies, ownership of transaction outputs is guaranteed by the possession of ECC private keys. However, the proof that an entity owns those private keys is not achieved by directly signing the transaction. The next sections on balance, ownership, change and proofs details how those two fundamental properties are achieved.","title":"Transacting with Mimblewimble"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#balance","text":"Building upon the properties of ECC we described above, one can obscure the values in a transaction. If v is the value of a transaction input or output and H a point on the elliptic curve C , we can simply embed v*H instead of v in a transaction. This works because using the ECC operations, we can still validate that the sum of the outputs of a transaction equals the sum of inputs: v1 + v2 = v3 => v1*H + v2*H = v3*H Verifying this property on every transaction allows the protocol to verify that a transaction doesn't create money out of thin air, without knowing what the actual values are. However, there are a finite number of usable values (transaction amounts) and one could try every single one of them to guess the value of the transaction. In addition, knowing v1 (from a previous transaction for example) and the resulting v1*H reveals all outputs with value v1 across the blockchain. For these reasons, we introduce a second point G on the same elliptic curve (practically G is just another generator point on the same curve group as H ) and a private key r used as a blinding factor . An input or output value in a transaction can then be expressed as: r*G + v*H Where: r is a private key used as a blinding factor, G is a point on the elliptic curve C and their product r*G is the public key for r (using G as generator point). v is the value of an input or output and H is another point on the elliptic curve C , together producing another public key v*H (using H as generator point). Neither v nor r can be deduced, leveraging the fundamental properties of Elliptic Curve Cryptography. r*G + v*H is called a Pedersen Commitment . As an example, let's assume we want to build a transaction with two inputs and one output. We have (ignoring fees): vi1 and vi2 as input values. vo3 as output value. Such that: vi1 + vi2 = vo3 Generating a private key as a blinding factor for each input value and replacing each value with their respective Pedersen Commitments in the previous equation, we obtain: (ri1*G + vi1*H) + (ri2*G + vi2*H) = (ro3*G + vo3*H) Which as a consequence requires that: ri1 + ri2 = ro3 This is the first pillar of Mimblewimble: the arithmetic required to validate a transaction can be done without knowing any of the values. As a final note, this idea is actually derived from Greg Maxwell's Confidential Transactions , which is itself derived from an Adam Back proposal for homomorphic values applied to Bitcoin.","title":"Balance"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#ownership","text":"In the previous section we introduced a private key as a blinding factor to obscure the transaction's values. The second insight of Mimblewimble is that this private key can be leveraged to prove ownership of the value. Alice sends you 3 coins and to obscure that amount, you chose 28 as your blinding factor (note that in practice, the blinding factor being a private key, it's an extremely large number). Somewhere on the blockchain, the following output appears and should only be spendable by you: X = 28*G + 3*H X , the result of the addition, is visible by everyone. The value 3 is only known to you and Alice, and 28 is only known to you. To transfer those 3 coins again, the protocol requires 28 to be known somehow. To demonstrate how this works, let's say you want to transfer those 3 same coins to Carol. You need to build a simple transaction such that: Xi => Y Where Xi is an input that spends your X output and Y is Carol's output. There is no way to build such a transaction and balance it without knowing your private key of 28. Indeed, if Carol is to balance this transaction, she needs to know both the value sent and your private key so that: Y - Xi = (28*G + 3*H) - (28*G + 3*H) = 0*G + 0*H By checking that everything has been zeroed out, we can again make sure that no new money has been created. Wait! Stop! Now you know the private key in Carol's output (which, in this case, must be the same as yours to balance out) and so you could steal the money back from Carol! To solve this, Carol uses a private key of her choosing. She picks 113 say, and what ends up on the blockchain is: Y - Xi = (113*G + 3*H) - (28*G + 3*H) = 85*G + 0*H Now the transaction no longer sums to zero and we have an excess value (85), which is the result of the summation of all blinding factors. Because 85*G is a valid public key for the generator point G the input and output values must sum to zero and the transaction is thus valid, since x*G + y*H is a valid public key for generator point G if and only if y = 0 . So all the protocol needs to verify is that ( Y - Xi ) is a valid public key for generator point G and that the transacting parties collectively can produce its private key (85 in the above example). The simplest way to do so is to require a signature built with the excess value (85), which then ensures that: The transacting parties collectively can produce the private key (the excess value) The sum of the outputs minus the inputs are zero (because only a valid public key will check against the signature). This signature, attached to every transaction, together with some additional data (like mining fees), is called a transaction kernel and is checked by all validators.","title":"Ownership"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#some-finer-points","text":"This section elaborates on the building of transactions by discussing how change is introduced and the requirement for range proofs so all values are proven to be non-negative. Neither of these are absolutely required to understand Mimblewimble and Grin, so if you're in a hurry, feel free to jump straight to Putting It All Together .","title":"Some Finer Points"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#change","text":"Let's say you only want to send 2 coins to Carol from the 3 you received from Alice. To do this you would send the remaining 1 coin back to yourself as change. You generate another private key (say 12) as a blinding factor to protect your change output. Carol uses her own private key as before. Change output: 12*G + 1*H Carol's output: 113*G + 2*H What ends up on the blockchain is something very similar to before. And the signature is again built with the excess value, 97 in this example. (12*G + 1*H) + (113*G + 2*H) - (28*G + 3*H) = 97*G + 0*H","title":"Change"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#range-proofs","text":"In all the above calculations, we rely on the transaction values to always be positive. The introduction of negative amounts would be extremely problematic as one could create new funds in every transaction. For example, one could create a transaction with an input of 2 and outputs of 5 and -3 and still obtain a well-balanced transaction. This can't be easily detected because even if x is negative, the corresponding point x*H on the curve looks like any other. To solve this problem, Mimblewimble leverages another cryptographic concept (also coming from Confidential Transactions) called range proofs: a proof that a number falls within a given range, without revealing the number. We won't elaborate on the range proof, but you just need to know that for any r*G + v*H we can build a proof that will show that v is greater than zero and does not overflow. It's also important to note that range proofs for both the blinding factor and the values are needed. The reason for this is that it prevents a censoring attack where a third party would be able to lock UTXOs without knowing their private keys by creating a transaction such as the following: Carol's UTXO: 113*G + 2*H Attacker's output: (113 + 99)*G + 2*H which can be signed by the attacker because Carol's blinding factor cancels out in the equation Y - Xi : Y - Xi = ((113 + 99)*G + 2*H) - (113*G + 2*H) = 99*G This output ( (113 + 99)*G + 2*H ) requires that both the numbers 113 and 99 are known in order to be spent; the attacker would thus have successfully locked Carol's UTXO. The requirement for a range proof for the blinding factor prevents this because the attacker doesn't know the number 113 and thus neither (113 + 99). A more detailed description of range proofs is further detailed in the range proof paper .","title":"Range Proofs"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#putting-it-all-together","text":"A Mimblewimble transaction includes the following: A set of inputs, that reference and spend a set of previous outputs. A set of new outputs that include: A value and a blinding factor (which is just a new private key) multiplied on a curve and summed to be r*G + v*H . A range proof that among other things shows that v is non-negative. An transaction fee in cleartext. A signature whose private key is computed by taking the excess value (the sum of all output values plus the fee, minus the input values).","title":"Putting It All Together"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#blocks-and-chain-state","text":"We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create money and proof of ownership is established through private keys. The Mimblewimble block format builds on this by introducing one additional concept: cut-through . With this addition, a Mimblewimble chain gains: Extremely good scalability, as the great majority of transaction data can be eliminated over time, without compromising security. Further anonymity by mixing and removing transaction data.","title":"Blocks and Chain State"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#transaction-aggregation","text":"Recall that a transaction consists of the following: a set of inputs that reference and spent a set of previous outputs a set of new outputs a transaction kernel consisting of: kernel excess (the public key of the excess value) transaction signature whose public key is the kernel excess A transaction is validated by determining that the kernel excess is a valid public key: (42*G + 1*H) + (99*G + 2*H) - (113*G + 3*H) = 28*G + 0*H The public key in this example is 28*G . We can say the following is true for any valid transaction (ignoring fees for simplicity): sum(outputs) - sum(inputs) = kernel_excess The same holds true for blocks themselves once we realize a block is simply a set of aggregated inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs from it and equating the resulting Pedersen commitment to the sum of the kernel excesses: sum(outputs) - sum(inputs) = sum(kernel_excess) Simplifying slightly, (again ignoring transaction fees) we can say that Mimblewimble blocks can be treated exactly as Mimblewimble transactions.","title":"Transaction Aggregation"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#kernel-offsets","text":"There is a subtle problem with Mimblewimble blocks and transactions as described above. It is possible (and in some cases trivial) to reconstruct the constituent transactions in a block. This is clearly bad for privacy. This is the \"subset\" problem: given a set of inputs, outputs, and transaction kernels a subset of these will recombine to reconstruct a valid transaction. Consider the following two transactions: (in1, in2) -> (out1), (kern1) (in3) -> (out2), (kern2) We can aggregate them into the following block (or aggregate transaction): (in1, in2, in3) -> (out1, out2), (kern1, kern2) It is trivially easy to try all possible permutations to recover one of the transactions (where it successfully sums to zero): (in1, in2) -> (out1), (kern1) We also know that everything remaining can be used to reconstruct the other valid transaction: (in3) -> (out2), (kern2) Remember that the kernel excess r*G simply is the public key of the excess value r . To mitigate this we redefine the kernel excess from r*G to (r-kernel_offset)*G and distribute the kernel offset to be included with every transaction kernel. The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the commitments sum to zero: sum(outputs) - sum(inputs) = r*G = (r-kernel_offset)*G + kernel_offset*G or alternatively sum(outputs) - sum(inputs) = kernel_excess + kernel_offset*G For a commitment r*G + 0*H with the offset a , the transaction is signed with (r-a) and a is published so that r*G can be calculated in order to verify the validity of the transaction. During block construction all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block. The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved. sum(outputs) - sum(inputs) = sum(kernel_excess) + kernel_offset*G","title":"Kernel Offsets"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#cut-through","text":"Blocks let miners assemble multiple transactions into a single set that's added to the chain. In the following block representations, containing 3 transactions, we only show inputs and outputs of transactions. Inputs reference outputs they spend. An output included in a previous block is marked with a lower-case x. I1 ( x1 ) --- O1 |- O2 I2 ( x2 ) --- O3 I3 ( O2 ) -| I4 ( O3 ) --- O4 |- O5 We notice the two following properties: Within this block, some outputs are directly spent by following inputs ( I3 spends O2 and I4 spends O3 ). The structure of each transaction does not actually matter. Since all transactions individually sum to zero, the sum of all transaction inputs and outputs must be zero. Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels ) and that the whole block did not create any coins (other than what's allowed as the mining reward). Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block: I1(x1) | O1 I2(x2) | O4 | O5 Note that all transaction structure has been eliminated and the order of inputs and outputs does not matter anymore. However, the sum of all inputs and outputs is still guaranteed to be zero. A block is simply built from: A block header. The list of inputs remaining after cut-through. The list of outputs remaining after cut-through. A single kernel offset to cover the full block. The transaction kernels containing, for each transaction: The public key r*G obtained from the summation of all inputs and outputs. The signatures generated using the excess value. The mining fee. When structured this way, a Mimblewimble block offers extremely good privacy guarantees: Intermediate (cut-through) transactions will be represented only by their transaction kernels. All outputs look the same: very large numbers that are impossible to meaningfully differentiate from one another. If someone wants to exclude a specific output, they'd have to exclude all. All transaction structure has been removed, making it impossible to tell which inputs and outputs match. And yet, it all still validates!","title":"Cut-through"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#cut-through-all-the-way","text":"Going back to the previous example block, outputs x1 and x2 , spent by I1 and I2 , must have appeared previously in the blockchain. So after the addition of this block, those outputs as well as I1 and I2 can also be removed from the blockchain as they now are intermediate transactions. We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information: The total amount of coins created by mining in the chain. The complete set of unspent outputs. The transactions kernels for each transaction. The first piece of information can be deduced just using the block height. Both the UTXOs and the transaction kernels are extremely compact. This has two important consequences: The blockchain a node needs to maintain is very small (on the order of a few gigabytes for a bitcoin-sized blockchain, and potentially optimizable to a few hundreds of megabytes). When a new node joins the network the amount of information that needs to be transferred is very small. In addition, the UTXO set cannot be tampered with. Adding or removing even one input or output would change the sum of the transactions to be something other than zero.","title":"Cut-through All The Way"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#conclusion","text":"In this document we covered the basic principles that underlie a Mimblewimble blockchain. By using the addition properties of Elliptic Curve Cryptography, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers.","title":"Conclusion"},{"location":"wiki/introduction/grin-for-bitcoiners/","text":"Grin for Bitcoiners Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . Privacy and Fungibility There are 3 main properties of Grin transactions that make them private: There are no addresses. There are no amounts. 2 transactions, one spending the other, can be merged in a block to form only one, removing all intermediary information. The 2 first properties mean that all transactions are indistinguishable from one another. Unless you directly participated in the transaction, all inputs and outputs look like random pieces of data (in lingo, they're all random curve points). Moreover, there are no more transactions in a block. A Grin block looks just like one giant transaction and all original association between inputs and outputs is lost. Scalability As explained in the previous section, thanks to the Mimblewimble transaction and block format we can merge transactions when an output is directly spent by the input of another. It's as if when Alice gives money to Bob, and then Bob gives it all to Carol, Bob was never involved and his transaction is actually never even seen on the blockchain. Pushing that further, between blocks, most outputs end up being spent sooner or later by another input. So all spent outputs can be safely removed . And the whole blockchain can be stored, downloaded and fully verified in just a few gigabytes or less (assuming a number of transactions similar to bitcoin). This means that the Grin blockchain scales with the number of users (unspent outputs), not the number of transactions. At the moment, there is one caveat to that: a small piece of data (called a kernel , about 100 bytes) needs to stay around for each transaction. But we're working on optimizing that as well. Scripting Maybe you've heard that Mimblewimble doesn't support scripts. And in some way, that's true. But thanks to cryptographic trickery , many contracts that in Bitcoin would require a script can be achieved with Grin using properties of Elliptic Curve Cryptography. So far, we know how to do: Multi-signature transactions. Atomic swaps. Time-locked transactions and outputs. Lightning Network Emission Rate Bitcoin's 10 minute block time has its initial 50 btc reward cut in half every 4 years until there are 21 million bitcoin in circulation. Grin's emission rate is linear, meaning it never drops. The block reward is currently set at 60 grin with a block goal of 60 seconds. This still works because 1) dilution trends toward zero and 2) a non-negligible amount of coins gets lost or destroyed every year. FAQ Wait, what!? No address? Nope, no address. All outputs in Grin are unique and have no common data with any previous output. Instead of relying on a known address to send money, transactions have to be built interactively, with two (or more) wallets exchanging data with one another. This interaction does not require both parties to be online at the same time . Practically speaking, there are many ways for two programs to interact privately and securely. This interaction could even take place over email or Signal (or carrier pigeons). If transaction information gets removed, can I just cheat and create money? No, and this is where Mimblewimble and Grin shine. Confidential transactions are a form of homomorphic encryption . Without revealing any amount, Grin can verify that the sum of all transaction inputs equal the sum of transaction outputs, plus the fee. Going even further, comparing the sum of all money created by mining with the total sum of money that's being held, Grin nodes can check the correctness of the total money supply. If I listen to transaction relay, can't I just figure out who they belong to before being cut-through? You can figure out which outputs are being spent by which transaction, but the trail of data stops here. All inputs and outputs look like random pieces of data, so you can't tell if the money was transferred, still belongs to the same person, which output is the actual transfer and which is the change, etc. Grin transactions are built with no identifiable piece of information . In addition, Grin leverages Dandelion relay , which provides additional anonymity as to which IP or client the transaction originated from, and allows for transactions to be aggregated. What about the quantum computaggedon? In every Grin output, we also include a bit of hashed data, which is quantum safe. If quantum computing was to become a reality, we can safely introduce additional verification that would protect existing coins from being hacked. How does all this magic work? Click Next down below.","title":"Grin for Bitcoiners"},{"location":"wiki/introduction/grin-for-bitcoiners/#grin-for-bitcoiners","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 .","title":"Grin for Bitcoiners"},{"location":"wiki/introduction/grin-for-bitcoiners/#privacy-and-fungibility","text":"There are 3 main properties of Grin transactions that make them private: There are no addresses. There are no amounts. 2 transactions, one spending the other, can be merged in a block to form only one, removing all intermediary information. The 2 first properties mean that all transactions are indistinguishable from one another. Unless you directly participated in the transaction, all inputs and outputs look like random pieces of data (in lingo, they're all random curve points). Moreover, there are no more transactions in a block. A Grin block looks just like one giant transaction and all original association between inputs and outputs is lost.","title":"Privacy and Fungibility"},{"location":"wiki/introduction/grin-for-bitcoiners/#scalability","text":"As explained in the previous section, thanks to the Mimblewimble transaction and block format we can merge transactions when an output is directly spent by the input of another. It's as if when Alice gives money to Bob, and then Bob gives it all to Carol, Bob was never involved and his transaction is actually never even seen on the blockchain. Pushing that further, between blocks, most outputs end up being spent sooner or later by another input. So all spent outputs can be safely removed . And the whole blockchain can be stored, downloaded and fully verified in just a few gigabytes or less (assuming a number of transactions similar to bitcoin). This means that the Grin blockchain scales with the number of users (unspent outputs), not the number of transactions. At the moment, there is one caveat to that: a small piece of data (called a kernel , about 100 bytes) needs to stay around for each transaction. But we're working on optimizing that as well.","title":"Scalability"},{"location":"wiki/introduction/grin-for-bitcoiners/#scripting","text":"Maybe you've heard that Mimblewimble doesn't support scripts. And in some way, that's true. But thanks to cryptographic trickery , many contracts that in Bitcoin would require a script can be achieved with Grin using properties of Elliptic Curve Cryptography. So far, we know how to do: Multi-signature transactions. Atomic swaps. Time-locked transactions and outputs. Lightning Network","title":"Scripting"},{"location":"wiki/introduction/grin-for-bitcoiners/#emission-rate","text":"Bitcoin's 10 minute block time has its initial 50 btc reward cut in half every 4 years until there are 21 million bitcoin in circulation. Grin's emission rate is linear, meaning it never drops. The block reward is currently set at 60 grin with a block goal of 60 seconds. This still works because 1) dilution trends toward zero and 2) a non-negligible amount of coins gets lost or destroyed every year.","title":"Emission Rate"},{"location":"wiki/introduction/grin-for-bitcoiners/#faq","text":"","title":"FAQ"},{"location":"wiki/introduction/grin-for-bitcoiners/#wait-what-no-address","text":"Nope, no address. All outputs in Grin are unique and have no common data with any previous output. Instead of relying on a known address to send money, transactions have to be built interactively, with two (or more) wallets exchanging data with one another. This interaction does not require both parties to be online at the same time . Practically speaking, there are many ways for two programs to interact privately and securely. This interaction could even take place over email or Signal (or carrier pigeons).","title":"Wait, what!? No address?"},{"location":"wiki/introduction/grin-for-bitcoiners/#if-transaction-information-gets-removed-can-i-just-cheat-and-create-money","text":"No, and this is where Mimblewimble and Grin shine. Confidential transactions are a form of homomorphic encryption . Without revealing any amount, Grin can verify that the sum of all transaction inputs equal the sum of transaction outputs, plus the fee. Going even further, comparing the sum of all money created by mining with the total sum of money that's being held, Grin nodes can check the correctness of the total money supply.","title":"If transaction information gets removed, can I just cheat and create money?"},{"location":"wiki/introduction/grin-for-bitcoiners/#if-i-listen-to-transaction-relay-cant-i-just-figure-out-who-they-belong-to-before-being-cut-through","text":"You can figure out which outputs are being spent by which transaction, but the trail of data stops here. All inputs and outputs look like random pieces of data, so you can't tell if the money was transferred, still belongs to the same person, which output is the actual transfer and which is the change, etc. Grin transactions are built with no identifiable piece of information . In addition, Grin leverages Dandelion relay , which provides additional anonymity as to which IP or client the transaction originated from, and allows for transactions to be aggregated.","title":"If I listen to transaction relay, can't I just figure out who they belong to before being cut-through?"},{"location":"wiki/introduction/grin-for-bitcoiners/#what-about-the-quantum-computaggedon","text":"In every Grin output, we also include a bit of hashed data, which is quantum safe. If quantum computing was to become a reality, we can safely introduce additional verification that would protect existing coins from being hacked.","title":"What about the quantum computaggedon?"},{"location":"wiki/introduction/grin-for-bitcoiners/#how-does-all-this-magic-work","text":"Click Next down below.","title":"How does all this magic work?"},{"location":"wiki/introduction/mimblewimble/commitments/","text":"Commitments In cryptography a Commitment (or commitment scheme) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public). The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person. They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \"committed\" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing. They have two important properties: Hiding - Nobody but the committer can see or infer the actual value behind the commitment. Binding - The committer can't change the value after the commitment is published. ECC can be used to create a commitment. Let\u2019s say we want to commit to the value 8 . commit (8) -> 8*G To everybody else, our commitment 8*G just looks like a random point, and we publish it. Some time later we reveal our value. reveal 8 And now any observer could multiply our stated value 8, by the public point G and verify that their result is equal to the commitment we published ealier. verify (8, commitment) == 8*G ? --> True/False However, there\u2019s a major issue. If our value is within a small range, which is typically the case, it\u2019s simple for anybody to find out what value we committed to, even if we don\u2019t reveal it; By trying out (brute-forcing) different values, they can find the one value that, when multiplied by G , matches the original commitment. Example Say we're betting on how many goals a team would score by the end of the year. Our guess is 23, and we commit to it by publishing the commitment 23*G . Problem is, it would be trivial for anybody to uncover our guess simply by trying to commit to 1, 2, 3, 4 etc and checking each result if it's equal to our commitment. In this case, our value will be revealed after only 23 simple steps. What\u2019s the solution? Blinding Factor The issue is solved by adding a blinding factor r, which is a random 256-bit integer (range 0 to 2^256, same as a typical private key) used to blind the value so that it can\u2019t be guessed and uncovered. We could try adding the blinding factor by comitting (8+r)*G and then revealing 8 and r . But, doing so breaks the binding property of the commitment, because instead of revealing value 8 and blinding factor r , we could reveal 7 and r+1 or any other value. Therefore, we require a different method to include r . Pedersen Commitments Introducing G \u2019s twin, H . H is another generator point, distinct from G (note how it\u2019s the next letter in the alphabet). Both are nothing-up-my-sleeve-points, meaning nobody knows n such that n*G = H . Using H we can blind the value while keeping the commitment binding. r*G + v*H This specific form of commitement is called a Pedersen Commitment. A Mimblewimble output is just a Pedersen Commitment , as we\u2019ll soon see. Its values are as follows: r is the blinding factor, and r*G is the public key point for r (using G as generator point). v is the value committed, and v*H is the public key point for v (using H as generator point). Homomorphic Commitments Commitments with homomorphic properties means you can perform calculations on encrypted values without decrypting them first. The result of the computation is a commitment which is identical to the result if the operations had been performed on the unencrypted values. They allow us to do as follows: commit (x) \u21d2 C 1 commit (y) \u21d2 C 2 commit (x+y) \u21d2 Z = C 1 + C 2 f we add two commitments to each other, the result would be an entirely new, valid commitment, which actually commits to the value x + y . So we\u2019re able to perform a math operation (addition) unto encrypted data (commitments) while keeping the underlying values \u201cintact\u201d. Elliptic curve commitments indeed have these homomorphic properties. We can do the following: x*G + y*G => (x + y)*G Notice how we add two different curve points and the result is a different point, which is a commitment to the sum of the values we\u2019re hiding. Similarly, we can add up two Pedersen Commitments. First let's create two of them: C 1 = r 1 G + v 1 H C 2 = r 2 G + v 2 H The point Z (remember a commitment is simply a point on the curve) is the result of addition between points C 1 and C 2 . Z = C1 + C2 Z = r1*G + r2*G + v1*H + v2*H So we can calculate what Z is: Z = (r1 + r2)*G + (v1 + v2)*H Hence point Z is a pedersen commitment that is the sum of commitments C 1 and C 2 . This is the foundation for the Elliptic-curve algebra used in Mimblewimble to prove both ownership of outputs (coins) and non-inflation. Finessing commitments \u21a9","title":"Commitments"},{"location":"wiki/introduction/mimblewimble/commitments/#commitments","text":"In cryptography a Commitment (or commitment scheme) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public). The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person. They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \"committed\" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing. They have two important properties: Hiding - Nobody but the committer can see or infer the actual value behind the commitment. Binding - The committer can't change the value after the commitment is published. ECC can be used to create a commitment. Let\u2019s say we want to commit to the value 8 . commit (8) -> 8*G To everybody else, our commitment 8*G just looks like a random point, and we publish it. Some time later we reveal our value. reveal 8 And now any observer could multiply our stated value 8, by the public point G and verify that their result is equal to the commitment we published ealier. verify (8, commitment) == 8*G ? --> True/False However, there\u2019s a major issue. If our value is within a small range, which is typically the case, it\u2019s simple for anybody to find out what value we committed to, even if we don\u2019t reveal it; By trying out (brute-forcing) different values, they can find the one value that, when multiplied by G , matches the original commitment. Example Say we're betting on how many goals a team would score by the end of the year. Our guess is 23, and we commit to it by publishing the commitment 23*G . Problem is, it would be trivial for anybody to uncover our guess simply by trying to commit to 1, 2, 3, 4 etc and checking each result if it's equal to our commitment. In this case, our value will be revealed after only 23 simple steps. What\u2019s the solution?","title":"Commitments"},{"location":"wiki/introduction/mimblewimble/commitments/#blinding-factor","text":"The issue is solved by adding a blinding factor r, which is a random 256-bit integer (range 0 to 2^256, same as a typical private key) used to blind the value so that it can\u2019t be guessed and uncovered. We could try adding the blinding factor by comitting (8+r)*G and then revealing 8 and r . But, doing so breaks the binding property of the commitment, because instead of revealing value 8 and blinding factor r , we could reveal 7 and r+1 or any other value. Therefore, we require a different method to include r .","title":"Blinding Factor"},{"location":"wiki/introduction/mimblewimble/commitments/#pedersen-commitments","text":"Introducing G \u2019s twin, H . H is another generator point, distinct from G (note how it\u2019s the next letter in the alphabet). Both are nothing-up-my-sleeve-points, meaning nobody knows n such that n*G = H . Using H we can blind the value while keeping the commitment binding. r*G + v*H This specific form of commitement is called a Pedersen Commitment. A Mimblewimble output is just a Pedersen Commitment , as we\u2019ll soon see. Its values are as follows: r is the blinding factor, and r*G is the public key point for r (using G as generator point). v is the value committed, and v*H is the public key point for v (using H as generator point).","title":"Pedersen Commitments"},{"location":"wiki/introduction/mimblewimble/commitments/#homomorphic-commitments","text":"Commitments with homomorphic properties means you can perform calculations on encrypted values without decrypting them first. The result of the computation is a commitment which is identical to the result if the operations had been performed on the unencrypted values. They allow us to do as follows: commit (x) \u21d2 C 1 commit (y) \u21d2 C 2 commit (x+y) \u21d2 Z = C 1 + C 2 f we add two commitments to each other, the result would be an entirely new, valid commitment, which actually commits to the value x + y . So we\u2019re able to perform a math operation (addition) unto encrypted data (commitments) while keeping the underlying values \u201cintact\u201d. Elliptic curve commitments indeed have these homomorphic properties. We can do the following: x*G + y*G => (x + y)*G Notice how we add two different curve points and the result is a different point, which is a commitment to the sum of the values we\u2019re hiding. Similarly, we can add up two Pedersen Commitments. First let's create two of them: C 1 = r 1 G + v 1 H C 2 = r 2 G + v 2 H The point Z (remember a commitment is simply a point on the curve) is the result of addition between points C 1 and C 2 . Z = C1 + C2 Z = r1*G + r2*G + v1*H + v2*H So we can calculate what Z is: Z = (r1 + r2)*G + (v1 + v2)*H Hence point Z is a pedersen commitment that is the sum of commitments C 1 and C 2 . This is the foundation for the Elliptic-curve algebra used in Mimblewimble to prove both ownership of outputs (coins) and non-inflation. Finessing commitments \u21a9","title":"Homomorphic Commitments"},{"location":"wiki/introduction/mimblewimble/ecc/","text":"Preface The following three-part series is intended for those who wish to understand what goes on inside Mimblewimble and Grin. We try to make this objective more accessible by going through the cryptographic primitives required to know first, without diving into proofs and specifics. Once those are in order, we connect everything explain how Mimblewimble works. Elliptic Curves Commitments Mimblewimble For the original introduction (along with many translations), refer to here . Elliptic Curve Cryptography Mimblewimble relies entirely on Elliptic-curve cryptography (ECC), an approach to public-key cryptography. Put simply, given an algebraic curve of the form y^2 = x^3 + ax + b , pairs of private and public keys can be derived. Picking a private key and computing its correspnding public key is trivial, but the reverse operation public key -> private key is called the discrete logarithm problem , and is considered to be computationally infeasible. Let's review the basics. Operations These are the relevant mathematical operations we can do on Elliptic-curve points. Addition - Given two points, we can add them to one another (or subtract) and the result would be a new point on the curve. Multiplication - Given a point, we can multiply it any number of times. Addition Given three aligned points P , Q and R , their sum is always 0. We treat this as an inherent property of elliptic curves. P + Q + R = 0 We can then write it as: P + Q = -R So that adding the two points P and Q results in -R, the inverse of R. If we draw a line passing through P and Q, this line will cross a third point on the curve, R (so that P, Q and R are aligned). If we take the inverse of this point, which is simply the one symmetric to it about the x-axis, we have found the result of adding two curve points, P + Q. Let\u2019s illustrate: In other words, addition of points is basically hopping around on the curve to a different, seemingly random point; It looks random unless you know the exact operation performed to reach it. Multiplication We can\u2019t multiply a point by another point, but we can multiply a point by a number (scalar). Multiplying point P by scalar k would simply require adding point P onto it self k times. This operation is easily demonstrated by assigning k=2 so that k*P = P+P . To illustrate how it would look like on the curve, we draw a tangent line. You can imagine that the line intersects three points, whereas two of them are P , such that: P + P = -R To calculate 8*P for e.g. wouldn\u2019t take 8 operations, but only 3; you can find 2*P , then add it onto itself, and then add 4*P onto itself, for the final result of 8*P . Key Pairs An ECC system defines a publicly known constant curve point called the generator point, G . The generator point is used to compute any public key. A key pair consists of: Private key k \u2013 A randomly chosen 256-bit integer (scalar). Public key P \u2013 An Elliptic-curve point derived by multiplying generator point G by the private key. And more clearly, a public key (of private key k ) is as follows: P = k*G This is easy to compute. But, if everybody knows points P and G, can they find out what k is? The answer is no; The difficulty of getting from one point to another is precisely the definition of the Elliptic curve discrete logarithm problem. Secp256k1 The specific Elliptic curve that Grin employs is rust-secp256k1 (y 2 = x 3 + 7) using Schnorr signature scheme. Elliptic Curve Cryptography: a gentle introduction \u21a9 A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography \u21a9 Cryptography: From Mathematical Magic to Secure Communication \u21a9","title":"Elliptic Curves"},{"location":"wiki/introduction/mimblewimble/ecc/#elliptic-curve-cryptography","text":"Mimblewimble relies entirely on Elliptic-curve cryptography (ECC), an approach to public-key cryptography. Put simply, given an algebraic curve of the form y^2 = x^3 + ax + b , pairs of private and public keys can be derived. Picking a private key and computing its correspnding public key is trivial, but the reverse operation public key -> private key is called the discrete logarithm problem , and is considered to be computationally infeasible. Let's review the basics.","title":"Elliptic Curve Cryptography"},{"location":"wiki/introduction/mimblewimble/ecc/#operations","text":"These are the relevant mathematical operations we can do on Elliptic-curve points. Addition - Given two points, we can add them to one another (or subtract) and the result would be a new point on the curve. Multiplication - Given a point, we can multiply it any number of times.","title":"Operations"},{"location":"wiki/introduction/mimblewimble/ecc/#addition","text":"Given three aligned points P , Q and R , their sum is always 0. We treat this as an inherent property of elliptic curves. P + Q + R = 0 We can then write it as: P + Q = -R So that adding the two points P and Q results in -R, the inverse of R. If we draw a line passing through P and Q, this line will cross a third point on the curve, R (so that P, Q and R are aligned). If we take the inverse of this point, which is simply the one symmetric to it about the x-axis, we have found the result of adding two curve points, P + Q. Let\u2019s illustrate: In other words, addition of points is basically hopping around on the curve to a different, seemingly random point; It looks random unless you know the exact operation performed to reach it.","title":"Addition"},{"location":"wiki/introduction/mimblewimble/ecc/#multiplication","text":"We can\u2019t multiply a point by another point, but we can multiply a point by a number (scalar). Multiplying point P by scalar k would simply require adding point P onto it self k times. This operation is easily demonstrated by assigning k=2 so that k*P = P+P . To illustrate how it would look like on the curve, we draw a tangent line. You can imagine that the line intersects three points, whereas two of them are P , such that: P + P = -R To calculate 8*P for e.g. wouldn\u2019t take 8 operations, but only 3; you can find 2*P , then add it onto itself, and then add 4*P onto itself, for the final result of 8*P .","title":"Multiplication"},{"location":"wiki/introduction/mimblewimble/ecc/#key-pairs","text":"An ECC system defines a publicly known constant curve point called the generator point, G . The generator point is used to compute any public key. A key pair consists of: Private key k \u2013 A randomly chosen 256-bit integer (scalar). Public key P \u2013 An Elliptic-curve point derived by multiplying generator point G by the private key. And more clearly, a public key (of private key k ) is as follows: P = k*G This is easy to compute. But, if everybody knows points P and G, can they find out what k is? The answer is no; The difficulty of getting from one point to another is precisely the definition of the Elliptic curve discrete logarithm problem. Secp256k1 The specific Elliptic curve that Grin employs is rust-secp256k1 (y 2 = x 3 + 7) using Schnorr signature scheme. Elliptic Curve Cryptography: a gentle introduction \u21a9 A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography \u21a9 Cryptography: From Mathematical Magic to Secure Communication \u21a9","title":"Key Pairs"},{"location":"wiki/introduction/mimblewimble/mimblewimble/","text":"Mimblewimble For the original introduction (along with many translations), refer to here . Earlier we demonstrated how a public key obtained from the addition of two private keys r and v , resulting in public key (v+r)*G , is identical to the addition of the public keys of each individual private key, r*G + v*G . Mimblewimble and Grin heavily rely on this principle. Transactions Every transaction has to prove two basic things: Zero sum - The sum of outputs minus inputs should always equal zero, proving that a transaction did not create new coins, without revealing the actual amounts. Possession of private keys - ownership of outputs is guaranteed by the possession of ECC private keys. However, the proof that an entity owns those private keys is not achieved by directly signing the transaction, as with most other cryptocurrencies. Going next, we'll examine how those two fundemental properties are achieved. Amounts Building upon the ECC princple described above, we can obscure the values in a transaction. If v is the amount value of an input or output and H is a generator point on the elliptic curve, we can simply embed v*H instead of v in a transaction. This works because using the ECC operations, we can validate that the sum of values in outputs, equals to the sum of values in inputs. If we subtract those sums (outputs minus inputs), the result would be 0. transaction Hidden Inputs Outputs v 1 H v 2 H v 3 H Transparent Inputs Outputs v 1 v 2 v 3 v3*H + v2*H - v1*H = (v3 + v2 - v1)*H = 0*H = 0 Recall that an input is just a reference to a past output being spent, so each input is practically an output. Verifying this property on every transaction allows the protocol to confirm that a transaction doesn't create money out of thin air, without knowing what the actual values are. However, we encounter a familiar issue; There are a finite number of usable values (amounts) and one could try every single one of them to guess the value of the transaction. Blinding Factor We introduce a blinding factor r , also used as a private key (explained later). Along with it we use a second generator point, G , on the same elliptic curve. Then, an output is expressed as: r*G + v*H r is both a blinding factor and a private key, and its public key is r*G (using G as a generator point). v is the value of an output, and its public key is v*H (using H as a generator point). The form of a Mimblewimble output is a Pedersen Commitment. Neither v nor r can be deduced, but the commiter can prove knowledge of them. We include r to obtain the following transaction. transaction Inputs Outputs r 1 G + v 1 H r 2 G + v 2 H r 3 G + v 3 H (r2*G + v2*H) + (r3*G + v3*H) - (r1*G + v1*H) = (r2 + r3 - r1)*G + 0*H Ownership In the previous section we introduced a blinding factor to obscure the transaction's values. Another insight of Mimblewimble is that this blinding factor can be leveraged to prove ownership of the value, serving also as a private key to an output. Let's illustrate this using an example: Alice sends 3 coins to Bob , and to obscure the amount, Bob chooses 28 as his blinding factor (in practice it's an extremely large number). The following output appears on the blockchain and is only spendable by Bob. X = 28*G + 3*H X is a commitment visible by everyone. The value 3 is only known to Bob and Alice, while 28 is only known to Bob. To transfer those 3 coins again, the protocol requires 28 to be known. Let's say Bob wants to send the 3 coins to Carol . He needs to build a simple transaction where Xi is his input, and Y is Carol's new output. For the transaction to be valid, proving no new coins were created, subtracting the input from the output should result in 0. Y - Xi = 0*G + 0*H = 0 If we want this transaction to sum to 0, it would look like this: Inputs Outputs 28*G + 3*H 28*G + 3*H Remember that a blinding factor also acts as a private key. But wait. We just introduced a major problem. Bob knows Carol's new blinding factor, so he can spend her output and steal it. To solve this, Carol chooses her own blinding factor, 114 . The transaction on the blockchain would then look like this: transaction Inputs Outputs 28*G + 3*H 114*G + 3*H Y - Xi = (114*G + 3*H) - (28*G + 3*H) = 86*G + 0*H Now the transaction no longer sums to zero and we have an excess value 86 . The excess value of a transaction is the sum of all outputs blinding factors, minus the sum of all inputs blinding factors, r o - r i . In this case, simply 114-28 = 86 . Then how does the protocol verify that values equal to 0? The transaction is only legitimate if Y - Xi is a valid public key for generator point G; which is the case only if Y - Xi = r*G + 0*H . In other words, if the values don't sum to 0, the result is recognized as an invalid public key for G. This can be verified by requiring the transactors to build a (schnorr) signature together, signing excess value 86 . This ensures that: The transacting parties can collectively produce the excess value (it is the private key of their joint signature). The sum of the outputs minus the inputs is 0, because only a valid public key for G will check out against the signature. This signature, along with a commitment to the excess value (86*G, which serves as a public key to verify the signature), is called a transcation kernel. Change Let's say Bob wants to send only 2 of his coins to Carol. To do this he would send the remaining 1 coin back to back to himself, by creating an output he controls. Bob generates a private key 13 as a blinding factor for his change output. Carol uses the same private key as before. transaction with change Inputs Outputs 28*G + 3*H 114*G + 2*H 13*G + 1*H (114*G + 2*H) + (13*G + 1*H) - (28*G + 3*H) = 99*G + 0*H The joint signature is again built with the excess value, 99 in this example. Rangeproofs Previously, we assumed output values to always be positive. However, by introducing negative amounts, a transcation could be balanced out, for example, with an input of 2 and outputs of 5 and -3 . This can't be detected as the values would still equal to zero. A rangeproof is therefore attached to every output and proves that its value isn't negative and that its size is restricted so it doesn't overflow. We won't elaborate on this here. Putting it all together A Mimblewimble transaction includes the following: full transaction Inputs Outputs 28*G + 3*H Rangeproof 114*G + 2*H Rangeproof 13*G + 1*H Rangeproof Kernel : TX fee Kernel excess Signature Set of inputs, that reference and spend a set of previous outputs. Set of new outputs where each includes: Value and a blinding factor (a new private key), both multiplied on a curve and summed up to r*G + v*H . Rangeproof that, among other things, shows that v is non-negative. Kernel consisting of: Transaction fee in plain text. Kernel excess, which is the public key corresponding to the excess value (computed by sum of outputs + fee - sum of inputs ) Transaction signature signed by the excess value as private key (and verifies with the kernel excess). Blocks and chain We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create new money and proof of ownership is established through private keys. The Mimblewimble block format builds on this by introducing two additional concepts: Aggregation and cut-through. With these additions, a Mimblewimble chain gains: Further anonymity by mixing and removing transaction data. Extremely good scalability, as the great majority of transaction data can be eliminated over time, without compromising security. Transaction aggregation While the kernel excess of a transaction can be computed by anyone, there's major benefit in including it in every transaction's kernel, as it allows for aggregation within blocks. The following is true for any valid transcation (ignoring fees): transaction: sum(outputs) - sum(inputs) = kernel_excess Note that we refer here to the complete pedersen commitments, not just their blinding factors (which would result in excess_value instead of kernel_excess ). The same holds true for entire blocks of transactions, if we realize a block is simply an extended set of inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs, and the result would be a commitment equal to the sum of the kernel excesses. block: sum(outputs) - sum(inputs) = sum(kernel_excess) Simplifying slightly (ignoring transaction fees), we can see how a Mimblewimble block can be treated exactly as single transaction. Similarly, transactions could be aggregated before block construction and thus enter the mempool at an already aggregated state. The Dandelion stem phase does so automatically when possible, and it could also be done manually and potentially through different aggregation services. Kernel offsets There is a subtle problem with Mimblewimble blocks and transactions as described above, that needs to be addressed. Given a set of inputs, outputs and transaction kernels, a subset of these will combine to reconstruct a valid transaction. Consider the two following transcations: 1 2 (in1, in2) -> (out1) | (kern1) (in3) -> (out2, out3) | (kern2) We can aggregate them into a block (simply another transcation): aggregated block/transaction Inputs Outputs Kernels in1 out1 kern1 in2 out2 kern2 in3 out3 Initially it seems that the two original transactions are indistinguishable from one another within the new transaction. However, it is trivial to try all possible combinations of inputs/outputs, and find the way in which they succesfully sum to one of the kernel excesses, such that in our example: (in1, in2) - (out1) = (excess_kern1) (in3) - (out2 + out3) = (excess_kern2) We're able to easily uncover the original form of both transactions. Then how do we solve this? Remember that the kernel excess r*G is simply the public key of the excess value r . To address this issue we introduce a kernel offset and redefine a transaction's kernel excess from r*G to (r-kernel_offset)*G . The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the sum of the commitments is valid: sum(outputs) - sum(inputs) + (kernel_offset)*G = (r + kernel_offset)*G If the sum of a transaction's inputs and outputs is the commitment r*G + 0*H , the transactors generate offset a and the transaction is signed with (r-a) instead of r . But, r*G could still be computed to verify the validity of the transaction because given the new form of kernel excess (r-a)*G and the offset a . The verifier computes a*G and calculates: `kernel_excess + kernel_offset*G = sum(blinding_factors) Translated to: (r-a)*G + a*G = r*G Given r*G the transaction can then be validated. During aggregation, all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block (or aggregated transaction). The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved. Cut-through Blocks let miners assemble multiple transactions into a single set that's added to the chain. Inputs reference outputs they spend, which are shown as in(output_spent) in the following example. non-cut-through block Inputs Outputs in1(prev_out) out1 out2 in2(prev_out) out3 in3(out2) in4(out3) out4 out5 We notice the two following properties: Within this block, some outputs are immediately spent by following inputs (e.g. in3 spends out2). The structure of each transaction does not actually matter. Since all transaction values individually sum to zero, then the collective sum of all inputs and outputs must be zero. Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels) and that the whole block did not create any coins, other than what's allowed as the mining reward. Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block: cut-through block Inputs Outputs in1(prev_out) out1 in2(prev_out) out4 out5 All transaction structure has been eliminated and the order of inputs and outputs does not matter anymore, while the sum of all inputs and outputs values is still guaranteed to be zero. A block is simply built from: Block header. Set of inputs remaining after cut-through. Set of outputs remaining after cut-through. A single kernel offset (sum of all kernel offsets) to cover the full block. The transaction kernels containing, for each transaction: The public key (r-a)*G , which is the (modified) kernel excess. The signatures generated using the (modified) excess value (r-a) as the signing private key. Mining fee. The block contents satisfy: sum(outputs) - sum(inputs) = sum(kernel_excess) + sum(kernel_offset)*G = (r-a)*G + a*G And it all still validates. Cut-through everything Going back to the previous example block, outputs prev_out1, prev_out2 , which were spent by in01, in02 respectively, must have appeared previously in the blockchain. After the addition of this new block, those past outputs as well as in01, in02 can also be removed from the blockchain as they now are intermediate transactions. The blocks they were originally included in would still remain valid after their removal. All that needs to remain is the set of currently unspent outputs out01, out02, out05 . We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information: The total amount of coins created by mining in the chain. The complete set of unspent outputs. The transactions kernels for each transaction. The extension of this idea is that all the way from the genesis block to the latest block, every input is deleted along with its referenced output. Both the set of unspent outputs (UTXO) and transaction kernels are extremely compact. This has important consequences; The blockchain a node needs to maintain is very small, as well as the amount of information transferred when a new node joins the network. Conclusion We covered the basic principles that underlie Mimblewimble. By using addition of elliptic curve points, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers. Further reading on how transactions are constructed: Grin Transactions Explained, Step-by-Step What\u2019s inside a Grin Transaction File?","title":"Mimblewimble"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#mimblewimble","text":"For the original introduction (along with many translations), refer to here . Earlier we demonstrated how a public key obtained from the addition of two private keys r and v , resulting in public key (v+r)*G , is identical to the addition of the public keys of each individual private key, r*G + v*G . Mimblewimble and Grin heavily rely on this principle.","title":"Mimblewimble"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#transactions","text":"Every transaction has to prove two basic things: Zero sum - The sum of outputs minus inputs should always equal zero, proving that a transaction did not create new coins, without revealing the actual amounts. Possession of private keys - ownership of outputs is guaranteed by the possession of ECC private keys. However, the proof that an entity owns those private keys is not achieved by directly signing the transaction, as with most other cryptocurrencies. Going next, we'll examine how those two fundemental properties are achieved.","title":"Transactions"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#amounts","text":"Building upon the ECC princple described above, we can obscure the values in a transaction. If v is the amount value of an input or output and H is a generator point on the elliptic curve, we can simply embed v*H instead of v in a transaction. This works because using the ECC operations, we can validate that the sum of values in outputs, equals to the sum of values in inputs. If we subtract those sums (outputs minus inputs), the result would be 0. transaction Hidden Inputs Outputs v 1 H v 2 H v 3 H Transparent Inputs Outputs v 1 v 2 v 3 v3*H + v2*H - v1*H = (v3 + v2 - v1)*H = 0*H = 0 Recall that an input is just a reference to a past output being spent, so each input is practically an output. Verifying this property on every transaction allows the protocol to confirm that a transaction doesn't create money out of thin air, without knowing what the actual values are. However, we encounter a familiar issue; There are a finite number of usable values (amounts) and one could try every single one of them to guess the value of the transaction.","title":"Amounts"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#blinding-factor","text":"We introduce a blinding factor r , also used as a private key (explained later). Along with it we use a second generator point, G , on the same elliptic curve. Then, an output is expressed as: r*G + v*H r is both a blinding factor and a private key, and its public key is r*G (using G as a generator point). v is the value of an output, and its public key is v*H (using H as a generator point). The form of a Mimblewimble output is a Pedersen Commitment. Neither v nor r can be deduced, but the commiter can prove knowledge of them. We include r to obtain the following transaction. transaction Inputs Outputs r 1 G + v 1 H r 2 G + v 2 H r 3 G + v 3 H (r2*G + v2*H) + (r3*G + v3*H) - (r1*G + v1*H) = (r2 + r3 - r1)*G + 0*H","title":"Blinding Factor"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#ownership","text":"In the previous section we introduced a blinding factor to obscure the transaction's values. Another insight of Mimblewimble is that this blinding factor can be leveraged to prove ownership of the value, serving also as a private key to an output. Let's illustrate this using an example: Alice sends 3 coins to Bob , and to obscure the amount, Bob chooses 28 as his blinding factor (in practice it's an extremely large number). The following output appears on the blockchain and is only spendable by Bob. X = 28*G + 3*H X is a commitment visible by everyone. The value 3 is only known to Bob and Alice, while 28 is only known to Bob. To transfer those 3 coins again, the protocol requires 28 to be known. Let's say Bob wants to send the 3 coins to Carol . He needs to build a simple transaction where Xi is his input, and Y is Carol's new output. For the transaction to be valid, proving no new coins were created, subtracting the input from the output should result in 0. Y - Xi = 0*G + 0*H = 0 If we want this transaction to sum to 0, it would look like this: Inputs Outputs 28*G + 3*H 28*G + 3*H Remember that a blinding factor also acts as a private key. But wait. We just introduced a major problem. Bob knows Carol's new blinding factor, so he can spend her output and steal it. To solve this, Carol chooses her own blinding factor, 114 . The transaction on the blockchain would then look like this: transaction Inputs Outputs 28*G + 3*H 114*G + 3*H Y - Xi = (114*G + 3*H) - (28*G + 3*H) = 86*G + 0*H Now the transaction no longer sums to zero and we have an excess value 86 . The excess value of a transaction is the sum of all outputs blinding factors, minus the sum of all inputs blinding factors, r o - r i . In this case, simply 114-28 = 86 . Then how does the protocol verify that values equal to 0? The transaction is only legitimate if Y - Xi is a valid public key for generator point G; which is the case only if Y - Xi = r*G + 0*H . In other words, if the values don't sum to 0, the result is recognized as an invalid public key for G. This can be verified by requiring the transactors to build a (schnorr) signature together, signing excess value 86 . This ensures that: The transacting parties can collectively produce the excess value (it is the private key of their joint signature). The sum of the outputs minus the inputs is 0, because only a valid public key for G will check out against the signature. This signature, along with a commitment to the excess value (86*G, which serves as a public key to verify the signature), is called a transcation kernel.","title":"Ownership"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#change","text":"Let's say Bob wants to send only 2 of his coins to Carol. To do this he would send the remaining 1 coin back to back to himself, by creating an output he controls. Bob generates a private key 13 as a blinding factor for his change output. Carol uses the same private key as before. transaction with change Inputs Outputs 28*G + 3*H 114*G + 2*H 13*G + 1*H (114*G + 2*H) + (13*G + 1*H) - (28*G + 3*H) = 99*G + 0*H The joint signature is again built with the excess value, 99 in this example.","title":"Change"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#rangeproofs","text":"Previously, we assumed output values to always be positive. However, by introducing negative amounts, a transcation could be balanced out, for example, with an input of 2 and outputs of 5 and -3 . This can't be detected as the values would still equal to zero. A rangeproof is therefore attached to every output and proves that its value isn't negative and that its size is restricted so it doesn't overflow. We won't elaborate on this here.","title":"Rangeproofs"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#putting-it-all-together","text":"A Mimblewimble transaction includes the following: full transaction Inputs Outputs 28*G + 3*H Rangeproof 114*G + 2*H Rangeproof 13*G + 1*H Rangeproof Kernel : TX fee Kernel excess Signature Set of inputs, that reference and spend a set of previous outputs. Set of new outputs where each includes: Value and a blinding factor (a new private key), both multiplied on a curve and summed up to r*G + v*H . Rangeproof that, among other things, shows that v is non-negative. Kernel consisting of: Transaction fee in plain text. Kernel excess, which is the public key corresponding to the excess value (computed by sum of outputs + fee - sum of inputs ) Transaction signature signed by the excess value as private key (and verifies with the kernel excess).","title":"Putting it all together"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#blocks-and-chain","text":"We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create new money and proof of ownership is established through private keys. The Mimblewimble block format builds on this by introducing two additional concepts: Aggregation and cut-through. With these additions, a Mimblewimble chain gains: Further anonymity by mixing and removing transaction data. Extremely good scalability, as the great majority of transaction data can be eliminated over time, without compromising security.","title":"Blocks and chain"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#transaction-aggregation","text":"While the kernel excess of a transaction can be computed by anyone, there's major benefit in including it in every transaction's kernel, as it allows for aggregation within blocks. The following is true for any valid transcation (ignoring fees): transaction: sum(outputs) - sum(inputs) = kernel_excess Note that we refer here to the complete pedersen commitments, not just their blinding factors (which would result in excess_value instead of kernel_excess ). The same holds true for entire blocks of transactions, if we realize a block is simply an extended set of inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs, and the result would be a commitment equal to the sum of the kernel excesses. block: sum(outputs) - sum(inputs) = sum(kernel_excess) Simplifying slightly (ignoring transaction fees), we can see how a Mimblewimble block can be treated exactly as single transaction. Similarly, transactions could be aggregated before block construction and thus enter the mempool at an already aggregated state. The Dandelion stem phase does so automatically when possible, and it could also be done manually and potentially through different aggregation services.","title":"Transaction aggregation"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#kernel-offsets","text":"There is a subtle problem with Mimblewimble blocks and transactions as described above, that needs to be addressed. Given a set of inputs, outputs and transaction kernels, a subset of these will combine to reconstruct a valid transaction. Consider the two following transcations: 1 2 (in1, in2) -> (out1) | (kern1) (in3) -> (out2, out3) | (kern2) We can aggregate them into a block (simply another transcation): aggregated block/transaction Inputs Outputs Kernels in1 out1 kern1 in2 out2 kern2 in3 out3 Initially it seems that the two original transactions are indistinguishable from one another within the new transaction. However, it is trivial to try all possible combinations of inputs/outputs, and find the way in which they succesfully sum to one of the kernel excesses, such that in our example: (in1, in2) - (out1) = (excess_kern1) (in3) - (out2 + out3) = (excess_kern2) We're able to easily uncover the original form of both transactions. Then how do we solve this? Remember that the kernel excess r*G is simply the public key of the excess value r . To address this issue we introduce a kernel offset and redefine a transaction's kernel excess from r*G to (r-kernel_offset)*G . The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the sum of the commitments is valid: sum(outputs) - sum(inputs) + (kernel_offset)*G = (r + kernel_offset)*G If the sum of a transaction's inputs and outputs is the commitment r*G + 0*H , the transactors generate offset a and the transaction is signed with (r-a) instead of r . But, r*G could still be computed to verify the validity of the transaction because given the new form of kernel excess (r-a)*G and the offset a . The verifier computes a*G and calculates: `kernel_excess + kernel_offset*G = sum(blinding_factors) Translated to: (r-a)*G + a*G = r*G Given r*G the transaction can then be validated. During aggregation, all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block (or aggregated transaction). The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved.","title":"Kernel offsets"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#cut-through","text":"Blocks let miners assemble multiple transactions into a single set that's added to the chain. Inputs reference outputs they spend, which are shown as in(output_spent) in the following example. non-cut-through block Inputs Outputs in1(prev_out) out1 out2 in2(prev_out) out3 in3(out2) in4(out3) out4 out5 We notice the two following properties: Within this block, some outputs are immediately spent by following inputs (e.g. in3 spends out2). The structure of each transaction does not actually matter. Since all transaction values individually sum to zero, then the collective sum of all inputs and outputs must be zero. Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels) and that the whole block did not create any coins, other than what's allowed as the mining reward. Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block: cut-through block Inputs Outputs in1(prev_out) out1 in2(prev_out) out4 out5 All transaction structure has been eliminated and the order of inputs and outputs does not matter anymore, while the sum of all inputs and outputs values is still guaranteed to be zero. A block is simply built from: Block header. Set of inputs remaining after cut-through. Set of outputs remaining after cut-through. A single kernel offset (sum of all kernel offsets) to cover the full block. The transaction kernels containing, for each transaction: The public key (r-a)*G , which is the (modified) kernel excess. The signatures generated using the (modified) excess value (r-a) as the signing private key. Mining fee. The block contents satisfy: sum(outputs) - sum(inputs) = sum(kernel_excess) + sum(kernel_offset)*G = (r-a)*G + a*G And it all still validates.","title":"Cut-through"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#cut-through-everything","text":"Going back to the previous example block, outputs prev_out1, prev_out2 , which were spent by in01, in02 respectively, must have appeared previously in the blockchain. After the addition of this new block, those past outputs as well as in01, in02 can also be removed from the blockchain as they now are intermediate transactions. The blocks they were originally included in would still remain valid after their removal. All that needs to remain is the set of currently unspent outputs out01, out02, out05 . We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information: The total amount of coins created by mining in the chain. The complete set of unspent outputs. The transactions kernels for each transaction. The extension of this idea is that all the way from the genesis block to the latest block, every input is deleted along with its referenced output. Both the set of unspent outputs (UTXO) and transaction kernels are extremely compact. This has important consequences; The blockchain a node needs to maintain is very small, as well as the amount of information transferred when a new node joins the network.","title":"Cut-through everything"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#conclusion","text":"We covered the basic principles that underlie Mimblewimble. By using addition of elliptic curve points, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers. Further reading on how transactions are constructed: Grin Transactions Explained, Step-by-Step What\u2019s inside a Grin Transaction File?","title":"Conclusion"},{"location":"wiki/miscellaneous/coinbase-maturity-rule/","text":"Coinbase Maturity Rule (aka Output Lock Heights) Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . Overview Coinbase outputs (block rewards & fees) are \"locked\" and require 1,440 confirmations (i.e 24 hours worth of blocks added to the chain) before they mature sufficiently to be spendable. This is to reduce the risk of later txs being reversed if a chain reorganization occurs. Bitcoin does something very similar, requiring 100 confirmations (Bitcoin blocks are every 10 minutes, Grin blocks are every 60 seconds) before mining rewards can be spent. Grin enforces coinbase maturity in both the transaction pool and the block validation pipeline. A transaction containing an input spending a coinbase output cannot be added to the transaction pool until it has sufficiently matured. Similarly a block is invalid if it contains an input spending a coinbase output before it has sufficiently matured. The maturity rule only applies to coinbase outputs, regular transaction outputs have an effective lock height of zero. Mimblewimble Output Lock Height An output consists of: Features (currently coinbase vs. non-coinbase) Commitment rG+vH Rangeproof To spend a regular transaction output two conditions must be met. We need to show the output has not been previously spent and we need to prove ownership of the output. A Grin transaction consists of the following: A set of inputs, each referencing a previous output being spent. A set of new outputs that include - A value v and a blinding factor (private key) r multiplied on a curve and summed to be rG+vH A range proof that shows that v is non-negative. An explicit transaction fee in the clear. A signature, computed by taking the excess blinding value (the sum of all outputs plus the fee, minus the inputs) and using it as the private key. We can show the output is unspent by looking for the commitment in the current Output set. The Output set is authoritative; if the output exists in the Output set we know it has not yet been spent. If an output does not exist in the Output set we know it has either never existed, or that it previously existed and has been spent (we will not necessarily know which). To prove ownership we can verify the transaction signature. We can only have signed the transaction if the transaction sums to zero and we know both v and r . Knowing v and r we can uniquely identify the output (via its commitment) and we can prove ownership of the output by validating the signature on the original coinbase transaction. Grin does not permit duplicate commitments to exist in the Output set at the same time. But once an output is spent it is removed from the Output set and a duplicate commitment can be added back into the Output set. This is not necessarily recommended but Grin must handle this situation in a way that does not break consensus across the network. Several things complicate this situation - It is possible for two blocks to have identical rewards, particularly for the case of empty blocks, but also possible for non-empty blocks with transaction fees. It is possible for a non-coinbase output to have the same value as a coinbase output. It is possible (but not recommended) for a miner to reuse private keys. Grin does not allow duplicate commitments to exist in the Output set simultaneously. But the Output set is specific to the state of a particular chain fork. It is possible for duplicate identical commitments to exist simultaneously on different concurrent forks. And these duplicate commitments may have different \"lock heights\" at which they mature and become spendable on the different forks. Output O 1 from block B 1 spendable at height h 1 (on fork f 1 ) Output O 1 ' from block B 2 spendable at height h 2 (on fork f 2 ) The complication here is that input I 1 will spend either O 1 or O 1 ' depending on which fork the block containing I 1 exists on. And crucially I 1 may be valid at a particular block height on one fork but not the other. Said another way - a commitment may refer to multiple outputs, all of which may have different lock heights. And we must ensure we correctly identify which output is actually being spent and that the coinbase maturity rules are correctly enforced based on the current chain state. A coinbase output, locked with the coinbase maturity rule at a specific lock height, cannot be uniquely identified, and cannot be safely spent by their commitment alone. To spend a coinbase output we need to know one additional piece of information - The block the coinbase output originated from Given this, we can verify the height of the block and derive the \"lock height\" of the output (+ 1,000 blocks).","title":"Coinbase Maturity Rule"},{"location":"wiki/miscellaneous/coinbase-maturity-rule/#coinbase-maturity-rule-aka-output-lock-heights","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 .","title":"Coinbase Maturity Rule (aka Output Lock Heights)"},{"location":"wiki/miscellaneous/coinbase-maturity-rule/#overview","text":"Coinbase outputs (block rewards & fees) are \"locked\" and require 1,440 confirmations (i.e 24 hours worth of blocks added to the chain) before they mature sufficiently to be spendable. This is to reduce the risk of later txs being reversed if a chain reorganization occurs. Bitcoin does something very similar, requiring 100 confirmations (Bitcoin blocks are every 10 minutes, Grin blocks are every 60 seconds) before mining rewards can be spent. Grin enforces coinbase maturity in both the transaction pool and the block validation pipeline. A transaction containing an input spending a coinbase output cannot be added to the transaction pool until it has sufficiently matured. Similarly a block is invalid if it contains an input spending a coinbase output before it has sufficiently matured. The maturity rule only applies to coinbase outputs, regular transaction outputs have an effective lock height of zero.","title":"Overview"},{"location":"wiki/miscellaneous/coinbase-maturity-rule/#mimblewimble-output-lock-height","text":"An output consists of: Features (currently coinbase vs. non-coinbase) Commitment rG+vH Rangeproof To spend a regular transaction output two conditions must be met. We need to show the output has not been previously spent and we need to prove ownership of the output. A Grin transaction consists of the following: A set of inputs, each referencing a previous output being spent. A set of new outputs that include - A value v and a blinding factor (private key) r multiplied on a curve and summed to be rG+vH A range proof that shows that v is non-negative. An explicit transaction fee in the clear. A signature, computed by taking the excess blinding value (the sum of all outputs plus the fee, minus the inputs) and using it as the private key. We can show the output is unspent by looking for the commitment in the current Output set. The Output set is authoritative; if the output exists in the Output set we know it has not yet been spent. If an output does not exist in the Output set we know it has either never existed, or that it previously existed and has been spent (we will not necessarily know which). To prove ownership we can verify the transaction signature. We can only have signed the transaction if the transaction sums to zero and we know both v and r . Knowing v and r we can uniquely identify the output (via its commitment) and we can prove ownership of the output by validating the signature on the original coinbase transaction. Grin does not permit duplicate commitments to exist in the Output set at the same time. But once an output is spent it is removed from the Output set and a duplicate commitment can be added back into the Output set. This is not necessarily recommended but Grin must handle this situation in a way that does not break consensus across the network. Several things complicate this situation - It is possible for two blocks to have identical rewards, particularly for the case of empty blocks, but also possible for non-empty blocks with transaction fees. It is possible for a non-coinbase output to have the same value as a coinbase output. It is possible (but not recommended) for a miner to reuse private keys. Grin does not allow duplicate commitments to exist in the Output set simultaneously. But the Output set is specific to the state of a particular chain fork. It is possible for duplicate identical commitments to exist simultaneously on different concurrent forks. And these duplicate commitments may have different \"lock heights\" at which they mature and become spendable on the different forks. Output O 1 from block B 1 spendable at height h 1 (on fork f 1 ) Output O 1 ' from block B 2 spendable at height h 2 (on fork f 2 ) The complication here is that input I 1 will spend either O 1 or O 1 ' depending on which fork the block containing I 1 exists on. And crucially I 1 may be valid at a particular block height on one fork but not the other. Said another way - a commitment may refer to multiple outputs, all of which may have different lock heights. And we must ensure we correctly identify which output is actually being spent and that the coinbase maturity rules are correctly enforced based on the current chain state. A coinbase output, locked with the coinbase maturity rule at a specific lock height, cannot be uniquely identified, and cannot be safely spent by their commitment alone. To spend a coinbase output we need to know one additional piece of information - The block the coinbase output originated from Given this, we can verify the height of the block and derive the \"lock height\" of the output (+ 1,000 blocks).","title":"Mimblewimble Output Lock Height"},{"location":"wiki/miscellaneous/cuckoo-cycle/","text":"Cuckoo Cycle Read this document in other languages: Korean . This document is meant to outline, at a level suitable for someone without prior knowledge, the algorithms and processes currently involved in Grin's Proof-of-Work system. We'll start with a general overview of cycles in a graph and the Cuckoo Cycle algorithm which forms the basis of Grin's proof-of-work. We'll then move on to Grin-specific details, which will outline the other systems that combine with Cuckoo Cycle to form the entirety of mining in Grin. Graphs and Cuckoo Cycle Grin's basic Proof-of-Work algorithm is called Cuckoo Cycle, which is specifically designed to be resistant to Bitcoin style hardware arms-races. It is primarily a memory bound algorithm, which (at least in theory) means that solution time is bound by memory bandwidth rather than raw processor or GPU speed. As such, mining Cuckoo Cycle solutions should be viable on most commodity hardware, and require far less energy than most other GPU, CPU or ASIC-bound proof of work algorithms. The Cuckoo Cycle POW is the work of John Tromp, and the most up-to-date documentation and implementations can be found in his github repository . The white paper is the best source of further technical details. Cycles in a Graph Cuckoo Cycle is an algorithm meant to detect cycles in a bipartite graph of N nodes and M edges. In plain terms, a bipartite graph is one in which edges (i.e. lines connecting nodes) travel only between 2 separate groups of nodes. In the case of the Cuckoo hashtable in Cuckoo Cycle, one side of the graph is an array numbered with odd indices (up to the size of the graph), and the other is numbered with even indices. A node is simply a numbered 'space' on either side of the Cuckoo Table, and an Edge is a line connecting two nodes on opposite sides. The simple graph below denotes just such a graph, with 4 nodes on the 'even' side (top), 4 nodes on the odd side (bottom) and zero Edges (i.e. no lines connecting any nodes.) A graph of 8 Nodes with Zero Edges Let's throw a few Edges into the graph now, randomly: 8 Nodes with 4 Edges, no solution We now have a randomly-generated graph with 8 nodes (N) and 4 edges (M), or an NxM graph where N=8 and M=4. Our basic Proof-of-Work is now concerned with finding 'cycles' of a certain length within this random graph, or, put simply, a series of connected nodes starting and ending on the same node. So, if we were looking for a cycle of length 4 (a path connecting 4 nodes, starting and ending on the same node), one cannot be detected in this graph. Adjusting the number of Edges M relative to the number of Nodes N changes the difficulty of the cycle-finding problem, and the probability that a cycle exists in the current graph. For instance, if our POW problem were concerned with finding a cycle of length 4 in the graph, the current difficulty of 4/8 (M/N) would mean that all 4 edges would need to be randomly generated in a perfect cycle (from 0-5-4-1-0) in order for there to be a solution. Let's add a few more edges, again at random: 8 Nodes with 7 Edges Where we can find a cycle: Cycle Found from 0-5-4-1-0 If you increase the number of edges relative to the number of nodes, you increase the probability that a solution exists. With a few more edges added to the graph above, a cycle of length 4 has appeared from 0-5-4-1-0, and the graph has a solution. Thus, modifying the ratio M/N changes the number of expected occurrences of a cycle for a graph with randomly generated edges. For a small graph such as the one above, determining whether a cycle of a certain length exists is trivial. But as the graphs get larger, detecting such cycles becomes more difficult. For instance, does this graph have a cycle of length 8, i.e. 8 connected nodes starting and ending on the same node? Meat-space Cycle Detection exercise The answer is left as an exercise to the reader, but the overall takeaways are: Detecting cycles in a graph becomes more difficult exercise as the size of a graph grows. The probability of a cycle of a given length in a graph increases as M/N becomes larger, i.e. you add more edges relative to the number of nodes in a graph. Cuckoo Cycle The Cuckoo Cycle algorithm is a specialized algorithm designed to solve exactly this problem, and it does so by inserting values into a structure called a 'Cuckoo Hashtable' according to a hash which maps nodes into possible locations in two separate arrays. This document won't go into detail on the base algorithm, as it's outlined plainly enough in section 5 of the white paper . There are also several variants on the algorithm that make various speed/memory tradeoffs, again beyond the scope of this document. However, there are a few details following from the above that we need to keep in mind before going on to more technical aspects of Grin's proof-of-work. The 'random' edges in the graph demonstrated above are not actually random but are generated by putting edge indices (0..N) through a seeded hash function, SIPHASH. Each edge index is put through the SIPHASH function twice to create two edge endpoints, with the first input value being 2 * edge_index, and the second 2 * edge_index+1. The seed for this function is based on a hash of a block header, outlined further below. The 'Proof' created by this algorithm is a set of nonces that generate a cycle of length 42, which can be trivially validated by other peers. Two main parameters, as explained above, are passed into the Cuckoo Cycle algorithm that affect the probability of a solution, and the time it takes to search the graph for a solution: The M/N ratio outlined above, which controls the number of edges relative to the size of the graph. Cuckoo Cycle fixes M at N/2, which limits the number of cycles to a few at most. The size of the graph itself How these parameters interact in practice is looked at in more detail below . Now, (hopefully) armed with a basic understanding of what the Cuckoo Cycle algorithm is intended to do, as well as the parameters that affect how difficult it is to find a solution, we move on to the other portions of Grin's POW system. Mining in Grin The Cuckoo Cycle outlined above forms the basis of Grin's mining process, however Grin uses two variantion of Cuckoo Cycle in tandem with several other systems to create a Proof-of-Work. for GPUs: Cuckaroo on 2^29 edges Tweaked every 6 months to maitain ASIC resistance. 90% of rewards at launch, linearly decreasing to 0% in 2 years. Variant of Cuckoo that enforces Mean mining. Takes 5.5GB of memory (perhaps 4GB with slowdown). for ASICs: Cuckatoo on 2^31 or more edge Variant of Cuckoo that simplifies ASIC design. 10% of rewards at launch, linearly increasing to 100% in 2 years. Takes 512 MB of memory, with random single-bit accesses to half. Mean mineable in high memory GPUs. Smoothly transitions to 2^32 or more by July 2020, called Cuckatoo32+ (explained why here ) Additional Difficulty Control In order to provide additional difficulty control in a manner that meets the needs of a network with constantly evolving hashpower availability, a further Hashcash-based difficulty check is applied to potential solution sets as follows: If the Blake2b hash of a potential set of solution nonces (currently an array of 42 u32s representing the cycle nonces,) is less than an evolving difficulty target T, then the solution is considered valid. More precisely, the proof difficulty is calculated as the maximum target hash (2^256) divided by the current hash, rounded to give an integer. If this integer is larger than the evolving network difficulty, the POW is considered valid and the block is submit to the chain for validation. In other words, a potential proof, as well as containing a valid Cuckoo Cycle, also needs to hash to a value higher than the target difficulty. This difficulty is derived from: Evolving Network Difficulty The difficulty target is intended to evolve according to the available network hashpower, with the goal of keeping the average block solution time within range of a target (currently 60 seconds, though this is subject to change). The difficulty calculation is based on both Digishield and GravityWave family of difficulty computation, coming to something very close to ZCash. The reference difficulty is an average of the difficulty over a window of 23 blocks (the current consensus value). The corresponding timespan is calculated by using the difference between the median timestamps at the beginning and the end of the window. If the timespan is higher or lower than a certain range, (adjusted with a dampening factor to allow for normal variation,) then the difficulty is raised or lowered to a value aiming for the target block solve time. The Mining Loop All of these systems are put together in the mining loop, which attempts to create valid Proofs-of-Work to create the latest block in the chain. The following is an outline of what the main mining loop does during a single iteration: Get the latest chain state and build a block on top of it, which includes a Block Header with new values particular to this mining attempt: The latest target difficulty as selected by the evolving network difficulty algorithm A set of transactions available for validation selected from the transaction pool A coinbase transaction (which we're hoping to give to ourselves) The current timestamp A randomly generated nonce to add further randomness to the header's hash The merkle root of the UTXO set and fees Then, a sub-loop runs for a set amount of time, currently configured at 2 seconds, where the following happens: The new block header is hashed to create a hash value The cuckoo graph generator is initialized, which accepts as parameters: The hash of the potential block header, which is to be used as the key to a SIPHASH function that will generate pairs of locations for each element in a set of nonces 0..N in the graph. The size of the graph (a consensus value). An easiness value, (a consensus value) representing the M/N ratio described above denoting the probability of a solution appearing in the graph The Cuckoo Cycle detection algorithm tries to find a solution (i.e. a cycle of length 42) within the generated graph. If a cycle is found, a Blake2b hash of the proof is created and is compared to the current target difficulty, as outlined in Additional Difficulty Control above. If the Blake2b Hash difficulty is greater than or equal to the target difficulty, the block is sent to the transaction pool, propagated amongst peers for validation, and work begins on the next block. If the Blake2b Hash difficulty is less than the target difficulty, the proof is thrown out and the timed loop continues. If no solution is found, increment the nonce in the header by 1, and update the header's timestamp so the next iteration hashes a different value for seeding the next loop's graph generation step. If the loop times out with no solution found, start over again from the top, collecting new transactions and creating a new block altogether. Mining Loop Difficulty Control and Timing Controlling the overall difficulty of the mining loop requires finding a balance between the three values outlined above: Graph size (currently represented as a bit-shift value n representing a size of 2^n nodes, consensus value DEFAULT_SIZESHIFT). Smaller graphs can be exhaustively searched more quickly, but will also have fewer solutions for a given easiness value. A very small graph needs a higher easiness value to have the same chance to have a solution as a larger graph with a lower easiness value. The 'Easiness' consensus value, or the M/N ratio of the graph expressed as a percentage. The higher this value, the more likely it is a generated graph will contain a solution. In tandem with the above, the larger the graph, the more solutions it will contain for a given easiness value. The Cuckoo Cycle implementations fix this M to N/2, giving a ratio of 50% The evolving network difficulty hash. These values need to be carefully tweaked in order for the mining algorithm to find the right balance between the cuckoo graph size and the evolving difficulty. The POW needs to remain mostly Cuckoo Cycle based, but still allow for reasonably short block times that allow new transactions to be quickly processed. If the graph size is too low and the easiness too high, for instance, then many cuckoo cycle solutions can easily be found for a given block, and the POW will start to favour those who can hash faster, precisely what Cuckoo Cycle is trying to avoid. If the graph is too large and easiness too low, however, then it can potentially take any solver a long time to find a solution in a single graph, well outside a window in which you'd like to stop to collect new transactions. These values are currently set to 2^12 for the graph size and 50% (as fixed by Cuckoo Cycle) for the easiness value, however the size is only a temporary values for testing. The current miner implementation is very unoptimized, and the graph size will need to be changed as faster and more optimized Cuckoo Cycle algorithms are put in place. Pooling Capability Contrary to some existing concerns about Cuckoo Cycle's poolability, the POW implementation in Grin as described above is perfectly suited to a mining pool. While it may be difficult to prove efforts to solve a single graph in isolation, the combination of factors within Grin's proof-of-work combine to enforce a notion called 'progress-freeness', which enables 'poolability' as well as a level of fairness among all miners. Progress Freeness Progress-freeness is central to the 'poolability' of a proof-of-work, and is simply based on the idea that a solution to a POW problem can be found within a reasonable amount of time. For instance, if a blockchain has a one minute POW time and miners have to spend one minute on average to find a solution, this still satisfies the POW requirement but gives a strong advantage to big miners. In such a setup, small miners will generally lose at least one minute every time while larger miners can move on as soon as they find a solution. So in order to keep mining relatively progress-free, a POW that requires multiple solution attempts with each attempt taking a relatively small amount of time is desirable. Following from this, Grin's progress-freeness is due to the fact that a solution to a Cuckoo with Grin's default parameters can typically be found in under a second on most GPUs, and there is the additional requirement of the Blake2b difficulty check on top of that. Members of a pool are thus able to prove they're working on a solution to a block by submitting valid Cuckoo solutions (or a small bundle of them) that simply fall under the current network target difficulty.","title":"Cuckoo Cycle"},{"location":"wiki/miscellaneous/cuckoo-cycle/#cuckoo-cycle","text":"Read this document in other languages: Korean . This document is meant to outline, at a level suitable for someone without prior knowledge, the algorithms and processes currently involved in Grin's Proof-of-Work system. We'll start with a general overview of cycles in a graph and the Cuckoo Cycle algorithm which forms the basis of Grin's proof-of-work. We'll then move on to Grin-specific details, which will outline the other systems that combine with Cuckoo Cycle to form the entirety of mining in Grin.","title":"Cuckoo Cycle"},{"location":"wiki/miscellaneous/cuckoo-cycle/#graphs-and-cuckoo-cycle","text":"Grin's basic Proof-of-Work algorithm is called Cuckoo Cycle, which is specifically designed to be resistant to Bitcoin style hardware arms-races. It is primarily a memory bound algorithm, which (at least in theory) means that solution time is bound by memory bandwidth rather than raw processor or GPU speed. As such, mining Cuckoo Cycle solutions should be viable on most commodity hardware, and require far less energy than most other GPU, CPU or ASIC-bound proof of work algorithms. The Cuckoo Cycle POW is the work of John Tromp, and the most up-to-date documentation and implementations can be found in his github repository . The white paper is the best source of further technical details.","title":"Graphs and Cuckoo Cycle"},{"location":"wiki/miscellaneous/cuckoo-cycle/#cycles-in-a-graph","text":"Cuckoo Cycle is an algorithm meant to detect cycles in a bipartite graph of N nodes and M edges. In plain terms, a bipartite graph is one in which edges (i.e. lines connecting nodes) travel only between 2 separate groups of nodes. In the case of the Cuckoo hashtable in Cuckoo Cycle, one side of the graph is an array numbered with odd indices (up to the size of the graph), and the other is numbered with even indices. A node is simply a numbered 'space' on either side of the Cuckoo Table, and an Edge is a line connecting two nodes on opposite sides. The simple graph below denotes just such a graph, with 4 nodes on the 'even' side (top), 4 nodes on the odd side (bottom) and zero Edges (i.e. no lines connecting any nodes.) A graph of 8 Nodes with Zero Edges Let's throw a few Edges into the graph now, randomly: 8 Nodes with 4 Edges, no solution We now have a randomly-generated graph with 8 nodes (N) and 4 edges (M), or an NxM graph where N=8 and M=4. Our basic Proof-of-Work is now concerned with finding 'cycles' of a certain length within this random graph, or, put simply, a series of connected nodes starting and ending on the same node. So, if we were looking for a cycle of length 4 (a path connecting 4 nodes, starting and ending on the same node), one cannot be detected in this graph. Adjusting the number of Edges M relative to the number of Nodes N changes the difficulty of the cycle-finding problem, and the probability that a cycle exists in the current graph. For instance, if our POW problem were concerned with finding a cycle of length 4 in the graph, the current difficulty of 4/8 (M/N) would mean that all 4 edges would need to be randomly generated in a perfect cycle (from 0-5-4-1-0) in order for there to be a solution. Let's add a few more edges, again at random: 8 Nodes with 7 Edges Where we can find a cycle: Cycle Found from 0-5-4-1-0 If you increase the number of edges relative to the number of nodes, you increase the probability that a solution exists. With a few more edges added to the graph above, a cycle of length 4 has appeared from 0-5-4-1-0, and the graph has a solution. Thus, modifying the ratio M/N changes the number of expected occurrences of a cycle for a graph with randomly generated edges. For a small graph such as the one above, determining whether a cycle of a certain length exists is trivial. But as the graphs get larger, detecting such cycles becomes more difficult. For instance, does this graph have a cycle of length 8, i.e. 8 connected nodes starting and ending on the same node? Meat-space Cycle Detection exercise The answer is left as an exercise to the reader, but the overall takeaways are: Detecting cycles in a graph becomes more difficult exercise as the size of a graph grows. The probability of a cycle of a given length in a graph increases as M/N becomes larger, i.e. you add more edges relative to the number of nodes in a graph.","title":"Cycles in a Graph"},{"location":"wiki/miscellaneous/cuckoo-cycle/#cuckoo-cycle_1","text":"The Cuckoo Cycle algorithm is a specialized algorithm designed to solve exactly this problem, and it does so by inserting values into a structure called a 'Cuckoo Hashtable' according to a hash which maps nodes into possible locations in two separate arrays. This document won't go into detail on the base algorithm, as it's outlined plainly enough in section 5 of the white paper . There are also several variants on the algorithm that make various speed/memory tradeoffs, again beyond the scope of this document. However, there are a few details following from the above that we need to keep in mind before going on to more technical aspects of Grin's proof-of-work. The 'random' edges in the graph demonstrated above are not actually random but are generated by putting edge indices (0..N) through a seeded hash function, SIPHASH. Each edge index is put through the SIPHASH function twice to create two edge endpoints, with the first input value being 2 * edge_index, and the second 2 * edge_index+1. The seed for this function is based on a hash of a block header, outlined further below. The 'Proof' created by this algorithm is a set of nonces that generate a cycle of length 42, which can be trivially validated by other peers. Two main parameters, as explained above, are passed into the Cuckoo Cycle algorithm that affect the probability of a solution, and the time it takes to search the graph for a solution: The M/N ratio outlined above, which controls the number of edges relative to the size of the graph. Cuckoo Cycle fixes M at N/2, which limits the number of cycles to a few at most. The size of the graph itself How these parameters interact in practice is looked at in more detail below . Now, (hopefully) armed with a basic understanding of what the Cuckoo Cycle algorithm is intended to do, as well as the parameters that affect how difficult it is to find a solution, we move on to the other portions of Grin's POW system.","title":"Cuckoo Cycle"},{"location":"wiki/miscellaneous/cuckoo-cycle/#mining-in-grin","text":"The Cuckoo Cycle outlined above forms the basis of Grin's mining process, however Grin uses two variantion of Cuckoo Cycle in tandem with several other systems to create a Proof-of-Work. for GPUs: Cuckaroo on 2^29 edges Tweaked every 6 months to maitain ASIC resistance. 90% of rewards at launch, linearly decreasing to 0% in 2 years. Variant of Cuckoo that enforces Mean mining. Takes 5.5GB of memory (perhaps 4GB with slowdown). for ASICs: Cuckatoo on 2^31 or more edge Variant of Cuckoo that simplifies ASIC design. 10% of rewards at launch, linearly increasing to 100% in 2 years. Takes 512 MB of memory, with random single-bit accesses to half. Mean mineable in high memory GPUs. Smoothly transitions to 2^32 or more by July 2020, called Cuckatoo32+ (explained why here )","title":"Mining in Grin"},{"location":"wiki/miscellaneous/cuckoo-cycle/#additional-difficulty-control","text":"In order to provide additional difficulty control in a manner that meets the needs of a network with constantly evolving hashpower availability, a further Hashcash-based difficulty check is applied to potential solution sets as follows: If the Blake2b hash of a potential set of solution nonces (currently an array of 42 u32s representing the cycle nonces,) is less than an evolving difficulty target T, then the solution is considered valid. More precisely, the proof difficulty is calculated as the maximum target hash (2^256) divided by the current hash, rounded to give an integer. If this integer is larger than the evolving network difficulty, the POW is considered valid and the block is submit to the chain for validation. In other words, a potential proof, as well as containing a valid Cuckoo Cycle, also needs to hash to a value higher than the target difficulty. This difficulty is derived from:","title":"Additional Difficulty Control"},{"location":"wiki/miscellaneous/cuckoo-cycle/#evolving-network-difficulty","text":"The difficulty target is intended to evolve according to the available network hashpower, with the goal of keeping the average block solution time within range of a target (currently 60 seconds, though this is subject to change). The difficulty calculation is based on both Digishield and GravityWave family of difficulty computation, coming to something very close to ZCash. The reference difficulty is an average of the difficulty over a window of 23 blocks (the current consensus value). The corresponding timespan is calculated by using the difference between the median timestamps at the beginning and the end of the window. If the timespan is higher or lower than a certain range, (adjusted with a dampening factor to allow for normal variation,) then the difficulty is raised or lowered to a value aiming for the target block solve time.","title":"Evolving Network Difficulty"},{"location":"wiki/miscellaneous/cuckoo-cycle/#the-mining-loop","text":"All of these systems are put together in the mining loop, which attempts to create valid Proofs-of-Work to create the latest block in the chain. The following is an outline of what the main mining loop does during a single iteration: Get the latest chain state and build a block on top of it, which includes a Block Header with new values particular to this mining attempt: The latest target difficulty as selected by the evolving network difficulty algorithm A set of transactions available for validation selected from the transaction pool A coinbase transaction (which we're hoping to give to ourselves) The current timestamp A randomly generated nonce to add further randomness to the header's hash The merkle root of the UTXO set and fees Then, a sub-loop runs for a set amount of time, currently configured at 2 seconds, where the following happens: The new block header is hashed to create a hash value The cuckoo graph generator is initialized, which accepts as parameters: The hash of the potential block header, which is to be used as the key to a SIPHASH function that will generate pairs of locations for each element in a set of nonces 0..N in the graph. The size of the graph (a consensus value). An easiness value, (a consensus value) representing the M/N ratio described above denoting the probability of a solution appearing in the graph The Cuckoo Cycle detection algorithm tries to find a solution (i.e. a cycle of length 42) within the generated graph. If a cycle is found, a Blake2b hash of the proof is created and is compared to the current target difficulty, as outlined in Additional Difficulty Control above. If the Blake2b Hash difficulty is greater than or equal to the target difficulty, the block is sent to the transaction pool, propagated amongst peers for validation, and work begins on the next block. If the Blake2b Hash difficulty is less than the target difficulty, the proof is thrown out and the timed loop continues. If no solution is found, increment the nonce in the header by 1, and update the header's timestamp so the next iteration hashes a different value for seeding the next loop's graph generation step. If the loop times out with no solution found, start over again from the top, collecting new transactions and creating a new block altogether.","title":"The Mining Loop"},{"location":"wiki/miscellaneous/cuckoo-cycle/#mining-loop-difficulty-control-and-timing","text":"Controlling the overall difficulty of the mining loop requires finding a balance between the three values outlined above: Graph size (currently represented as a bit-shift value n representing a size of 2^n nodes, consensus value DEFAULT_SIZESHIFT). Smaller graphs can be exhaustively searched more quickly, but will also have fewer solutions for a given easiness value. A very small graph needs a higher easiness value to have the same chance to have a solution as a larger graph with a lower easiness value. The 'Easiness' consensus value, or the M/N ratio of the graph expressed as a percentage. The higher this value, the more likely it is a generated graph will contain a solution. In tandem with the above, the larger the graph, the more solutions it will contain for a given easiness value. The Cuckoo Cycle implementations fix this M to N/2, giving a ratio of 50% The evolving network difficulty hash. These values need to be carefully tweaked in order for the mining algorithm to find the right balance between the cuckoo graph size and the evolving difficulty. The POW needs to remain mostly Cuckoo Cycle based, but still allow for reasonably short block times that allow new transactions to be quickly processed. If the graph size is too low and the easiness too high, for instance, then many cuckoo cycle solutions can easily be found for a given block, and the POW will start to favour those who can hash faster, precisely what Cuckoo Cycle is trying to avoid. If the graph is too large and easiness too low, however, then it can potentially take any solver a long time to find a solution in a single graph, well outside a window in which you'd like to stop to collect new transactions. These values are currently set to 2^12 for the graph size and 50% (as fixed by Cuckoo Cycle) for the easiness value, however the size is only a temporary values for testing. The current miner implementation is very unoptimized, and the graph size will need to be changed as faster and more optimized Cuckoo Cycle algorithms are put in place.","title":"Mining Loop Difficulty Control and Timing"},{"location":"wiki/miscellaneous/cuckoo-cycle/#pooling-capability","text":"Contrary to some existing concerns about Cuckoo Cycle's poolability, the POW implementation in Grin as described above is perfectly suited to a mining pool. While it may be difficult to prove efforts to solve a single graph in isolation, the combination of factors within Grin's proof-of-work combine to enforce a notion called 'progress-freeness', which enables 'poolability' as well as a level of fairness among all miners.","title":"Pooling Capability"},{"location":"wiki/miscellaneous/cuckoo-cycle/#progress-freeness","text":"Progress-freeness is central to the 'poolability' of a proof-of-work, and is simply based on the idea that a solution to a POW problem can be found within a reasonable amount of time. For instance, if a blockchain has a one minute POW time and miners have to spend one minute on average to find a solution, this still satisfies the POW requirement but gives a strong advantage to big miners. In such a setup, small miners will generally lose at least one minute every time while larger miners can move on as soon as they find a solution. So in order to keep mining relatively progress-free, a POW that requires multiple solution attempts with each attempt taking a relatively small amount of time is desirable. Following from this, Grin's progress-freeness is due to the fact that a solution to a Cuckoo with Grin's default parameters can typically be found in under a second on most GPUs, and there is the additional requirement of the Blake2b difficulty check on top of that. Members of a pool are thus able to prove they're working on a solution to a block by submitting valid Cuckoo solutions (or a small bundle of them) that simply fall under the current network target difficulty.","title":"Progress Freeness"},{"location":"wiki/miscellaneous/dandelion/","text":"Dandelion++ in Grin: Privacy-Preserving Transaction Aggregation and Propagation Read this document in other languages: Korean [out of date]. Introduction The Dandelion++ protocol for broadcasting transactions, proposed by Fanti et al. (Sigmetrics 2018) 1 , intends to defend against deanonymization attacks during transaction propagation. In Grin, it also provides an opportunity to aggregate transactions before they are broadcast to the entire network. This document describes the protocol and the simplified version of it that is implemented in Grin. In the following section, past research on the protocol is summarized. This is then followed by describing details of the Grin implementation; the objectives behind its inclusion, how the current implementation differs from the original paper, what some of the known limitations are, and outlining some areas of improvement for future work. Research The original version of Dandelion was introduced by Fanti et al. and presented at ACM Sigmetrics 2017 2 . On June 2017, a BIP 3 was proposed introducing a more practical and robust variant of Dandelion called Dandelion++, which was formalized into a paper in 2018 1 . The protocols are outlined at a high level here. For a more in-depth presentation with extensive literature references, please refer to the original papers. Motivation Dandelion was conceived as a way to mitigate large scale deanonymization attacks on the network layer of Bitcoin, made possible by the diffusion method for propagating transactions on the network. By deploying \"super-nodes\" that connect to a large number of honest nodes on the network, adversaries can listen to the transactions relayed by the honest nodes as they get diffused symmetrically on the network using epidemic flooding or diffusion. By observing the spreading dynamic of a transaction, it has been proven possible to link it (and therefore also the sender's Bitcoin address) to the originating IP address with a high degree of accuracy, and as a result de-anonymize users. Dandelion In the original paper 2 , a dandelion spreading protocol is introduced. Dandelion spreading propagation consists of two phases: first the anonymity phase, or the \u201cstem\u201d phase, and second the spreading phase, or the \u201cfluff\u201d phase, as illustrated in Figure 1. Figure 1. Dandelion phase illustration. \u250c-> F ... \u250c-> D --\u2524 | \u2514-> G ... A --[stem]--> B --[stem]--> C --[fluff]--\u2524 | \u250c-> H ... \u2514-> E --\u2524 \u2514-> I ... In the initial stem-phase , each node relays the transaction to a single randomly selected peer , constructing a line graph. Users then forward transactions along the same path on the graph. After a random number of hops along the stem, the transaction enters the fluff-phase , which behaves like ordinary diffusion. This means that even when an attacker can identify the originator of the fluff phase, it becomes more difficult to identify the source of the stem (and thus the original broadcaster of the transaction). Each individual node pseudorandomly selects if he is a stem or a fluff node at regular intervals, called epoch periods. Epochs are asynchronous, with each individual node keeping its own internal clock and starting a new epoch once a certain threshold has been reached. Thus, the constructed line graph is periodically re-generated randomly, at the expiry of each epoch, limiting an adversary's possibility to build knowledge of the graph. The 'Dandelion' name is derived from how the protocol resembles the spreading of the seeds of a dandelion. Dandelion++ In the Dandelion++ paper 1 , the authors build on the original concept further by defending against stronger adversaries that are allowed to disobey protocol. The original paper makes three ideal assumptions: All nodes obey protocol. Each node generates exactly one transaction. All nodes on the network run Dandelion. An adversary can violate these rules, and by doing so, break some of the anonymity properties. The modified Dandelion++ protocol makes small changes to many of the Dandelion choices, resulting in an exponentially more complex information space. This in turn makes it harder for an adversary to de-anonymize the network. The paper describes five types of attacks, and proposes specific updates to the original Dandelion protocol to mitigate against these, presented in Table A (here in summarized form). Table A. Summary of Dandelion++ changes Attack Solution Graph-learning 4-regular anonymity graph Intersection Pseudorandom forwarding Graph-construction Non-interactive construction Black-hole Random stem timers Partial deployment Blind stem selection Dandelion++ Algorithm As with the original Dandelion protocol, epochs are asynchronous, each node keeping track of its own epoch, which the suggested duration being in the order of 10 minutes. Anonymity Graph Rather than a line graph as per the original paper (which is 2-regular), a quasi-4-regular graph is constructed by a node at the beginning of each epoch: the node chooses (up to) two of its outbound peers uniformly at random as its dandelion++ relays . As a node enters into a new epoch, new dandelion++ relays are chosen. Figure 2. representation of a 4-regular graph. in1 out1 \\ / \\ / NodeX / \\ / \\ in2 out2 NodeX has four connections to other nodes, input nodes in1 and in2 , and output nodes out1 and out2 . 4-regular vs 2-regular graphs The choice between using 4-regular or 2-regular (line) graphs is not obvious. The authors note that it is difficult to construct an exact 4-regular graph within a fully-distributed network in practice. They outline a method to construct an approximate 4-regular graph in the paper. They also write: ... We recommend making the design decision between 4-regular graphs and line graphs based on the priorities of the system builders. If linkability of transactions is a first-order concern, then line graphs may be a better choice. Otherwise, we find that 4-regular graphs can give constant- order privacy benefits against adversaries with knowledge of the graph. Transaction forwarding (own) At the beginning of each epoch, NodeX picks one of out1 and out2 to use as a route to broadcast its own transactions through as a stem-phase transaction. The same route is used throughout the duration epoch, and NodeX always forwards (stems) its own transaction. Transaction forwarding (relay) At the start of each epoch, NodeX makes a choice to be either in fluff-mode or in stem-mode. This choice is made in pseudorandom fashion, with the paper suggesting it being computed from a hash of the node's own identity and epoch number. The probability of choosing to be in fluff-mode (or as the paper calls it, the path length parameter q ) is recommended to be q \u2264 0.2. Once the choice has been made whether to stem or to fluff, it applies to all relayed transactions passing through it during the epoch. in fluff-mode , NodeX is will broadcast any received transactions to the network using diffusion. in stem-mode , at the beginning of each epoch NodeX will map in1 to either out1 or out2 pseudorandomly, and similarly map in2 to either out1 or out2 in the same fashion. Based on this mapping, it will then forward all txs from in1 along the chosen route, and similarly forward all transactions from in2 along that route. The mapping persists throughout the duration of the epoch. Fail-safe mechanism For each stem-phase transaction that was sent or relayed, NodeX tracks whether it is seen again as a fluff-phase transaction within some random amount of time. If not, the node fluffs the transaction itself. This expiration timer is set by each stem-node upon receiving a transaction to forward, and is chosen randomly. Nodes are initialized with a timeout parameter T base . As per equation (7) in the paper, when a stem-node v receives a transaction, it sets an expiration time T out (v): T out (v) ~ current_time + exp(1/T base ) If the transaction is not received again by relay v before the expiry of T out (v), then it broadcasts the message using diffusion. This approach means that the if the transaction gets does not enter fluff-phase in time, the first stem-node to broadcast is approximately uniformly selected among all stem-nodes who have seen the transaction, rather than the originating node who created it. The paper also proceeds to specify the size of the initiating time out parameter T base as part of Proposition 3 in the paper: Proposition3. For a timeout parameter T base \u2265 (\u2212k(k\u22121)\u03b4 hop ) / 2 log(1\u2212\u03b5 ), where k , \u03b5 are parameters and \u03b4 hop is the time between each hop (e.g., network and/or internal node latency), transactions travel for k hops without any peer initiating diffusion with a probability of at least 1 \u2212 \u03b5 . Dandelion in Grin Objectives The choice to include Dandelion in Grin has two main motives behind it: Act as a countermeasure against mass de-anonymization attacks. Similar to Bitcoin, the Grin P2P network would be vulnerable to attackers deploying malicious \"super-nodes\" connecting to most peers on the network and monitoring transactions as they become diffused by their honest peers. This would allow a motivated actor to infer with a high degree of probability from which peer (IP address) transactions originate from, having negative privacy consequences. Aggregate transactions before they are being broadcast to the entire network. This is a benefit to blockchains that enable non-interactive CoinJoins on the protocol level, such as Mimblewimble. Despite its good privacy features, some input and output linking is still possible in Mimblewimble and Grin. 4 If you know which input spends to which output, it is possible to construct a transaction graph and follow a chain of transaction outputs (TXOs) as they are being spent. Aggregating transactions make this more difficult to carry out, as it becomes less clear which input spends to which output (Figure 3). In order for this to be effective, there needs to be a large anonymity set, i.e. many transactions to aggregate with one another. Dandelion enables this aggregation to occur before transactions are fluffed and diffused to the entire network. This adds obfuscation to the transaction graph, as a malicious observer who is not participating in the stemming or fluffing would not only need to figure out from where a transaction originated, but also which outputs and inputs out of a larger group should be attributed to the originating transaction. Figure 3. (switch between tabs) Not Aggregated Inputs Outputs Kernels t r a n s a c t i o n A X Kernel 1 Y t r a n s a c t i o n B Z Kernel 2 C Aggregated Inputs Outputs Kernels A X Kernel 1 B Y Kernel 2 C Z Current implementation Grin implements a simplified version of the Dandelion++ protocol. It's been improved several times, most recently in version 1.1.0 5 . Dandelion configuration options in grin-server.toml (default) #dandelion epoch duration epoch_secs = 600 #fluff and broadcast after embargo expires if tx not seen on network embargo_secs = 180 #dandelion aggregation period in secs aggregation_secs = 30 #dandelion stem probability (stem 90% of the time, fluff 10% of the time) stem_probability = 90 #always stem our (pushed via api) txs regardless of stem/fluff epoch (as per Dandelion++ paper) always_stem_our_txs = true DandelionEpoch tracks a node's current epoch. This is configurable via epoch_secs with default epoch set to last for 10 minutes. Epochs are set and tracked by nodes individually. At the beginning of an epoch, the node chooses a single connected peer at random to use as their outbound relay. At the beginning of an epoch, the node makes a decision whether to be in stem mode or in fluff mode. This decision lasts for the duration of the epoch. By default, this is a random choice, with the probability to be in stem mode set to 90%, which implies a fluff mode probability, q of 10%. The probability is configurable via DANDELION_STEM_PROBABILITY . The number of expected stem hops a transaction does before arriving to a fluff node is 1/q = 1/0.1 = 10 . Any transactions received from inbound peers or transactions originated from the node itself are first added to the node's stempool , which is a list of stem transactions, that each node keeps track of individually. Transactions are removed from the stempool if: The node fluffs the transaction itself. The node sees the transaction in question propagated through regular diffusion, i.e. from a different peer having \"fluffed\" it. The node receives a block containing this transaction, meaning that the transaction was propagated and included in a block. For each transaction added to the stempool, the node sets an embargo timer . This is set by default to 180 seconds, and is configurable via embargo_secs . A dandelion_monitor runs every 10 seconds and handles tasks. If the node is in stem mode , then: After being added to the stempool, received stem transactions are forwarded onto the their relay node as a stem transaction. As peers connect at random, it is possible they create a circular loop of connected stem mode nodes (i.e. A -> B -> C -> A ). Therefore, if a node receives a stem transaction from an inbound node that already exists in its own stempool, it will fluff it, broadcasting it using regular diffusion. dandelion_monitor checks for transactions in the node's stempool with an expired embargo timer, and broadcast those individually. If the node is in fluff mode , then: Transactions received from inbound nodes are kept in the stempool. dandelion_monitor checks in the stempool whether any transactions are older than 30 seconds (configurable as DANDELION_AGGREGATION_SECS ). If so, these are aggregated and then fluffed. Otherwise no action is taken, allowing for more stem transactions to aggregate in the stempool in time for the next triggering of dandelion_monitor . At the expiry of an epoch, all stem transactions remaining in the stem pool are aggregated and fluffed. Nodes stem their own transactions Regardless of whether the node is in fluff or stem mode, any transactions generated from the node itself are forwarded onwards to their relay node as a stem transaction. 6 Known limitations 2-regular graphs are used rather than 4-regular graphs as proposed by the paper. It's not clear what impact this has, the paper suggests a trade-off between general linkability of transactions and protection against adversaries who know the entire network graph. Additionally, unlike the Dandelion++ paper, the embargo timer is by default identical across all nodes. This means that during a black-hole attack where a malicious node withholds transactions, the node most likely to have its embargo timer expire and fluff the transaction will be the originating node, therefore exposing itself. Future work Randomized embargo timer according to the recommendations of the paper to make it more random which node fluffs an expired transaction. Evaluation of whether 4-regular graphs are preferred over 2-regular line graphs. Simulation of the current implementation to understand performance. References Dandelion++: Lightweight Cryptocurrency Networking with Formal Anonymity Guarantees (Sigmetrics'18) \u21a9 \u21a9 \u21a9 Dandelion: Redesigning the Bitcoin Network for Anonymity (Sigmetrics'17) \u21a9 \u21a9 Dandelion BIP \u21a9 Grin Privacy Primer \u21a9 #2628: Dandelion++ Rewrite \u21a9 #2876: Always stem local txs if configured that way (unless explicitly fluffed) \u21a9","title":"Dandelion"},{"location":"wiki/miscellaneous/dandelion/#dandelion-in-grin-privacy-preserving-transaction-aggregation-and-propagation","text":"Read this document in other languages: Korean [out of date].","title":"Dandelion++ in Grin: Privacy-Preserving Transaction Aggregation and Propagation"},{"location":"wiki/miscellaneous/dandelion/#introduction","text":"The Dandelion++ protocol for broadcasting transactions, proposed by Fanti et al. (Sigmetrics 2018) 1 , intends to defend against deanonymization attacks during transaction propagation. In Grin, it also provides an opportunity to aggregate transactions before they are broadcast to the entire network. This document describes the protocol and the simplified version of it that is implemented in Grin. In the following section, past research on the protocol is summarized. This is then followed by describing details of the Grin implementation; the objectives behind its inclusion, how the current implementation differs from the original paper, what some of the known limitations are, and outlining some areas of improvement for future work.","title":"Introduction"},{"location":"wiki/miscellaneous/dandelion/#research","text":"The original version of Dandelion was introduced by Fanti et al. and presented at ACM Sigmetrics 2017 2 . On June 2017, a BIP 3 was proposed introducing a more practical and robust variant of Dandelion called Dandelion++, which was formalized into a paper in 2018 1 . The protocols are outlined at a high level here. For a more in-depth presentation with extensive literature references, please refer to the original papers.","title":"Research"},{"location":"wiki/miscellaneous/dandelion/#motivation","text":"Dandelion was conceived as a way to mitigate large scale deanonymization attacks on the network layer of Bitcoin, made possible by the diffusion method for propagating transactions on the network. By deploying \"super-nodes\" that connect to a large number of honest nodes on the network, adversaries can listen to the transactions relayed by the honest nodes as they get diffused symmetrically on the network using epidemic flooding or diffusion. By observing the spreading dynamic of a transaction, it has been proven possible to link it (and therefore also the sender's Bitcoin address) to the originating IP address with a high degree of accuracy, and as a result de-anonymize users.","title":"Motivation"},{"location":"wiki/miscellaneous/dandelion/#dandelion","text":"In the original paper 2 , a dandelion spreading protocol is introduced. Dandelion spreading propagation consists of two phases: first the anonymity phase, or the \u201cstem\u201d phase, and second the spreading phase, or the \u201cfluff\u201d phase, as illustrated in Figure 1. Figure 1. Dandelion phase illustration. \u250c-> F ... \u250c-> D --\u2524 | \u2514-> G ... A --[stem]--> B --[stem]--> C --[fluff]--\u2524 | \u250c-> H ... \u2514-> E --\u2524 \u2514-> I ... In the initial stem-phase , each node relays the transaction to a single randomly selected peer , constructing a line graph. Users then forward transactions along the same path on the graph. After a random number of hops along the stem, the transaction enters the fluff-phase , which behaves like ordinary diffusion. This means that even when an attacker can identify the originator of the fluff phase, it becomes more difficult to identify the source of the stem (and thus the original broadcaster of the transaction). Each individual node pseudorandomly selects if he is a stem or a fluff node at regular intervals, called epoch periods. Epochs are asynchronous, with each individual node keeping its own internal clock and starting a new epoch once a certain threshold has been reached. Thus, the constructed line graph is periodically re-generated randomly, at the expiry of each epoch, limiting an adversary's possibility to build knowledge of the graph. The 'Dandelion' name is derived from how the protocol resembles the spreading of the seeds of a dandelion.","title":"Dandelion"},{"location":"wiki/miscellaneous/dandelion/#dandelion_1","text":"In the Dandelion++ paper 1 , the authors build on the original concept further by defending against stronger adversaries that are allowed to disobey protocol. The original paper makes three ideal assumptions: All nodes obey protocol. Each node generates exactly one transaction. All nodes on the network run Dandelion. An adversary can violate these rules, and by doing so, break some of the anonymity properties. The modified Dandelion++ protocol makes small changes to many of the Dandelion choices, resulting in an exponentially more complex information space. This in turn makes it harder for an adversary to de-anonymize the network. The paper describes five types of attacks, and proposes specific updates to the original Dandelion protocol to mitigate against these, presented in Table A (here in summarized form). Table A. Summary of Dandelion++ changes Attack Solution Graph-learning 4-regular anonymity graph Intersection Pseudorandom forwarding Graph-construction Non-interactive construction Black-hole Random stem timers Partial deployment Blind stem selection","title":"Dandelion++"},{"location":"wiki/miscellaneous/dandelion/#dandelion-algorithm","text":"As with the original Dandelion protocol, epochs are asynchronous, each node keeping track of its own epoch, which the suggested duration being in the order of 10 minutes.","title":"Dandelion++ Algorithm"},{"location":"wiki/miscellaneous/dandelion/#anonymity-graph","text":"Rather than a line graph as per the original paper (which is 2-regular), a quasi-4-regular graph is constructed by a node at the beginning of each epoch: the node chooses (up to) two of its outbound peers uniformly at random as its dandelion++ relays . As a node enters into a new epoch, new dandelion++ relays are chosen. Figure 2. representation of a 4-regular graph. in1 out1 \\ / \\ / NodeX / \\ / \\ in2 out2 NodeX has four connections to other nodes, input nodes in1 and in2 , and output nodes out1 and out2 . 4-regular vs 2-regular graphs The choice between using 4-regular or 2-regular (line) graphs is not obvious. The authors note that it is difficult to construct an exact 4-regular graph within a fully-distributed network in practice. They outline a method to construct an approximate 4-regular graph in the paper. They also write: ... We recommend making the design decision between 4-regular graphs and line graphs based on the priorities of the system builders. If linkability of transactions is a first-order concern, then line graphs may be a better choice. Otherwise, we find that 4-regular graphs can give constant- order privacy benefits against adversaries with knowledge of the graph.","title":"Anonymity Graph"},{"location":"wiki/miscellaneous/dandelion/#transaction-forwarding-own","text":"At the beginning of each epoch, NodeX picks one of out1 and out2 to use as a route to broadcast its own transactions through as a stem-phase transaction. The same route is used throughout the duration epoch, and NodeX always forwards (stems) its own transaction.","title":"Transaction forwarding (own)"},{"location":"wiki/miscellaneous/dandelion/#transaction-forwarding-relay","text":"At the start of each epoch, NodeX makes a choice to be either in fluff-mode or in stem-mode. This choice is made in pseudorandom fashion, with the paper suggesting it being computed from a hash of the node's own identity and epoch number. The probability of choosing to be in fluff-mode (or as the paper calls it, the path length parameter q ) is recommended to be q \u2264 0.2. Once the choice has been made whether to stem or to fluff, it applies to all relayed transactions passing through it during the epoch. in fluff-mode , NodeX is will broadcast any received transactions to the network using diffusion. in stem-mode , at the beginning of each epoch NodeX will map in1 to either out1 or out2 pseudorandomly, and similarly map in2 to either out1 or out2 in the same fashion. Based on this mapping, it will then forward all txs from in1 along the chosen route, and similarly forward all transactions from in2 along that route. The mapping persists throughout the duration of the epoch.","title":"Transaction forwarding (relay)"},{"location":"wiki/miscellaneous/dandelion/#fail-safe-mechanism","text":"For each stem-phase transaction that was sent or relayed, NodeX tracks whether it is seen again as a fluff-phase transaction within some random amount of time. If not, the node fluffs the transaction itself. This expiration timer is set by each stem-node upon receiving a transaction to forward, and is chosen randomly. Nodes are initialized with a timeout parameter T base . As per equation (7) in the paper, when a stem-node v receives a transaction, it sets an expiration time T out (v): T out (v) ~ current_time + exp(1/T base ) If the transaction is not received again by relay v before the expiry of T out (v), then it broadcasts the message using diffusion. This approach means that the if the transaction gets does not enter fluff-phase in time, the first stem-node to broadcast is approximately uniformly selected among all stem-nodes who have seen the transaction, rather than the originating node who created it. The paper also proceeds to specify the size of the initiating time out parameter T base as part of Proposition 3 in the paper: Proposition3. For a timeout parameter T base \u2265 (\u2212k(k\u22121)\u03b4 hop ) / 2 log(1\u2212\u03b5 ), where k , \u03b5 are parameters and \u03b4 hop is the time between each hop (e.g., network and/or internal node latency), transactions travel for k hops without any peer initiating diffusion with a probability of at least 1 \u2212 \u03b5 .","title":"Fail-safe mechanism"},{"location":"wiki/miscellaneous/dandelion/#dandelion-in-grin","text":"","title":"Dandelion in Grin"},{"location":"wiki/miscellaneous/dandelion/#objectives","text":"The choice to include Dandelion in Grin has two main motives behind it: Act as a countermeasure against mass de-anonymization attacks. Similar to Bitcoin, the Grin P2P network would be vulnerable to attackers deploying malicious \"super-nodes\" connecting to most peers on the network and monitoring transactions as they become diffused by their honest peers. This would allow a motivated actor to infer with a high degree of probability from which peer (IP address) transactions originate from, having negative privacy consequences. Aggregate transactions before they are being broadcast to the entire network. This is a benefit to blockchains that enable non-interactive CoinJoins on the protocol level, such as Mimblewimble. Despite its good privacy features, some input and output linking is still possible in Mimblewimble and Grin. 4 If you know which input spends to which output, it is possible to construct a transaction graph and follow a chain of transaction outputs (TXOs) as they are being spent. Aggregating transactions make this more difficult to carry out, as it becomes less clear which input spends to which output (Figure 3). In order for this to be effective, there needs to be a large anonymity set, i.e. many transactions to aggregate with one another. Dandelion enables this aggregation to occur before transactions are fluffed and diffused to the entire network. This adds obfuscation to the transaction graph, as a malicious observer who is not participating in the stemming or fluffing would not only need to figure out from where a transaction originated, but also which outputs and inputs out of a larger group should be attributed to the originating transaction. Figure 3. (switch between tabs) Not Aggregated Inputs Outputs Kernels t r a n s a c t i o n A X Kernel 1 Y t r a n s a c t i o n B Z Kernel 2 C Aggregated Inputs Outputs Kernels A X Kernel 1 B Y Kernel 2 C Z","title":"Objectives"},{"location":"wiki/miscellaneous/dandelion/#current-implementation","text":"Grin implements a simplified version of the Dandelion++ protocol. It's been improved several times, most recently in version 1.1.0 5 . Dandelion configuration options in grin-server.toml (default) #dandelion epoch duration epoch_secs = 600 #fluff and broadcast after embargo expires if tx not seen on network embargo_secs = 180 #dandelion aggregation period in secs aggregation_secs = 30 #dandelion stem probability (stem 90% of the time, fluff 10% of the time) stem_probability = 90 #always stem our (pushed via api) txs regardless of stem/fluff epoch (as per Dandelion++ paper) always_stem_our_txs = true DandelionEpoch tracks a node's current epoch. This is configurable via epoch_secs with default epoch set to last for 10 minutes. Epochs are set and tracked by nodes individually. At the beginning of an epoch, the node chooses a single connected peer at random to use as their outbound relay. At the beginning of an epoch, the node makes a decision whether to be in stem mode or in fluff mode. This decision lasts for the duration of the epoch. By default, this is a random choice, with the probability to be in stem mode set to 90%, which implies a fluff mode probability, q of 10%. The probability is configurable via DANDELION_STEM_PROBABILITY . The number of expected stem hops a transaction does before arriving to a fluff node is 1/q = 1/0.1 = 10 . Any transactions received from inbound peers or transactions originated from the node itself are first added to the node's stempool , which is a list of stem transactions, that each node keeps track of individually. Transactions are removed from the stempool if: The node fluffs the transaction itself. The node sees the transaction in question propagated through regular diffusion, i.e. from a different peer having \"fluffed\" it. The node receives a block containing this transaction, meaning that the transaction was propagated and included in a block. For each transaction added to the stempool, the node sets an embargo timer . This is set by default to 180 seconds, and is configurable via embargo_secs . A dandelion_monitor runs every 10 seconds and handles tasks. If the node is in stem mode , then: After being added to the stempool, received stem transactions are forwarded onto the their relay node as a stem transaction. As peers connect at random, it is possible they create a circular loop of connected stem mode nodes (i.e. A -> B -> C -> A ). Therefore, if a node receives a stem transaction from an inbound node that already exists in its own stempool, it will fluff it, broadcasting it using regular diffusion. dandelion_monitor checks for transactions in the node's stempool with an expired embargo timer, and broadcast those individually. If the node is in fluff mode , then: Transactions received from inbound nodes are kept in the stempool. dandelion_monitor checks in the stempool whether any transactions are older than 30 seconds (configurable as DANDELION_AGGREGATION_SECS ). If so, these are aggregated and then fluffed. Otherwise no action is taken, allowing for more stem transactions to aggregate in the stempool in time for the next triggering of dandelion_monitor . At the expiry of an epoch, all stem transactions remaining in the stem pool are aggregated and fluffed. Nodes stem their own transactions Regardless of whether the node is in fluff or stem mode, any transactions generated from the node itself are forwarded onwards to their relay node as a stem transaction. 6","title":"Current implementation"},{"location":"wiki/miscellaneous/dandelion/#known-limitations","text":"2-regular graphs are used rather than 4-regular graphs as proposed by the paper. It's not clear what impact this has, the paper suggests a trade-off between general linkability of transactions and protection against adversaries who know the entire network graph. Additionally, unlike the Dandelion++ paper, the embargo timer is by default identical across all nodes. This means that during a black-hole attack where a malicious node withholds transactions, the node most likely to have its embargo timer expire and fluff the transaction will be the originating node, therefore exposing itself.","title":"Known limitations"},{"location":"wiki/miscellaneous/dandelion/#future-work","text":"Randomized embargo timer according to the recommendations of the paper to make it more random which node fluffs an expired transaction. Evaluation of whether 4-regular graphs are preferred over 2-regular line graphs. Simulation of the current implementation to understand performance.","title":"Future work"},{"location":"wiki/miscellaneous/dandelion/#references","text":"Dandelion++: Lightweight Cryptocurrency Networking with Formal Anonymity Guarantees (Sigmetrics'18) \u21a9 \u21a9 \u21a9 Dandelion: Redesigning the Bitcoin Network for Anonymity (Sigmetrics'17) \u21a9 \u21a9 Dandelion BIP \u21a9 Grin Privacy Primer \u21a9 #2628: Dandelion++ Rewrite \u21a9 #2876: Always stem local txs if configured that way (unless explicitly fluffed) \u21a9","title":"References"},{"location":"wiki/miscellaneous/nrd-kernels/","text":"NRD Kernels Title: nrd-kernels Authors: Antioch Peverell Start date: Mar 24, 2020 RFC PR: mimblewimble/grin-rfcs#47 Tracking issue: mimblewimble/grin#3288 Summary Grin supports a limited implementation of \"relative timelocks\" with \"No Recent Duplicate\" (NRD) transaction kernels. Transactions can be constructed such that they share duplicate kernels. An NRD kernel instance is not valid within a specified number of blocks relative to a prior duplicate instance of the kernel. A minimum height difference must therefore exist between two instances of an NRD kernel. This provides the relative height lock between transactions. Motivation Relative timelocks are a prerequisite for robust payment channels. NRD kernels can be used to implement a revocable channel close mechanism. A mandatory revocation period can be introduced through a relative timelock between two transactions. Any attempt to close an old invalid channel state can be safely revoked during the revocation period. Recently, Ruben Somsen announced a design for [Succinct Atomic Swaps (SAS)] 10 reducing the number of on-chain transactions required to implement the swap. This design uses a combination of relative locks and [adaptor signatures] 11 . SAS would appear to be compatible with Grin/MW but with some caveats, namely the need for an additional transaction kernel as the NRD lock and the adaptor signature cannot co-exist on the same kernel. This is discussed in Unresolved questions below. Community-level explanation A minimum distance in block height is enforced between successive duplicate instances of a given NRD kernel. This can be used to enforce a relative lock height between two transactions. A transaction containing an NRD kernel will not be accepted as valid within the specified block height relative to any prior instance of the NRD kernel. Transactions can be constructed around an existing transaction kernel by introducing either an additional kernel or in some cases by simply adjusting the kernel offset. This allows NRD kernels to be used across any pair of transactions. The NRD kernel implementation aims for simplicity and a minimal approach to solving the problem of \"relative locks\". Grin does not support a general solution for arbitrary length locks between arbitrary kernels. The implementation is limited in scope to avoid adversely impacting performance and scalability. References between duplicate kernels are implicit , avoiding the need to store kernel references. Locks are limited in length to recent history, avoiding the need to inspect the full historical kernel set during verification. Reference-level explanation An NRD kernel is not valid within a specified number of blocks of a previous duplicate instance of the same NRD kernel. We define duplicate here as two NRD kernels sharing the same public excess commitment. NRD kernels with different excess commitments are not treated as duplicates. An NRD kernel and a non-NRD kernel (plain kernel, coinbase kernel etc.) sharing the same excess commitment are not treated as duplicates. An NRD kernel has an associated relative lock height. For a block B containing this kernel to be valid, no duplicate instance of the kernel can exist in the last RH blocks (up to and including B ), where RH is the relative lock height. For example, a transaction containing an NRD kernel with relative lock height 1440 (24 hours) is included in a block at height 1000000. This block is only valid if no duplicate instance of this kernel exists in any block from height 998561 (h-1439) to height 1000000 (h-0) inclusive. A duplicate instance is permitted at height 998560 (h-1440), with the transaction seen as valid. If no duplicate instance of the kernel exists within this range then the lock criteria is met. A kernel can be delayed by the existence of a previous kernel. The non-existence of a previous kernel has no impact on the lock criteria. Note that this implies the first singular occurrence of any NRD kernel meets the lock criteria trivially as it cannot, by definition, be locked by a previous kernel. Thus, the relative lock defaults to \"fail open\" semantics. Each node maintains an index of recent NRD kernels to enable efficient checking of NRD relative lock heights. Note we only need to index NRD locks and we only need to index those within recent history. Relative locks longer than 7 days are not valid. This is believed to be sufficient to cover all proposed use cases. The minimum value for a relative lock height is 1 meaning a prior instance of the kernel can exist in the previous block for the lock criteria to be met. An instance of the NRD kernel in the same block will invalidate the block as the lock criteria will not be met. NRD lock heights of 0 are invalid and it is never valid for two duplicate instances of the same NRD kernel to exist in the same block. It follows that two transactions containing duplicate instances of the same NRD kernel cannot be accepted as valid in the transaction pool concurrently. Current txpool behavior is \"first one wins\" semantics when receiving transactions and this will also apply to transactions containing NRD kernels. We plan to revisit this in a future \"fee\" RFC and plan to investigate the feasibility of introducing \"replace by fee\" semantics at that time. Grin supports \"rewind\" back through recent history to handle fork and chain reorg scenarios. 1 week of full blocks are maintained on each node and up to 10080 blocks can be rewound. To support relative lock heights each node must maintain an index over sufficient kernel history for an additional 10080 blocks beyond this rewind horizon. Each node should maintain 2 weeks of kernel history in the local NRD kernel index. This will cover the pathological case of a 1 week rewind and the validation of a 1 week long relative lock beyond that. The primary use case is for revocable payment channel close operations. We believe a 7 day period is more than sufficient for this. We do not require long, extended revocation periods and limiting this to a few days is preferable to keep the cost of verification low. The need for these revocable transactions to be included on chain should be low as these are only required in a non-cooperative situation but where required we want to minimize the cost of verification which must be performed across all nodes. The following kernel variants are supported in Grin - Plain Coinbase HeightLocked NoRecentDuplicate These are implemented as kernel \"feature\" variants - pub enum KernelFeatures { /// Plain kernel (default for Grin txs). Plain = 0, /// A coinbase kernel. Coinbase = 1, /// A kernel with an explicit absolute lock height. HeightLocked = 2, /// A relative height locked NRD kernel. NoRecentDuplicate = 3, } Each kernel variant includes feature specific data - # Plain { \"fee\": 8 } # Coinbase { # empty } # Height Locked { \"fee\": 8, \"lock_height\": 295800 } # No Recent Duplicate (NRD) { \"fee\": 8, \"relative_height\": 1440, } Note that NRD kernels require no additional data beyond that required for absolute height locked kernels. The reference to the previous kernel is implicit and based on a duplicate NRD kernel excess commitment. The maximum supported NRD relative_height is 10080 (7 days) and the relative height can be safely and conveniently represented as a u16 (2 bytes). This differs from absolute lock heights where u64 (8 bytes) is necessary to specify the lock height. The minimum supported NRD relative_height is 1 and a value of 0 is not valid. Two duplicate instances of a given NRD kernel cannot exist simultaneously in the same block. There must be a relative height of at least 1 block between them. Nodes on the Grin network currently support two serialization versions for transaction kernels - V1 \"fixed size kernels\" In V1 all kernels are serialized to the same \"fixed\" number of bytes: feature ( 1 byte ) | fee ( 8 bytes ) | additional_data ( 8 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 01 f7 8 a 40 | 00 00 00 00 00 00 05 A0 | 08 b1 ... 22 d8 | 33 11 ... b9 69 NRD kernels use the last 2 bytes of feature specific data for the relative lock height as big-endian u16. The first 6 bytes of feature specific data must be all zero: 00 00 00 00 00 00 05 A0 Note: absolute lock height (u64) and relative lock height (u16) have identical serialization in practice. V1 is supported for backward compatibility with nodes that do not support V2 \"variable size kernels\". V2 \"variable size kernels\" V2 kernels have been supported since Grin v2.1.0 and V2 supports the notion of \"variable size\" kernels. See [RFC-0005 \"Varible Size Kernels\"] 12 for details of this. NRD kernels include 8 bytes for the fee as big-endian u64 and 2 bytes for the relative lock height: feature ( 1 byte ) | fee ( 8 bytes ) | relative_height ( 2 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 00 6 a cf c0 | 05 A0 | 09 4 d ... bb 9 a | 09 c7 ... bd 54 In V2 relative lock height is 2 bytes as big-endian u16: 05 A0 Note: the serialization strategy is used for both network \"on the wire\" serialization of both transactions and full blocks, and local storage, both the database for full blocks and the kernel MMR backend files. Version negotiation occurs during the initial peer connection setup process and determines which version is used for p2p message serialization. If a node uses V2 serialization for the kernel MMR backend file then it will provide a V2 txhashset based on these underlying files. Kernel Signature Message Every kernel contains a signature proving the excess commitment is a commitment to zero. The message being signed includes the features, fee and other associated data to prevent malleability of the transaction kernel and the overall transaction. The transaction fee cannot be modified after signing, for example. For NRD kernels the message being signed is constructed as follows with the relative lock height serialized as 2 bytes. Hash(feature | fee | relative_height) Hash(03 | 00 00 00 00 01 f7 8a 40 | 05 A0) No additional data is introduced with NRD kernels beyond the 2 bytes representing the relative lock height. There is no opportunity to include arbitrary data. Any additional kernel included in a transaction is itself still a fully valid kernel. There is no explicit reference necessary that could be misused to include arbitrary data. An additional NRD kernel in a transaction will increase the \"weight\" of the transaction by this single additional kernel and allows for a simple way to deal with additional fees. A transaction with an additional kernel must provide additional fees to cover the additional \"weight\". NRD kernels cannot be added for free. Note that in some limited situations it is possible to replace a kernel with an NRD kernel. If the NRD lock can be introduced without adding an additional kernel then the fee does not have to be increased and the lock is effectively added for free. A transaction kernel consists of an excess commitment and an associated signature showing this excess is indeed a commitment to 0. A transaction with a single kernel can always be represented as a transaction with multiple kernels, provided the kernels excess commitments sum to the correct total excess. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment - rG + 0H This transaction can be represented as a pair of kernels with excess commitments - rG + 0H = (r'G + 0H) + (r-r'G + 0H) We take advantage of this to allow an arbitrary NRD kernel to be included in any transaction at construction time. Additionally the kernel offset included in each transaction can be used in certain situations to allow the replacement of a single transaction kernel with an NRD kernel without needing to introduce an additional kernel. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment and kernel offset - rG + 0H, o This transaction can be rewritten to use the NRD kernel - r'G + 0H, (o+r-r') These two \"degrees of freedom\", introducing multiple kernels and adjusting the kernel offset, allowing for flexibility to introduce an NRD kernel in a variety of ways. Introduce NRD kernel to transaction, compensate with additional kernel. Introduce NRD kernel to transaction, compensate with kernel offset. Payment Channel Implementation NRD kernels can be used to delay alternate \"branches\" of conflicting transactions, enabling a payment channel implementation. A payment channel is represented as a single multi-party output. Each channel state transition is represented as a pair of \"close\" and \"settle\" transactions with an NRD kernel enforcing a delay between them. Funds are held in an intermediate multi-party output while delayed. The NRD kernel is reused across both transactions by adjusting kernel offsets. X -> Y, K nrd_a \\ Y -> [Z a , Z b ], K nrd_a Alice closes the channel X with their \"close\" transaction. After a delay Alice can \"settle\" the funds out to Alice and Bob. Attribution of \"close\" and \"settle\" transactions for each channel state is provided through endpoint specific NRD kernels. This allows the other party to \"revoke\" old invalid state without the NRD delay. Each channel state transition involves a new pair of \"close\" and \"settle\" transactions for each participant along with a shared \"revoke\" transaction. The \"revoke\" transaction simply spends funds back to the channel output and a plain kernel suffices. [Z a , Z b ] -> X, K rev Alice attempts to close old invalid state ( Y 1 ): X -> Y 1 , K nrd_a1 Bob can immediately revoke and close current state ( Y 1 -> Y 2 ): Y 1 -> ~[Z a , Z b ]~, K nrd_b1 \\ ~[Z a , Z b ]~ -> X , K rev_1 \\ X -> Y 2 , K nrd_b2 \\ => Y 1 -> Y 2 , [K nrd_b1 , K rev_1 , K nrd_b2 ] Bob publishes only the final cut-through multi-kernel transaction ( Y 1 -> Y 2 ). Bob's individual settle transaction is not revealed. Neither party can self-revoke without introducing the NRD delay. The other party always has the opportunity to revoke first. Self-revocation cannot be used to lock funds up indefinitely. HF3 (July 2020) Rollout/Deployment The following rules will be enforced during rollout as part of HF3 - Assumptions: HF3 will occur at height 786,240. Blocks at height >= 786,240 will have block version >= 4. Block Specific Rules: A block containing NRD kernel(s) is only be valid if block version >= 4. A block containing NRD kernel(s) is only valid if all defined relative lock height rules are met. Two duplicate NRD kernel instances cannot exist in the same block. Transaction Specific Rules: A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless chain head version >= 4. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless chain head version >= 4. A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless it meets the defined relative lock height rule in the next block. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless it meets the defined relative lock height rule in the next block. Two duplicate NRD kernel instances cannot exist in the txpool/stempool concurrently. Weights & Fees For the purpose of block weight calculations, each kernel is treated as 3 \"weight units\" where each unit is approximately 32 bytes. This covers the excess commitment and the associated signature common across all kernel variants. The additional 2 bytes of \"relative height\" on NRD kernels are ignored for the purposes of calculating block weight. For the purpose of minimum transaction relay fees all kernels are treated as 1 \"fee unit\" with each unit being 1 milligrin. We plan to revisit the entire transaction fee structure in a future RFC. Kernel variants may affect the transaction fee calculations differently in the future. Drawbacks NRD kernels are a limited and restricted form of \"relative locks\" between kernels. These locks are limited to a period of 7 days and \"fail open\" beyond that window. This approach meets the requirements for limited revocable payment channel operations but there are likely to be use cases where this approach is not sufficient or unsuitable. While it would be nice to provide a fully general purpose solution that would allow arbitrary locks to be implemented, it does appear to be hard, if not impossible, to do this in Grin/MW. Rationale and alternatives Referencing historical data in Grin and in Mimblewimble in general is difficult due to the possibility of pruning historical data. It is not possible to reference old outputs once they are spent. Historical validators must have access to any referenced data to validate consensus rules. This leaves transaction kernels as the only available data to be referenced. While arbitrary historical kernels can be referenced this is not desirable as we do not want to impose additional constraints on nodes, requiring them to maintain historical data that would otherwise be prunable. An earlier design iteration was \"No Such Kernel Recently\" (NSKR) locks. Where NRD references were implicit, with duplicate kernel excess commitments, NSKR kernels referenced prior kernels explicitly. These explicit references were problematic for several reasons - Additional overhead, both local storage and network traffic due to the explicit references. Optimization by referencing prior kernel based on MMR position introduced a dependency on external data (kernels can no longer be validated in isolation). Permitting non-existence of references due to limited window of history, opened up a vector for \"spam\" where arbitrary data could be used in place of a valid reference. To prevent \"spam\" a signature can be used to verify the reference was indeed a valid commitment. By including a signature along with the commitment, the reference is effectively a full transaction kernel. The idea of using Merkle proofs to verify inclusion of a historical referenced kernel in the kernel MMR was also considered. This gets expensive both in terms of transaction size and increased verification cost. There is also the problem of position not yet being known at transaction creation time, necessitating Merkle proof generation at block creation time by miners which adds complexity. Prior art Bitcoin allows transaction inputs to be \"encumbered\" with a relative locktime based on the sequence number field. This restricts an input from spending the associated output until a certain number of blocks have passed. BIP112 describes the CHECKSEQUENCEVERIFY opcode in Bitcoin and BIP68 describes the underlying consensus changes around the sequence number field. [Timelock#CheckSequenceVerify (bitcoin wiki)] 6 [CheckSequenceVerify (bitcoin wiki)] 7 [Bitcoin BIP-0068] 8 [Bitcoin BIP-0112] 9 Note that relative locks in Bitcoin are based on transaction inputs and outputs , with inputs only able to spend outputs once confirmed beneath a certain number of blocks. We cannot do this in Grin due to the pruning of old data. Spent outputs will eventually be removed and cannot be relied upon as part of the validation process. Bitcoin encumbers individual outputs whereas in Grin we encumber transactions via the constituent transaction kernels. Unresolved questions Some investigation is still needed around the conditions necessary to allow a kernel to simply be reused with an adjustment to the kernel offset and where an additional kernel is necessary. An adjustment to the kernel offset will expose the private excess under certain conditions and cannot be done safely for all transactions. One outstanding question is what use cases are not covered by NRD kernels. We believe them to be sufficient for the revocable payment channel close mechanism. But they may not be sufficient for all use cases. [Succinct Atomic Swaps (SAS)] 10 describes the use of both relative locks and [adaptor signatures] 11 to implement atomic swaps with only two on-chain transactions. The secret associated with the adaptor signature is swapped to allow funds to be claimed while the relative lock locks funds prior to a refund being claimed. We note that NRD kernels and adaptor signatures are not directly compatible as a prior instance of an NRD kernel would have revealed the secret associated with the adaptor signature. That said we can produce transactions with multiple kernels and we can use this to isolate the adaptor signature on a separate kernel alongside an NRD kernel. It is an unresolved question if there is a way to modify the SAS protocol and avoid the need for these additional kernels in Grin/MW. References Original \"triggers\" mailing list post by Ruben Somsen \u21a9 \"No Such Kernel Recently\" post by John Tromp \u21a9 \"Duplicate Kernels\" post by Antioch \u21a9 \"NRD based payment channel\" post by John Tromp \u21a9 Earlier NSKR based payment channel design \u21a9 Timelock#CheckSequenceVerify (bitcoin wiki) \u21a9 CheckSequenceVerify (bitcoin wiki) \u21a9 Bitcoin BIP-0068 \u21a9 Bitcoin BIP-0112 \u21a9 Succinct Atomic Swaps by Ruben Somsen \u21a9 \u21a9 Scriptless Scripts \u21a9 \u21a9 RFC-0005 \"Variable Size Kernels\" \u21a9","title":"NRD Kernels"},{"location":"wiki/miscellaneous/nrd-kernels/#nrd-kernels","text":"Title: nrd-kernels Authors: Antioch Peverell Start date: Mar 24, 2020 RFC PR: mimblewimble/grin-rfcs#47 Tracking issue: mimblewimble/grin#3288","title":"NRD Kernels"},{"location":"wiki/miscellaneous/nrd-kernels/#summary","text":"Grin supports a limited implementation of \"relative timelocks\" with \"No Recent Duplicate\" (NRD) transaction kernels. Transactions can be constructed such that they share duplicate kernels. An NRD kernel instance is not valid within a specified number of blocks relative to a prior duplicate instance of the kernel. A minimum height difference must therefore exist between two instances of an NRD kernel. This provides the relative height lock between transactions.","title":"Summary"},{"location":"wiki/miscellaneous/nrd-kernels/#motivation","text":"Relative timelocks are a prerequisite for robust payment channels. NRD kernels can be used to implement a revocable channel close mechanism. A mandatory revocation period can be introduced through a relative timelock between two transactions. Any attempt to close an old invalid channel state can be safely revoked during the revocation period. Recently, Ruben Somsen announced a design for [Succinct Atomic Swaps (SAS)] 10 reducing the number of on-chain transactions required to implement the swap. This design uses a combination of relative locks and [adaptor signatures] 11 . SAS would appear to be compatible with Grin/MW but with some caveats, namely the need for an additional transaction kernel as the NRD lock and the adaptor signature cannot co-exist on the same kernel. This is discussed in Unresolved questions below.","title":"Motivation"},{"location":"wiki/miscellaneous/nrd-kernels/#community-level-explanation","text":"A minimum distance in block height is enforced between successive duplicate instances of a given NRD kernel. This can be used to enforce a relative lock height between two transactions. A transaction containing an NRD kernel will not be accepted as valid within the specified block height relative to any prior instance of the NRD kernel. Transactions can be constructed around an existing transaction kernel by introducing either an additional kernel or in some cases by simply adjusting the kernel offset. This allows NRD kernels to be used across any pair of transactions. The NRD kernel implementation aims for simplicity and a minimal approach to solving the problem of \"relative locks\". Grin does not support a general solution for arbitrary length locks between arbitrary kernels. The implementation is limited in scope to avoid adversely impacting performance and scalability. References between duplicate kernels are implicit , avoiding the need to store kernel references. Locks are limited in length to recent history, avoiding the need to inspect the full historical kernel set during verification.","title":"Community-level explanation"},{"location":"wiki/miscellaneous/nrd-kernels/#reference-level-explanation","text":"An NRD kernel is not valid within a specified number of blocks of a previous duplicate instance of the same NRD kernel. We define duplicate here as two NRD kernels sharing the same public excess commitment. NRD kernels with different excess commitments are not treated as duplicates. An NRD kernel and a non-NRD kernel (plain kernel, coinbase kernel etc.) sharing the same excess commitment are not treated as duplicates. An NRD kernel has an associated relative lock height. For a block B containing this kernel to be valid, no duplicate instance of the kernel can exist in the last RH blocks (up to and including B ), where RH is the relative lock height. For example, a transaction containing an NRD kernel with relative lock height 1440 (24 hours) is included in a block at height 1000000. This block is only valid if no duplicate instance of this kernel exists in any block from height 998561 (h-1439) to height 1000000 (h-0) inclusive. A duplicate instance is permitted at height 998560 (h-1440), with the transaction seen as valid. If no duplicate instance of the kernel exists within this range then the lock criteria is met. A kernel can be delayed by the existence of a previous kernel. The non-existence of a previous kernel has no impact on the lock criteria. Note that this implies the first singular occurrence of any NRD kernel meets the lock criteria trivially as it cannot, by definition, be locked by a previous kernel. Thus, the relative lock defaults to \"fail open\" semantics. Each node maintains an index of recent NRD kernels to enable efficient checking of NRD relative lock heights. Note we only need to index NRD locks and we only need to index those within recent history. Relative locks longer than 7 days are not valid. This is believed to be sufficient to cover all proposed use cases. The minimum value for a relative lock height is 1 meaning a prior instance of the kernel can exist in the previous block for the lock criteria to be met. An instance of the NRD kernel in the same block will invalidate the block as the lock criteria will not be met. NRD lock heights of 0 are invalid and it is never valid for two duplicate instances of the same NRD kernel to exist in the same block. It follows that two transactions containing duplicate instances of the same NRD kernel cannot be accepted as valid in the transaction pool concurrently. Current txpool behavior is \"first one wins\" semantics when receiving transactions and this will also apply to transactions containing NRD kernels. We plan to revisit this in a future \"fee\" RFC and plan to investigate the feasibility of introducing \"replace by fee\" semantics at that time. Grin supports \"rewind\" back through recent history to handle fork and chain reorg scenarios. 1 week of full blocks are maintained on each node and up to 10080 blocks can be rewound. To support relative lock heights each node must maintain an index over sufficient kernel history for an additional 10080 blocks beyond this rewind horizon. Each node should maintain 2 weeks of kernel history in the local NRD kernel index. This will cover the pathological case of a 1 week rewind and the validation of a 1 week long relative lock beyond that. The primary use case is for revocable payment channel close operations. We believe a 7 day period is more than sufficient for this. We do not require long, extended revocation periods and limiting this to a few days is preferable to keep the cost of verification low. The need for these revocable transactions to be included on chain should be low as these are only required in a non-cooperative situation but where required we want to minimize the cost of verification which must be performed across all nodes. The following kernel variants are supported in Grin - Plain Coinbase HeightLocked NoRecentDuplicate These are implemented as kernel \"feature\" variants - pub enum KernelFeatures { /// Plain kernel (default for Grin txs). Plain = 0, /// A coinbase kernel. Coinbase = 1, /// A kernel with an explicit absolute lock height. HeightLocked = 2, /// A relative height locked NRD kernel. NoRecentDuplicate = 3, } Each kernel variant includes feature specific data - # Plain { \"fee\": 8 } # Coinbase { # empty } # Height Locked { \"fee\": 8, \"lock_height\": 295800 } # No Recent Duplicate (NRD) { \"fee\": 8, \"relative_height\": 1440, } Note that NRD kernels require no additional data beyond that required for absolute height locked kernels. The reference to the previous kernel is implicit and based on a duplicate NRD kernel excess commitment. The maximum supported NRD relative_height is 10080 (7 days) and the relative height can be safely and conveniently represented as a u16 (2 bytes). This differs from absolute lock heights where u64 (8 bytes) is necessary to specify the lock height. The minimum supported NRD relative_height is 1 and a value of 0 is not valid. Two duplicate instances of a given NRD kernel cannot exist simultaneously in the same block. There must be a relative height of at least 1 block between them. Nodes on the Grin network currently support two serialization versions for transaction kernels - V1 \"fixed size kernels\" In V1 all kernels are serialized to the same \"fixed\" number of bytes: feature ( 1 byte ) | fee ( 8 bytes ) | additional_data ( 8 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 01 f7 8 a 40 | 00 00 00 00 00 00 05 A0 | 08 b1 ... 22 d8 | 33 11 ... b9 69 NRD kernels use the last 2 bytes of feature specific data for the relative lock height as big-endian u16. The first 6 bytes of feature specific data must be all zero: 00 00 00 00 00 00 05 A0 Note: absolute lock height (u64) and relative lock height (u16) have identical serialization in practice. V1 is supported for backward compatibility with nodes that do not support V2 \"variable size kernels\". V2 \"variable size kernels\" V2 kernels have been supported since Grin v2.1.0 and V2 supports the notion of \"variable size\" kernels. See [RFC-0005 \"Varible Size Kernels\"] 12 for details of this. NRD kernels include 8 bytes for the fee as big-endian u64 and 2 bytes for the relative lock height: feature ( 1 byte ) | fee ( 8 bytes ) | relative_height ( 2 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 00 6 a cf c0 | 05 A0 | 09 4 d ... bb 9 a | 09 c7 ... bd 54 In V2 relative lock height is 2 bytes as big-endian u16: 05 A0 Note: the serialization strategy is used for both network \"on the wire\" serialization of both transactions and full blocks, and local storage, both the database for full blocks and the kernel MMR backend files. Version negotiation occurs during the initial peer connection setup process and determines which version is used for p2p message serialization. If a node uses V2 serialization for the kernel MMR backend file then it will provide a V2 txhashset based on these underlying files. Kernel Signature Message Every kernel contains a signature proving the excess commitment is a commitment to zero. The message being signed includes the features, fee and other associated data to prevent malleability of the transaction kernel and the overall transaction. The transaction fee cannot be modified after signing, for example. For NRD kernels the message being signed is constructed as follows with the relative lock height serialized as 2 bytes. Hash(feature | fee | relative_height) Hash(03 | 00 00 00 00 01 f7 8a 40 | 05 A0) No additional data is introduced with NRD kernels beyond the 2 bytes representing the relative lock height. There is no opportunity to include arbitrary data. Any additional kernel included in a transaction is itself still a fully valid kernel. There is no explicit reference necessary that could be misused to include arbitrary data. An additional NRD kernel in a transaction will increase the \"weight\" of the transaction by this single additional kernel and allows for a simple way to deal with additional fees. A transaction with an additional kernel must provide additional fees to cover the additional \"weight\". NRD kernels cannot be added for free. Note that in some limited situations it is possible to replace a kernel with an NRD kernel. If the NRD lock can be introduced without adding an additional kernel then the fee does not have to be increased and the lock is effectively added for free. A transaction kernel consists of an excess commitment and an associated signature showing this excess is indeed a commitment to 0. A transaction with a single kernel can always be represented as a transaction with multiple kernels, provided the kernels excess commitments sum to the correct total excess. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment - rG + 0H This transaction can be represented as a pair of kernels with excess commitments - rG + 0H = (r'G + 0H) + (r-r'G + 0H) We take advantage of this to allow an arbitrary NRD kernel to be included in any transaction at construction time. Additionally the kernel offset included in each transaction can be used in certain situations to allow the replacement of a single transaction kernel with an NRD kernel without needing to introduce an additional kernel. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment and kernel offset - rG + 0H, o This transaction can be rewritten to use the NRD kernel - r'G + 0H, (o+r-r') These two \"degrees of freedom\", introducing multiple kernels and adjusting the kernel offset, allowing for flexibility to introduce an NRD kernel in a variety of ways. Introduce NRD kernel to transaction, compensate with additional kernel. Introduce NRD kernel to transaction, compensate with kernel offset.","title":"Reference-level explanation"},{"location":"wiki/miscellaneous/nrd-kernels/#payment-channel-implementation","text":"NRD kernels can be used to delay alternate \"branches\" of conflicting transactions, enabling a payment channel implementation. A payment channel is represented as a single multi-party output. Each channel state transition is represented as a pair of \"close\" and \"settle\" transactions with an NRD kernel enforcing a delay between them. Funds are held in an intermediate multi-party output while delayed. The NRD kernel is reused across both transactions by adjusting kernel offsets. X -> Y, K nrd_a \\ Y -> [Z a , Z b ], K nrd_a Alice closes the channel X with their \"close\" transaction. After a delay Alice can \"settle\" the funds out to Alice and Bob. Attribution of \"close\" and \"settle\" transactions for each channel state is provided through endpoint specific NRD kernels. This allows the other party to \"revoke\" old invalid state without the NRD delay. Each channel state transition involves a new pair of \"close\" and \"settle\" transactions for each participant along with a shared \"revoke\" transaction. The \"revoke\" transaction simply spends funds back to the channel output and a plain kernel suffices. [Z a , Z b ] -> X, K rev Alice attempts to close old invalid state ( Y 1 ): X -> Y 1 , K nrd_a1 Bob can immediately revoke and close current state ( Y 1 -> Y 2 ): Y 1 -> ~[Z a , Z b ]~, K nrd_b1 \\ ~[Z a , Z b ]~ -> X , K rev_1 \\ X -> Y 2 , K nrd_b2 \\ => Y 1 -> Y 2 , [K nrd_b1 , K rev_1 , K nrd_b2 ] Bob publishes only the final cut-through multi-kernel transaction ( Y 1 -> Y 2 ). Bob's individual settle transaction is not revealed. Neither party can self-revoke without introducing the NRD delay. The other party always has the opportunity to revoke first. Self-revocation cannot be used to lock funds up indefinitely. HF3 (July 2020) Rollout/Deployment The following rules will be enforced during rollout as part of HF3 - Assumptions: HF3 will occur at height 786,240. Blocks at height >= 786,240 will have block version >= 4. Block Specific Rules: A block containing NRD kernel(s) is only be valid if block version >= 4. A block containing NRD kernel(s) is only valid if all defined relative lock height rules are met. Two duplicate NRD kernel instances cannot exist in the same block. Transaction Specific Rules: A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless chain head version >= 4. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless chain head version >= 4. A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless it meets the defined relative lock height rule in the next block. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless it meets the defined relative lock height rule in the next block. Two duplicate NRD kernel instances cannot exist in the txpool/stempool concurrently.","title":"Payment Channel Implementation"},{"location":"wiki/miscellaneous/nrd-kernels/#weights-fees","text":"For the purpose of block weight calculations, each kernel is treated as 3 \"weight units\" where each unit is approximately 32 bytes. This covers the excess commitment and the associated signature common across all kernel variants. The additional 2 bytes of \"relative height\" on NRD kernels are ignored for the purposes of calculating block weight. For the purpose of minimum transaction relay fees all kernels are treated as 1 \"fee unit\" with each unit being 1 milligrin. We plan to revisit the entire transaction fee structure in a future RFC. Kernel variants may affect the transaction fee calculations differently in the future.","title":"Weights &amp; Fees"},{"location":"wiki/miscellaneous/nrd-kernels/#drawbacks","text":"NRD kernels are a limited and restricted form of \"relative locks\" between kernels. These locks are limited to a period of 7 days and \"fail open\" beyond that window. This approach meets the requirements for limited revocable payment channel operations but there are likely to be use cases where this approach is not sufficient or unsuitable. While it would be nice to provide a fully general purpose solution that would allow arbitrary locks to be implemented, it does appear to be hard, if not impossible, to do this in Grin/MW.","title":"Drawbacks"},{"location":"wiki/miscellaneous/nrd-kernels/#rationale-and-alternatives","text":"Referencing historical data in Grin and in Mimblewimble in general is difficult due to the possibility of pruning historical data. It is not possible to reference old outputs once they are spent. Historical validators must have access to any referenced data to validate consensus rules. This leaves transaction kernels as the only available data to be referenced. While arbitrary historical kernels can be referenced this is not desirable as we do not want to impose additional constraints on nodes, requiring them to maintain historical data that would otherwise be prunable. An earlier design iteration was \"No Such Kernel Recently\" (NSKR) locks. Where NRD references were implicit, with duplicate kernel excess commitments, NSKR kernels referenced prior kernels explicitly. These explicit references were problematic for several reasons - Additional overhead, both local storage and network traffic due to the explicit references. Optimization by referencing prior kernel based on MMR position introduced a dependency on external data (kernels can no longer be validated in isolation). Permitting non-existence of references due to limited window of history, opened up a vector for \"spam\" where arbitrary data could be used in place of a valid reference. To prevent \"spam\" a signature can be used to verify the reference was indeed a valid commitment. By including a signature along with the commitment, the reference is effectively a full transaction kernel. The idea of using Merkle proofs to verify inclusion of a historical referenced kernel in the kernel MMR was also considered. This gets expensive both in terms of transaction size and increased verification cost. There is also the problem of position not yet being known at transaction creation time, necessitating Merkle proof generation at block creation time by miners which adds complexity.","title":"Rationale and alternatives"},{"location":"wiki/miscellaneous/nrd-kernels/#prior-art","text":"Bitcoin allows transaction inputs to be \"encumbered\" with a relative locktime based on the sequence number field. This restricts an input from spending the associated output until a certain number of blocks have passed. BIP112 describes the CHECKSEQUENCEVERIFY opcode in Bitcoin and BIP68 describes the underlying consensus changes around the sequence number field. [Timelock#CheckSequenceVerify (bitcoin wiki)] 6 [CheckSequenceVerify (bitcoin wiki)] 7 [Bitcoin BIP-0068] 8 [Bitcoin BIP-0112] 9 Note that relative locks in Bitcoin are based on transaction inputs and outputs , with inputs only able to spend outputs once confirmed beneath a certain number of blocks. We cannot do this in Grin due to the pruning of old data. Spent outputs will eventually be removed and cannot be relied upon as part of the validation process. Bitcoin encumbers individual outputs whereas in Grin we encumber transactions via the constituent transaction kernels.","title":"Prior art"},{"location":"wiki/miscellaneous/nrd-kernels/#unresolved-questions","text":"Some investigation is still needed around the conditions necessary to allow a kernel to simply be reused with an adjustment to the kernel offset and where an additional kernel is necessary. An adjustment to the kernel offset will expose the private excess under certain conditions and cannot be done safely for all transactions. One outstanding question is what use cases are not covered by NRD kernels. We believe them to be sufficient for the revocable payment channel close mechanism. But they may not be sufficient for all use cases. [Succinct Atomic Swaps (SAS)] 10 describes the use of both relative locks and [adaptor signatures] 11 to implement atomic swaps with only two on-chain transactions. The secret associated with the adaptor signature is swapped to allow funds to be claimed while the relative lock locks funds prior to a refund being claimed. We note that NRD kernels and adaptor signatures are not directly compatible as a prior instance of an NRD kernel would have revealed the secret associated with the adaptor signature. That said we can produce transactions with multiple kernels and we can use this to isolate the adaptor signature on a separate kernel alongside an NRD kernel. It is an unresolved question if there is a way to modify the SAS protocol and avoid the need for these additional kernels in Grin/MW.","title":"Unresolved questions"},{"location":"wiki/miscellaneous/nrd-kernels/#references","text":"Original \"triggers\" mailing list post by Ruben Somsen \u21a9 \"No Such Kernel Recently\" post by John Tromp \u21a9 \"Duplicate Kernels\" post by Antioch \u21a9 \"NRD based payment channel\" post by John Tromp \u21a9 Earlier NSKR based payment channel design \u21a9 Timelock#CheckSequenceVerify (bitcoin wiki) \u21a9 CheckSequenceVerify (bitcoin wiki) \u21a9 Bitcoin BIP-0068 \u21a9 Bitcoin BIP-0112 \u21a9 Succinct Atomic Swaps by Ruben Somsen \u21a9 \u21a9 Scriptless Scripts \u21a9 \u21a9 RFC-0005 \"Variable Size Kernels\" \u21a9","title":"References"},{"location":"wiki/miscellaneous/switch-commitments/","text":"Introduction to Switch Commitments Read this in other languages: \u7b80\u4f53\u4e2d\u6587 . General introduction In cryptography a Commitment (or commitment scheme ) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public). The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person. They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \" committed \" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing. Examples Hash Commitment A simple commitment scheme can be realized with a cryptographic hash function. For example: Alice and Bob want to play \"Guess my number\" and Alice comes up with with her really secret number 29 which Bob has to guess in the game, then before the game starts, Alice calculates: hash( 29 + r ) and publishes the result to Bob. The r is a randomly chosen Blinding Factor which is needed because otherwise Bob could just try hashing all the possible numbers for the game and compare the hashes. When the game is finished, Alice simply needs to publish her secret number 29 and the blinding factor r and Bob can calculate the hash himself and easily verify that Alice did not change the secret number during the game. Pedersen Commitment Other, more advanced commitment schemes can have additional properties. For example Mimblewimble and Confidential Transactions (CT) make heavy use of Pedersen Commitments , which are homomorphic commitments. Homomorphic in this context means that (speaking in the \"box\" metaphor from above) you can take two of these locked boxes ( box1 and box2 ) and somehow \" add \" them together, so that you get a single box as result (which still is locked), and if you open this single box later (like in the examples before) the secret it contains, is the sum of the secrets from box1 and box2 . While this \"box\" metaphor no longer seems to be reasonable in the real-world this is perfectly possible using the properties of operations on elliptic curves. Look into Introduction to Mimblewimble for further details on Pedersen Commitments and how they are used in Grin. Properties of commitment schemes: In general for any commitment scheme we can identify two important properties which can be weaker or stronger, depending on the type of commitment scheme: Hidingness (or Confidentiality): How good is the commitment scheme protecting the secret commitment. Or speaking in terms of our example from above: what would an attacker need to open the box (and learn the secret number) without having the key to unlock it? Bindingness: Is it possible at all (or how hard would it be) for an attacker to somehow find a different secret, which would produce the same commitment, so that the attacker could later open the commitment to a different secret, thus breaking the binding of the commitment. Security of these properties: For these two properties different security levels can be identified. The two most important combinations of these are perfectly binding and computationally hiding commitment schemes and computationally binding and perfectly hiding commitment schemes \" Computationally \" binding or hiding means that the property (bindingness/hidingness) is secured by the fact that the underlying mathematical problem is too hard to be solved with existing computing power in reasonable time (i.e. not breakable today as computational resources are bound in the real world). \" Perfectly \" binding or hiding means that even with infinite computing power it would be impossible to break the property (bindingness/hidingness). Mutual exclusivity: It is important to realize that it's impossible that any commitment scheme can be perfectly binding and perfectly hiding at the same time. This can be easily shown with a thought experiment: Imagine an attacker having infinite computing power, he could simply generate a commitment for all possible values (and blinding factors) until finding a pair that outputs the same commitment. If we further assume the commitment scheme is perfectly binding (meaning there cannot be two different values leading to the same commitment) this uniquely would identify the value within the commitment, thus breaking the hidingness. The same is true the other way around. If a commitment scheme is perfectly hiding there must exist several input values resulting in the same commitment (otherwise an attacker with infinite computing power could just try all possible values as described above). This concludes that the commitment scheme cannot be perfectly binding . Always a compromise The key take-away point is this: it's always a compromise , you can never have both properties ( hidingness and bindingness ) with perfect security. If one is perfectly secure then the other can be at most computationally secure (and the other way around). Considerations for cryptocurrencies Which roles do these properties play in the design of cryptocurrencies? Hidingness : In privacy oriented cryptocurrencies like Grin, commitment schemes are used to secure the contents of transactions. The sender commits to an amount of coins he sends, but for the general public the concrete amount should remain private (protected by the hidingness property of the commitment scheme). Bindingness : At the same time no transaction creator should ever be able to change his commitment to a different transaction amount later in time. If this would be possible, an attacker could spend more coins than previously committed to in an UTXO (unspent transaction output) and therefore inflate coins out of thin air. Even worse, as the amounts are hidden, this could go undetected. So there is a valid interest in having both of these properties always secured and never be violated. Even with the intent being that both of these properties will hold for the lifetime of a cryptocurrency, still a choice has to be made about which commitment scheme to use. A hard choice? Which one of these two properties needs to be perfectly safe and for which one it would be sufficient to be computationally safe? Or in other words: in case of a disaster, if the commitment scheme unexpectedly gets broken, which one of the two properties should be valued higher? Economical soundness (no hidden inflation possible) or ensured privacy (privacy will be preserved)? This seems like a hard to choice to make. If we look closer into this we realize that the commitment scheme only needs to be perfectly binding at the point in time when the scheme actually gets broken. Until then it will be safe even if it's only computationally binding. At the same time a privacy-oriented cryptocurrency needs to ensure the hidingness property forever . Unlike the binding property, which only is important at the time when a transaction is created and will not affect past transactions, the hidingness property must be ensured at all times. Otherwise, in the unfortunate case should the commitment scheme be broken, an attacker could go back in the chain and unblind past transactions, thus break the privacy property retroactively. Properties of Pedersen Commitments Pedersen Commitments are computationally binding and perfectly hiding as for a given commitment to the value v : v*H + r*G there may exist a pair of different values r1 and v1 such that the sum will be the same. Even if you have infinite computing power and could try all possible values, you would not be able to tell which one is the original one (thus perfectly hiding ). Introducing Switch Commitments So what can be done if the bindingness of the Pedersen Commitment unexpectedly gets broken? In general a cryptocurrency confronted with a broken commitment scheme could choose to change the scheme in use, but the problem with this approach would be that it requires to create new transaction outputs using the new scheme to make funds secure again. This would require every coin holder to move his coins into new transaction outputs. If coins are not moved into new outputs, they will not profit from the security of the new commitment scheme. Also, this has to happen before the scheme gets actually broken in the wild, otherwise the existing UTXOs no longer can be assumed to contain correct values. In this situation Switch Commitments offer a neat solution. These type of commitments allow changing the properties of the commitments just by changing the revealing / validating procedure without changing the way commitments are created. (You \" switch \" to a new validation scheme which is backwards compatible with commitments created long before the actual \" switch \"). How does this work in detail First let's introduce a new commitment scheme: The ElGamal commitment scheme is a commitment scheme similiar to Pedersen Commitments and it's perfectly binding (but only computationally hiding as we can never have both). It looks very similar to a Pedersen Commitment, with the addition of a new element, calculated by multiplying the blinding factor r with another generator point J : v*H + r*G , r*J So if we store the additional field r*J and ignore it for now, we can treat it like Pedersen Commitments, until we decide to also validate the full ElGamal commitment at some time in future. This is exactly what was implemented in an earlier version of Grin , before mainnet was launched. In detail: the hashed value of r*J ( switch_commit_hash ) was added to the transaction output, but this came with the burden of increasing the size of each output by 32 bytes. Fortunately, later on the Mimblewimble mailinglist Tim Ruffing came up with a really beautiful idea (initially suggested by Pieter Wuille), which offers the same advantages but doesn't need this extra storage of an additional element per transaction output: The idea is the following: A normal Pedersen commitment looks like this: v*H + r*G ( v is value of the input/output, r is a truly random blinding factor, and H and G are two generator points on the elliptic curve). If we adapt this by having r not being random itself, but using another random number r' and create the Pedersen Commitment: v*H + r*G such that: r = r' + hash( v*H + r'*G , r'*J ) (using the additional third generation point J on the curve) then r still is perfectly valid as a blinding factor, as it's still randomly distributed, but now we see that the part within the brackets of the hash function ( v*H + r'*G , r'*J ) is an ElGamal commitment . This neat idea lead to the removal of the switch commitment hash from the outputs in this (and following) pull requests as now it could be easily included into the Pedersen Commitments. This is how it is currently implemented in Grin. Pedersen commitments are used for the Confidential Transaction but instead of choosing the blinding factor r only by random, it is calculated by adding the hash of an ElGamal commitment to a random r' (see here in main_impl.h#L267 ). In general switch commitments were first described in the paper \"Switch Commitments: A Safety Switch for Confidential Transactions\" ). The \"switch\" in the name comes from the fact that you can virtually flip a \"switch\" in the future and simply by changing the validation procedure you can change the strength of the bindingness and hidingness property of your commitments and this even works in a backwards compatible way with commitments created today. Conclusion Grin uses Pedersen Commitments - like other privacy cryptocurrencies do as well - with the only difference that the random blinding factor r is created using the ElGamal commitment scheme. This might not seem like a big change on a first look, but it provides an important safety measure: Pedersen Commitments are already perfectly hiding so whatever happens, privacy will never be at risk without requiring any action from users. But in case of a disaster if the bindingness of the commitment scheme gets broken, then switch commitments can be enabled (via a soft fork) requiring that all new transactions prove that their commitment is not breaking the bindingness by validating the full ElGamal commitment. But in this case users would still have a choice: they can decide to continue to create new transactions, even if this might compromise their privacy (only on their last UTXOs) as the ElGamal commitment scheme is only computationally hiding, but at least they would still have access to their coins or users can decide to just leave the money alone, walk away and make no more transactions (but preserve their privacy, as their old transactions only validated the Pedersen commitment which is perfectly hiding) There are many cases where a privacy leak is much more dangerous to one's life than some cryptocurrency might be worth. But this is a decision that should be left up to the individual user and switch commitments enable this type of choice. It should be made clear that this is a safety measure meant to be enabled in case of a disaster. If advances in computing would put the hardness of the discrete log problem in question, a lot of other cryptographic systems, including other cryptocurrencies, will be in urgent need of updating their primitives to a future-proof system. The switch commitments just provide an additional layer of security if the bindingness of Pedersen commitments ever breaks unexpectedly.","title":"Switch Commitments"},{"location":"wiki/miscellaneous/switch-commitments/#introduction-to-switch-commitments","text":"Read this in other languages: \u7b80\u4f53\u4e2d\u6587 .","title":"Introduction to Switch Commitments"},{"location":"wiki/miscellaneous/switch-commitments/#general-introduction","text":"In cryptography a Commitment (or commitment scheme ) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public). The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person. They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \" committed \" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing.","title":"General introduction"},{"location":"wiki/miscellaneous/switch-commitments/#examples","text":"","title":"Examples"},{"location":"wiki/miscellaneous/switch-commitments/#hash-commitment","text":"A simple commitment scheme can be realized with a cryptographic hash function. For example: Alice and Bob want to play \"Guess my number\" and Alice comes up with with her really secret number 29 which Bob has to guess in the game, then before the game starts, Alice calculates: hash( 29 + r ) and publishes the result to Bob. The r is a randomly chosen Blinding Factor which is needed because otherwise Bob could just try hashing all the possible numbers for the game and compare the hashes. When the game is finished, Alice simply needs to publish her secret number 29 and the blinding factor r and Bob can calculate the hash himself and easily verify that Alice did not change the secret number during the game.","title":"Hash Commitment"},{"location":"wiki/miscellaneous/switch-commitments/#pedersen-commitment","text":"Other, more advanced commitment schemes can have additional properties. For example Mimblewimble and Confidential Transactions (CT) make heavy use of Pedersen Commitments , which are homomorphic commitments. Homomorphic in this context means that (speaking in the \"box\" metaphor from above) you can take two of these locked boxes ( box1 and box2 ) and somehow \" add \" them together, so that you get a single box as result (which still is locked), and if you open this single box later (like in the examples before) the secret it contains, is the sum of the secrets from box1 and box2 . While this \"box\" metaphor no longer seems to be reasonable in the real-world this is perfectly possible using the properties of operations on elliptic curves. Look into Introduction to Mimblewimble for further details on Pedersen Commitments and how they are used in Grin.","title":"Pedersen Commitment"},{"location":"wiki/miscellaneous/switch-commitments/#properties-of-commitment-schemes","text":"In general for any commitment scheme we can identify two important properties which can be weaker or stronger, depending on the type of commitment scheme: Hidingness (or Confidentiality): How good is the commitment scheme protecting the secret commitment. Or speaking in terms of our example from above: what would an attacker need to open the box (and learn the secret number) without having the key to unlock it? Bindingness: Is it possible at all (or how hard would it be) for an attacker to somehow find a different secret, which would produce the same commitment, so that the attacker could later open the commitment to a different secret, thus breaking the binding of the commitment.","title":"Properties of commitment schemes:"},{"location":"wiki/miscellaneous/switch-commitments/#security-of-these-properties","text":"For these two properties different security levels can be identified. The two most important combinations of these are perfectly binding and computationally hiding commitment schemes and computationally binding and perfectly hiding commitment schemes \" Computationally \" binding or hiding means that the property (bindingness/hidingness) is secured by the fact that the underlying mathematical problem is too hard to be solved with existing computing power in reasonable time (i.e. not breakable today as computational resources are bound in the real world). \" Perfectly \" binding or hiding means that even with infinite computing power it would be impossible to break the property (bindingness/hidingness).","title":"Security of these properties:"},{"location":"wiki/miscellaneous/switch-commitments/#mutual-exclusivity","text":"It is important to realize that it's impossible that any commitment scheme can be perfectly binding and perfectly hiding at the same time. This can be easily shown with a thought experiment: Imagine an attacker having infinite computing power, he could simply generate a commitment for all possible values (and blinding factors) until finding a pair that outputs the same commitment. If we further assume the commitment scheme is perfectly binding (meaning there cannot be two different values leading to the same commitment) this uniquely would identify the value within the commitment, thus breaking the hidingness. The same is true the other way around. If a commitment scheme is perfectly hiding there must exist several input values resulting in the same commitment (otherwise an attacker with infinite computing power could just try all possible values as described above). This concludes that the commitment scheme cannot be perfectly binding .","title":"Mutual exclusivity:"},{"location":"wiki/miscellaneous/switch-commitments/#always-a-compromise","text":"The key take-away point is this: it's always a compromise , you can never have both properties ( hidingness and bindingness ) with perfect security. If one is perfectly secure then the other can be at most computationally secure (and the other way around).","title":"Always a compromise"},{"location":"wiki/miscellaneous/switch-commitments/#considerations-for-cryptocurrencies","text":"Which roles do these properties play in the design of cryptocurrencies? Hidingness : In privacy oriented cryptocurrencies like Grin, commitment schemes are used to secure the contents of transactions. The sender commits to an amount of coins he sends, but for the general public the concrete amount should remain private (protected by the hidingness property of the commitment scheme). Bindingness : At the same time no transaction creator should ever be able to change his commitment to a different transaction amount later in time. If this would be possible, an attacker could spend more coins than previously committed to in an UTXO (unspent transaction output) and therefore inflate coins out of thin air. Even worse, as the amounts are hidden, this could go undetected. So there is a valid interest in having both of these properties always secured and never be violated. Even with the intent being that both of these properties will hold for the lifetime of a cryptocurrency, still a choice has to be made about which commitment scheme to use.","title":"Considerations for cryptocurrencies"},{"location":"wiki/miscellaneous/switch-commitments/#a-hard-choice","text":"Which one of these two properties needs to be perfectly safe and for which one it would be sufficient to be computationally safe? Or in other words: in case of a disaster, if the commitment scheme unexpectedly gets broken, which one of the two properties should be valued higher? Economical soundness (no hidden inflation possible) or ensured privacy (privacy will be preserved)? This seems like a hard to choice to make. If we look closer into this we realize that the commitment scheme only needs to be perfectly binding at the point in time when the scheme actually gets broken. Until then it will be safe even if it's only computationally binding. At the same time a privacy-oriented cryptocurrency needs to ensure the hidingness property forever . Unlike the binding property, which only is important at the time when a transaction is created and will not affect past transactions, the hidingness property must be ensured at all times. Otherwise, in the unfortunate case should the commitment scheme be broken, an attacker could go back in the chain and unblind past transactions, thus break the privacy property retroactively.","title":"A hard choice?"},{"location":"wiki/miscellaneous/switch-commitments/#properties-of-pedersen-commitments","text":"Pedersen Commitments are computationally binding and perfectly hiding as for a given commitment to the value v : v*H + r*G there may exist a pair of different values r1 and v1 such that the sum will be the same. Even if you have infinite computing power and could try all possible values, you would not be able to tell which one is the original one (thus perfectly hiding ).","title":"Properties of Pedersen Commitments"},{"location":"wiki/miscellaneous/switch-commitments/#introducing-switch-commitments","text":"So what can be done if the bindingness of the Pedersen Commitment unexpectedly gets broken? In general a cryptocurrency confronted with a broken commitment scheme could choose to change the scheme in use, but the problem with this approach would be that it requires to create new transaction outputs using the new scheme to make funds secure again. This would require every coin holder to move his coins into new transaction outputs. If coins are not moved into new outputs, they will not profit from the security of the new commitment scheme. Also, this has to happen before the scheme gets actually broken in the wild, otherwise the existing UTXOs no longer can be assumed to contain correct values. In this situation Switch Commitments offer a neat solution. These type of commitments allow changing the properties of the commitments just by changing the revealing / validating procedure without changing the way commitments are created. (You \" switch \" to a new validation scheme which is backwards compatible with commitments created long before the actual \" switch \").","title":"Introducing Switch Commitments"},{"location":"wiki/miscellaneous/switch-commitments/#how-does-this-work-in-detail","text":"First let's introduce a new commitment scheme: The ElGamal commitment scheme is a commitment scheme similiar to Pedersen Commitments and it's perfectly binding (but only computationally hiding as we can never have both). It looks very similar to a Pedersen Commitment, with the addition of a new element, calculated by multiplying the blinding factor r with another generator point J : v*H + r*G , r*J So if we store the additional field r*J and ignore it for now, we can treat it like Pedersen Commitments, until we decide to also validate the full ElGamal commitment at some time in future. This is exactly what was implemented in an earlier version of Grin , before mainnet was launched. In detail: the hashed value of r*J ( switch_commit_hash ) was added to the transaction output, but this came with the burden of increasing the size of each output by 32 bytes. Fortunately, later on the Mimblewimble mailinglist Tim Ruffing came up with a really beautiful idea (initially suggested by Pieter Wuille), which offers the same advantages but doesn't need this extra storage of an additional element per transaction output: The idea is the following: A normal Pedersen commitment looks like this: v*H + r*G ( v is value of the input/output, r is a truly random blinding factor, and H and G are two generator points on the elliptic curve). If we adapt this by having r not being random itself, but using another random number r' and create the Pedersen Commitment: v*H + r*G such that: r = r' + hash( v*H + r'*G , r'*J ) (using the additional third generation point J on the curve) then r still is perfectly valid as a blinding factor, as it's still randomly distributed, but now we see that the part within the brackets of the hash function ( v*H + r'*G , r'*J ) is an ElGamal commitment . This neat idea lead to the removal of the switch commitment hash from the outputs in this (and following) pull requests as now it could be easily included into the Pedersen Commitments. This is how it is currently implemented in Grin. Pedersen commitments are used for the Confidential Transaction but instead of choosing the blinding factor r only by random, it is calculated by adding the hash of an ElGamal commitment to a random r' (see here in main_impl.h#L267 ). In general switch commitments were first described in the paper \"Switch Commitments: A Safety Switch for Confidential Transactions\" ). The \"switch\" in the name comes from the fact that you can virtually flip a \"switch\" in the future and simply by changing the validation procedure you can change the strength of the bindingness and hidingness property of your commitments and this even works in a backwards compatible way with commitments created today.","title":"How does this work in detail"},{"location":"wiki/miscellaneous/switch-commitments/#conclusion","text":"Grin uses Pedersen Commitments - like other privacy cryptocurrencies do as well - with the only difference that the random blinding factor r is created using the ElGamal commitment scheme. This might not seem like a big change on a first look, but it provides an important safety measure: Pedersen Commitments are already perfectly hiding so whatever happens, privacy will never be at risk without requiring any action from users. But in case of a disaster if the bindingness of the commitment scheme gets broken, then switch commitments can be enabled (via a soft fork) requiring that all new transactions prove that their commitment is not breaking the bindingness by validating the full ElGamal commitment. But in this case users would still have a choice: they can decide to continue to create new transactions, even if this might compromise their privacy (only on their last UTXOs) as the ElGamal commitment scheme is only computationally hiding, but at least they would still have access to their coins or users can decide to just leave the money alone, walk away and make no more transactions (but preserve their privacy, as their old transactions only validated the Pedersen commitment which is perfectly hiding) There are many cases where a privacy leak is much more dangerous to one's life than some cryptocurrency might be worth. But this is a decision that should be left up to the individual user and switch commitments enable this type of choice. It should be made clear that this is a safety measure meant to be enabled in case of a disaster. If advances in computing would put the hardness of the discrete log problem in question, a lot of other cryptographic systems, including other cryptocurrencies, will be in urgent need of updating their primitives to a future-proof system. The switch commitments just provide an additional layer of security if the bindingness of Pedersen commitments ever breaks unexpectedly.","title":"Conclusion"},{"location":"wiki/security-process/code-audits/","text":"Code Audits Continued code reviews and audits are important for the security of Grin. As such, we highly encourage interested security researchers to: Review our code, even if no contributions are planned. Publish their findings in accordance with our responsible disclosure standard , even if no particular bug or vulnerability was found. We can all learn from new sets of eyes and benefit from increased scrutiny. While we may disagree with some small points of design or trade-offs, we will always do so respectfully. All code review and audit contributions are welcome regardless of depth, area or background of the contributor. Many contributions from many different perspectives can help ensure long term security for the Grin codebase. A complete list of PGP keys, canaries, CVEs and audits can be found in the grin-security repository. Past Audits Audit Results JP Aumasson, secp256k1 extensions report - status Coinspect, code audit v1.0.1 report - status Nym Seddon, code audit v4.0.0 report - status","title":"Code Audits"},{"location":"wiki/security-process/code-audits/#code-audits","text":"Continued code reviews and audits are important for the security of Grin. As such, we highly encourage interested security researchers to: Review our code, even if no contributions are planned. Publish their findings in accordance with our responsible disclosure standard , even if no particular bug or vulnerability was found. We can all learn from new sets of eyes and benefit from increased scrutiny. While we may disagree with some small points of design or trade-offs, we will always do so respectfully. All code review and audit contributions are welcome regardless of depth, area or background of the contributor. Many contributions from many different perspectives can help ensure long term security for the Grin codebase. A complete list of PGP keys, canaries, CVEs and audits can be found in the grin-security repository.","title":"Code Audits"},{"location":"wiki/security-process/code-audits/#past-audits","text":"Audit Results JP Aumasson, secp256k1 extensions report - status Coinspect, code audit v1.0.1 report - status Nym Seddon, code audit v4.0.0 report - status","title":"Past Audits"},{"location":"wiki/security-process/grin-security-process/","text":"Grin's Security Process Grin has a code of conduct and the handling of vulnerability disclosure is no exception. We are committed to conduct our security process in a professional and civil manner. Public shaming, under-reporting or misrepresentation of vulnerabilities will not be tolerated. Responsible Disclosure Standard Grin follows a community standard for responsible disclosure in cryptocurrency and related software. This document is a public commitment to following the standard. This standard provides detailed information for: Initial Contact : how the initial contact process works Giving Details : what details to include with your disclosure after receiving a response to your initial contact Setting Dates : details for when to release updates and publicize details of the issue Any expected deviations and necessary clarifications around the standard are explained in the following sections. Receiving Disclosures We are committed to working with researchers who submit security vulnerability notifications to us, to resolve those issues on an appropriate timeline and perform a coordinated release, giving credit to the reporter if they would like. Please submit issues to all of the following main points of contact for security related issues according to the initial contact and details guidelines. More information is available about the expected timelines for the full disclosure cycle . For all security related issues, there are 3 main points of contact : Daniel Lehnberg, daniel.lehnberg at protonmail.com PGP key John Woeltz, joltz at protonmail.com PGP key Send all communications PGP encrypted to all parties. Sending Disclosures In the case where we become aware of security issues affecting other projects that has never affected Grin, our intention is to inform those projects of security issues on a best effort basis. In the case where we fix a security issue in Grin that also affects the following neighboring projects, our intention is to engage in responsible disclosures with them as described in the adopted standard , subject to the deviations described in the deviations section of this document. Bilateral Responsible Disclosure Agreements Grin does not currently have any established bilateral disclosure agreements. Recognition and Bug Bounties Grin's responsible disclosure standard includes some general language about Bounty Payments and Acknowledgements . Grin is a traditional open source project with limited to no direct funding . As such, we have little means with which to compensate security researchers for their contributions. We recognize this is a shame and intend to do our best to still make these worth while by: Advertising the vulnerability, the researchers, or their team on a public page linked from our website, with a links of their choosing. Acting as reference whenever this is needed. Setting up retroactive bounties whenever possible. There is not currently a formal bug bounty program for Grin as it would require a high level of resources and engagement to operate in good faith. More funding can help provide the necessary resources to run one in the future for the Grin community. Deviations from the Standard Grin is a technology that provides strong privacy with zero-knowledge commitments and rangeproofs. Due to the nature of the cryptography used, if a counterfeiting bug results it could be exploited without a way to identify which data was corrupted. This renders rollbacks or other fork-based attempted fixes ineffective. The standard describes reporters of vulnerabilities including full details of an issue, in order to reproduce it. This is necessary for instance in the case of an external researcher both demonstrating and proving that there really is a security issue, and that security issue really has the impact that they say it has - allowing the development team to accurately prioritize and resolve the issue. In the case of a counterfeiting or privacy-breaking bug, however, we might decide not to include those details with our reports to partners ahead of coordinated release, so long as we are sure that they are vulnerable. More Information Additional security-related information about the Grin project including previous audits, CVEs, canaries, signatures and PGP public keys can be found in the grin-security repository.","title":"Grin's Security Process"},{"location":"wiki/security-process/grin-security-process/#grins-security-process","text":"Grin has a code of conduct and the handling of vulnerability disclosure is no exception. We are committed to conduct our security process in a professional and civil manner. Public shaming, under-reporting or misrepresentation of vulnerabilities will not be tolerated.","title":"Grin's Security Process"},{"location":"wiki/security-process/grin-security-process/#responsible-disclosure-standard","text":"Grin follows a community standard for responsible disclosure in cryptocurrency and related software. This document is a public commitment to following the standard. This standard provides detailed information for: Initial Contact : how the initial contact process works Giving Details : what details to include with your disclosure after receiving a response to your initial contact Setting Dates : details for when to release updates and publicize details of the issue Any expected deviations and necessary clarifications around the standard are explained in the following sections.","title":"Responsible Disclosure Standard"},{"location":"wiki/security-process/grin-security-process/#receiving-disclosures","text":"We are committed to working with researchers who submit security vulnerability notifications to us, to resolve those issues on an appropriate timeline and perform a coordinated release, giving credit to the reporter if they would like. Please submit issues to all of the following main points of contact for security related issues according to the initial contact and details guidelines. More information is available about the expected timelines for the full disclosure cycle . For all security related issues, there are 3 main points of contact : Daniel Lehnberg, daniel.lehnberg at protonmail.com PGP key John Woeltz, joltz at protonmail.com PGP key Send all communications PGP encrypted to all parties.","title":"Receiving Disclosures"},{"location":"wiki/security-process/grin-security-process/#sending-disclosures","text":"In the case where we become aware of security issues affecting other projects that has never affected Grin, our intention is to inform those projects of security issues on a best effort basis. In the case where we fix a security issue in Grin that also affects the following neighboring projects, our intention is to engage in responsible disclosures with them as described in the adopted standard , subject to the deviations described in the deviations section of this document.","title":"Sending Disclosures"},{"location":"wiki/security-process/grin-security-process/#bilateral-responsible-disclosure-agreements","text":"Grin does not currently have any established bilateral disclosure agreements.","title":"Bilateral Responsible Disclosure Agreements"},{"location":"wiki/security-process/grin-security-process/#recognition-and-bug-bounties","text":"Grin's responsible disclosure standard includes some general language about Bounty Payments and Acknowledgements . Grin is a traditional open source project with limited to no direct funding . As such, we have little means with which to compensate security researchers for their contributions. We recognize this is a shame and intend to do our best to still make these worth while by: Advertising the vulnerability, the researchers, or their team on a public page linked from our website, with a links of their choosing. Acting as reference whenever this is needed. Setting up retroactive bounties whenever possible. There is not currently a formal bug bounty program for Grin as it would require a high level of resources and engagement to operate in good faith. More funding can help provide the necessary resources to run one in the future for the Grin community.","title":"Recognition and Bug Bounties"},{"location":"wiki/security-process/grin-security-process/#deviations-from-the-standard","text":"Grin is a technology that provides strong privacy with zero-knowledge commitments and rangeproofs. Due to the nature of the cryptography used, if a counterfeiting bug results it could be exploited without a way to identify which data was corrupted. This renders rollbacks or other fork-based attempted fixes ineffective. The standard describes reporters of vulnerabilities including full details of an issue, in order to reproduce it. This is necessary for instance in the case of an external researcher both demonstrating and proving that there really is a security issue, and that security issue really has the impact that they say it has - allowing the development team to accurately prioritize and resolve the issue. In the case of a counterfeiting or privacy-breaking bug, however, we might decide not to include those details with our reports to partners ahead of coordinated release, so long as we are sure that they are vulnerable.","title":"Deviations from the Standard"},{"location":"wiki/security-process/grin-security-process/#more-information","text":"Additional security-related information about the Grin project including previous audits, CVEs, canaries, signatures and PGP public keys can be found in the grin-security repository.","title":"More Information"},{"location":"wiki/security-process/security-team/","text":"Security Team Title: security-team Authors: joltz Start date: Jan 22 2020 RFC PR: mimblewimble/grin-rfcs#39 Tracking issue: mimblewimble/grin-pm/#258 Summary The security team for Grin carries out the security priorities of the Grin community and core team, which are to be defined prior to formation of the team. The security team streamlines the security decision making process for the core team while maintaining a careful balance of security and transparency for the community. Motivation Improve transparency, efficiency, decisiveness and scalability around security-related decision making Dedicated support for security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work Increase confidence in the ecosystem for future contributions A clear and structured decision making process is needed to fully support the current security process as well as community initiatives such as bilateral disclosure agreements, bug bounty programs and future audit work. This process was previously maintained by the core team who had many areas of focus, leading to a lack of clarity, timeliness and ability to decisively execute on community security initiatives. The security team frees up core resources to focus on other important areas while expanding dedicated resources to security work, allowing the Grin ecosystem to continue to scale. A clear decision making structure around the security process instills confidence in the greater ecosystem and encourages projects, developers and users to continue to increase contributions of time and resources into Grin. Community-level explanation Grin's security team is responsible for making predefined security related decisions for the Grin project. This includes, but is not limited to, decisions about the specification and implementation of Grin's security processes. As much as possible Grin's security team carries out the security priorities of the community and core team in a transparent manner. There may be some unique security-related cases that require the security team to make some decisions in private to protect the security of Grin users. In these cases, once it is safe to do so, the security team is responsible for sharing as many details as possible with the community for transparency and accountability purposes. The primary day-to-day impact this will have on the community is making available structured support around security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work. The community and other teams will have regular opportunity to interact with, provide input to and receive input from the security team. Example Here we will walk through an example case that highlights how Grin's security team would operate, contrasting with the current process. In the example case, a vulnerability is disclosed to the disclosure contacts listed in Grin's security policy. It is shown that the community gains greater transparency into the decision making process and related outcomes with the proposed security team. Additionally the disclosure map is more tightly contained in the proposed process, resulting in less risk of vulnerability exploitation to the community. Previous Process Grin's security contacts make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, all details of the disclosure are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy Once the vulnerability is mitigated the core team may optionally share some of the details with the community Security Team Process Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, a conversation and plan of action is determined and executed by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated the security team must disclose all information that is not still security-critical with the community Reference-level explanation Grin's security team will be implemented as stated below. Membership Bootstrapped by existing security contacts (@lehnberg, @hashmap, @joltz) Minimum three, maximum five members Membership is recommended by the security team and approved by the core team All members must have relevant domain expertise in security, cryptography, the Grin codebase or Grin community All members must have high competency in maintaining personal operational security (keeping private keys secure, maintaining secure communications channels etc.) Membership is revoked by failure to update the canary, unanimous decision by team or decision from the core team Note if the core team engages in removing members from the security team without reasonable justification, the security team loses purpose, becomes ineffective and is relegated to useless security theater Decision Making Distinction between security-team decisions and security-related decisions : The security team is responsible for making predefined security-team decisions, not all possible ambiguous security-related decisions Decisions are made primarily with consideration to the security priorities outlined prior to the team's formation Unanimous approval of security team members is needed to make all impactful decisions Some decisions made must also be approved by the core team to be carried out: Adding/removing parties from disclosure agreements Adding members to the security team Updating the security policy In the event that the core team does not follow a security team recommendation, a reasonable explanation must be provided as to why the security recommendation was not followed Some decisions must be made without fully informing the core team of all details: When fixing a vulnerability requires a deviation from the standard In these cases not all information will be shared with core team, such as specific details to carry out an exploit, full impact and other relevant information that will create unnecessary risk if disclosed The core team must be notified of all cases of these decisions within a reasonable time frame that does not pose a security risk (e.g. after a fix is implemented) and provided with a reasonable explanation by the security team Vetoes Any member of the security team may veto an impactful security team decision The ability to veto an impactful security team decision is important to preserve the ability for members of the security team to make honest recommendations. Important and controversial decisions will be made and members of the security team need the ability to not sign their names to a decision they are not comfortable with that could have serious ramifications. These cases will be handled according to the Deadlocks section below. The security team should always strive to reach its own decisions. Constant vetoes and inability to reach unanimous decisions will dampen the advantages of the existence of the team and may render it obsolete. It is important to strike the right balance of different perspectives, expertise and reasonability in members to take advantage of the benefits that come with a diverse and functional security-related decision making process. Deadlocks Impactful security team decisions that can't be made unanimously by the security team will be made by the core team according to their decision making process If the core team is deadlocked, the decision made will be whichever decision, if any, will provide the end user with the greatest measure of security Deadlocks should be avoided at all costs. The inability of the security team to reach a unanimous decision based on the security priorities of Grin's community and core team should be a red flag to the community and core team for the health of the team. All members should be able to clearly discuss the factual merits of the options and reach a decision that is in the clear best possible interest for the security of Grin's ecosystem and users. Example By following the previous example in more detail, critical differences can be further explored between the current process and the proposed security team process in the handling of a unique case. In cases where fixing a vulnerability is so critical that it requires a deviation from the standard , the proposed process reduces the likelihood of the vulnerability being exploited with a focused decision making process and by restricting the details to essential persons only. Previous Process Grin's security contacts make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug All details of the disclosure, including the steps to carry out the exploit, are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy This conversation may take days or weeks as there is no particular decision making process for security-related issues Once the vulnerability is mitigated the core team may optionally share some of the details with the community Security Team Process Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug A conversation and plan of action is quickly and unanimously determined and executed on by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated, the security team must disclose all information that is not still security-critical with the community Drawbacks The core team is already busy and the formation and management of a security team may distract from other pressing and immediate issues Even though it decentralizes the core team, it potentially creates another point of centralization Adds resource overhead to the project that must be upheld (it is not acceptable to fail to follow through in security processes once established!) Possibly distracts from other important work- we don't want to spread attention too wide too early Adds bulk to Grin's governance structure The community may trust core more than a team to make critical security decisions Rationale and alternatives One alternative, currently in use, is adding the input of a security expert to the existing core decision making process This is better than nothing but we lose a few benefits without a dedicated security team: Strengthened security process: reduced likelihood of exploit leaks Improved transparency: there is currently little transparency around core's security decision making process Improved reaction times: informed, thoughtful, decisive actions with input from relevant experts only Possibility for security initiatives: clear decision making process for bilateral disclosure agreements, bug bounty programs, audit work Stronger commitments to the community, ecosystem and other projects: viable with a dedicated, clear decision making process Long-term scalability: extend capacity for security work to grow beyond the core team's attention capacity Another alternative is to rely on an open community to handle all incidents as they come in This is less desirable than both the previous process and security team process: Vulnerabilities would essentially be public before they can by mitigated There is no decision making team so mitigation actions may be slow and contentious There is no accountability to ensure that the responsible disclosure process is followed This model is much more transparent than other alternatives but comes with the unacceptable associated costs above Prior art grin-governance 1 and security-process 2 RFCs lay groundwork for the security-team RFC. Unresolved questions What are the security priorities of the Grin community and core team? (e.g. is privacy a higher priority than undetectable inflation?) Is this the most minimal model that can have long-term success for Grin's security-related decision making process? Is the single-veto model sufficient for a consistent, timely decision making process? Future possibilities Budget allocation and management Manage an allocated budget for possible initiatives Bug bounty programs Audits Full time contributors Development of security tooling Security team working groups Red team Blue team Audit team Bug bounty team Community outreach team Expanding security-team decisions Currently security-team decisions are restricted to predefined decisions around the security processes In the future security-team decisions can be expanded to include more security-related decisions References Grin's Governance RFC \u21a9 Grin's Security Proccess RFC \u21a9","title":"Security Team"},{"location":"wiki/security-process/security-team/#security-team","text":"Title: security-team Authors: joltz Start date: Jan 22 2020 RFC PR: mimblewimble/grin-rfcs#39 Tracking issue: mimblewimble/grin-pm/#258","title":"Security Team"},{"location":"wiki/security-process/security-team/#summary","text":"The security team for Grin carries out the security priorities of the Grin community and core team, which are to be defined prior to formation of the team. The security team streamlines the security decision making process for the core team while maintaining a careful balance of security and transparency for the community.","title":"Summary"},{"location":"wiki/security-process/security-team/#motivation","text":"Improve transparency, efficiency, decisiveness and scalability around security-related decision making Dedicated support for security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work Increase confidence in the ecosystem for future contributions A clear and structured decision making process is needed to fully support the current security process as well as community initiatives such as bilateral disclosure agreements, bug bounty programs and future audit work. This process was previously maintained by the core team who had many areas of focus, leading to a lack of clarity, timeliness and ability to decisively execute on community security initiatives. The security team frees up core resources to focus on other important areas while expanding dedicated resources to security work, allowing the Grin ecosystem to continue to scale. A clear decision making structure around the security process instills confidence in the greater ecosystem and encourages projects, developers and users to continue to increase contributions of time and resources into Grin.","title":"Motivation"},{"location":"wiki/security-process/security-team/#community-level-explanation","text":"Grin's security team is responsible for making predefined security related decisions for the Grin project. This includes, but is not limited to, decisions about the specification and implementation of Grin's security processes. As much as possible Grin's security team carries out the security priorities of the community and core team in a transparent manner. There may be some unique security-related cases that require the security team to make some decisions in private to protect the security of Grin users. In these cases, once it is safe to do so, the security team is responsible for sharing as many details as possible with the community for transparency and accountability purposes. The primary day-to-day impact this will have on the community is making available structured support around security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work. The community and other teams will have regular opportunity to interact with, provide input to and receive input from the security team.","title":"Community-level explanation"},{"location":"wiki/security-process/security-team/#example","text":"Here we will walk through an example case that highlights how Grin's security team would operate, contrasting with the current process. In the example case, a vulnerability is disclosed to the disclosure contacts listed in Grin's security policy. It is shown that the community gains greater transparency into the decision making process and related outcomes with the proposed security team. Additionally the disclosure map is more tightly contained in the proposed process, resulting in less risk of vulnerability exploitation to the community. Previous Process Grin's security contacts make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, all details of the disclosure are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy Once the vulnerability is mitigated the core team may optionally share some of the details with the community Security Team Process Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, a conversation and plan of action is determined and executed by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated the security team must disclose all information that is not still security-critical with the community","title":"Example"},{"location":"wiki/security-process/security-team/#reference-level-explanation","text":"Grin's security team will be implemented as stated below.","title":"Reference-level explanation"},{"location":"wiki/security-process/security-team/#membership","text":"Bootstrapped by existing security contacts (@lehnberg, @hashmap, @joltz) Minimum three, maximum five members Membership is recommended by the security team and approved by the core team All members must have relevant domain expertise in security, cryptography, the Grin codebase or Grin community All members must have high competency in maintaining personal operational security (keeping private keys secure, maintaining secure communications channels etc.) Membership is revoked by failure to update the canary, unanimous decision by team or decision from the core team Note if the core team engages in removing members from the security team without reasonable justification, the security team loses purpose, becomes ineffective and is relegated to useless security theater","title":"Membership"},{"location":"wiki/security-process/security-team/#decision-making","text":"Distinction between security-team decisions and security-related decisions : The security team is responsible for making predefined security-team decisions, not all possible ambiguous security-related decisions Decisions are made primarily with consideration to the security priorities outlined prior to the team's formation Unanimous approval of security team members is needed to make all impactful decisions Some decisions made must also be approved by the core team to be carried out: Adding/removing parties from disclosure agreements Adding members to the security team Updating the security policy In the event that the core team does not follow a security team recommendation, a reasonable explanation must be provided as to why the security recommendation was not followed Some decisions must be made without fully informing the core team of all details: When fixing a vulnerability requires a deviation from the standard In these cases not all information will be shared with core team, such as specific details to carry out an exploit, full impact and other relevant information that will create unnecessary risk if disclosed The core team must be notified of all cases of these decisions within a reasonable time frame that does not pose a security risk (e.g. after a fix is implemented) and provided with a reasonable explanation by the security team","title":"Decision Making"},{"location":"wiki/security-process/security-team/#vetoes","text":"Any member of the security team may veto an impactful security team decision The ability to veto an impactful security team decision is important to preserve the ability for members of the security team to make honest recommendations. Important and controversial decisions will be made and members of the security team need the ability to not sign their names to a decision they are not comfortable with that could have serious ramifications. These cases will be handled according to the Deadlocks section below. The security team should always strive to reach its own decisions. Constant vetoes and inability to reach unanimous decisions will dampen the advantages of the existence of the team and may render it obsolete. It is important to strike the right balance of different perspectives, expertise and reasonability in members to take advantage of the benefits that come with a diverse and functional security-related decision making process.","title":"Vetoes"},{"location":"wiki/security-process/security-team/#deadlocks","text":"Impactful security team decisions that can't be made unanimously by the security team will be made by the core team according to their decision making process If the core team is deadlocked, the decision made will be whichever decision, if any, will provide the end user with the greatest measure of security Deadlocks should be avoided at all costs. The inability of the security team to reach a unanimous decision based on the security priorities of Grin's community and core team should be a red flag to the community and core team for the health of the team. All members should be able to clearly discuss the factual merits of the options and reach a decision that is in the clear best possible interest for the security of Grin's ecosystem and users.","title":"Deadlocks"},{"location":"wiki/security-process/security-team/#example_1","text":"By following the previous example in more detail, critical differences can be further explored between the current process and the proposed security team process in the handling of a unique case. In cases where fixing a vulnerability is so critical that it requires a deviation from the standard , the proposed process reduces the likelihood of the vulnerability being exploited with a focused decision making process and by restricting the details to essential persons only. Previous Process Grin's security contacts make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug All details of the disclosure, including the steps to carry out the exploit, are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy This conversation may take days or weeks as there is no particular decision making process for security-related issues Once the vulnerability is mitigated the core team may optionally share some of the details with the community Security Team Process Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug A conversation and plan of action is quickly and unanimously determined and executed on by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated, the security team must disclose all information that is not still security-critical with the community","title":"Example"},{"location":"wiki/security-process/security-team/#drawbacks","text":"The core team is already busy and the formation and management of a security team may distract from other pressing and immediate issues Even though it decentralizes the core team, it potentially creates another point of centralization Adds resource overhead to the project that must be upheld (it is not acceptable to fail to follow through in security processes once established!) Possibly distracts from other important work- we don't want to spread attention too wide too early Adds bulk to Grin's governance structure The community may trust core more than a team to make critical security decisions","title":"Drawbacks"},{"location":"wiki/security-process/security-team/#rationale-and-alternatives","text":"One alternative, currently in use, is adding the input of a security expert to the existing core decision making process This is better than nothing but we lose a few benefits without a dedicated security team: Strengthened security process: reduced likelihood of exploit leaks Improved transparency: there is currently little transparency around core's security decision making process Improved reaction times: informed, thoughtful, decisive actions with input from relevant experts only Possibility for security initiatives: clear decision making process for bilateral disclosure agreements, bug bounty programs, audit work Stronger commitments to the community, ecosystem and other projects: viable with a dedicated, clear decision making process Long-term scalability: extend capacity for security work to grow beyond the core team's attention capacity Another alternative is to rely on an open community to handle all incidents as they come in This is less desirable than both the previous process and security team process: Vulnerabilities would essentially be public before they can by mitigated There is no decision making team so mitigation actions may be slow and contentious There is no accountability to ensure that the responsible disclosure process is followed This model is much more transparent than other alternatives but comes with the unacceptable associated costs above","title":"Rationale and alternatives"},{"location":"wiki/security-process/security-team/#prior-art","text":"grin-governance 1 and security-process 2 RFCs lay groundwork for the security-team RFC.","title":"Prior art"},{"location":"wiki/security-process/security-team/#unresolved-questions","text":"What are the security priorities of the Grin community and core team? (e.g. is privacy a higher priority than undetectable inflation?) Is this the most minimal model that can have long-term success for Grin's security-related decision making process? Is the single-veto model sufficient for a consistent, timely decision making process?","title":"Unresolved questions"},{"location":"wiki/security-process/security-team/#future-possibilities","text":"Budget allocation and management Manage an allocated budget for possible initiatives Bug bounty programs Audits Full time contributors Development of security tooling Security team working groups Red team Blue team Audit team Bug bounty team Community outreach team Expanding security-team decisions Currently security-team decisions are restricted to predefined decisions around the security processes In the future security-team decisions can be expanded to include more security-related decisions","title":"Future possibilities"},{"location":"wiki/security-process/security-team/#references","text":"Grin's Governance RFC \u21a9 Grin's Security Proccess RFC \u21a9","title":"References"},{"location":"wiki/services/list-of-services/","text":"List of Grin Services Exchanges Poloniex BitForex KuCoin Bittrex HitBTC Hotbit HBTC Gate.io Kaiserex BigONE TradeOgre Block Explorers Grinscan Grinmint Blockscan GrinExplorer Mining Pools GrinMint Sparkpool F2Pool WoolyPooly BTC.com 2Miners MinerGate","title":"List of Services"},{"location":"wiki/services/list-of-services/#list-of-grin-services","text":"","title":"List of Grin Services"},{"location":"wiki/services/list-of-services/#exchanges","text":"Poloniex BitForex KuCoin Bittrex HitBTC Hotbit HBTC Gate.io Kaiserex BigONE TradeOgre","title":"Exchanges"},{"location":"wiki/services/list-of-services/#block-explorers","text":"Grinscan Grinmint Blockscan GrinExplorer","title":"Block Explorers"},{"location":"wiki/services/list-of-services/#mining-pools","text":"GrinMint Sparkpool F2Pool WoolyPooly BTC.com 2Miners MinerGate","title":"Mining Pools"},{"location":"wiki/services/slatepack-integration/","text":"Slatepack Integration Guide Slatepack is a new transaction building standard for Grin designed to improve and simplify the transacting experience for all users. The full specification is available here Slatepack was introduced in v4.0.0. Wallets and services must fully support it by v5.0.0 (Jan 2021). Motivation Previously, users and exchanges had to decide between multiple transaction methods to find one that works for them. Transactions were commonly done through HTTPS, requiring users to open ports and configure firewalls, or with slate files which bring their own set of challenges. With Slatepack, a single standard needs to be supported. Summary The Slatepack standard eliminates the need for HTTPS or exchanging files. Instead, it introduces two methods: Synchronous commuication done through Tor (transaction is completed automatically similar to HTTPS). Asynchronous communication using Slatepack Messages, which are encoded transaction strings exchanged by a simple copy-paste. Additionally, Slatepack Addresses are introduced to facilitate the interaction between two wallets. No more endless support tickets Notice how the transactions can be completed without requiring additional help from exchange support staff; When needed, wallets resort to exchanging simple string messages to complete the interaction. This should drastically reduce time spent on support tickets related to troubles around transacting with Grin. Overview Slatepack Address A Slatepack address is a bech32 encoded address, similar to those used in Bitcoin. However, Slatepack addresses do not touch the network; they are used strictly for transaction building between two wallets, and never appear on-chain or represent ownership. Addresses are exchanged between parties to serve as instructions for how to complete the payment. Therefore, a Slatepack address serves a double prupose: It decodes to a Tor address. Acts as a key to encrypt the transaction data being communicated by Slatepack Messages (strings). example address grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 Since Slatepack addresses are bech32, they can easily be QR encoded. Tor (Synchronous Tx Completion) Any Slatepack address is decoded by the wallet as a Tor address , where the wallet will be listening. Therefore, if both the exchange's and the user's wallets are online and connected to Tor, payments will complete automatically (the receiver's wallet needs to listen). However, if a Tor connection between the two wallets can't be established (fails for any reason), or when a Slatepack address is not provided, the wallet will resort to exchanging Slatepack Messages for completing a transaction. Slatepack Messages (Asynchronous Tx Completion) The Slatepack standard automatically handles a failed Tor connection by outputting a Slatepack Message, which is an encoded transaction string to be exchanged manually by copy-paste. Given that the sender provides a destination address (always recommended even if Tor isn't desired), then the Slatepack Messages will be encrypted. Transaction Flow As an example, let's demonstrate the workflow of an exchange. (switch between tabs) Withdrawal Step Exchange User 1 Provide Slatepack Address 2 Send to Slatepack Address (send) 3 IF TOR FAILS : Copy message[1] 4 Paste message[1] 5 Copy message[2] 6 Paste message[2] (finalize) Withdrawal UI Deposit Step Exchange User 1 Provide Slatepack Address (address) 2 Send to Slatepack Address 3 IF TOR FAILS : Copy message[1] 4 Paste message[1] (receive) 5 Copy message[2] 6 Paste message[2] Deposit UI Exchange Integration Exchanges may consider several different paths for intergration: Exchanges may run Tor hidden services to automatically complete transactions, and also provide a user-interface for copy-pasting Slatepack Messages as a fallback mechanism. Some exchanges may not wish to have Tor running anywhere in their infrastructure. In this case, they may provide only the user-interface required for exchanging Slatepack Messages via copy and paste text boxes. Exchanges may provide unique Tor end points to serve as unique deposit addresses for each user. Payment proofs Grin's lack of on-chain addresses slightly complicates proving a transaction occured. In order to solve disputes and prove funds were sent to the correct wallet, seperate payment proofs are used. By default, whenever a transaction is sent to a destination Slatepack Address, a payment proof is created automatically. The sender (wallet who finalized tx) can export the payment proof by specifying the tx-id ( -i ) or tx-log-id ( -t ) of a transaction, and choosing the path for the proof file, e.g: grin-wallet export_proof -i 4 \"~/Documents/proof.txt\" He can then provide this proof to any wallet for verification. To verify: grin-wallet verify_proof /path/proof.txt This will ensure that: The kernel for the transaction in the proof is validated and can be found on-chain. Both the sender and recipient's signatures correctly sign for the amount and the kernel. Additionally, if the recipient of the transaction is the same wallet trying to verify it, then they will be informed as follows: grin-wallet verify_proof proof.txt Payment proof's signatures are valid. The proof's recipient address belongs to this wallet. Questions & Support For questions about the Slatepack standard or its implementation, send a message in @grincoin#support on Keybase. Technical Details See the full specification for complete technical details. Address A SlatepackAddress is a bech32 encoded ed25519 public key which maps to: A Tor onion address bech32 -> ed25519 -> onionv3 A derivable x25519 public key for optional encryption bech32 -> ed25519 -> x25519 Keys used in SlatepackAddresses are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys. Unique addresses (not yet supported) SlatepackAddress keys may be derived in parallel to the blinding factor derivation path, such that a unique address is derived for each new transaction. Message Formatting WORD_LENGTH : 15 characters Number of SimpleBase58Check encoded characters per word; chosen for human readability across device screen sizes LINE_BREAK : 200 words Number of words of WORD_LENGTH to include before inserting a newline; chosen for user friendliness in terminals and messaging applications MAX_STRING_SIZE : 1MB Maximum size for an armored SlatepackMessage string without requiring a file container If a SlatepackMessage exceeds this value it must be handled as a .slatepack file instead of a string This parameter chosen to cover as many cases as possible and still be supported by most clipboards Note that WORD_LENGTH and LINE_BREAK parameters are adjustable as a formatting convenience. Services and exchanges would be reasonable to support the Slatepack standard, without handling the rare file edge case (string >1MB). The SlatepackWorkflow establishes the steps followed to adhere to the standard: Try to establish connection via Tor Derive onion address from ED25519 public key decoded from the bech32 SlatepackAddress Attempt to complete the transaction via Tor and json-rpc as per the previous implementations If connection fails, proceed to step 2 Fall back to copy/paste (optionally encrypted) ascii-armored transaction strings known as SlatepackMessage If using encryption, derive encryption key: SlatepackAddress -> ed25519 public key -> x25519 public key Build ascii-armored string according to standard including SimpleBase58Check , appropriate binary encoding and framing A SlatepackMessage is a transaction string formatted for manual copy/paste transport. It contains the required components to build a transaction manually, similar to the transaction files previously supported but compacted for transport. Example: BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv pcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY GWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx wNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK.","title":"Slatepack Integration Guide"},{"location":"wiki/services/slatepack-integration/#slatepack-integration-guide","text":"Slatepack is a new transaction building standard for Grin designed to improve and simplify the transacting experience for all users. The full specification is available here Slatepack was introduced in v4.0.0. Wallets and services must fully support it by v5.0.0 (Jan 2021).","title":"Slatepack Integration Guide"},{"location":"wiki/services/slatepack-integration/#motivation","text":"Previously, users and exchanges had to decide between multiple transaction methods to find one that works for them. Transactions were commonly done through HTTPS, requiring users to open ports and configure firewalls, or with slate files which bring their own set of challenges. With Slatepack, a single standard needs to be supported.","title":"Motivation"},{"location":"wiki/services/slatepack-integration/#summary","text":"The Slatepack standard eliminates the need for HTTPS or exchanging files. Instead, it introduces two methods: Synchronous commuication done through Tor (transaction is completed automatically similar to HTTPS). Asynchronous communication using Slatepack Messages, which are encoded transaction strings exchanged by a simple copy-paste. Additionally, Slatepack Addresses are introduced to facilitate the interaction between two wallets. No more endless support tickets Notice how the transactions can be completed without requiring additional help from exchange support staff; When needed, wallets resort to exchanging simple string messages to complete the interaction. This should drastically reduce time spent on support tickets related to troubles around transacting with Grin.","title":"Summary"},{"location":"wiki/services/slatepack-integration/#overview","text":"","title":"Overview"},{"location":"wiki/services/slatepack-integration/#slatepack-address","text":"A Slatepack address is a bech32 encoded address, similar to those used in Bitcoin. However, Slatepack addresses do not touch the network; they are used strictly for transaction building between two wallets, and never appear on-chain or represent ownership. Addresses are exchanged between parties to serve as instructions for how to complete the payment. Therefore, a Slatepack address serves a double prupose: It decodes to a Tor address. Acts as a key to encrypt the transaction data being communicated by Slatepack Messages (strings). example address grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 Since Slatepack addresses are bech32, they can easily be QR encoded.","title":"Slatepack Address"},{"location":"wiki/services/slatepack-integration/#tor-synchronous-tx-completion","text":"Any Slatepack address is decoded by the wallet as a Tor address , where the wallet will be listening. Therefore, if both the exchange's and the user's wallets are online and connected to Tor, payments will complete automatically (the receiver's wallet needs to listen). However, if a Tor connection between the two wallets can't be established (fails for any reason), or when a Slatepack address is not provided, the wallet will resort to exchanging Slatepack Messages for completing a transaction.","title":"Tor (Synchronous Tx Completion)"},{"location":"wiki/services/slatepack-integration/#slatepack-messages-asynchronous-tx-completion","text":"The Slatepack standard automatically handles a failed Tor connection by outputting a Slatepack Message, which is an encoded transaction string to be exchanged manually by copy-paste. Given that the sender provides a destination address (always recommended even if Tor isn't desired), then the Slatepack Messages will be encrypted.","title":"Slatepack Messages (Asynchronous Tx Completion)"},{"location":"wiki/services/slatepack-integration/#transaction-flow","text":"As an example, let's demonstrate the workflow of an exchange. (switch between tabs) Withdrawal Step Exchange User 1 Provide Slatepack Address 2 Send to Slatepack Address (send) 3 IF TOR FAILS : Copy message[1] 4 Paste message[1] 5 Copy message[2] 6 Paste message[2] (finalize) Withdrawal UI Deposit Step Exchange User 1 Provide Slatepack Address (address) 2 Send to Slatepack Address 3 IF TOR FAILS : Copy message[1] 4 Paste message[1] (receive) 5 Copy message[2] 6 Paste message[2] Deposit UI","title":"Transaction Flow"},{"location":"wiki/services/slatepack-integration/#exchange-integration","text":"Exchanges may consider several different paths for intergration: Exchanges may run Tor hidden services to automatically complete transactions, and also provide a user-interface for copy-pasting Slatepack Messages as a fallback mechanism. Some exchanges may not wish to have Tor running anywhere in their infrastructure. In this case, they may provide only the user-interface required for exchanging Slatepack Messages via copy and paste text boxes. Exchanges may provide unique Tor end points to serve as unique deposit addresses for each user.","title":"Exchange Integration"},{"location":"wiki/services/slatepack-integration/#payment-proofs","text":"Grin's lack of on-chain addresses slightly complicates proving a transaction occured. In order to solve disputes and prove funds were sent to the correct wallet, seperate payment proofs are used. By default, whenever a transaction is sent to a destination Slatepack Address, a payment proof is created automatically. The sender (wallet who finalized tx) can export the payment proof by specifying the tx-id ( -i ) or tx-log-id ( -t ) of a transaction, and choosing the path for the proof file, e.g: grin-wallet export_proof -i 4 \"~/Documents/proof.txt\" He can then provide this proof to any wallet for verification. To verify: grin-wallet verify_proof /path/proof.txt This will ensure that: The kernel for the transaction in the proof is validated and can be found on-chain. Both the sender and recipient's signatures correctly sign for the amount and the kernel. Additionally, if the recipient of the transaction is the same wallet trying to verify it, then they will be informed as follows: grin-wallet verify_proof proof.txt Payment proof's signatures are valid. The proof's recipient address belongs to this wallet.","title":"Payment proofs"},{"location":"wiki/services/slatepack-integration/#questions-support","text":"For questions about the Slatepack standard or its implementation, send a message in @grincoin#support on Keybase.","title":"Questions &amp; Support"},{"location":"wiki/services/slatepack-integration/#technical-details","text":"See the full specification for complete technical details.","title":"Technical Details"},{"location":"wiki/services/slatepack-integration/#address","text":"A SlatepackAddress is a bech32 encoded ed25519 public key which maps to: A Tor onion address bech32 -> ed25519 -> onionv3 A derivable x25519 public key for optional encryption bech32 -> ed25519 -> x25519 Keys used in SlatepackAddresses are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys. Unique addresses (not yet supported) SlatepackAddress keys may be derived in parallel to the blinding factor derivation path, such that a unique address is derived for each new transaction.","title":"Address"},{"location":"wiki/services/slatepack-integration/#message-formatting","text":"WORD_LENGTH : 15 characters Number of SimpleBase58Check encoded characters per word; chosen for human readability across device screen sizes LINE_BREAK : 200 words Number of words of WORD_LENGTH to include before inserting a newline; chosen for user friendliness in terminals and messaging applications MAX_STRING_SIZE : 1MB Maximum size for an armored SlatepackMessage string without requiring a file container If a SlatepackMessage exceeds this value it must be handled as a .slatepack file instead of a string This parameter chosen to cover as many cases as possible and still be supported by most clipboards Note that WORD_LENGTH and LINE_BREAK parameters are adjustable as a formatting convenience. Services and exchanges would be reasonable to support the Slatepack standard, without handling the rare file edge case (string >1MB). The SlatepackWorkflow establishes the steps followed to adhere to the standard: Try to establish connection via Tor Derive onion address from ED25519 public key decoded from the bech32 SlatepackAddress Attempt to complete the transaction via Tor and json-rpc as per the previous implementations If connection fails, proceed to step 2 Fall back to copy/paste (optionally encrypted) ascii-armored transaction strings known as SlatepackMessage If using encryption, derive encryption key: SlatepackAddress -> ed25519 public key -> x25519 public key Build ascii-armored string according to standard including SimpleBase58Check , appropriate binary encoding and framing A SlatepackMessage is a transaction string formatted for manual copy/paste transport. It contains the required components to build a transaction manually, similar to the transaction files previously supported but compacted for transport. Example: BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv pcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY GWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx wNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK.","title":"Message Formatting"},{"location":"wiki/transactions/contracts/","text":"Contracts Read this in other languages: \u7b80\u4f53\u4e2d\u6587 This document describes smart contracts that can be setup using Grin even though its simplicity does not allow scripting. All of these types of contracts rely on a few basic Mimblewimble features, and compose them in increasingly clever ways. None of those constructs are fully original or invented by the authors of this document or the Grin developers. Most of the credit should be attributed to a long list of cryptographers and researchers. To name just a few: Torben Pryds Pedersen, Gregory Maxwell, Andrew Poelstra, John Tromp, Claus Peter Schnorr. We apologize in advance for all those we couldn't name and recognize that most computer science discoveries are incremental. Built-ins This section is meant as a reminder of some crucial features of the Grin chain. We assume some prior knowledge as to how these are constructed and used. Pedersen Commitments All outputs include a Pedersen commitment of the form r*G + v*H with r the blinding factor, v the value, and G and H two distinct generator points on the same curve group. Aggregate Signatures (a.k.a. Schnorr, MuSig) We suppose we have the SHA256 hash function and the same G curve as above. In its simplest form, an aggregate signature is built from: the message M to sign, in our case the transaction fee a private key x , with its matching public key x*G a nonce k just used for the purpose of building the signature We build the challenge e = SHA256(M | k*G | x*G) , and the scalar s = k + e * x . The full aggregate signature is then the pair (s, k*G) . The signature can be checked using the public key x*G , re-calculating e using M and k*G from the 2nd part of the signature pair and by verifying that s , the first part of the signature pair, satisfies: s*G = k*G + e * x*G In this simple case of someone sending a transaction to a receiver they trust (see later for the trustless case), an aggregate signature can be directly built for a Grin transaction by taking the above private key x to be the sum of output blinding factors minus the sum of input blinding factors. The resulting kernel is assembled from the aggregate signature generated using r and the public key r*G , and allows to verify non-inflation for all Grin transactions (and signs the fees). Because these signatures are built simply from a scalar and a public key, they can be used to construct a variety of contracts using \"simple\" arithmetic. Timelocked Transactions Absolute Timelocked Analogous to Bitcoin's nLockTime . A transaction can be time-locked with a few simple modifications. The message M to sign becomes the lock_height h at which the transaction becomes spendable, appended to the fee, such that M = fee | h . The lock height h is then included in the transaction kernel. If a block contains a kernel that includes a lock height greater than the current block height, it is rejected. Relative Timelocked We can extend the concept of an absolute locktime on a tx by including a (kernel) commitment that we can define the lock_height relative to. The lock_height would be relative to the block height where the referenced kernel was first included in the chain state. Tx2 can then be restricted such that it would only be valid to include it in a block once h blocks have passed after first seeing Tx1 (via the referenced kernel commitment). The message M to sign would need to include the following: The fee as before The lock_height h (as before but interpreted as a relative value) A referenced kernel commitment C M = fee | h | C For Tx2 to be accepted it would also need to include a Merkle proof identifying the block including C from Tx1. This proves the relative lock_height requirement has been met. Derived Contracts Trustless Transactions An aggregate (Schnorr) signature involving a single party is relatively simple but does not demonstrate the full flexibility of the construction. We show here how to generalize it for use in outputs involving multiple parties. As constructed in section 1.2, an aggregate signature requires trusting the receiving party. As Grin outputs are completely obscured by Pedersen Commitments, one cannot prove money was actually sent to the right party, hence a receiver could claim not having received anything. To solve this issue, we require the receiver to collaborate with the sender in building a transaction and specifically its kernel signature. Alice wants to pay Bob in grins. She starts the transaction building process: Alice selects her inputs and builds her change output. The sum of all blinding factors (change output minus inputs) is rs . Alice picks a random nonce ks and sends her partial transaction, ks*G and rs*G to Bob. Bob picks his own random nonce kr and the blinding factor for his output rr . Using rr , Bob adds his output to the transaction. Bob computes the message M = fee | lock_height , the Schnorr challenge e = SHA256(M | kr*G + ks*G | rr*G + rs*G) and finally his side of the signature sr = kr + e * rr . Bob sends sr , kr*G and rr*G to Alice. Alice computes e just like Bob did and can check that sr*G = kr*G + e*rr*G . Alice sends her side of the signature ss = ks + e * rs to Bob. Bob validates ss*G just like Alice did for sr*G in step 6 and can produce the final signature s = (ss + sr, ks*G + kr*G) as well as the final transaction kernel including s and the public key rr*G + rs*G . This protocol requires 3 data exchanges (Alice to Bob, Bob back to Alice, and finally Alice to Bob) and is therefore said to be interactive. However the interaction can be done over any medium and in any period of time, including the pony express over 2 weeks. This protocol can also be generalized to any number i of parties. On the first round, all the ki*G and ri*G are shared. On the 2nd round, everyone can compute e = SHA256(M | sum(ki*G) | sum(ri*G)) and their own signature si . Finally, a finalizing party can then gather all the partial signatures si , validate them and produce s = (sum(si), sum(ki*G)) . Multiparty Outputs (multisig) We describe here a way to build a transaction with an output that can only be spent when multiple parties approve it. This construction is very similar to the previous setup for trustless transactions, however in this case both the signature and a Pedersen Commitment need to be aggregated. This time, Alice wants to send funds such that both Bob and her need to agree to spend. Alice builds the transaction normally and adds the multiparty output such that: Bob picks a blinding factor rb and sends rb*G to Alice. Alice picks a blinding factor ra and builds the commitment C = ra*G + rb*G + v*H . She sends the commitment to Bob. Bob creates a range proof for v using C and rb and sends it to Alice. Alice generates her own range proof, aggregates it with Bob, finalizing the multiparty output Oab . The kernel is built following the same procedure as for Trustless Transactions. We observe that for that new output Oab , neither party know the whole blinding factor. To be able to build a transaction spending Oab, someone would need to know ra + rb to produce a kernel signature. To produce that spending kernel, Alice and Bob need to collaborate. This, again, is done using a protocol very close to Trustless Transactions. Multiparty Timelocks This contract is a building block for multiple other contracts. Here, Alice agrees to lock some funds to start a financial interaction with Bob and prove to Bob she has funds. The setup is the following: Alice builds a a 2-of-2 multiparty transaction with an output she shares with Bob, however she does not participate in building the kernel signature yet. Bob builds a refund transaction with Alice that sends the funds back to Alice using a timelock (for example 1440 blocks ahead, about 24h). Alice and Bob finish the 2-of-2 transaction by building the corresponding kernel and broadcast it. Now Alice and Bob are free to build additional transactions distributing the funds locked in the 2-of-2 output in any way they see fit. If Bob refuses to cooperate, Alice just needs to broadcast her refund transaction after the time lock expires. This contract can be trivially used for unidirectional payment channels. Conditional Output Timelocks Analogous to Bitcoin's CheckLockTimeVerify . We currently have unconditional lock_heights on txs (tx is not valid and will not be accepted until lock_height has passed). Private keys can be summed together. Key 3 = Key 1 + Key 2 Commitments can be summed together. C 3 = C 1 + C 2 Given unconditional locktimes on txs we can leverage these to give us conditional locktimes on outputs by \"entangling\" two outputs on two related txs together. We can construct two txs (Tx 1 , Tx 2 ) with two entangled outputs Out 1 and Out 2 such that - Out 1 (commitment C 1 ) is from Tx 1 and built using Key 1 Out 2 (commitment C 2 ) is from Tx 2 and built using Key 2 Tx 2 has an unconditional lock_height on it If we do this (and we can manage the keys as necessary) - Out 1 + Out 2 can only be spent as a pair using Key 3 They can only be spent after lock_height from Tx 2 Tx 1 (containing Out 1 ) can be broadcast, accepted and confirmed on-chain immediately. Tx 2 cannot be broadcast and accepted until lock_height has passed. So if Alice only knows K 3 and does not know Key 1 or Key 2 , then Out 1 can only be spent by Alice after lock_height has passed. If Bob on the other hand knows Key 2 then Out 1 can be spent by Bob immediately. We have a conditional timelock on Out 1 (confirmed, on-chain) where it can be spent either with Key 3 (after lock_height), or Key 2 immediately. (Relative) Conditional Output Timelocks Analogous to Bitcoin's CheckSequenceVerify . By combining \"Conditional Timelock on Output\" with \"(Relative) Timelocked Transactions\" we can encumber a confirmed output with a relative timelock (relative to a related tx kernel). Tx 1 (containing Out 1 ) can be broadcast, accepted and confirmed on-chain immediately. Tx 2 cannot be broadcast and accepted until the relative lock_height has passed, relative to the referenced kernel from the earlier Tx 1 . Atomic Swap This setup relies on a time locked contract combined with a check for 2 public keys. On Bitcoin this would be a 2-of-2 multisig, one public key being Alice's, the second being the hash of a preimage that Bob has to reveal. In this setup, we consider public key derivation x*G to be the hash function and by Bob revealing x , Alice can then produce an adequate signature proving she knows x (in addition to her own private key). Alice has grins and Bob has bitcoin. They would like to swap. We assume Bob created an output on the Bitcoin blockchain that allows spending either by Alice if she learns a hash pre-image x , or by Bob after time Tb . Alice is ready to send her grins to Bob if he reveals x . First, Alice sends her grins to a multiparty timelock contract with a refund time Ta < Tb . To send the 2-of-2 output to Bob and execute the swap, Alice and Bob start as if they were building a normal trustless transaction as specified in section 2.1. Alice picks a random nonce ks and her blinding sum rs and sends ks*G and rs*G to Bob. Bob picks a random blinding factor rr and a random nonce kr . However this time, instead of simply sending sr = kr + e * rr with his rr*G and kr*G , Bob sends sr' = kr + x + e * rr as well as x*G . Alice can validate that sr'*G = kr*G + x*G + rr*G . She can also check that Bob has money locked with x*G on the other chain. Alice sends back her ss = ks + e * xs as she normally would, now that she can also compute e = SHA256(M | ks*G + kr*G) . To complete the signature, Bob computes sr = kr + e * rr and the final signature is (sr + ss, kr*G + ks*G) . As soon as Bob broadcasts the final transaction to get his new grins, Alice can compute sr' - sr to get x . Notes on the Bitcoin setup Prior to completing the atomic swap, Bob needs to know Alice's public key. Bob would then create an output on the Bitcoin blockchain with a 2-of-2 multisig similar to alice_pubkey secret_pubkey 2 OP_CHECKMULTISIG . This should be wrapped in an OP_IF so Bob can get his money back after an agreed-upon time and all of this can even be wrapped in a P2SH. Here secret_pubkey is x*G from the previous section. To verify the output, Alice would take x*G , recreate the bitcoin script, hash it and check that her hash matches what's in the P2SH (step 2 in previous section). Once she gets x (step 6), she can build the 2 signatures necessary to spend the 2-of-2, having both private keys, and get her bitcoin. \"Relative Timelocks\" (Lightning Network) See No Recent Duplicate (NRD) transaction kernels for more details.","title":"Contracts"},{"location":"wiki/transactions/contracts/#contracts","text":"Read this in other languages: \u7b80\u4f53\u4e2d\u6587 This document describes smart contracts that can be setup using Grin even though its simplicity does not allow scripting. All of these types of contracts rely on a few basic Mimblewimble features, and compose them in increasingly clever ways. None of those constructs are fully original or invented by the authors of this document or the Grin developers. Most of the credit should be attributed to a long list of cryptographers and researchers. To name just a few: Torben Pryds Pedersen, Gregory Maxwell, Andrew Poelstra, John Tromp, Claus Peter Schnorr. We apologize in advance for all those we couldn't name and recognize that most computer science discoveries are incremental.","title":"Contracts"},{"location":"wiki/transactions/contracts/#built-ins","text":"This section is meant as a reminder of some crucial features of the Grin chain. We assume some prior knowledge as to how these are constructed and used.","title":"Built-ins"},{"location":"wiki/transactions/contracts/#pedersen-commitments","text":"All outputs include a Pedersen commitment of the form r*G + v*H with r the blinding factor, v the value, and G and H two distinct generator points on the same curve group.","title":"Pedersen Commitments"},{"location":"wiki/transactions/contracts/#aggregate-signatures-aka-schnorr-musig","text":"We suppose we have the SHA256 hash function and the same G curve as above. In its simplest form, an aggregate signature is built from: the message M to sign, in our case the transaction fee a private key x , with its matching public key x*G a nonce k just used for the purpose of building the signature We build the challenge e = SHA256(M | k*G | x*G) , and the scalar s = k + e * x . The full aggregate signature is then the pair (s, k*G) . The signature can be checked using the public key x*G , re-calculating e using M and k*G from the 2nd part of the signature pair and by verifying that s , the first part of the signature pair, satisfies: s*G = k*G + e * x*G In this simple case of someone sending a transaction to a receiver they trust (see later for the trustless case), an aggregate signature can be directly built for a Grin transaction by taking the above private key x to be the sum of output blinding factors minus the sum of input blinding factors. The resulting kernel is assembled from the aggregate signature generated using r and the public key r*G , and allows to verify non-inflation for all Grin transactions (and signs the fees). Because these signatures are built simply from a scalar and a public key, they can be used to construct a variety of contracts using \"simple\" arithmetic.","title":"Aggregate Signatures (a.k.a. Schnorr, MuSig)"},{"location":"wiki/transactions/contracts/#timelocked-transactions","text":"","title":"Timelocked Transactions"},{"location":"wiki/transactions/contracts/#absolute-timelocked","text":"Analogous to Bitcoin's nLockTime . A transaction can be time-locked with a few simple modifications. The message M to sign becomes the lock_height h at which the transaction becomes spendable, appended to the fee, such that M = fee | h . The lock height h is then included in the transaction kernel. If a block contains a kernel that includes a lock height greater than the current block height, it is rejected.","title":"Absolute Timelocked"},{"location":"wiki/transactions/contracts/#relative-timelocked","text":"We can extend the concept of an absolute locktime on a tx by including a (kernel) commitment that we can define the lock_height relative to. The lock_height would be relative to the block height where the referenced kernel was first included in the chain state. Tx2 can then be restricted such that it would only be valid to include it in a block once h blocks have passed after first seeing Tx1 (via the referenced kernel commitment). The message M to sign would need to include the following: The fee as before The lock_height h (as before but interpreted as a relative value) A referenced kernel commitment C M = fee | h | C For Tx2 to be accepted it would also need to include a Merkle proof identifying the block including C from Tx1. This proves the relative lock_height requirement has been met.","title":"Relative Timelocked"},{"location":"wiki/transactions/contracts/#derived-contracts","text":"","title":"Derived Contracts"},{"location":"wiki/transactions/contracts/#trustless-transactions","text":"An aggregate (Schnorr) signature involving a single party is relatively simple but does not demonstrate the full flexibility of the construction. We show here how to generalize it for use in outputs involving multiple parties. As constructed in section 1.2, an aggregate signature requires trusting the receiving party. As Grin outputs are completely obscured by Pedersen Commitments, one cannot prove money was actually sent to the right party, hence a receiver could claim not having received anything. To solve this issue, we require the receiver to collaborate with the sender in building a transaction and specifically its kernel signature. Alice wants to pay Bob in grins. She starts the transaction building process: Alice selects her inputs and builds her change output. The sum of all blinding factors (change output minus inputs) is rs . Alice picks a random nonce ks and sends her partial transaction, ks*G and rs*G to Bob. Bob picks his own random nonce kr and the blinding factor for his output rr . Using rr , Bob adds his output to the transaction. Bob computes the message M = fee | lock_height , the Schnorr challenge e = SHA256(M | kr*G + ks*G | rr*G + rs*G) and finally his side of the signature sr = kr + e * rr . Bob sends sr , kr*G and rr*G to Alice. Alice computes e just like Bob did and can check that sr*G = kr*G + e*rr*G . Alice sends her side of the signature ss = ks + e * rs to Bob. Bob validates ss*G just like Alice did for sr*G in step 6 and can produce the final signature s = (ss + sr, ks*G + kr*G) as well as the final transaction kernel including s and the public key rr*G + rs*G . This protocol requires 3 data exchanges (Alice to Bob, Bob back to Alice, and finally Alice to Bob) and is therefore said to be interactive. However the interaction can be done over any medium and in any period of time, including the pony express over 2 weeks. This protocol can also be generalized to any number i of parties. On the first round, all the ki*G and ri*G are shared. On the 2nd round, everyone can compute e = SHA256(M | sum(ki*G) | sum(ri*G)) and their own signature si . Finally, a finalizing party can then gather all the partial signatures si , validate them and produce s = (sum(si), sum(ki*G)) .","title":"Trustless Transactions"},{"location":"wiki/transactions/contracts/#multiparty-outputs-multisig","text":"We describe here a way to build a transaction with an output that can only be spent when multiple parties approve it. This construction is very similar to the previous setup for trustless transactions, however in this case both the signature and a Pedersen Commitment need to be aggregated. This time, Alice wants to send funds such that both Bob and her need to agree to spend. Alice builds the transaction normally and adds the multiparty output such that: Bob picks a blinding factor rb and sends rb*G to Alice. Alice picks a blinding factor ra and builds the commitment C = ra*G + rb*G + v*H . She sends the commitment to Bob. Bob creates a range proof for v using C and rb and sends it to Alice. Alice generates her own range proof, aggregates it with Bob, finalizing the multiparty output Oab . The kernel is built following the same procedure as for Trustless Transactions. We observe that for that new output Oab , neither party know the whole blinding factor. To be able to build a transaction spending Oab, someone would need to know ra + rb to produce a kernel signature. To produce that spending kernel, Alice and Bob need to collaborate. This, again, is done using a protocol very close to Trustless Transactions.","title":"Multiparty Outputs (multisig)"},{"location":"wiki/transactions/contracts/#multiparty-timelocks","text":"This contract is a building block for multiple other contracts. Here, Alice agrees to lock some funds to start a financial interaction with Bob and prove to Bob she has funds. The setup is the following: Alice builds a a 2-of-2 multiparty transaction with an output she shares with Bob, however she does not participate in building the kernel signature yet. Bob builds a refund transaction with Alice that sends the funds back to Alice using a timelock (for example 1440 blocks ahead, about 24h). Alice and Bob finish the 2-of-2 transaction by building the corresponding kernel and broadcast it. Now Alice and Bob are free to build additional transactions distributing the funds locked in the 2-of-2 output in any way they see fit. If Bob refuses to cooperate, Alice just needs to broadcast her refund transaction after the time lock expires. This contract can be trivially used for unidirectional payment channels.","title":"Multiparty Timelocks"},{"location":"wiki/transactions/contracts/#conditional-output-timelocks","text":"Analogous to Bitcoin's CheckLockTimeVerify . We currently have unconditional lock_heights on txs (tx is not valid and will not be accepted until lock_height has passed). Private keys can be summed together. Key 3 = Key 1 + Key 2 Commitments can be summed together. C 3 = C 1 + C 2 Given unconditional locktimes on txs we can leverage these to give us conditional locktimes on outputs by \"entangling\" two outputs on two related txs together. We can construct two txs (Tx 1 , Tx 2 ) with two entangled outputs Out 1 and Out 2 such that - Out 1 (commitment C 1 ) is from Tx 1 and built using Key 1 Out 2 (commitment C 2 ) is from Tx 2 and built using Key 2 Tx 2 has an unconditional lock_height on it If we do this (and we can manage the keys as necessary) - Out 1 + Out 2 can only be spent as a pair using Key 3 They can only be spent after lock_height from Tx 2 Tx 1 (containing Out 1 ) can be broadcast, accepted and confirmed on-chain immediately. Tx 2 cannot be broadcast and accepted until lock_height has passed. So if Alice only knows K 3 and does not know Key 1 or Key 2 , then Out 1 can only be spent by Alice after lock_height has passed. If Bob on the other hand knows Key 2 then Out 1 can be spent by Bob immediately. We have a conditional timelock on Out 1 (confirmed, on-chain) where it can be spent either with Key 3 (after lock_height), or Key 2 immediately.","title":"Conditional Output Timelocks"},{"location":"wiki/transactions/contracts/#relative-conditional-output-timelocks","text":"Analogous to Bitcoin's CheckSequenceVerify . By combining \"Conditional Timelock on Output\" with \"(Relative) Timelocked Transactions\" we can encumber a confirmed output with a relative timelock (relative to a related tx kernel). Tx 1 (containing Out 1 ) can be broadcast, accepted and confirmed on-chain immediately. Tx 2 cannot be broadcast and accepted until the relative lock_height has passed, relative to the referenced kernel from the earlier Tx 1 .","title":"(Relative) Conditional Output Timelocks"},{"location":"wiki/transactions/contracts/#atomic-swap","text":"This setup relies on a time locked contract combined with a check for 2 public keys. On Bitcoin this would be a 2-of-2 multisig, one public key being Alice's, the second being the hash of a preimage that Bob has to reveal. In this setup, we consider public key derivation x*G to be the hash function and by Bob revealing x , Alice can then produce an adequate signature proving she knows x (in addition to her own private key). Alice has grins and Bob has bitcoin. They would like to swap. We assume Bob created an output on the Bitcoin blockchain that allows spending either by Alice if she learns a hash pre-image x , or by Bob after time Tb . Alice is ready to send her grins to Bob if he reveals x . First, Alice sends her grins to a multiparty timelock contract with a refund time Ta < Tb . To send the 2-of-2 output to Bob and execute the swap, Alice and Bob start as if they were building a normal trustless transaction as specified in section 2.1. Alice picks a random nonce ks and her blinding sum rs and sends ks*G and rs*G to Bob. Bob picks a random blinding factor rr and a random nonce kr . However this time, instead of simply sending sr = kr + e * rr with his rr*G and kr*G , Bob sends sr' = kr + x + e * rr as well as x*G . Alice can validate that sr'*G = kr*G + x*G + rr*G . She can also check that Bob has money locked with x*G on the other chain. Alice sends back her ss = ks + e * xs as she normally would, now that she can also compute e = SHA256(M | ks*G + kr*G) . To complete the signature, Bob computes sr = kr + e * rr and the final signature is (sr + ss, kr*G + ks*G) . As soon as Bob broadcasts the final transaction to get his new grins, Alice can compute sr' - sr to get x . Notes on the Bitcoin setup Prior to completing the atomic swap, Bob needs to know Alice's public key. Bob would then create an output on the Bitcoin blockchain with a 2-of-2 multisig similar to alice_pubkey secret_pubkey 2 OP_CHECKMULTISIG . This should be wrapped in an OP_IF so Bob can get his money back after an agreed-upon time and all of this can even be wrapped in a P2SH. Here secret_pubkey is x*G from the previous section. To verify the output, Alice would take x*G , recreate the bitcoin script, hash it and check that her hash matches what's in the P2SH (step 2 in previous section). Once she gets x (step 6), she can build the 2 signatures necessary to spend the 2-of-2, having both private keys, and get her bitcoin.","title":"Atomic Swap"},{"location":"wiki/transactions/contracts/#relative-timelocks-lightning-network","text":"See No Recent Duplicate (NRD) transaction kernels for more details.","title":"\"Relative Timelocks\" (Lightning Network)"},{"location":"wiki/transactions/payment-proofs/","text":"Payment Proofs Title: payment-proofs Authors: David Burkett Start date: Nov 05 2019 RFC PR: mimblewimble/grin-rfcs#31 Tracking issue: mimblewimble/grin-wallet#230 Summary Support generating and validating payment proofs for sender-initiated (i.e. non-invoice) transactions. Motivation Bitcoin and other cryptocurrencies with transparent protocol-level addressing and immutable, unprunable blockchains can prove sender, receiver, and amounts of payments simply by pointing to the transaction in the blockchain. Grin's privacy and scalability means users no longer have this ability. This prevents some merchants from accepting Grin due to the high possibility of payment disputes that are unresolvable in the same way they are for transparent coins. This RFC changes the transaction building process where payers can require payees to create a \"proof\" they've received a payment before the payer finalizes and broadcasts the transaction. Community-level explanation From an end-user perspective, payers can require payees to prove receipt of funds as part of the transacting process. Payers can then use these \"proofs\" to resolve payment disputes and prove they sent funds to the correct payee. Reference-level explanation Slate changes A new (optional) structure ( payment_info ) will be added to transaction slates, along with a version increase. The payment_info structure will contain: sender_address - An ed25519 public key generated by the sender. receiver_address - An ed25519 public key for the receiver, typically the public key of the user's v3 onion address. receiver_signature - A signature of the sender_address, received amount, and kernel commitment that validates against the receiver_address . Generating proofs Receipt confirmations ( receiver_signature ) will be generated by the payee by providing an ED25519 signature of: (amount || kernel_commitment || sender_address) , using the private key of the receiver_address . The sender_signature can be generated for (amount || kernel_commitment || sender_address) using the private key of the sender_address . Sender will then create and store the following info, which can be considered the complete payment_proof : receiver_address receiver_signature amount kernel_commitment sender_address sender_signature Verifying Proofs This payment_proof can be provided by the sender at any time to convince a payee that a payment was made to them. The proof can be verified as follows: Ensure the kernel_commitment is confirmed on-chain. Verify that the receiver_address belongs to the payee. Verify that the receiver_signature is valid. Verify that the sender_signature is valid. Wallet actions init-send As part of the first step of the tx-building process, the sender/payer generates the sender_address using their keychain. The receiver_address and keychain path of the sender_address must be stored locally, along with the slate_id . The sender_address and receiver_address will then be added to the payment_proof structure of the slate. receive If the payment_proof structure exists on the slate, it is mandatory that the receiver_signature is generated and added to the slate as part of the receive tx-building step. finalize Using the slate_id , the sender can retrieve the original sender_address and receiver_address that were included in the slate, and verify that those fields remain unchanged. The sender must then validate the receiver_signature . If any of the original payment_proof slate fields were modified, or if the receiver_signature is invalid, the transaction must be rejected by the sender. Once the payment_info details have been validated, the sender can generate and store the payment_proof (See Generating Proofs above), and then finalize the transaction as normal. Drawbacks Increases the size of tx slates. Possibility of privacy leakage through address reuse. Rationale and alternatives This design works well with TOR tx building, yet is generic enough to work with all known transacting mechanisms. Prior art Wallet713 implements payment proofs for grinbox transactions, which our design adapts and builds on to work more seemlessly with onion addresses and with transaction building methods that don't inherently rely on addresses. Unresolved questions Can this be adapted to work for invoices? Future possibilities Payment proofs could potentially be added to invoice payments in the future, but at the cost of an additional round of communication. References Tx slate structure \u21a9 Beam's payment proof model \u21a9","title":"Payment Proofs"},{"location":"wiki/transactions/payment-proofs/#payment-proofs","text":"Title: payment-proofs Authors: David Burkett Start date: Nov 05 2019 RFC PR: mimblewimble/grin-rfcs#31 Tracking issue: mimblewimble/grin-wallet#230","title":"Payment Proofs"},{"location":"wiki/transactions/payment-proofs/#summary","text":"Support generating and validating payment proofs for sender-initiated (i.e. non-invoice) transactions.","title":"Summary"},{"location":"wiki/transactions/payment-proofs/#motivation","text":"Bitcoin and other cryptocurrencies with transparent protocol-level addressing and immutable, unprunable blockchains can prove sender, receiver, and amounts of payments simply by pointing to the transaction in the blockchain. Grin's privacy and scalability means users no longer have this ability. This prevents some merchants from accepting Grin due to the high possibility of payment disputes that are unresolvable in the same way they are for transparent coins. This RFC changes the transaction building process where payers can require payees to create a \"proof\" they've received a payment before the payer finalizes and broadcasts the transaction.","title":"Motivation"},{"location":"wiki/transactions/payment-proofs/#community-level-explanation","text":"From an end-user perspective, payers can require payees to prove receipt of funds as part of the transacting process. Payers can then use these \"proofs\" to resolve payment disputes and prove they sent funds to the correct payee.","title":"Community-level explanation"},{"location":"wiki/transactions/payment-proofs/#reference-level-explanation","text":"","title":"Reference-level explanation"},{"location":"wiki/transactions/payment-proofs/#slate-changes","text":"A new (optional) structure ( payment_info ) will be added to transaction slates, along with a version increase. The payment_info structure will contain: sender_address - An ed25519 public key generated by the sender. receiver_address - An ed25519 public key for the receiver, typically the public key of the user's v3 onion address. receiver_signature - A signature of the sender_address, received amount, and kernel commitment that validates against the receiver_address .","title":"Slate changes"},{"location":"wiki/transactions/payment-proofs/#generating-proofs","text":"Receipt confirmations ( receiver_signature ) will be generated by the payee by providing an ED25519 signature of: (amount || kernel_commitment || sender_address) , using the private key of the receiver_address . The sender_signature can be generated for (amount || kernel_commitment || sender_address) using the private key of the sender_address . Sender will then create and store the following info, which can be considered the complete payment_proof : receiver_address receiver_signature amount kernel_commitment sender_address sender_signature","title":"Generating proofs"},{"location":"wiki/transactions/payment-proofs/#verifying-proofs","text":"This payment_proof can be provided by the sender at any time to convince a payee that a payment was made to them. The proof can be verified as follows: Ensure the kernel_commitment is confirmed on-chain. Verify that the receiver_address belongs to the payee. Verify that the receiver_signature is valid. Verify that the sender_signature is valid.","title":"Verifying Proofs"},{"location":"wiki/transactions/payment-proofs/#wallet-actions","text":"","title":"Wallet actions"},{"location":"wiki/transactions/payment-proofs/#init-send","text":"As part of the first step of the tx-building process, the sender/payer generates the sender_address using their keychain. The receiver_address and keychain path of the sender_address must be stored locally, along with the slate_id . The sender_address and receiver_address will then be added to the payment_proof structure of the slate.","title":"init-send"},{"location":"wiki/transactions/payment-proofs/#receive","text":"If the payment_proof structure exists on the slate, it is mandatory that the receiver_signature is generated and added to the slate as part of the receive tx-building step.","title":"receive"},{"location":"wiki/transactions/payment-proofs/#finalize","text":"Using the slate_id , the sender can retrieve the original sender_address and receiver_address that were included in the slate, and verify that those fields remain unchanged. The sender must then validate the receiver_signature . If any of the original payment_proof slate fields were modified, or if the receiver_signature is invalid, the transaction must be rejected by the sender. Once the payment_info details have been validated, the sender can generate and store the payment_proof (See Generating Proofs above), and then finalize the transaction as normal.","title":"finalize"},{"location":"wiki/transactions/payment-proofs/#drawbacks","text":"Increases the size of tx slates. Possibility of privacy leakage through address reuse.","title":"Drawbacks"},{"location":"wiki/transactions/payment-proofs/#rationale-and-alternatives","text":"This design works well with TOR tx building, yet is generic enough to work with all known transacting mechanisms.","title":"Rationale and alternatives"},{"location":"wiki/transactions/payment-proofs/#prior-art","text":"Wallet713 implements payment proofs for grinbox transactions, which our design adapts and builds on to work more seemlessly with onion addresses and with transaction building methods that don't inherently rely on addresses.","title":"Prior art"},{"location":"wiki/transactions/payment-proofs/#unresolved-questions","text":"Can this be adapted to work for invoices?","title":"Unresolved questions"},{"location":"wiki/transactions/payment-proofs/#future-possibilities","text":"Payment proofs could potentially be added to invoice payments in the future, but at the cost of an additional round of communication.","title":"Future possibilities"},{"location":"wiki/transactions/payment-proofs/#references","text":"Tx slate structure \u21a9 Beam's payment proof model \u21a9","title":"References"},{"location":"wiki/transactions/range-proof-format/","text":"Rangeproof Format This document could use a re-write. secp256k1-zkp Bulletproof format Grin uses Bulletproofs , the currently most efficient range proofs which do not require a trusted setup. Implemented at mimblewimble/secp256k1-zkp , a fork of the Blockstream C library ElementsProject/secp256k1-zkp . In this document we explain how to recover the proof parameters from the output bytes. Note that we name the parameters as they are named in the C library, which might be slightly different than the paper in some cases. Here is a sample proof output taken from a Grin transaction: 0b1bdf235e9c438aab5c6d02d3fe8173304bc528a3330825fb2311fa60fcdd6bfb92a248e26f849aebd511d2b326fa34b7f3030517d2f8e08a9b3cac7fa9fd200d07a46ca6ec5af30ce569b1e5faf2acf525cf1ed90cbed74ab7378b9b3957f28635fe7440aac2dc2c4bf43265b6ad1bfa82fddd9a827c4e97a913ce451b9a66bb06d3c08e03e85e98c581bbdf8c852796371a4603b8d52b80a1f2e95bd5e2a91c7a00b4d4564d9586235a7858d9ce8a8888bead7d51be2dd802de5af2921e079586817fce16d36c7764af8b4bf133b56b39970d6a568bf9ff101e6d33409e7c3bb081df7425b276655be611941245ceaad529495a86bc0e3d0f8634a8acf65c34c4e244959a5098bd58285408945a247d2fd894e5b18027d698c7e494e4256110553df54babf90592fbdffa0138b6b5a2a423ea5e2ec4d8f852a33c271a73b10fed9e1ee8cb2db1e71311cacd9e1d0b6dbf6cfab15723ec3cac4cc52154fc9d532202a085238e756ad1fa804cce2a634decc1b348f6ff939f9f80187d85aa5c308224a505c75e7f58fc7f35424276db7956474c1895e23ac55f864f4177b59f3ce92ef8c99e011cf55e0cefc5635d2eaf573df29af057a19bb209392a8c0e29a4b77adad76d385422e7f1d06de2d4f14e61ac3619aa22ae5bc288bb41cb56ddb70bb39ae84d00eb0cb34b4063bb55a83b9fe52604e545adcd41beb6ce14cdff73a21beb7493fa443a34585b7d2927f608cad17aa5f0e8e154b14d35315f63dd3580e80d06d8be4039f58778967f7bf2cdd9020fbcc9fed799b8159814f6a261c568e8b59c59df3180efb9cc13c576bf313248c96fa867aba43a80e799ff19ac685d7208cea7944dc9dcba7a61f2809540ecd0711e76b601969bdc551845e0b11fb821871d00e417ad002a70353867db25fa647e98a0db4c3bbaf828d97fc66079ef0d First, we have two 32 byte scalars. These are the already negated versions of taux and mu. We negate them such that the verifier doesn't have to do it (rangeproof_impl.h 701-702). 0b1bdf235e9c438aab5c6d02d3fe8173304bc528a3330825fb2311fa60fcdd6b (5024686248162052924872973414517693136231035491146611931625298995470137089387) taux (negated) fb92a248e26f849aebd511d2b326fa34b7f3030517d2f8e08a9b3cac7fa9fd20 (113789604713728301456840843635921464549630649029317112794749678552821986360608) mu (negated) After that, we have 4 points, which represent commitments A, S, T1, T2. Points are encoded in a very smart way. We have one offset byte. We use this offset byte indicate the LSB of y, telling us if the points y value needs to be negated when recovered. If this is the case, the bit is set to 1 (starting at the LSB); otherwise, it is left at 0. If we have more then eight points, we need 2 bytes offset, if we have more then 16, then three, and so forth (rangeproof_impl.h 703). 0d offset 0000 1101 offset in binary From this, we can recover the 4 points. (using the standard compressed point version here with leading 02 or 03) We start reading at the LSB. 0307a46ca6ec5af30ce569b1e5faf2acf525cf1ed90cbed74ab7378b9b3957f286 A (03 because of the 1 bit in the offset) 0235fe7440aac2dc2c4bf43265b6ad1bfa82fddd9a827c4e97a913ce451b9a66bb S (02 here because of the 0 bit in the offset) 0306d3c08e03e85e98c581bbdf8c852796371a4603b8d52b80a1f2e95bd5e2a91c T1 037a00b4d4564d9586235a7858d9ce8a8888bead7d51be2dd802de5af2921e0795 T2 Next, we have the final value of the dot product which again is a 32-byte scalar ( inner_product_impl.h 811 ) 86817fce16d36c7764af8b4bf133b56b39970d6a568bf9ff101e6d33409e7c3b (60838727059453008536034129618950719358562694528830851223208761064459354405947) dot Then we have the final values (32-byte scalars) of the shrunk vectors a, b used in the inner product protocol. The library does not do the last round of the protocol, meaning it will stop when the vectors are of length two instead of length one. This is because every round creates two commitments Li and Ri. If we don't do the last round, we spare two commitments with the cost that our two vectors are of size two instead of one, which is more space-efficient, and we save computing time. ( inner_product_impl.h 835-836 ) b081df7425b276655be611941245ceaad529495a86bc0e3d0f8634a8acf65c34 (79836526842770413616887368822368313168206709119259360230886972660827215518772) a1 c4e244959a5098bd58285408945a247d2fd894e5b18027d698c7e494e4256110 (89053099110995010594661038229216983605420219413380810817771304480647904846096) b1 553df54babf90592fbdffa0138b6b5a2a423ea5e2ec4d8f852a33c271a73b10f (38556062768490931671602594328406809964645337276375001909352144464132590252303) a2 ed9e1ee8cb2db1e71311cacd9e1d0b6dbf6cfab15723ec3cac4cc52154fc9d53 (107477520278964342277912932357487306000871347661927764278313323679782451060051) b2 And last we have the commitments Li and Ri of every round. In Grin we create range proofs with a range of 0 to (2^64 -1). This means we have six rounds (log(64) = 6); however, since we stop early, we only do five rounds, so 10 points instead of 12. The implementation always computes L before R. ( inner_product_impl.h 627 ) Again we have an offset in which we specify how to recover y values. Now since we have more than eight points we need two bytes offset. We start reading at the LSB of the first byte and then go to the LSB of the second byte. ( inner_product_impl.h 839 ) 2202 offset 0010 0010 first offset byte (binary) 0000 0010 second offset byte (binary) 02a085238e756ad1fa804cce2a634decc1b348f6ff939f9f80187d85aa5c308224 L1 03a505c75e7f58fc7f35424276db7956474c1895e23ac55f864f4177b59f3ce92e R1 (03 because of the 1 at bit number 2 of first offset byte) 02f8c99e011cf55e0cefc5635d2eaf573df29af057a19bb209392a8c0e29a4b77a L2 02dad76d385422e7f1d06de2d4f14e61ac3619aa22ae5bc288bb41cb56ddb70bb3 R2 029ae84d00eb0cb34b4063bb55a83b9fe52604e545adcd41beb6ce14cdff73a21b L3 03eb7493fa443a34585b7d2927f608cad17aa5f0e8e154b14d35315f63dd3580e8 R3 (03 because of the 1 at bit number 6 of first offset byte) 020d06d8be4039f58778967f7bf2cdd9020fbcc9fed799b8159814f6a261c568e8 L4 02b59c59df3180efb9cc13c576bf313248c96fa867aba43a80e799ff19ac685d72 R4 0208cea7944dc9dcba7a61f2809540ecd0711e76b601969bdc551845e0b11fb821 L5 03871d00e417ad002a70353867db25fa647e98a0db4c3bbaf828d97fc66079ef0d R5 (03 because of the 1 at bit number 2 of second offset byte)","title":"Rangeproof Format"},{"location":"wiki/transactions/range-proof-format/#rangeproof-format","text":"This document could use a re-write.","title":"Rangeproof Format"},{"location":"wiki/transactions/range-proof-format/#secp256k1-zkp-bulletproof-format","text":"Grin uses Bulletproofs , the currently most efficient range proofs which do not require a trusted setup. Implemented at mimblewimble/secp256k1-zkp , a fork of the Blockstream C library ElementsProject/secp256k1-zkp . In this document we explain how to recover the proof parameters from the output bytes. Note that we name the parameters as they are named in the C library, which might be slightly different than the paper in some cases. Here is a sample proof output taken from a Grin transaction: 0b1bdf235e9c438aab5c6d02d3fe8173304bc528a3330825fb2311fa60fcdd6bfb92a248e26f849aebd511d2b326fa34b7f3030517d2f8e08a9b3cac7fa9fd200d07a46ca6ec5af30ce569b1e5faf2acf525cf1ed90cbed74ab7378b9b3957f28635fe7440aac2dc2c4bf43265b6ad1bfa82fddd9a827c4e97a913ce451b9a66bb06d3c08e03e85e98c581bbdf8c852796371a4603b8d52b80a1f2e95bd5e2a91c7a00b4d4564d9586235a7858d9ce8a8888bead7d51be2dd802de5af2921e079586817fce16d36c7764af8b4bf133b56b39970d6a568bf9ff101e6d33409e7c3bb081df7425b276655be611941245ceaad529495a86bc0e3d0f8634a8acf65c34c4e244959a5098bd58285408945a247d2fd894e5b18027d698c7e494e4256110553df54babf90592fbdffa0138b6b5a2a423ea5e2ec4d8f852a33c271a73b10fed9e1ee8cb2db1e71311cacd9e1d0b6dbf6cfab15723ec3cac4cc52154fc9d532202a085238e756ad1fa804cce2a634decc1b348f6ff939f9f80187d85aa5c308224a505c75e7f58fc7f35424276db7956474c1895e23ac55f864f4177b59f3ce92ef8c99e011cf55e0cefc5635d2eaf573df29af057a19bb209392a8c0e29a4b77adad76d385422e7f1d06de2d4f14e61ac3619aa22ae5bc288bb41cb56ddb70bb39ae84d00eb0cb34b4063bb55a83b9fe52604e545adcd41beb6ce14cdff73a21beb7493fa443a34585b7d2927f608cad17aa5f0e8e154b14d35315f63dd3580e80d06d8be4039f58778967f7bf2cdd9020fbcc9fed799b8159814f6a261c568e8b59c59df3180efb9cc13c576bf313248c96fa867aba43a80e799ff19ac685d7208cea7944dc9dcba7a61f2809540ecd0711e76b601969bdc551845e0b11fb821871d00e417ad002a70353867db25fa647e98a0db4c3bbaf828d97fc66079ef0d First, we have two 32 byte scalars. These are the already negated versions of taux and mu. We negate them such that the verifier doesn't have to do it (rangeproof_impl.h 701-702). 0b1bdf235e9c438aab5c6d02d3fe8173304bc528a3330825fb2311fa60fcdd6b (5024686248162052924872973414517693136231035491146611931625298995470137089387) taux (negated) fb92a248e26f849aebd511d2b326fa34b7f3030517d2f8e08a9b3cac7fa9fd20 (113789604713728301456840843635921464549630649029317112794749678552821986360608) mu (negated) After that, we have 4 points, which represent commitments A, S, T1, T2. Points are encoded in a very smart way. We have one offset byte. We use this offset byte indicate the LSB of y, telling us if the points y value needs to be negated when recovered. If this is the case, the bit is set to 1 (starting at the LSB); otherwise, it is left at 0. If we have more then eight points, we need 2 bytes offset, if we have more then 16, then three, and so forth (rangeproof_impl.h 703). 0d offset 0000 1101 offset in binary From this, we can recover the 4 points. (using the standard compressed point version here with leading 02 or 03) We start reading at the LSB. 0307a46ca6ec5af30ce569b1e5faf2acf525cf1ed90cbed74ab7378b9b3957f286 A (03 because of the 1 bit in the offset) 0235fe7440aac2dc2c4bf43265b6ad1bfa82fddd9a827c4e97a913ce451b9a66bb S (02 here because of the 0 bit in the offset) 0306d3c08e03e85e98c581bbdf8c852796371a4603b8d52b80a1f2e95bd5e2a91c T1 037a00b4d4564d9586235a7858d9ce8a8888bead7d51be2dd802de5af2921e0795 T2 Next, we have the final value of the dot product which again is a 32-byte scalar ( inner_product_impl.h 811 ) 86817fce16d36c7764af8b4bf133b56b39970d6a568bf9ff101e6d33409e7c3b (60838727059453008536034129618950719358562694528830851223208761064459354405947) dot Then we have the final values (32-byte scalars) of the shrunk vectors a, b used in the inner product protocol. The library does not do the last round of the protocol, meaning it will stop when the vectors are of length two instead of length one. This is because every round creates two commitments Li and Ri. If we don't do the last round, we spare two commitments with the cost that our two vectors are of size two instead of one, which is more space-efficient, and we save computing time. ( inner_product_impl.h 835-836 ) b081df7425b276655be611941245ceaad529495a86bc0e3d0f8634a8acf65c34 (79836526842770413616887368822368313168206709119259360230886972660827215518772) a1 c4e244959a5098bd58285408945a247d2fd894e5b18027d698c7e494e4256110 (89053099110995010594661038229216983605420219413380810817771304480647904846096) b1 553df54babf90592fbdffa0138b6b5a2a423ea5e2ec4d8f852a33c271a73b10f (38556062768490931671602594328406809964645337276375001909352144464132590252303) a2 ed9e1ee8cb2db1e71311cacd9e1d0b6dbf6cfab15723ec3cac4cc52154fc9d53 (107477520278964342277912932357487306000871347661927764278313323679782451060051) b2 And last we have the commitments Li and Ri of every round. In Grin we create range proofs with a range of 0 to (2^64 -1). This means we have six rounds (log(64) = 6); however, since we stop early, we only do five rounds, so 10 points instead of 12. The implementation always computes L before R. ( inner_product_impl.h 627 ) Again we have an offset in which we specify how to recover y values. Now since we have more than eight points we need two bytes offset. We start reading at the LSB of the first byte and then go to the LSB of the second byte. ( inner_product_impl.h 839 ) 2202 offset 0010 0010 first offset byte (binary) 0000 0010 second offset byte (binary) 02a085238e756ad1fa804cce2a634decc1b348f6ff939f9f80187d85aa5c308224 L1 03a505c75e7f58fc7f35424276db7956474c1895e23ac55f864f4177b59f3ce92e R1 (03 because of the 1 at bit number 2 of first offset byte) 02f8c99e011cf55e0cefc5635d2eaf573df29af057a19bb209392a8c0e29a4b77a L2 02dad76d385422e7f1d06de2d4f14e61ac3619aa22ae5bc288bb41cb56ddb70bb3 R2 029ae84d00eb0cb34b4063bb55a83b9fe52604e545adcd41beb6ce14cdff73a21b L3 03eb7493fa443a34585b7d2927f608cad17aa5f0e8e154b14d35315f63dd3580e8 R3 (03 because of the 1 at bit number 6 of first offset byte) 020d06d8be4039f58778967f7bf2cdd9020fbcc9fed799b8159814f6a261c568e8 L4 02b59c59df3180efb9cc13c576bf313248c96fa867aba43a80e799ff19ac685d72 R4 0208cea7944dc9dcba7a61f2809540ecd0711e76b601969bdc551845e0b11fb821 L5 03871d00e417ad002a70353867db25fa647e98a0db4c3bbaf828d97fc66079ef0d R5 (03 because of the 1 at bit number 2 of second offset byte)","title":"secp256k1-zkp Bulletproof format"},{"location":"wiki/transactions/slatepack/","text":"Slatepack Title: slatepack Authors: joltz Start date: May 07 2020 RFC PR: mimblewimble/grin-rfcs#55 Tracking issue: mimblewimble/grin-wallet#406 Summary Slatepack is a universal transaction standard for Grin. It is designed to provide a single coherent transaction building framework to improve both the user and developer experiences in the Grin ecosystem. All wallets and services are expected to fully support the Slatepack standard by the last scheduled hard fork in January 2021 to remain compatible. This document specifies the required components of the Slatepack standard and introduces them in the context of existing methods for transaction building in Grin. It assumes that Slatepack is the default supported transaction standard for Grin and is intended to operate under all conditions and edge cases. Slatepack is intended to be compatible with the objects and serialization methods defined in the Slate V4/Compact Slates RFC. This RFC is meant to replace the Slate Serialization , Armored Slates and Encrypted Slates RFCs. Motivation Without a comprehensive transaction building flow, users and services are left to make their own complicated decisions about firewalls, file handling and compatibility, risking their security, privacy and sanity. The objective of this RFC is to converge on a simple, universal, adoptable, secure and privacy preserving workflow standard for Grin transactions: Slatepack. Community-level explanation Slatepack changes the existing transaction building process in Grin in a few ways: Users, developers and services are no longer required to choose between many possible transaction methods to use and support: Slatepack is a universal Grin transaction standard The transport method decision now occurs automatically for the user by following the Slatepack standard There is only one synchronous method and one asynchronous method supported by default to keep things simple for developers and support workers Tor is the only synchronous transaction transport method that is currently supported in the Slatepack standard This happens \"under the hood\" by the wallet and the user only has to keep track of a SlatepackAddress for their counterparty If Tor is not successful, the transaction process automatically falls back to using an encrypted copy and pastable SlatepackMessage string to complete the transaction asynchronously The asynchronous method by default is now a copy and pastable SlatepackMessage string instead of a file SlatepackMessage is an ascii-armor string that supports encryption of its payload with a SlatepackAddress An encrypted SlatepackMessage is not meaningfully larger than a plain text SlatepackMessage with regard to transportability as proposed here The difference between synchronous and asynchronous transaction methods is abstracted away from the end user with the Slatepack standard grin-wallet send -d SlatepackAddress 1.337 will first try to send the Grin synchronously via Tor to the SlatepackAddress If that fails it will fall back to outputting an armored encrypted SlatepackMessage string for manual copy and paste transport Example SlatepackAddress : grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x Asynchronous transactions are now encrypted by default by knowing the SlatepackAddress of your counterparty(s) If a counterparty is unwilling or unable to provide a SlatepackAddress , a plain text SlatepackMessage can still be exchanged Sending a mobile Grin transaction should be as easy as scanning a simple QR encoded from a bech32 SlatepackAddress Or as easy as pasting the SlatepackAddress of your counterparty into your wallet for any other device Or if Tor is not accessible, or the receiving party is not online, as easy as copying and pasting a couple of SlatepackMessage strings with a counterparty in an alternative communication channel (email, forum, social media, instant messenger, generic web text box, carrier pigeon etc.) Reference-level explanation The Slatepack standard defines the three primary components: SlatepackAddress , SlatepackMessage and SlatepackWorkflow . The SlatepackAddress is a shareable bech32 encoded ed25519 public key that can be used both to route synchronous transactions and to encrypt asynchronous transactions . The SlatepackMessage is an easily copy and pastable ascii-armor string that contains an encrypted slate payload by default and is used in asynchronous transactions. The SlatepackWorkflow specifies how both of these components interact in a universally adoptable transaction standard for Grin. SlatepackAddress A SlatepackAddress is a bech32 encoded ed25519 public key and when shared with other parties is used to represent the ability to receive Grin transactions. grin-wallet already handles ed25519 keys for the v3 onion addresses in Tor transactions. These keys can be extended to be a general SlatepackAddress to allow a universal key format for both transport and encryption that is error-checked, QR friendly and easily human identifiable. Existing ed25519 public keys from the wallet are bech32 encoded with grin as the human-readable part to build a SlatepackAddress tgrin is the HRP for a floonet SlatepackAddress A SlatepackAddress can be decoded to its ed25519 public key which can then be mapped to an x25519 public key to be used for encryption By default, all wallets should generate a new SlatepackAddress for each transaction for improved user privacy and security. Wallets can optionally support the ability for a static, reusable receiving SlatepackAddress with a warning about the privacy risks of reusing these addresses. The exact proposal for the implementation of simulatenous active SlatepackAddresses to enforce address uniqueness by default according to this standard is left as an implementation detail to wallets to ensure that wallets can interactively receive Grin across many SlatepackAddresses simulataneously and efficiently. ed25519 keys are bech32 encoded as SlatepackAddresses rather than x25519 keys because the mapping from ed25519 to x25519 is more straightforward (x25519 public keys do not carry a v coordinate so they can map to two possible ed25519 public keys- this is solvable but using the ed25519 as the first order key avoids a potentially complex solution). Key Generation Keys used in SlatepackAddresses are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys used to derive Tor onion addresses. ed25519 keys used for a SlatepackAddress are derived from this second derivation path of the master seed. SlatepackAddress keys may be derived in parallel to the blinding factor derivation path such that a unique SlatepackAddress is derived each time a new blinding factor is derived for a transaction to satisfy the requirement for a unique SlatepackAddress to be used for each transaction by default. In a future update it may be desirable to encode the derivation path for the SlatepackAddress for a given encrypted SlatepackMessage somewhere so that the x25519 decryption keys can be derived without grinding down the path to find the right key to use. Example SlatepackAddress grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x SlatepackMessage A SlatepackMessage requires multiple layers of data and encoding. Serialization Grin slates are serialized as first order JSON objects. Binary serialization is done on those JSON objects. Before Slatepack, users could use both binary and JSON serialization for asynchronous transactions. With the Slatepack standard, all asynchronous transactions serialize the slate JSON objects as binary. JSON serialization for synchronous transactions (Tor) is still used as before. The Slatepack standard serialization choices are only relevant for asynchronous transaction methods. The details for the binary serialization of the most recent slates at the time of this writing can be found in the Slate V4 (Compact Slates) RFC. Future variations in slate binary serialization should be referenced in an RFC and may require the update of this document. Plain Text Metadata Plain text metadata is included with Slatepack messages to indicate how to handle the encryption if any for the slate data in addition to tracking versions for compatibility. It can be expanded in future versions with new fields that are safe to include as plain text. These fields are neither encrypted nor authenticated. \"slatepack\": [Major, Minor] Where [Major, Minor] are positive fixnum ints representing the Slatepack version used to build the SlatepackMessage \"mode\": int Where int is a positive fixnum int indicating the type of SlatepackMessage 0 == plain text 1 == encrypted Extendable to future new modes (e.g. multiparty) Indicates which additional metadata fields should be expected to follow \"sender\": SlatepackAddress Only used here where mode == 0 , otherwise this field is encrypted as described below Where SlatepackAddress is a bech32 encoded ed25519 public key generated by the sender's wallet For Slatepacks where the user does not wish to provide any SlatepackAddress a 0 value is used This value is used in the SlatepackWorkflow to attempt to complete the transaction via Tor and to otherwise encrypt a slate for asynchronous transport Encrypted Metadata Encrypted metadata is included with an encrypted SlatepackMessage to improve privacy for the sender of a Slatepack transaction in cases where Tor is not available. It is a basic structure containing the sender SlatepackAddress and potential recipients_list field for multiparty use to be encrypted by age. If these fields are included as plain text metadata, they would require an additional MAC field for authentication and reveal data that would be desirable to keep private. Note that recipients_list does not gain the same privacy advantages of the sender field because the values can be derived from the plain text data included in the age header with a bit of work. \"sender\": SlatepackAddress Used to complete the SlatepackWorkflow \"recipients_list\": vec<SlatepackAddress> Only included in multiparty encrypted mode for use in future versions Array of recipients such that each recipients SlatepackAddress in recipients_list matches their associated epk and emk by index in the age encryption header of the encrypted payload E.g. \"recipients_list\": [grin1a, grin1b] , \"age_header_recipients\": [(X25519, EPKa, EMKa), (X25519, EPKb, EMKb)] grin1a and (X25519, EPKa, EMKa) both belong to the same party as they are both at index 0 grin1b and (X25519, EPKb, EMKb) both belong to the same party as they are both at index 1 Encryption Slatepack encryption adheres to the cryptography decisions made by age . It supports a conversion from the ed25519 signing key type that grin-wallet already uses for Tor to a x25519 encryption key type that age uses for encryption. This allows us to avoid having to make new cryptography decisions to support encrypted slates with keys already used in grin-wallet. While Slatepack adheres to the cryptography decisions and payload structure choices made by age in its encrypted payloads, this data alone is not sufficient to handle all possible SlatepackWorkflow steps (because the age recipient header data contains x25519 keys, we want ed25519 keys for the workflow as key mapping in the other direction is not desirable). It should also be noted that a SlatepackAddress could be used to do generic age encryption by decoding the bech32 to the ed25519 public key and mapping that to its corresponding x25519 public key used in age. An age Address could also be used as a SlatepackAddress with some extra effort: bech32 decode to the x25519 public key and then follow Signal's lead to attempt to solve the problem of an x25519 key mapping to two ed25519 keys to give a single ed25519 public key to be used to build a SlatepackAddress by bech32 encoding with slatepack as the HRP. Payload (age Encryption) A binary serialized slate and associated Encrypted Metadata fields are concatenated and encrypted according to the age encryption specification. The steps taken here follow age as closely as possible to avoid losing any security properties. A fairly well-reviewed age library in rust is available to use for implementation. Any deviations in Slatepack encryption from the exact cryptography steps and decisions made in age are unintentional and should be corrected unless they are explicitly stated as a deviation from the cryptography decisions made by age. An encrypted Slatepack payload is built with the same steps as an encrypted age payload, where the X25519 keys are derived from a participants SlatepackAddress . E.g. age_encrypt(sender + slate_binary) where mode == 1 and sender is a valid SlatepackAddress Armor The payload that will be armored is an optionally encrypted, binary serialized Slatepack JSON object and any associated encrypted metadata. Armor is Framing wrapped around a SimpleBase58Check encoded Payload . Framing Armor uses specific Headers , Footers and Periods as Framing to contain its Payload . Header Supported Headers: BEGINSLATEPACK Regex: ^[>\\n\\r\\t ]*BEGINSLATEPACK[>\\n\\r\\t ]*$ Footer Supported Footers ENDSLATEPACK Regex: ^[>\\n\\r\\t ]*ENDSLATEPACK[>\\n\\r\\t ]*$ Periods All data of an armored slate up to the first . is the framing header All data after the first . and before the second . is the SimpleBase58Check encoded payload which contains the slate data All data after the second . and before the third . is the framing footer Any data after the third . is ignored Encoding SimpleBase58Check SlatepackMessage armor payloads are encoded similar to legacy bitcoin addresses, with the primary differences being that the SimpleBase58Check used here does not include version bytes and includes the error checking code at the beginning of the payload instead of at the end. SHA256(SHA256(SLATEPACK_MESSAGE_BINARY)) First four bytes from previous step are ERROR_CHECK_CODE Concatenate ERROR_CHECK_CODE + SLATEPACK_MESSAGE_BINARY Base58 encode the output from the previous step to complete the armor Payload It should be noted that the ERROR_CHECK_CODE does not have a robust error checking ability because a double sha256 hash is not a proper error check code and the encoding scheme itself was meant to be used for bitcoin addresses which are much smaller than slate payloads. A more robust error correction option was not chosen here because the consequences of the failure to detect an error are not as severe as they would be for a bitcoin address as further validation would need to occur for Grin. The purpose is to catch some characters being accidentally added or lost during armor transport rather than preventing a spend to an address we don't know the key to spend from. Formatting WORD_LENGTH : 15 Number of SimpleBase58Check encoded characters per word; chosen for human readability across device screen sizes LINE_BREAK : 200 words Number of words of WORD_LENGTH to include before inserting a newline; chosen for user friendliness in terminals and messaging applications MAX_STRING_SIZE : 1MB Maximum size for an armored SlatepackMessage string without requiring a file container If a SlatepackMessage exceeds this value it must be handled as a .slatepack file instead of a string This parameter chosen to cover as many cases as possible and still be supported by most clipboards WORD_LENGTH and LINE_BREAK parameters are adjustable as a formatting convenience. MAX_STRING_SIZE is fixed and cannot be exceeded without wrapping the armored SlatepackMessage in a .slatepack file. Edge Case: Large Slates (>1MB) Some slate payloads may be so large that they cannot be reliably handled across all clipboards. To handle these edge cases, a SlatepackMessage will be expected to be passed in a .slatepack file format in cases where Tor is unsuccessful and the armored SlatepackMessage string output would exceed 1MB. A file format was chosen as opposed to a multi-part message approach because messages are already written to file by default by grin-wallet and they are potentially simpler to handle from an implementation perspective. While wallets must support handling these edge cases to avoid all possible cases where a wallet cannot spend or receive a valid transaction, it would be reasonable for services and exchanges to support the Slatepack standard without the requirement of handling the rare file edge case. Example Slatepack JSON Object Mode 0: Plain Text In this plain text example, neither the sender nor the receiver wish to share a SlatepackAddress { \"slatepack\": [1, 0], \"mode\": 0, \"sender\": \"0\", \"payload\": <binary serialized slate> } Mode 1: Encrypted { \"slatepack\": [1, 0], \"mode\": 1, \"payload\": <age encrypted binary: sender slatepack address + binary serialized slate>, } Example SlatepackMessage BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv pcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY GWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx wNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK. SlatepackWorkflow Adoption of the Slatepack standard allows for a unified workflow that can still function without knowledge of a SlatepackAddress from a counterparty. With a SlatepackAddress grin-wallet send -d grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x 1.337 Sender wallet derives an onion v3 address from grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x and attempts to complete the transaction synchronously via Tor (Fallback) If the synchronous transaction fails, a SlatepackMessage string is encrypted to the SlatepackAddress and output for manual asynchronous transport by the user Without a SlatepackAddress grin-wallet send 1.337 A SlatepackMessage string is output for manual asynchronous transport by the user With QR Codes A QR-based SlatepackWorkflow will always begin with a standard QR size because they are encoded directly from a bech32 SlatepackAddress . This encoding simultaneously provides a derivable onion address to attempt a synchronous transaction ( bech32 -> ed25519 -> onionv3 ) and a derivable encryption key ( bech32 -> ed25519 -> x25519 ) to return an encrypted Slatepack string to complete the transaction asynchronously as a fallback. As a consequence, a SlatepackAddress must be revealed by the party producing a QR code in the SlatepackWorkflow . Receiver shares SlatepackAddress via QR Sender scans QR code and the transaction is completed synchronously via Tor by deriving the recipient's onion v3 address from their SlatepackAddress (Fallback) If the synchronous transaction fails, a SlatepackMessage string is output for manual asynchronous transport by the user With Three or More Parties Some possible future Slatepack transactions may require more than two parties to successfully build. These cases should not require any breaking changes to the core Slatepack standard workflow. The exact flow order (round-robin etc) will be defined by the accompanying RFCs that define the possible future multiple party slates themselves. In some cases, new slate versions may require (non-breaking) updates to this RFC. From there, the same standard Slatepack standard workflow of attempting to exchange the data via Tor first with an ascii armor fallback is still valid. For example, a future Slatepack version will add support for an array containing a SlatepackAddress for each party in the order desired to finish building the transaction. The wallet of each subsequent party will attempt to establish a connection with the next via Tor. In the event of a Tor failure it would be the responsibility of the most recent party to manually transport it to the next. In cases with many parties, the fallback method of the Slatepack standard could quickly become cumbersome if, for example, every third participant fails to achieve a Tor connection. Implementation Timeline Initial Slatepack implementation introduced with the July 2020 hard fork May or may not support encryption by default yet The proposed Slatepack standard is fully implemented and adopted as a universal transaction standard in last hard fork (Jan 2021) Slatepack is the default transaction standard in all wallets and services Drawbacks This puts a lot of eggs in one basket (if Slatepack fails there will likely be confusion returning to old methods) This may be a bit rushed to have where we want it before HF schedule Deprecating HTTP(S) is already a major change- by requiring the adoption of this completely new standard in addition we risk putting a lot of effort on the shoulders of existing services in the Grin ecosystem Rationale and alternatives By adding new options without simplifying the workflow for users we risk confusion and friction We could just add an option for copy and pastable slates instead of introducing an entirely new universal transaction flow standard Prior art Note that while previous asynchronous Mimblewimble transaction solutions require a relatively short TTL for a counterparty to successfully connect to their respective network before transactions fail (currently 72 hours for Tari DHT Network, 24 hours for Beam SBBS), Grin Slatepack transactions can remain valid indefinitely without spamming the network when using the ascii armor fallback. Tari Tari uses the Tari DHT Network to support asynchronous Mimblewimble transactions. This approach is comprehensive and comprises of the entire peer to peer messaging network, including both nodes and wallets. This is distinct from Slatepack which is strictly an approach to transaction building between wallet software, not general protocol messaging. Similar to Slatepack, Tari users derive a public key from their master seed (which is represented to users as emojis instead of bech32) and is used to look up peers in peer databases (as opposed to directly routing to a traditional Tor hidden service as in Slatepack). By default, Tari, like Slatepack, uses Tor for communication. While Slatepack and Tari both have addresses that decode to public keys used to find and communicate with counterparty wallets via Tor, they both handle the Tor failure case differently. Tari seems to rely on its custom DHT network to gracefully handle this at the cost of the complexity of a custom DHT layer. Slatepack falls back to an unopinionated, encrypted ascii armor string for the user to transport \"outside of the Grin network\" to complete the transaction. The advantage for Slatepack is significantly reduced complexity by using Tor directly with an unopinionated fallback mode. The disadvantage for Slatepack is that transactions don't \"magically\" just work if Tor communication is failing- they still require some effort from the user to transport the ascii armor themselves. Note that these details were taken from early documentation and not code- transactions in Tari may behave differently in practice. Beam Beam uses the SBBS gossip protocol to support asynchronous mimblewimble transactions. SBBS adds a nontrivial amount of complexity and attack surface to the core Beam software. In exchange, Beam receives a somewhat user-friendly mechanism for users to build transactions asynchronously. The asynchronous fallback method for Slatepack transactions is a simple ascii armor string that does not contain an opinion about a particular protocol with which to exchange the data. The advantage with the Slatepack method is that much less code is required to support these transactions which can improve the overall stability and security of the codebase running the Grin network. The disadvantage of this for Slatepack is that asynchronous transactions don't \"magically\" work- they still need to be between users via an outside channel (instant message, text box, email etc). Slatepack makes the tradeoff of slightly more work for the end user in exchange for a simpler and potentially more secure network for Grin. Unresolved questions How to handle key derivation harmoniously? What are unmentioned security considerations for using the same base key to both map to an onion address and map to an encryption key used in transactions? Related, what are unmentioned security considerations to SlatepackAddress reuse? Should we still use double-sha256 in SimpleBase58Check or take the opportunity to use a BCH or CRC code which may be more appropriate for error detection on slatepack messages? Is additional engineering desired here if there will always be further validation of the slate payload before a spend can occur? If addresses are not reused by default and since wallets need to be able to conduct multiple transactions in parallel, they need the ability to listen on all \"active\" addresses at the same time Future possibilities Extended to support future modes (payment channel, payjoin, multiple counterparties etc) An entirely different standard could be adopted in the future if non-interactive transactions become the default, eliminating the need for Slatepack It might be possible for a new standard to remain compatible with the existing SlatepackAddress to allow a more generic GrinAddress References Bitcoin BIP173 \u21a9 age - File Encryption Tool & Format \u21a9 age Rust library \u21a9 Ed25519 Keys \u21a9 Ed25519 to Curve25519 \u21a9 Using Ed25519 signing keys for encryption \u21a9 Armored Slates RFC \u21a9 Saltpack \u21a9 Tor v3 Specification \u21a9 Signal Docs XEdDSA \u21a9 How Tari Works \u21a9 Beam Docs SBBS \u21a9","title":"Slatepack"},{"location":"wiki/transactions/slatepack/#slatepack","text":"Title: slatepack Authors: joltz Start date: May 07 2020 RFC PR: mimblewimble/grin-rfcs#55 Tracking issue: mimblewimble/grin-wallet#406","title":"Slatepack"},{"location":"wiki/transactions/slatepack/#summary","text":"Slatepack is a universal transaction standard for Grin. It is designed to provide a single coherent transaction building framework to improve both the user and developer experiences in the Grin ecosystem. All wallets and services are expected to fully support the Slatepack standard by the last scheduled hard fork in January 2021 to remain compatible. This document specifies the required components of the Slatepack standard and introduces them in the context of existing methods for transaction building in Grin. It assumes that Slatepack is the default supported transaction standard for Grin and is intended to operate under all conditions and edge cases. Slatepack is intended to be compatible with the objects and serialization methods defined in the Slate V4/Compact Slates RFC. This RFC is meant to replace the Slate Serialization , Armored Slates and Encrypted Slates RFCs.","title":"Summary"},{"location":"wiki/transactions/slatepack/#motivation","text":"Without a comprehensive transaction building flow, users and services are left to make their own complicated decisions about firewalls, file handling and compatibility, risking their security, privacy and sanity. The objective of this RFC is to converge on a simple, universal, adoptable, secure and privacy preserving workflow standard for Grin transactions: Slatepack.","title":"Motivation"},{"location":"wiki/transactions/slatepack/#community-level-explanation","text":"Slatepack changes the existing transaction building process in Grin in a few ways: Users, developers and services are no longer required to choose between many possible transaction methods to use and support: Slatepack is a universal Grin transaction standard The transport method decision now occurs automatically for the user by following the Slatepack standard There is only one synchronous method and one asynchronous method supported by default to keep things simple for developers and support workers Tor is the only synchronous transaction transport method that is currently supported in the Slatepack standard This happens \"under the hood\" by the wallet and the user only has to keep track of a SlatepackAddress for their counterparty If Tor is not successful, the transaction process automatically falls back to using an encrypted copy and pastable SlatepackMessage string to complete the transaction asynchronously The asynchronous method by default is now a copy and pastable SlatepackMessage string instead of a file SlatepackMessage is an ascii-armor string that supports encryption of its payload with a SlatepackAddress An encrypted SlatepackMessage is not meaningfully larger than a plain text SlatepackMessage with regard to transportability as proposed here The difference between synchronous and asynchronous transaction methods is abstracted away from the end user with the Slatepack standard grin-wallet send -d SlatepackAddress 1.337 will first try to send the Grin synchronously via Tor to the SlatepackAddress If that fails it will fall back to outputting an armored encrypted SlatepackMessage string for manual copy and paste transport Example SlatepackAddress : grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x Asynchronous transactions are now encrypted by default by knowing the SlatepackAddress of your counterparty(s) If a counterparty is unwilling or unable to provide a SlatepackAddress , a plain text SlatepackMessage can still be exchanged Sending a mobile Grin transaction should be as easy as scanning a simple QR encoded from a bech32 SlatepackAddress Or as easy as pasting the SlatepackAddress of your counterparty into your wallet for any other device Or if Tor is not accessible, or the receiving party is not online, as easy as copying and pasting a couple of SlatepackMessage strings with a counterparty in an alternative communication channel (email, forum, social media, instant messenger, generic web text box, carrier pigeon etc.)","title":"Community-level explanation"},{"location":"wiki/transactions/slatepack/#reference-level-explanation","text":"The Slatepack standard defines the three primary components: SlatepackAddress , SlatepackMessage and SlatepackWorkflow . The SlatepackAddress is a shareable bech32 encoded ed25519 public key that can be used both to route synchronous transactions and to encrypt asynchronous transactions . The SlatepackMessage is an easily copy and pastable ascii-armor string that contains an encrypted slate payload by default and is used in asynchronous transactions. The SlatepackWorkflow specifies how both of these components interact in a universally adoptable transaction standard for Grin.","title":"Reference-level explanation"},{"location":"wiki/transactions/slatepack/#slatepackaddress","text":"A SlatepackAddress is a bech32 encoded ed25519 public key and when shared with other parties is used to represent the ability to receive Grin transactions. grin-wallet already handles ed25519 keys for the v3 onion addresses in Tor transactions. These keys can be extended to be a general SlatepackAddress to allow a universal key format for both transport and encryption that is error-checked, QR friendly and easily human identifiable. Existing ed25519 public keys from the wallet are bech32 encoded with grin as the human-readable part to build a SlatepackAddress tgrin is the HRP for a floonet SlatepackAddress A SlatepackAddress can be decoded to its ed25519 public key which can then be mapped to an x25519 public key to be used for encryption By default, all wallets should generate a new SlatepackAddress for each transaction for improved user privacy and security. Wallets can optionally support the ability for a static, reusable receiving SlatepackAddress with a warning about the privacy risks of reusing these addresses. The exact proposal for the implementation of simulatenous active SlatepackAddresses to enforce address uniqueness by default according to this standard is left as an implementation detail to wallets to ensure that wallets can interactively receive Grin across many SlatepackAddresses simulataneously and efficiently. ed25519 keys are bech32 encoded as SlatepackAddresses rather than x25519 keys because the mapping from ed25519 to x25519 is more straightforward (x25519 public keys do not carry a v coordinate so they can map to two possible ed25519 public keys- this is solvable but using the ed25519 as the first order key avoids a potentially complex solution).","title":"SlatepackAddress"},{"location":"wiki/transactions/slatepack/#key-generation","text":"Keys used in SlatepackAddresses are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys used to derive Tor onion addresses. ed25519 keys used for a SlatepackAddress are derived from this second derivation path of the master seed. SlatepackAddress keys may be derived in parallel to the blinding factor derivation path such that a unique SlatepackAddress is derived each time a new blinding factor is derived for a transaction to satisfy the requirement for a unique SlatepackAddress to be used for each transaction by default. In a future update it may be desirable to encode the derivation path for the SlatepackAddress for a given encrypted SlatepackMessage somewhere so that the x25519 decryption keys can be derived without grinding down the path to find the right key to use.","title":"Key Generation"},{"location":"wiki/transactions/slatepack/#example-slatepackaddress","text":"grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x","title":"Example SlatepackAddress"},{"location":"wiki/transactions/slatepack/#slatepackmessage","text":"A SlatepackMessage requires multiple layers of data and encoding.","title":"SlatepackMessage"},{"location":"wiki/transactions/slatepack/#serialization","text":"Grin slates are serialized as first order JSON objects. Binary serialization is done on those JSON objects. Before Slatepack, users could use both binary and JSON serialization for asynchronous transactions. With the Slatepack standard, all asynchronous transactions serialize the slate JSON objects as binary. JSON serialization for synchronous transactions (Tor) is still used as before. The Slatepack standard serialization choices are only relevant for asynchronous transaction methods. The details for the binary serialization of the most recent slates at the time of this writing can be found in the Slate V4 (Compact Slates) RFC. Future variations in slate binary serialization should be referenced in an RFC and may require the update of this document.","title":"Serialization"},{"location":"wiki/transactions/slatepack/#plain-text-metadata","text":"Plain text metadata is included with Slatepack messages to indicate how to handle the encryption if any for the slate data in addition to tracking versions for compatibility. It can be expanded in future versions with new fields that are safe to include as plain text. These fields are neither encrypted nor authenticated. \"slatepack\": [Major, Minor] Where [Major, Minor] are positive fixnum ints representing the Slatepack version used to build the SlatepackMessage \"mode\": int Where int is a positive fixnum int indicating the type of SlatepackMessage 0 == plain text 1 == encrypted Extendable to future new modes (e.g. multiparty) Indicates which additional metadata fields should be expected to follow \"sender\": SlatepackAddress Only used here where mode == 0 , otherwise this field is encrypted as described below Where SlatepackAddress is a bech32 encoded ed25519 public key generated by the sender's wallet For Slatepacks where the user does not wish to provide any SlatepackAddress a 0 value is used This value is used in the SlatepackWorkflow to attempt to complete the transaction via Tor and to otherwise encrypt a slate for asynchronous transport","title":"Plain Text Metadata"},{"location":"wiki/transactions/slatepack/#encrypted-metadata","text":"Encrypted metadata is included with an encrypted SlatepackMessage to improve privacy for the sender of a Slatepack transaction in cases where Tor is not available. It is a basic structure containing the sender SlatepackAddress and potential recipients_list field for multiparty use to be encrypted by age. If these fields are included as plain text metadata, they would require an additional MAC field for authentication and reveal data that would be desirable to keep private. Note that recipients_list does not gain the same privacy advantages of the sender field because the values can be derived from the plain text data included in the age header with a bit of work. \"sender\": SlatepackAddress Used to complete the SlatepackWorkflow \"recipients_list\": vec<SlatepackAddress> Only included in multiparty encrypted mode for use in future versions Array of recipients such that each recipients SlatepackAddress in recipients_list matches their associated epk and emk by index in the age encryption header of the encrypted payload E.g. \"recipients_list\": [grin1a, grin1b] , \"age_header_recipients\": [(X25519, EPKa, EMKa), (X25519, EPKb, EMKb)] grin1a and (X25519, EPKa, EMKa) both belong to the same party as they are both at index 0 grin1b and (X25519, EPKb, EMKb) both belong to the same party as they are both at index 1","title":"Encrypted Metadata"},{"location":"wiki/transactions/slatepack/#encryption","text":"Slatepack encryption adheres to the cryptography decisions made by age . It supports a conversion from the ed25519 signing key type that grin-wallet already uses for Tor to a x25519 encryption key type that age uses for encryption. This allows us to avoid having to make new cryptography decisions to support encrypted slates with keys already used in grin-wallet. While Slatepack adheres to the cryptography decisions and payload structure choices made by age in its encrypted payloads, this data alone is not sufficient to handle all possible SlatepackWorkflow steps (because the age recipient header data contains x25519 keys, we want ed25519 keys for the workflow as key mapping in the other direction is not desirable). It should also be noted that a SlatepackAddress could be used to do generic age encryption by decoding the bech32 to the ed25519 public key and mapping that to its corresponding x25519 public key used in age. An age Address could also be used as a SlatepackAddress with some extra effort: bech32 decode to the x25519 public key and then follow Signal's lead to attempt to solve the problem of an x25519 key mapping to two ed25519 keys to give a single ed25519 public key to be used to build a SlatepackAddress by bech32 encoding with slatepack as the HRP.","title":"Encryption"},{"location":"wiki/transactions/slatepack/#payload-age-encryption","text":"A binary serialized slate and associated Encrypted Metadata fields are concatenated and encrypted according to the age encryption specification. The steps taken here follow age as closely as possible to avoid losing any security properties. A fairly well-reviewed age library in rust is available to use for implementation. Any deviations in Slatepack encryption from the exact cryptography steps and decisions made in age are unintentional and should be corrected unless they are explicitly stated as a deviation from the cryptography decisions made by age. An encrypted Slatepack payload is built with the same steps as an encrypted age payload, where the X25519 keys are derived from a participants SlatepackAddress . E.g. age_encrypt(sender + slate_binary) where mode == 1 and sender is a valid SlatepackAddress","title":"Payload (age Encryption)"},{"location":"wiki/transactions/slatepack/#armor","text":"The payload that will be armored is an optionally encrypted, binary serialized Slatepack JSON object and any associated encrypted metadata. Armor is Framing wrapped around a SimpleBase58Check encoded Payload .","title":"Armor"},{"location":"wiki/transactions/slatepack/#framing","text":"Armor uses specific Headers , Footers and Periods as Framing to contain its Payload . Header Supported Headers: BEGINSLATEPACK Regex: ^[>\\n\\r\\t ]*BEGINSLATEPACK[>\\n\\r\\t ]*$ Footer Supported Footers ENDSLATEPACK Regex: ^[>\\n\\r\\t ]*ENDSLATEPACK[>\\n\\r\\t ]*$ Periods All data of an armored slate up to the first . is the framing header All data after the first . and before the second . is the SimpleBase58Check encoded payload which contains the slate data All data after the second . and before the third . is the framing footer Any data after the third . is ignored","title":"Framing"},{"location":"wiki/transactions/slatepack/#encoding-simplebase58check","text":"SlatepackMessage armor payloads are encoded similar to legacy bitcoin addresses, with the primary differences being that the SimpleBase58Check used here does not include version bytes and includes the error checking code at the beginning of the payload instead of at the end. SHA256(SHA256(SLATEPACK_MESSAGE_BINARY)) First four bytes from previous step are ERROR_CHECK_CODE Concatenate ERROR_CHECK_CODE + SLATEPACK_MESSAGE_BINARY Base58 encode the output from the previous step to complete the armor Payload It should be noted that the ERROR_CHECK_CODE does not have a robust error checking ability because a double sha256 hash is not a proper error check code and the encoding scheme itself was meant to be used for bitcoin addresses which are much smaller than slate payloads. A more robust error correction option was not chosen here because the consequences of the failure to detect an error are not as severe as they would be for a bitcoin address as further validation would need to occur for Grin. The purpose is to catch some characters being accidentally added or lost during armor transport rather than preventing a spend to an address we don't know the key to spend from.","title":"Encoding SimpleBase58Check"},{"location":"wiki/transactions/slatepack/#formatting","text":"WORD_LENGTH : 15 Number of SimpleBase58Check encoded characters per word; chosen for human readability across device screen sizes LINE_BREAK : 200 words Number of words of WORD_LENGTH to include before inserting a newline; chosen for user friendliness in terminals and messaging applications MAX_STRING_SIZE : 1MB Maximum size for an armored SlatepackMessage string without requiring a file container If a SlatepackMessage exceeds this value it must be handled as a .slatepack file instead of a string This parameter chosen to cover as many cases as possible and still be supported by most clipboards WORD_LENGTH and LINE_BREAK parameters are adjustable as a formatting convenience. MAX_STRING_SIZE is fixed and cannot be exceeded without wrapping the armored SlatepackMessage in a .slatepack file.","title":"Formatting"},{"location":"wiki/transactions/slatepack/#edge-case-large-slates-1mb","text":"Some slate payloads may be so large that they cannot be reliably handled across all clipboards. To handle these edge cases, a SlatepackMessage will be expected to be passed in a .slatepack file format in cases where Tor is unsuccessful and the armored SlatepackMessage string output would exceed 1MB. A file format was chosen as opposed to a multi-part message approach because messages are already written to file by default by grin-wallet and they are potentially simpler to handle from an implementation perspective. While wallets must support handling these edge cases to avoid all possible cases where a wallet cannot spend or receive a valid transaction, it would be reasonable for services and exchanges to support the Slatepack standard without the requirement of handling the rare file edge case.","title":"Edge Case: Large Slates (&gt;1MB)"},{"location":"wiki/transactions/slatepack/#example-slatepack-json-object","text":"","title":"Example Slatepack JSON Object"},{"location":"wiki/transactions/slatepack/#mode-0-plain-text","text":"In this plain text example, neither the sender nor the receiver wish to share a SlatepackAddress { \"slatepack\": [1, 0], \"mode\": 0, \"sender\": \"0\", \"payload\": <binary serialized slate> }","title":"Mode 0: Plain Text"},{"location":"wiki/transactions/slatepack/#mode-1-encrypted","text":"{ \"slatepack\": [1, 0], \"mode\": 1, \"payload\": <age encrypted binary: sender slatepack address + binary serialized slate>, }","title":"Mode 1: Encrypted"},{"location":"wiki/transactions/slatepack/#example-slatepackmessage","text":"BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv pcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY GWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx wNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK.","title":"Example SlatepackMessage"},{"location":"wiki/transactions/slatepack/#slatepackworkflow","text":"Adoption of the Slatepack standard allows for a unified workflow that can still function without knowledge of a SlatepackAddress from a counterparty.","title":"SlatepackWorkflow"},{"location":"wiki/transactions/slatepack/#with-a-slatepackaddress","text":"grin-wallet send -d grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x 1.337 Sender wallet derives an onion v3 address from grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x and attempts to complete the transaction synchronously via Tor (Fallback) If the synchronous transaction fails, a SlatepackMessage string is encrypted to the SlatepackAddress and output for manual asynchronous transport by the user","title":"With a SlatepackAddress"},{"location":"wiki/transactions/slatepack/#without-a-slatepackaddress","text":"grin-wallet send 1.337 A SlatepackMessage string is output for manual asynchronous transport by the user","title":"Without a SlatepackAddress"},{"location":"wiki/transactions/slatepack/#with-qr-codes","text":"A QR-based SlatepackWorkflow will always begin with a standard QR size because they are encoded directly from a bech32 SlatepackAddress . This encoding simultaneously provides a derivable onion address to attempt a synchronous transaction ( bech32 -> ed25519 -> onionv3 ) and a derivable encryption key ( bech32 -> ed25519 -> x25519 ) to return an encrypted Slatepack string to complete the transaction asynchronously as a fallback. As a consequence, a SlatepackAddress must be revealed by the party producing a QR code in the SlatepackWorkflow . Receiver shares SlatepackAddress via QR Sender scans QR code and the transaction is completed synchronously via Tor by deriving the recipient's onion v3 address from their SlatepackAddress (Fallback) If the synchronous transaction fails, a SlatepackMessage string is output for manual asynchronous transport by the user","title":"With QR Codes"},{"location":"wiki/transactions/slatepack/#with-three-or-more-parties","text":"Some possible future Slatepack transactions may require more than two parties to successfully build. These cases should not require any breaking changes to the core Slatepack standard workflow. The exact flow order (round-robin etc) will be defined by the accompanying RFCs that define the possible future multiple party slates themselves. In some cases, new slate versions may require (non-breaking) updates to this RFC. From there, the same standard Slatepack standard workflow of attempting to exchange the data via Tor first with an ascii armor fallback is still valid. For example, a future Slatepack version will add support for an array containing a SlatepackAddress for each party in the order desired to finish building the transaction. The wallet of each subsequent party will attempt to establish a connection with the next via Tor. In the event of a Tor failure it would be the responsibility of the most recent party to manually transport it to the next. In cases with many parties, the fallback method of the Slatepack standard could quickly become cumbersome if, for example, every third participant fails to achieve a Tor connection.","title":"With Three or More Parties"},{"location":"wiki/transactions/slatepack/#implementation-timeline","text":"Initial Slatepack implementation introduced with the July 2020 hard fork May or may not support encryption by default yet The proposed Slatepack standard is fully implemented and adopted as a universal transaction standard in last hard fork (Jan 2021) Slatepack is the default transaction standard in all wallets and services","title":"Implementation Timeline"},{"location":"wiki/transactions/slatepack/#drawbacks","text":"This puts a lot of eggs in one basket (if Slatepack fails there will likely be confusion returning to old methods) This may be a bit rushed to have where we want it before HF schedule Deprecating HTTP(S) is already a major change- by requiring the adoption of this completely new standard in addition we risk putting a lot of effort on the shoulders of existing services in the Grin ecosystem","title":"Drawbacks"},{"location":"wiki/transactions/slatepack/#rationale-and-alternatives","text":"By adding new options without simplifying the workflow for users we risk confusion and friction We could just add an option for copy and pastable slates instead of introducing an entirely new universal transaction flow standard","title":"Rationale and alternatives"},{"location":"wiki/transactions/slatepack/#prior-art","text":"Note that while previous asynchronous Mimblewimble transaction solutions require a relatively short TTL for a counterparty to successfully connect to their respective network before transactions fail (currently 72 hours for Tari DHT Network, 24 hours for Beam SBBS), Grin Slatepack transactions can remain valid indefinitely without spamming the network when using the ascii armor fallback.","title":"Prior art"},{"location":"wiki/transactions/slatepack/#tari","text":"Tari uses the Tari DHT Network to support asynchronous Mimblewimble transactions. This approach is comprehensive and comprises of the entire peer to peer messaging network, including both nodes and wallets. This is distinct from Slatepack which is strictly an approach to transaction building between wallet software, not general protocol messaging. Similar to Slatepack, Tari users derive a public key from their master seed (which is represented to users as emojis instead of bech32) and is used to look up peers in peer databases (as opposed to directly routing to a traditional Tor hidden service as in Slatepack). By default, Tari, like Slatepack, uses Tor for communication. While Slatepack and Tari both have addresses that decode to public keys used to find and communicate with counterparty wallets via Tor, they both handle the Tor failure case differently. Tari seems to rely on its custom DHT network to gracefully handle this at the cost of the complexity of a custom DHT layer. Slatepack falls back to an unopinionated, encrypted ascii armor string for the user to transport \"outside of the Grin network\" to complete the transaction. The advantage for Slatepack is significantly reduced complexity by using Tor directly with an unopinionated fallback mode. The disadvantage for Slatepack is that transactions don't \"magically\" just work if Tor communication is failing- they still require some effort from the user to transport the ascii armor themselves. Note that these details were taken from early documentation and not code- transactions in Tari may behave differently in practice.","title":"Tari"},{"location":"wiki/transactions/slatepack/#beam","text":"Beam uses the SBBS gossip protocol to support asynchronous mimblewimble transactions. SBBS adds a nontrivial amount of complexity and attack surface to the core Beam software. In exchange, Beam receives a somewhat user-friendly mechanism for users to build transactions asynchronously. The asynchronous fallback method for Slatepack transactions is a simple ascii armor string that does not contain an opinion about a particular protocol with which to exchange the data. The advantage with the Slatepack method is that much less code is required to support these transactions which can improve the overall stability and security of the codebase running the Grin network. The disadvantage of this for Slatepack is that asynchronous transactions don't \"magically\" work- they still need to be between users via an outside channel (instant message, text box, email etc). Slatepack makes the tradeoff of slightly more work for the end user in exchange for a simpler and potentially more secure network for Grin.","title":"Beam"},{"location":"wiki/transactions/slatepack/#unresolved-questions","text":"How to handle key derivation harmoniously? What are unmentioned security considerations for using the same base key to both map to an onion address and map to an encryption key used in transactions? Related, what are unmentioned security considerations to SlatepackAddress reuse? Should we still use double-sha256 in SimpleBase58Check or take the opportunity to use a BCH or CRC code which may be more appropriate for error detection on slatepack messages? Is additional engineering desired here if there will always be further validation of the slate payload before a spend can occur? If addresses are not reused by default and since wallets need to be able to conduct multiple transactions in parallel, they need the ability to listen on all \"active\" addresses at the same time","title":"Unresolved questions"},{"location":"wiki/transactions/slatepack/#future-possibilities","text":"Extended to support future modes (payment channel, payjoin, multiple counterparties etc) An entirely different standard could be adopted in the future if non-interactive transactions become the default, eliminating the need for Slatepack It might be possible for a new standard to remain compatible with the existing SlatepackAddress to allow a more generic GrinAddress","title":"Future possibilities"},{"location":"wiki/transactions/slatepack/#references","text":"Bitcoin BIP173 \u21a9 age - File Encryption Tool & Format \u21a9 age Rust library \u21a9 Ed25519 Keys \u21a9 Ed25519 to Curve25519 \u21a9 Using Ed25519 signing keys for encryption \u21a9 Armored Slates RFC \u21a9 Saltpack \u21a9 Tor v3 Specification \u21a9 Signal Docs XEdDSA \u21a9 How Tari Works \u21a9 Beam Docs SBBS \u21a9","title":"References"},{"location":"wiki/transactions/slates/","text":"Slates Title: slate-v4 (compact slates) Authors: Michael Cordner Start date: April 03 2020 RFC PR: mimblewimble/grin-rfcs#49 Tracking issue: mimblewimble/grin-wallet#317 Summary What is a slate? To exchange Grin, users must exchange transaction slates in one form or another. A transaction slate is a blob containing the necessary data to be included at each step of the transaction building process. This RFC describes the changes between version 3 and version 4 of the Slate transaction exchange format, which had the goal of reducing the contents of the Slate to be as minimal as possible. Motivation Previously, the definition of Slate versions up to V3 had been put together with no regard for its size or/and redundant/irrelevant content. In order to facilitate future exchange method possibilities, it's desirable to ensure the Slate is as compact as possible, particularly on the 'first leg' of a transaction exchange which only actually requires minimal information from the transaction initiator. This RFC aims to define the contents of a streamlined \"compact\" slate by: Removing all redundant or unnecessary Slate fields Shortening the names of many Slate fields Reducing the size of the Slate to at all phases of a transaction Defining an optional highly-minimized binary format for Slate output Although this RFC doesn't address any particular transaction exchange methods that might be facilitated by this streamlining, one could envisage possibilities such as: An exchange placing the entire initial slate in a QR code Encoding the initial slate as an easily-cut-and-paste chunk Community-level explanation There are two basic transaction workflows in a two-party Grin transaction: In the Basic workflow, a sender adds their inputs and change outputs to a transaction, and sends them, along with the fee, the amount and their signature data to the recipient. The recipient adds a output for the amount to the transaction, adds their signature data and returns to the sender, who completes the transaction and posts. In the Invoice workflow, the invoice creator adds a new output to a transaction, and sends the amount and signature data to the payer. The payer adds their inputs and change outputs to the transaction along with their signature data and fee information, then returns to the invoicer, who completes the transaction and posts. Although previous versions of the Slate included every party's complete inputs and outputs at every stage of the transaction, it is not technically necessary for the initiator to provide their inputs and outputs to the other party. It suffices for the initiator to store the input/output listing in their local transaction context, and only provide the amount, fee, excess and signature data to the other party. Recognising this, it is possible to ensure that the 'first-leg' of a transaction stage is extremely compact. For instance, version 3 of the Slate on transaction initiation may have looked something like the following: { \"version_info\": { \"version\": 3, \"orig_version\": 3, \"block_header_version\": 2 }, \"num_participants\": 2, \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"tx\": { \"offset\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"body\": { \"inputs\": [ { \"features\": \"Coinbase\", \"commit\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"features\": \"Coinbase\", \"commit\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ], \"outputs\": [ { \"features\": \"Plain\", \"commit\": \"0812276cc788e6870612296d926cba9f0e7b9810670710b5a6e6f1ba006d395774\", \"proof\": \"dcff6175390c602bfa92c2ffd1a9b2d84dcc9ea941f6f317bdd0f875244ef23e696fd17c71df79760ce5ce1a96aab1d15dd057358dc835e972febeb86d50ccec0dad7cfe0246d742eb753cf7b88c045d15bc7123f8cf7155647ccf663fca92a83c9a65d0ed756ea7ebffd2cac90c380a102ed9caaa355d175ed0bf58d3ac2f5e909d6c447dfc6b605e04925c2b17c33ebd1908c965a5541ea5d2ed45a0958e6402f89d7a56df1992e036d836e74017e73ccad5cb3a82b8e139e309792a31b15f3ffd72ed033253428c156c2b9799458a25c1da65b719780a22de7fe7f437ae2fccd22cf7ea357ab5aa66a5ef7d71fb0dc64aa0b5761f68278062bb39bb296c787e4cabc5e2a2933a416ce1c9a9696160386449c437e9120f7bb26e5b0e74d1f2e7d5bcd7aafb2a92b87d1548f1f911fb06af7bd6cc13cee29f7c9cb79021aed18186272af0e9d189ec107c81a8a3aeb4782b0d950e4881aa51b776bb6844b25bce97035b48a9bdb2aea3608687bcdd479d4fa998b5a839ff88558e4a29dff0ed13b55900abb5d439b70793d902ae9ad34587b18c919f6b875c91d14deeb1c373f5e76570d59a6549758f655f1128a54f162dfe8868e1587028e26ad91e528c5ae7ee9335fa58fb59022b5de29d80f0764a9917390d46db899acc6a5b416e25ecc9dccb7153646addcc81cadb5f0078febc7e05d7735aba494f39ef05697bbcc9b47b2ccc79595d75fc13c80678b5e237edce58d731f34c05b1ddcaa649acf2d865bbbc3ceda10508bcdd29d0496744644bf1c3516f6687dfeef5649c7dff90627d642739a59d91a8d1d0c4dc55d74a949e1074427664b467992c9e0f7d3af9d6ea79513e8946ddc0d356bac49878e64e6a95b0a30214214faf2ce317fa622ff3266b32a816e10a18e6d789a5da1f23e67b4f970a68a7bcd9e18825ee274b0483896a40\" } ], \"kernels\": [ { \"features\": \"Plain\", \"fee\": \"7000000\", \"lock_height\": \"0\", \"excess\": \"000000000000000000000000000000000000000000000000000000000000000000\", \"excess_sig\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } ] } }, \"amount\": \"60000000000\", \"fee\": \"7000000\", \"height\": \"5\", \"lock_height\": \"0\", \"ttl_cutoff_height\": null, \"payment_proof\": null, \"participant_data\": [ { \"id\": \"0\", \"public_blind_excess\": \"033ac2158fa0077f087de60c19d8e431753baa5b63b6e1477f05a2a6e7190d4592\", \"public_nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part_sig\": null, \"message\": null, \"message_sig\": null } ] } In version 4 of the Slate format, the initial Slate now looks like the following: { \"ver\": \"4:2\" \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"amt\": \"6000000000\", \"fee\": \"8000000\", \"sigs\": [ { \"xs\": \"023878ce845727f3a4ec76ca3f3db4b38a2d05d636b8c3632108b857fed63c96de\" \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ], } While a \"return\" slate might look something like the following: { \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S2\", \"off\": \"a4052c9200000001a6052c9200000002ed564fab50b75fc5ea32ce052fc9bebf\", \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part\": \"8f07ddd5e9f5179cff19486034181ed76505baaad53e5d994064127b56c5841b54735cb9ed2f59fb457144f7b1c8226d08b54cbdd0eb7e6492950751b0bb54f9\" } ], \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" } ] } The 'return' slate from the recipient to the originator is expected to be larger, as it must include the recipient's outputs/inputs and proofs (as the party who posts the transaction needs all of this information). However, compacting the slate at each stage of its journey allows for future possibilities that may have been more difficult in previous iterations of the slate format. For instance, an initiator taking Grin payments might be expected to be better equipped to receive Grin transactions. They could present the payer with an invoice transaction for the amount compacted to the size of a QR code, which the payer could scan, accept, and then post back to the invoicer's listening wallet infrastructure. Compacting the slate also acts as a minor privacy-enhancer by hiding the initiator's outputs from the other party. Reference-level explanation Slate Definition - JSON Entries prefixed with // denote fields that may be omitted, as well as their default assumed values. # denotes a comment for the purposes of illustration. Field ordering is canonical. { # These fields are always present \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", # These fields may or may not be present //\"num_parts: 2, //\"fee\": \"8000000\", //\"amt\": \"1000000000\", //\"feat\": 0, //\"ttl\": null, # Sigs is always present with at least one entry \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", // \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ] # These structs may or may not be present //\"coms\": null, //\"proof\": null, //\"feat_args\": null } A description of all fields and their meanings is as follows: Top-Level Slate Struct Fields Always ver - The slate version and supported block header version, separated by a : id - The slate's UUID, standard hex-string encoding for UUIDs sta - 2 character String representing the current stage of the the transaction. See Status Codes off - The running transaction offset total, hex-string encoded. All parties select a random offset at the beginning of the transaction and subtract their offset from the excess value of their outputs. They then subtract the value of the inputs from the offset when committing to inputs, updating the total offset before sending to the next stage. Optional (depending on state and transaction options) num_parts - The number of participants in the transaction, assumed to be 2 if omitted amt - The transaction amount as a string parseable as a u64. May be omitted on a return journey. fee - The transaction fee as a string parseable as a u64. May be omitted on a return journey, except during an invoice transaction. feat - Kernel Features ID. If omitted, kernel is assumed to be Plain (0). If set to 1 or otherwise, any arguments required for a particular kernel feature set will be found in the feat_args struct. ttl - Time to Live, or block height beyond which wallets should refuse to further process the transaction. Assumed 0 (no ttl) if omitted from the slate. Structs Always sigs - An array of signature data containing the signature information of the last participant. See Signature Data Optional (depending on state of transaction) proof - An optional payment proof request. See Payment Proof Data coms - The Transaction; (link) is removed from the slate in favour of including this top-level Slate field that can be used to reconstruct the transaction object as expected by the Grin node. See Transaction Object Fields feat_args - Optional arguments for Kernel features. Status Codes Valid values of the sta field and their meanings are: S1 - Standard (payer to payee) transaction flow, new transaction that incorporates the sender's inputs and change output(s), if any. Sender's signature nonce, excess (with kernel offset) is included and ready for sending to recipient. S2 - Standard transaction flow, recipient has created their outputs(s) and supplied their excess, nonce and partial signature, ready to return to recipient for completion. S3 - Standard transaction flow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting I1 - Invoice (payee to payer) transaction flow, new transaction that incorporates the Invoicer's output(s). Invoicer's signature nonce and excess (with kernel offset) is included and ready for sending to Invoicee. I2 - Invoice workflow, Invoicee has added their inputs and change output(s). Invoicee's signature, nonce and excess is included and ready for sending back to the invoicer. I3 - Invoice workflow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting Signature Data An entry in the sigs array is as follows: { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } The sigs struct contains is comprised of an array of participant signature data, with each entry comprising: * xs - Hex string encoded short form public key on the secp256k1 curve representing the public blind excess for the participants outputs subtracted from each party's part of the offset. * part - Hex string encoded Aggregated (Schnorr) secp2561k signature represeting the participant's partial sig. May be omitted if the participant does not yet have enough data to create it * nonce - Hex string encoded The public key of the nonce chosen by the participant for their partial signature The other party's sig entry is removed from the slate before sending it back to the transaction initiator during the S2 and I2 phases. Payment Proof Data If included, the proof structure is: \"proof\": { \"saddr\": \"7e008eb593ba17d116e282d6267a3c6aad87b910933ad34dfa4d7d2c92b6ba31\", // \"rsig\": null, \"raddr\": \"3a425bd5da5f0f78593251ede7fad0ecf7a95679d84b2cb405255d97ce068234\" } The proof struct is an optional payment proof request that must be filled out by the recipient if requested (only valid for basic transaction flow). Its fields are as follows: saddr - Hex string encoded short-form public key on the ed25519 curve, representing the sender's wallet address (see the payment proofs rfc for details. raddr - Hex string encoded short-form public key on the ed25519 curve represnting the recipient's wallet address rsig - Hex string encoded EdDSA ed25519 signature representing the recipient's payment-proof signature. Can be omitted if this has not yet been filled out Transaction Object Fields The V4 Version of the Slate contains its own separate representation of Grin's internal Transaction object. (Grin's internal transaction struct definition can be found here: Transaction ). Internally, the wallet will transform its representation into the format expected by the node while posting the transaction. The tx struct in a V4 Slate is removed, and is replaced instead by the following Top-Level fields. Wallets recreate the transaction object as expected by the Grin node from these fields before posting. coms is an array containing the outputs and inputs that have been added to the slate. These will appear during the I1 or S2 phases of a transaction. Each entry includes: f : The output features, assumed to be 'Plain' if omitted. 0 denotes Plain, 1 denotes Coinbase c : The output/input commitment, hex string Encoded p : The output's range proof, hex string Encoded. If this is included, the entry is assumed to be an output. If not, it is an input. When rebuilding the transaction kernel for the Node (done during the S3 or I3 phases,) the kernel is assumed to be 'Plain' unless the top-level feat field is non-zero. In this case, the kernel features are filled accordingly with any needed values from the feat_args struct. In a typical S3 phase, these fields may look something like: \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" }, { \"c\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"c\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ], Feature arguments Depending on the chosen Kernel Feature set, feat_args may be populated with arguments specific to the kernel. The exact arguments that will be present here depend on the value of feat . Currently, the only supported kernel is HeightLocked (value 1) which has the arguments: \"feat_args\": { \"lock_hgt\": \"2343234\" // For HeightLocked kernels (1) } Changes from existing V3 Slate Top-Level Slate Struct The version_info struct is removed, and is replaced with ver , which has the format \"[version]:[block header version]\" sta is added, with possible values S1|S2|S3|I1|I2|I3|NA num_participants is renamed to num_parts num_parts may be omitted from the slate. If omitted its value is assumed to be 2. amount is renamed to amt amt may be removed from the slate on the S2 phase of a transaction. fee may be removed from the slate on the S2 phase of a transaction. It may also be omitted when initiating an I1 transaction, and added during the I2 phase. lock_height is removed feat is added to the slate denoting the Kernel feature set. May be omitted from the slate if kernel is plain ttl_cutoff_height is renamed to ttl ttl may be omitted from the slate. If omitted its value is assumed to be 0 (no TTL). The participant_data struct is renamed to sigs tx is removed The coms (commitments) array is added, from which the final transaction object can be reconstructed The payment_proof struct is renamed to proof The feat_args struct is added, which may be populated for non-Plain kernels proof may be omitted from the slate if it is None (null), offset is added, which keeps track of the running offset total as it's modified by the participants Participant Data ( sigs ) public_blind_excess is renamed to xs public_nonce is renamed to nonce part_sig is renamed to part part may be omitted if it has not yet been filled out message is removed message_sig is removed id is removed. Parties can identify themselves via the keys stored in their transaction context Payment Proof Data ( proof ) The sender_address field is renamed to saddr The receiver_address field is renamed to raddr The receiver_signature field is renamed to rsig rsig may be omitted if it has not yet been filled out Pretty-Printing The examples above are pretty-printed for reference, but all Slates should remove all whitespace before sending to other parties. The whitespace and formatting can be re-added anywhere the Slate needs to be presented for debugging. Slate Definition - Binary While the JSON slate remains the first-order slate definition, and should be accepted by all wallets and APIs, wallets should also have the ability to transform slates between the JSON format and a reduced binary format suitable for armoring or direct transfer. The definition of the V4 binary slate format follows. All integer values are Big-Endian. Slate V4 Field type len notes ver.slate_version u16 2 ver.block_header_version u16 2 id Uuid 16 binary Uuid representation sta u8 1 See Status Byte offset BlindingFactor 32 Optional field status u8 1 See Optional Field Status num_parts u8 (1) If present amt u64 (8) If present fee u64 (8) If present feat u8 (1) If present ttl u64 (8) If present sigs entries struct varies See Sigs Entries Optional struct status u8 1 See Optional Struct Status coms entries struct (varies) If present. See Coms Entries proof struct (varies) If present. See Proof feat_args entries struct (varies) If present. See Feature Args Status Byte Encodes slate status ( sta ) field, mapped as follows: State value NA (Unknown) 0 S1 1 S2 2 S3 3 I1 4 I2 5 I3 6 Optional Field Status A bit field that denotes the presence or absence of the optional slate fields. Each bit is mapped to particular slate field as follows: Bit 7 6 5 4 3 2 1 0 field ttl feat fee amt num_parts If the corresponding field for a bit is 1, the field is present and must be read accordingly. Sigs Entries Sigs Entries contains a length-prefixed array of entries corresponding to the sigs struct. Field type len notes length u8 1 entries struct varies array of entries, see below Each Sigs Entry is structured as follows: Field type len notes complete flag u8 1 If non-zero, entry contains part xs secp256k1 Public Key 33 nonce secp256k1 Public Key 33 part secp256k1 AggSig (64) If present Optional Struct Status A bit field that denotes the presence or absence of the optional slate structures. Each bit is mapped to particular slate structure as follows: Bit 7 6 5 4 3 2 1 0 struct proof coms If the corresponding field for a struct is 1, the struct is present and must be read accordingly. Coms Entries Coms Entries contains a length-prefixed array of entries corresponding to the coms struct. Field type len notes length u16 2 entries struct varies array of entries, see below Each Coms Entry is structured as follows: Field type len notes output flag u8 1 If non-zero, entry is output and contains p (proof) f u8 1 features (1 = Coinbase, 0 = Plain) c Commitment 33 p Rangeproof 675 If present Proof Optional Payment proof, with fields as follows Proof Field type len notes saddr ed25519 Public Key 32 raddr ed25519 Public Key 32 rsig flag u8 1 If non-zero, rsig field is present rsig ed25519 EDCSA Sig (64) If present Feature Args Optional feature args, presence or absence of which should be determined by the value of the feat field. Currently only present if feat is 2. Field type len notes lock_hgt u64 8 Lock height, present if feat is 2 Unresolved questions Is block header version needed? NRD Kernels need to be included Future possibilities This RFC is envisaged as a necessary first step for all slate-exchange possibilities that would benefit from compactness, e.g: QR Code encoding of slates Armored slates Slatepack","title":"Slates"},{"location":"wiki/transactions/slates/#slates","text":"Title: slate-v4 (compact slates) Authors: Michael Cordner Start date: April 03 2020 RFC PR: mimblewimble/grin-rfcs#49 Tracking issue: mimblewimble/grin-wallet#317","title":"Slates"},{"location":"wiki/transactions/slates/#summary","text":"What is a slate? To exchange Grin, users must exchange transaction slates in one form or another. A transaction slate is a blob containing the necessary data to be included at each step of the transaction building process. This RFC describes the changes between version 3 and version 4 of the Slate transaction exchange format, which had the goal of reducing the contents of the Slate to be as minimal as possible.","title":"Summary"},{"location":"wiki/transactions/slates/#motivation","text":"Previously, the definition of Slate versions up to V3 had been put together with no regard for its size or/and redundant/irrelevant content. In order to facilitate future exchange method possibilities, it's desirable to ensure the Slate is as compact as possible, particularly on the 'first leg' of a transaction exchange which only actually requires minimal information from the transaction initiator. This RFC aims to define the contents of a streamlined \"compact\" slate by: Removing all redundant or unnecessary Slate fields Shortening the names of many Slate fields Reducing the size of the Slate to at all phases of a transaction Defining an optional highly-minimized binary format for Slate output Although this RFC doesn't address any particular transaction exchange methods that might be facilitated by this streamlining, one could envisage possibilities such as: An exchange placing the entire initial slate in a QR code Encoding the initial slate as an easily-cut-and-paste chunk","title":"Motivation"},{"location":"wiki/transactions/slates/#community-level-explanation","text":"There are two basic transaction workflows in a two-party Grin transaction: In the Basic workflow, a sender adds their inputs and change outputs to a transaction, and sends them, along with the fee, the amount and their signature data to the recipient. The recipient adds a output for the amount to the transaction, adds their signature data and returns to the sender, who completes the transaction and posts. In the Invoice workflow, the invoice creator adds a new output to a transaction, and sends the amount and signature data to the payer. The payer adds their inputs and change outputs to the transaction along with their signature data and fee information, then returns to the invoicer, who completes the transaction and posts. Although previous versions of the Slate included every party's complete inputs and outputs at every stage of the transaction, it is not technically necessary for the initiator to provide their inputs and outputs to the other party. It suffices for the initiator to store the input/output listing in their local transaction context, and only provide the amount, fee, excess and signature data to the other party. Recognising this, it is possible to ensure that the 'first-leg' of a transaction stage is extremely compact. For instance, version 3 of the Slate on transaction initiation may have looked something like the following: { \"version_info\": { \"version\": 3, \"orig_version\": 3, \"block_header_version\": 2 }, \"num_participants\": 2, \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"tx\": { \"offset\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"body\": { \"inputs\": [ { \"features\": \"Coinbase\", \"commit\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"features\": \"Coinbase\", \"commit\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ], \"outputs\": [ { \"features\": \"Plain\", \"commit\": \"0812276cc788e6870612296d926cba9f0e7b9810670710b5a6e6f1ba006d395774\", \"proof\": \"dcff6175390c602bfa92c2ffd1a9b2d84dcc9ea941f6f317bdd0f875244ef23e696fd17c71df79760ce5ce1a96aab1d15dd057358dc835e972febeb86d50ccec0dad7cfe0246d742eb753cf7b88c045d15bc7123f8cf7155647ccf663fca92a83c9a65d0ed756ea7ebffd2cac90c380a102ed9caaa355d175ed0bf58d3ac2f5e909d6c447dfc6b605e04925c2b17c33ebd1908c965a5541ea5d2ed45a0958e6402f89d7a56df1992e036d836e74017e73ccad5cb3a82b8e139e309792a31b15f3ffd72ed033253428c156c2b9799458a25c1da65b719780a22de7fe7f437ae2fccd22cf7ea357ab5aa66a5ef7d71fb0dc64aa0b5761f68278062bb39bb296c787e4cabc5e2a2933a416ce1c9a9696160386449c437e9120f7bb26e5b0e74d1f2e7d5bcd7aafb2a92b87d1548f1f911fb06af7bd6cc13cee29f7c9cb79021aed18186272af0e9d189ec107c81a8a3aeb4782b0d950e4881aa51b776bb6844b25bce97035b48a9bdb2aea3608687bcdd479d4fa998b5a839ff88558e4a29dff0ed13b55900abb5d439b70793d902ae9ad34587b18c919f6b875c91d14deeb1c373f5e76570d59a6549758f655f1128a54f162dfe8868e1587028e26ad91e528c5ae7ee9335fa58fb59022b5de29d80f0764a9917390d46db899acc6a5b416e25ecc9dccb7153646addcc81cadb5f0078febc7e05d7735aba494f39ef05697bbcc9b47b2ccc79595d75fc13c80678b5e237edce58d731f34c05b1ddcaa649acf2d865bbbc3ceda10508bcdd29d0496744644bf1c3516f6687dfeef5649c7dff90627d642739a59d91a8d1d0c4dc55d74a949e1074427664b467992c9e0f7d3af9d6ea79513e8946ddc0d356bac49878e64e6a95b0a30214214faf2ce317fa622ff3266b32a816e10a18e6d789a5da1f23e67b4f970a68a7bcd9e18825ee274b0483896a40\" } ], \"kernels\": [ { \"features\": \"Plain\", \"fee\": \"7000000\", \"lock_height\": \"0\", \"excess\": \"000000000000000000000000000000000000000000000000000000000000000000\", \"excess_sig\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } ] } }, \"amount\": \"60000000000\", \"fee\": \"7000000\", \"height\": \"5\", \"lock_height\": \"0\", \"ttl_cutoff_height\": null, \"payment_proof\": null, \"participant_data\": [ { \"id\": \"0\", \"public_blind_excess\": \"033ac2158fa0077f087de60c19d8e431753baa5b63b6e1477f05a2a6e7190d4592\", \"public_nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part_sig\": null, \"message\": null, \"message_sig\": null } ] } In version 4 of the Slate format, the initial Slate now looks like the following: { \"ver\": \"4:2\" \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"amt\": \"6000000000\", \"fee\": \"8000000\", \"sigs\": [ { \"xs\": \"023878ce845727f3a4ec76ca3f3db4b38a2d05d636b8c3632108b857fed63c96de\" \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ], } While a \"return\" slate might look something like the following: { \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S2\", \"off\": \"a4052c9200000001a6052c9200000002ed564fab50b75fc5ea32ce052fc9bebf\", \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part\": \"8f07ddd5e9f5179cff19486034181ed76505baaad53e5d994064127b56c5841b54735cb9ed2f59fb457144f7b1c8226d08b54cbdd0eb7e6492950751b0bb54f9\" } ], \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" } ] } The 'return' slate from the recipient to the originator is expected to be larger, as it must include the recipient's outputs/inputs and proofs (as the party who posts the transaction needs all of this information). However, compacting the slate at each stage of its journey allows for future possibilities that may have been more difficult in previous iterations of the slate format. For instance, an initiator taking Grin payments might be expected to be better equipped to receive Grin transactions. They could present the payer with an invoice transaction for the amount compacted to the size of a QR code, which the payer could scan, accept, and then post back to the invoicer's listening wallet infrastructure. Compacting the slate also acts as a minor privacy-enhancer by hiding the initiator's outputs from the other party.","title":"Community-level explanation"},{"location":"wiki/transactions/slates/#reference-level-explanation","text":"","title":"Reference-level explanation"},{"location":"wiki/transactions/slates/#slate-definition-json","text":"Entries prefixed with // denote fields that may be omitted, as well as their default assumed values. # denotes a comment for the purposes of illustration. Field ordering is canonical. { # These fields are always present \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", # These fields may or may not be present //\"num_parts: 2, //\"fee\": \"8000000\", //\"amt\": \"1000000000\", //\"feat\": 0, //\"ttl\": null, # Sigs is always present with at least one entry \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", // \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ] # These structs may or may not be present //\"coms\": null, //\"proof\": null, //\"feat_args\": null } A description of all fields and their meanings is as follows:","title":"Slate Definition - JSON"},{"location":"wiki/transactions/slates/#top-level-slate-struct","text":"","title":"Top-Level Slate Struct"},{"location":"wiki/transactions/slates/#fields","text":"","title":"Fields"},{"location":"wiki/transactions/slates/#always","text":"ver - The slate version and supported block header version, separated by a : id - The slate's UUID, standard hex-string encoding for UUIDs sta - 2 character String representing the current stage of the the transaction. See Status Codes off - The running transaction offset total, hex-string encoded. All parties select a random offset at the beginning of the transaction and subtract their offset from the excess value of their outputs. They then subtract the value of the inputs from the offset when committing to inputs, updating the total offset before sending to the next stage.","title":"Always"},{"location":"wiki/transactions/slates/#optional","text":"(depending on state and transaction options) num_parts - The number of participants in the transaction, assumed to be 2 if omitted amt - The transaction amount as a string parseable as a u64. May be omitted on a return journey. fee - The transaction fee as a string parseable as a u64. May be omitted on a return journey, except during an invoice transaction. feat - Kernel Features ID. If omitted, kernel is assumed to be Plain (0). If set to 1 or otherwise, any arguments required for a particular kernel feature set will be found in the feat_args struct. ttl - Time to Live, or block height beyond which wallets should refuse to further process the transaction. Assumed 0 (no ttl) if omitted from the slate.","title":"Optional"},{"location":"wiki/transactions/slates/#structs","text":"","title":"Structs"},{"location":"wiki/transactions/slates/#always_1","text":"sigs - An array of signature data containing the signature information of the last participant. See Signature Data","title":"Always"},{"location":"wiki/transactions/slates/#optional_1","text":"(depending on state of transaction) proof - An optional payment proof request. See Payment Proof Data coms - The Transaction; (link) is removed from the slate in favour of including this top-level Slate field that can be used to reconstruct the transaction object as expected by the Grin node. See Transaction Object Fields feat_args - Optional arguments for Kernel features.","title":"Optional"},{"location":"wiki/transactions/slates/#status-codes","text":"Valid values of the sta field and their meanings are: S1 - Standard (payer to payee) transaction flow, new transaction that incorporates the sender's inputs and change output(s), if any. Sender's signature nonce, excess (with kernel offset) is included and ready for sending to recipient. S2 - Standard transaction flow, recipient has created their outputs(s) and supplied their excess, nonce and partial signature, ready to return to recipient for completion. S3 - Standard transaction flow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting I1 - Invoice (payee to payer) transaction flow, new transaction that incorporates the Invoicer's output(s). Invoicer's signature nonce and excess (with kernel offset) is included and ready for sending to Invoicee. I2 - Invoice workflow, Invoicee has added their inputs and change output(s). Invoicee's signature, nonce and excess is included and ready for sending back to the invoicer. I3 - Invoice workflow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting","title":"Status Codes"},{"location":"wiki/transactions/slates/#signature-data","text":"An entry in the sigs array is as follows: { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } The sigs struct contains is comprised of an array of participant signature data, with each entry comprising: * xs - Hex string encoded short form public key on the secp256k1 curve representing the public blind excess for the participants outputs subtracted from each party's part of the offset. * part - Hex string encoded Aggregated (Schnorr) secp2561k signature represeting the participant's partial sig. May be omitted if the participant does not yet have enough data to create it * nonce - Hex string encoded The public key of the nonce chosen by the participant for their partial signature The other party's sig entry is removed from the slate before sending it back to the transaction initiator during the S2 and I2 phases.","title":"Signature Data"},{"location":"wiki/transactions/slates/#payment-proof-data","text":"If included, the proof structure is: \"proof\": { \"saddr\": \"7e008eb593ba17d116e282d6267a3c6aad87b910933ad34dfa4d7d2c92b6ba31\", // \"rsig\": null, \"raddr\": \"3a425bd5da5f0f78593251ede7fad0ecf7a95679d84b2cb405255d97ce068234\" } The proof struct is an optional payment proof request that must be filled out by the recipient if requested (only valid for basic transaction flow). Its fields are as follows: saddr - Hex string encoded short-form public key on the ed25519 curve, representing the sender's wallet address (see the payment proofs rfc for details. raddr - Hex string encoded short-form public key on the ed25519 curve represnting the recipient's wallet address rsig - Hex string encoded EdDSA ed25519 signature representing the recipient's payment-proof signature. Can be omitted if this has not yet been filled out","title":"Payment Proof Data"},{"location":"wiki/transactions/slates/#transaction-object-fields","text":"The V4 Version of the Slate contains its own separate representation of Grin's internal Transaction object. (Grin's internal transaction struct definition can be found here: Transaction ). Internally, the wallet will transform its representation into the format expected by the node while posting the transaction. The tx struct in a V4 Slate is removed, and is replaced instead by the following Top-Level fields. Wallets recreate the transaction object as expected by the Grin node from these fields before posting. coms is an array containing the outputs and inputs that have been added to the slate. These will appear during the I1 or S2 phases of a transaction. Each entry includes: f : The output features, assumed to be 'Plain' if omitted. 0 denotes Plain, 1 denotes Coinbase c : The output/input commitment, hex string Encoded p : The output's range proof, hex string Encoded. If this is included, the entry is assumed to be an output. If not, it is an input. When rebuilding the transaction kernel for the Node (done during the S3 or I3 phases,) the kernel is assumed to be 'Plain' unless the top-level feat field is non-zero. In this case, the kernel features are filled accordingly with any needed values from the feat_args struct. In a typical S3 phase, these fields may look something like: \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" }, { \"c\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"c\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ],","title":"Transaction Object Fields"},{"location":"wiki/transactions/slates/#feature-arguments","text":"Depending on the chosen Kernel Feature set, feat_args may be populated with arguments specific to the kernel. The exact arguments that will be present here depend on the value of feat . Currently, the only supported kernel is HeightLocked (value 1) which has the arguments: \"feat_args\": { \"lock_hgt\": \"2343234\" // For HeightLocked kernels (1) }","title":"Feature arguments"},{"location":"wiki/transactions/slates/#changes-from-existing-v3-slate","text":"","title":"Changes from existing V3 Slate"},{"location":"wiki/transactions/slates/#top-level-slate-struct_1","text":"The version_info struct is removed, and is replaced with ver , which has the format \"[version]:[block header version]\" sta is added, with possible values S1|S2|S3|I1|I2|I3|NA num_participants is renamed to num_parts num_parts may be omitted from the slate. If omitted its value is assumed to be 2. amount is renamed to amt amt may be removed from the slate on the S2 phase of a transaction. fee may be removed from the slate on the S2 phase of a transaction. It may also be omitted when initiating an I1 transaction, and added during the I2 phase. lock_height is removed feat is added to the slate denoting the Kernel feature set. May be omitted from the slate if kernel is plain ttl_cutoff_height is renamed to ttl ttl may be omitted from the slate. If omitted its value is assumed to be 0 (no TTL). The participant_data struct is renamed to sigs tx is removed The coms (commitments) array is added, from which the final transaction object can be reconstructed The payment_proof struct is renamed to proof The feat_args struct is added, which may be populated for non-Plain kernels proof may be omitted from the slate if it is None (null), offset is added, which keeps track of the running offset total as it's modified by the participants","title":"Top-Level Slate Struct"},{"location":"wiki/transactions/slates/#participant-data-sigs","text":"public_blind_excess is renamed to xs public_nonce is renamed to nonce part_sig is renamed to part part may be omitted if it has not yet been filled out message is removed message_sig is removed id is removed. Parties can identify themselves via the keys stored in their transaction context","title":"Participant Data (sigs)"},{"location":"wiki/transactions/slates/#payment-proof-data-proof","text":"The sender_address field is renamed to saddr The receiver_address field is renamed to raddr The receiver_signature field is renamed to rsig rsig may be omitted if it has not yet been filled out","title":"Payment Proof Data (proof)"},{"location":"wiki/transactions/slates/#pretty-printing","text":"The examples above are pretty-printed for reference, but all Slates should remove all whitespace before sending to other parties. The whitespace and formatting can be re-added anywhere the Slate needs to be presented for debugging.","title":"Pretty-Printing"},{"location":"wiki/transactions/slates/#slate-definition-binary","text":"While the JSON slate remains the first-order slate definition, and should be accepted by all wallets and APIs, wallets should also have the ability to transform slates between the JSON format and a reduced binary format suitable for armoring or direct transfer. The definition of the V4 binary slate format follows. All integer values are Big-Endian. Slate V4 Field type len notes ver.slate_version u16 2 ver.block_header_version u16 2 id Uuid 16 binary Uuid representation sta u8 1 See Status Byte offset BlindingFactor 32 Optional field status u8 1 See Optional Field Status num_parts u8 (1) If present amt u64 (8) If present fee u64 (8) If present feat u8 (1) If present ttl u64 (8) If present sigs entries struct varies See Sigs Entries Optional struct status u8 1 See Optional Struct Status coms entries struct (varies) If present. See Coms Entries proof struct (varies) If present. See Proof feat_args entries struct (varies) If present. See Feature Args Status Byte Encodes slate status ( sta ) field, mapped as follows: State value NA (Unknown) 0 S1 1 S2 2 S3 3 I1 4 I2 5 I3 6 Optional Field Status A bit field that denotes the presence or absence of the optional slate fields. Each bit is mapped to particular slate field as follows: Bit 7 6 5 4 3 2 1 0 field ttl feat fee amt num_parts If the corresponding field for a bit is 1, the field is present and must be read accordingly. Sigs Entries Sigs Entries contains a length-prefixed array of entries corresponding to the sigs struct. Field type len notes length u8 1 entries struct varies array of entries, see below Each Sigs Entry is structured as follows: Field type len notes complete flag u8 1 If non-zero, entry contains part xs secp256k1 Public Key 33 nonce secp256k1 Public Key 33 part secp256k1 AggSig (64) If present Optional Struct Status A bit field that denotes the presence or absence of the optional slate structures. Each bit is mapped to particular slate structure as follows: Bit 7 6 5 4 3 2 1 0 struct proof coms If the corresponding field for a struct is 1, the struct is present and must be read accordingly. Coms Entries Coms Entries contains a length-prefixed array of entries corresponding to the coms struct. Field type len notes length u16 2 entries struct varies array of entries, see below Each Coms Entry is structured as follows: Field type len notes output flag u8 1 If non-zero, entry is output and contains p (proof) f u8 1 features (1 = Coinbase, 0 = Plain) c Commitment 33 p Rangeproof 675 If present Proof Optional Payment proof, with fields as follows Proof Field type len notes saddr ed25519 Public Key 32 raddr ed25519 Public Key 32 rsig flag u8 1 If non-zero, rsig field is present rsig ed25519 EDCSA Sig (64) If present Feature Args Optional feature args, presence or absence of which should be determined by the value of the feat field. Currently only present if feat is 2. Field type len notes lock_hgt u64 8 Lock height, present if feat is 2","title":"Slate Definition - Binary"},{"location":"wiki/transactions/slates/#unresolved-questions","text":"Is block header version needed? NRD Kernels need to be included","title":"Unresolved questions"},{"location":"wiki/transactions/slates/#future-possibilities","text":"This RFC is envisaged as a necessary first step for all slate-exchange possibilities that would benefit from compactness, e.g: QR Code encoding of slates Armored slates Slatepack","title":"Future possibilities"}]}
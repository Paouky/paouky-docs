{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Simple, privacy-focused, scalable Mimblewimble chain implementation. Grin aims to serve as digital cash. To provide electronic transactions for all, without censorship or restrictions. Principles Open Grin is developed openly, by individual contributors all over the world. There's no company or foundation behind it, and no ICO, founder reward, pre-mine or dev-tax. The coin distribution is designed to be as fair (but not gratis) as is known to be possible. Privacy Privacy by default. Transactions have no amount, no addresses and can be trivially aggregated. This enables complete fungibility without precluding the ability to selectively disclose information as needed. Scalability Scales mostly with the number of users and minimally with the number of transactions. Past transactional data can be pruned, making it drastically lightweight compared to other blockchains. Simplicity Minimal implementation that strives to remain as clear and simple as possible, making it easy to audit and maintain over time. Proven Cryptography Mimblewimble only relies on strong Elliptic Curve cryptography which has been tried and tested for decades. About Grin Get Started Wiki \u30c4","title":"./ Grin"},{"location":"#principles","text":"","title":"Principles"},{"location":"#open","text":"Grin is developed openly, by individual contributors all over the world. There's no company or foundation behind it, and no ICO, founder reward, pre-mine or dev-tax. The coin distribution is designed to be as fair (but not gratis) as is known to be possible.","title":"Open"},{"location":"#privacy","text":"Privacy by default. Transactions have no amount, no addresses and can be trivially aggregated. This enables complete fungibility without precluding the ability to selectively disclose information as needed.","title":"Privacy"},{"location":"#scalability","text":"Scales mostly with the number of users and minimally with the number of transactions. Past transactional data can be pruned, making it drastically lightweight compared to other blockchains.","title":"Scalability"},{"location":"#simplicity","text":"Minimal implementation that strives to remain as clear and simple as possible, making it easy to audit and maintain over time.","title":"Simplicity"},{"location":"#proven-cryptography","text":"Mimblewimble only relies on strong Elliptic Curve cryptography which has been tried and tested for decades. About Grin Get Started Wiki \u30c4","title":"Proven Cryptography"},{"location":"docs-temp/","text":"Documents to keep Documents to keep, but that might not have proper place in the new structure. From wiki Mimblewimble Whitepaper - Obviously. How to: Run a Grin node on Google Cloud for free - A very useful guide to run a cloud node. Community projects~~ - A useful list but hard to keep up to date. Worth keeping for users asking about exchanges. News and Channels~~ - Maybe update and keep, not sure if its needed. Regarding Foundations - A well written overview that's worth keeping. Troubleshooting~~ - Needs revisiting, not sure how and by who. Build and run automation - A guide to run grin as a service seems useful. Needs polishing. Monetary Policy - Replaced by Emission but a good document nevertheless. Move to grin/doc Very technical documents that have their place in the grin repo. They are not perfect but so are most grin repo docs. Still useful. P2P Protocol Validation logic Block Header Move to grin-pm Adding repos to mimblewimble - Should find a suitable place (MOVED) Move to grin-miner How to mine Grin Pages Events - A nice list of past events. Most links are useless, but maybe worth keeping. Some good slides hidden there. Roadmap - Not sure what to do with it. It looks relatively up-to-date but is not needed imo. The Story of Distribution - I like it. I'm biased though. Plain fun Nomenclature BS - I love this, such a creative mind. Core team should have remained the technocratic council cough cough . User Stories Use Cases - This shit cracks me up. No this, no that - Very succint, cool.","title":"Documents (temp)"},{"location":"docs-temp/#documents-to-keep","text":"Documents to keep, but that might not have proper place in the new structure.","title":"Documents to keep"},{"location":"docs-temp/#from-wiki","text":"Mimblewimble Whitepaper - Obviously. How to: Run a Grin node on Google Cloud for free - A very useful guide to run a cloud node. Community projects~~ - A useful list but hard to keep up to date. Worth keeping for users asking about exchanges. News and Channels~~ - Maybe update and keep, not sure if its needed. Regarding Foundations - A well written overview that's worth keeping. Troubleshooting~~ - Needs revisiting, not sure how and by who. Build and run automation - A guide to run grin as a service seems useful. Needs polishing. Monetary Policy - Replaced by Emission but a good document nevertheless.","title":"From wiki"},{"location":"docs-temp/#move-to-grindoc","text":"Very technical documents that have their place in the grin repo. They are not perfect but so are most grin repo docs. Still useful. P2P Protocol Validation logic Block Header","title":"Move to grin/doc"},{"location":"docs-temp/#move-to-grin-pm","text":"Adding repos to mimblewimble - Should find a suitable place (MOVED)","title":"Move to grin-pm"},{"location":"docs-temp/#move-to-grin-miner","text":"How to mine Grin","title":"Move to grin-miner"},{"location":"docs-temp/#pages","text":"Events - A nice list of past events. Most links are useless, but maybe worth keeping. Some good slides hidden there. Roadmap - Not sure what to do with it. It looks relatively up-to-date but is not needed imo. The Story of Distribution - I like it. I'm biased though.","title":"Pages"},{"location":"docs-temp/#plain-fun","text":"Nomenclature BS - I love this, such a creative mind. Core team should have remained the technocratic council cough cough . User Stories Use Cases - This shit cracks me up. No this, no that - Very succint, cool.","title":"Plain fun"},{"location":"example/","text":"Full example from sanic import Sanic from sanic.response import json from sanic_camelcase_middleware import Camelize app = Sanic ( __name__ ) Camelize ( app ) @app.route ( \"/post\" , methods = [ \"POST\" ]) async def test ( request ): return json ( \"is_camelcase\" : True , \"message\" : request . json }) if __name__ == \"__main__\" : app . run ( host = \"0.0.0.0\" , port = 8000 )","title":"Full example"},{"location":"example/#full-example","text":"from sanic import Sanic from sanic.response import json from sanic_camelcase_middleware import Camelize app = Sanic ( __name__ ) Camelize ( app ) @app.route ( \"/post\" , methods = [ \"POST\" ]) async def test ( request ): return json ( \"is_camelcase\" : True , \"message\" : request . json }) if __name__ == \"__main__\" : app . run ( host = \"0.0.0.0\" , port = 8000 )","title":"Full example"},{"location":"about-grin/community/","text":"How is grin administrated? Who received the donations? Who manages the github organization? Of course, a protocol-derived pool of rewards with which to pay developers would have been much more convenient, but it would have completely undermined the political neutrality of the monetary system. rfcs acceptes list and pull requests page","title":"Community"},{"location":"about-grin/emission/","text":"Emission A new grin \u30c4 is emitted every second, forever, meaning the emission rate stays constant and completely linear. As time passes, the relative dilution becomes smaller; After 10 years, it falls below 10%. After 20, below 5%. This results in a decreasing inflation rate, or disinflation. This simple design serves to ensure the long term security and stability of the chain, as well as provide a fair process of distribution. We'll set to explore those topics more thoroughly. The first four years of Bitcoin emission rate are identical to the first four of Grin. Bitcoin had a full reward for 4 years, followed by half that for the following 4 years. So compared to a constant supply, after 8 years, the total amount of coins emitted is only 25% less. Compare that to daily price fluctuations. Security The more resources being spent on mining a proof-of-work chain, the less it's suceptible to various mining attacks, most prominently 51% attacks. The financial resources deployed, or the overall mining revenue, are often referred to as security spend , which is solely determined by the incentives provided as block rewards. This reward is composed both of transactions fees, and of the block subsidy, i.e. newly generated coins. Block Subsidy Grin introduces a constant block subsidy in order to remain sufficiently secure over the coming years and decades. Block reward is then guaranteed , regardless of how full the blocks are, or how much users are willing to pay in fees for faster confirmation. Furthermore, This type of emission removes a lot of uncertainty, and avoids the shortcomings of the standard decreasing emission which has yet to be proven stable and effective on a longer time horizon. Fees All other proof-of-work chains are designed to generate and distribute most of the supply early on, to the benefit of a few, and then increasingly rely on transaction fees to incentivize mining. An apparent issue with this approach is that overall security spend is likely to decrease as time passes, making the chain fundamentally less secure in the face of mining attacks, whether by selfish attackers or state actors. This results in a \"tragedy of the commons\", as individual users strive to pay a minimum amount of fees, while also depending on the security that their fees are paying for 1 . Even then, the stability of a chain sustaining it self through high transaction fees is questionable 2 , potentially being prone to a new set of mining attacks, all of which could be avoided given similar mining revenues earned only through block subsidy. Distribution How the coin gets distributed carries significant importance. Grin was not created to quickly enrich a few people, but for providing private digital cash to all. Fairness The constant issuance establishes a fair coin distribution 3 , where equal opportunity is given to everyone, in any point in time. New users should not feel discouraged or disadvantaged when adopting a new form money. In constrast, distributing a very large portion of the coins early, mostly benefits the first users but presents an unwelcoming narrative to new ones, as it assigns them a substabially smaller portion of the network's value. This in turn affects the currency's long-standing story of distribution 4 . Wide Distribution As it stands today, the ownership of bitcoin is very centralized and will likely remain so. The situation is far worse in most other cryptocurrencies. The likely result is that a narrow group emerges, consisting of individuals and organizations who may have an exorbitant amount of control over the market price. More importantly, they have the the power to influence the project and its ecosystem more than any others, since early, unpropotional hoarding carries a good deal of centralization pressure. A constant emission aims to support Grin's intent of being at the hands of many people and being used to transact freely, as a privacy-perserving medium of exchange. More Additional properties of constant emission that are worthy to consider: Early users do not profit exponentially due to a decreasing supply, but purely through increasing demand for the coin. 1 grin/s is very intuitive to understand 5 . Such clear emission rule is more likely to be enforced by community concensus, unlike a blurred, complex model. One of the pitfalls of monetary inflation in fiat currencies is governments can inflate the monetary supply on a whim. This has been used to disastrous effect throughout history. A consensus based currency solves this issue by making the emission policy well known ahead of time, and makes it difficult if not impossible to change. Removing central authorities with arbitrary control is much more what makes Bitcoin important than the arbitrary amount of its capped supply. By this definition, Grin is just as much \"sound money\". When ownership is more evenly distributed, it likely means that more participants are holding a sizable portion of the network, and thus more users are meaningfully incentivized to advance its growth & improve it. Bitcoin's Security Trilemma \u21a9 On the Instability of Bitcoin Without the Block Reward \u21a9 Grin and the Mythical Fair Launch \u21a9 The Story of Distribution \u21a9 Nick Szabo on Supply Predictabilty \u21a9","title":"Emission"},{"location":"about-grin/emission/#emission","text":"A new grin \u30c4 is emitted every second, forever, meaning the emission rate stays constant and completely linear. As time passes, the relative dilution becomes smaller; After 10 years, it falls below 10%. After 20, below 5%. This results in a decreasing inflation rate, or disinflation. This simple design serves to ensure the long term security and stability of the chain, as well as provide a fair process of distribution. We'll set to explore those topics more thoroughly. The first four years of Bitcoin emission rate are identical to the first four of Grin. Bitcoin had a full reward for 4 years, followed by half that for the following 4 years. So compared to a constant supply, after 8 years, the total amount of coins emitted is only 25% less. Compare that to daily price fluctuations.","title":"Emission"},{"location":"about-grin/emission/#security","text":"The more resources being spent on mining a proof-of-work chain, the less it's suceptible to various mining attacks, most prominently 51% attacks. The financial resources deployed, or the overall mining revenue, are often referred to as security spend , which is solely determined by the incentives provided as block rewards. This reward is composed both of transactions fees, and of the block subsidy, i.e. newly generated coins.","title":"Security"},{"location":"about-grin/emission/#block-subsidy","text":"Grin introduces a constant block subsidy in order to remain sufficiently secure over the coming years and decades. Block reward is then guaranteed , regardless of how full the blocks are, or how much users are willing to pay in fees for faster confirmation. Furthermore, This type of emission removes a lot of uncertainty, and avoids the shortcomings of the standard decreasing emission which has yet to be proven stable and effective on a longer time horizon.","title":"Block Subsidy"},{"location":"about-grin/emission/#fees","text":"All other proof-of-work chains are designed to generate and distribute most of the supply early on, to the benefit of a few, and then increasingly rely on transaction fees to incentivize mining. An apparent issue with this approach is that overall security spend is likely to decrease as time passes, making the chain fundamentally less secure in the face of mining attacks, whether by selfish attackers or state actors. This results in a \"tragedy of the commons\", as individual users strive to pay a minimum amount of fees, while also depending on the security that their fees are paying for 1 . Even then, the stability of a chain sustaining it self through high transaction fees is questionable 2 , potentially being prone to a new set of mining attacks, all of which could be avoided given similar mining revenues earned only through block subsidy.","title":"Fees"},{"location":"about-grin/emission/#distribution","text":"How the coin gets distributed carries significant importance. Grin was not created to quickly enrich a few people, but for providing private digital cash to all.","title":"Distribution"},{"location":"about-grin/emission/#fairness","text":"The constant issuance establishes a fair coin distribution 3 , where equal opportunity is given to everyone, in any point in time. New users should not feel discouraged or disadvantaged when adopting a new form money. In constrast, distributing a very large portion of the coins early, mostly benefits the first users but presents an unwelcoming narrative to new ones, as it assigns them a substabially smaller portion of the network's value. This in turn affects the currency's long-standing story of distribution 4 .","title":"Fairness"},{"location":"about-grin/emission/#wide-distribution","text":"As it stands today, the ownership of bitcoin is very centralized and will likely remain so. The situation is far worse in most other cryptocurrencies. The likely result is that a narrow group emerges, consisting of individuals and organizations who may have an exorbitant amount of control over the market price. More importantly, they have the the power to influence the project and its ecosystem more than any others, since early, unpropotional hoarding carries a good deal of centralization pressure. A constant emission aims to support Grin's intent of being at the hands of many people and being used to transact freely, as a privacy-perserving medium of exchange.","title":"Wide Distribution"},{"location":"about-grin/emission/#more","text":"Additional properties of constant emission that are worthy to consider: Early users do not profit exponentially due to a decreasing supply, but purely through increasing demand for the coin. 1 grin/s is very intuitive to understand 5 . Such clear emission rule is more likely to be enforced by community concensus, unlike a blurred, complex model. One of the pitfalls of monetary inflation in fiat currencies is governments can inflate the monetary supply on a whim. This has been used to disastrous effect throughout history. A consensus based currency solves this issue by making the emission policy well known ahead of time, and makes it difficult if not impossible to change. Removing central authorities with arbitrary control is much more what makes Bitcoin important than the arbitrary amount of its capped supply. By this definition, Grin is just as much \"sound money\". When ownership is more evenly distributed, it likely means that more participants are holding a sizable portion of the network, and thus more users are meaningfully incentivized to advance its growth & improve it. Bitcoin's Security Trilemma \u21a9 On the Instability of Bitcoin Without the Block Reward \u21a9 Grin and the Mythical Fair Launch \u21a9 The Story of Distribution \u21a9 Nick Szabo on Supply Predictabilty \u21a9","title":"More"},{"location":"about-grin/intro/","text":"in our case, when two outputs are encypted (commits), one can still compute the encryption of the sum of both outputs, and verify that it's a multlipiaction of the G generator point. My personal preference for MimbleWimble comes from its extreme simplicity (especially compared to zk-snarks) and great scalability. It's also less opaque than zcash, you can still reason about inputs and outputs while all identifiable information about them is obscured. Confidence in certain cryptography is gained by having it last a long time without being broken. Mimblewimble only relies on elliptic curves; simple and very well vetted cryptographic constructs and assumptions.","title":"Intro"},{"location":"about-grin/privacy/","text":"Privacy Overview Privacy is instrumental to a peer-to-peer electronic cash system. In its essence, cash cannot distinguish between users, it does not reveal the amounts transferred or owned by individuals, and it holds no bias to the history of a specific coin or person. Grin aims to preserve the user's privacy, while keeping in mind its core design principles of minimalism and scalability. That said, by cleverly employing Mimblewimble along with several other methods, it is able to achieve a relatively high level of anonymity for its users. This document sets to explore how and to what extent. Amounts First, there are no amounts. A Mimblewimble implementation natively uses Confidential Transactions, meaning all amounts are hidden; They are provably impossible to uncover, yet easily verified. Even before anything else, simply hiding amounts makes any analysis significantly more challenging. Addresses Notably, there are no on-chain addresses either, as transaction building is interactive. Transactions hold minimal information, and each output is simply a commitment: a point on the curve. A transaction might look like this: transaction Inputs Outputs 08c482407fac2.....e335bf2f10d82 085cc6944467b.....a3f1d4274b79b 097b2588fd494.....494e43580476b Each transaction also carries rangeproofs and a kernel, but it's mostly irrelevant for this topic. The above illustrates a normal transaction of 1 input and 2 outputs. The outputs (an input is also a reference to an output) are commitments, a 33 byte blurb to any observer. There's no address to tie an identity to, and it's not clear which output is the change and which belongs to the receiver. In a Bitcoin-like system, there are multiple ways in which a user might (accidentally or intentionally) link an address to his identity. Consequently it is often trivial for analysis to link many of his addresses. Not only does his own privacy suffer, but also the entire network's privacy diminishes as a result. A Grin commitment is one unique output. An address may be used to create an unlimited amount of outputs. An interesting analogy could then be used to emphasize the difference: A commitment, once on-chain, is like a one-time-use address. Both of them only ever \"contain\" a single output. A commitment is not used to form transactions, unlike an address. A commitment is infact a result of a transaction after it was built peer-to-peer. This makes it significantly harder to link an identity to. Aggregation Furthermore, a key concept of Mimblewimble transactions is that several of them can be safely merged together, resulting in what looks like a single transaction. When done at the block level, every block essentially becomes one large transaction: block Inputs Outputs 08c482407fac2.....e335bf2f10d82 097b2588fd494.....494e43580476b 0857b6b7eb6a2.....a0a283ed35974 09f731e071316.....42dae69672dca 085e205dea687.....8b8aeac7562c6 085cc6944467b.....a3f1d4274b79b 09035d331b17a.....bb76238f605fb 094262a95a67a.....2f246f6ce60ce 0961ee1db49ad.....602489c9c4517 09cf2db66b748.....7327297b8e69c 09c2751af8fe9.....fc745808238b6 0900015eec3c1.....d52d78fca78de The outcome is a non-interactive CoinJoin with hidden amounts. It's called non-interactive since all transactions are aggregated into one without any coordination required between the different parties, as it's made possible at the protocol level. An observer knows how many transactions are included in the block, since each one carries a kernel, but nothing more. Any further information is impossible to obtain by looking at the chain. Cut-through Another trick Mimblewimble sets the stage for, is to perform cut-through. In an example scenario where A sent funds to B , and then B sent them over to C , any trace of B 's involvement can be completely removed, such that the result is seen as A -> C . cut-through Inputs Outputs \u21d2 Inputs Outputs A B \u21d2 A B C \u21d2 C This is could be done at any level of transaction building; Before broadcast, during peer propagation, or in a block. While this trick's use cases are limited, it is a unique manifestation of the \"right to be forgotten\" in a blockchain. Transaction Graph Despite the fact that chain analysis can extract very little (if any) information about users and outputs, it is possible to monitor peer-to-peer network activity and obtain the transactions before they're included in a block and aggregated with others. By setting up sniffing nodes connected to many peers, you can figure out which outputs are being spent by what transaction, allowing you to build a transaction graph, practically seperating the aggregation done at the block level. It's unclear at this points if meaningful information could be derived from this, as the trail of data stops there. ( paragraph not worded yet, WIP ) Grin has many methods that may drastically improve privacy such as payjoin, coinswap etc and the beauty about them is that unlike bitcoin, your coins arent tainted for participating in what is pretty obviously a specific mixing transaction. a payjoin/coinswap/aggregated tx looks exactly the same, nobody knows you took extra privacy precautions to obfuscate the transaction graph Dandelion An important piece of information that commonly leaks is the IP address that originally sent the transaction. Normally, a transaction is just broadcasted to all connected peers and spreads quickly on the network, allowing for statistical analysis to deduce where it originated. In a peer-to-peer network, this might be hard as transactions are relayed, but over multiple transactions it becomes trivial. To tackle this issue, Grin employs Dandelion++ (originally proposed as a BIP), a protocol designed to hide a transcation's origin IP address. Dandelion has two phases; a stem phase and a fluff phase. Once a transaction is initially broadcasted, it enters the stem phase, in which it it hops between individual peers. At a random point, the transcation enters its fluff phase and is spread (fluffed) among the entire network. This makes it almost impossible to deduce a reliable IP address, and renders statistical analysis impractical. Moreover, Dandelion provides an additional benefit unique to Mimblewimble, as it allows for transactions to be aggregated at a very early stage. Right before a transaction beings it's fluff phase, it enters a 30s waiting period in which it will be aggregated with any other transactions it meets, thus obscuring linkability of inputs and outputs that a sniffing node may have learned. However it remains to be seen how much actual privacy is gained from aggregation before fluffing, as it depends on having many other transactions. Afterword Privacy is complex and information leakage is surprisingly easy. Privacy-preserving systems need to be extremely strong to ensure reasonable amounts of protection. Unfortunately, they often fail in practice simply because they are cumbersome to use, causing people to revert to convenience. Grin is commited to long term privacy protection and will continue to advance in that direction, while remaining practical and accessible to all, regardless of a person's sophistication or available resources.","title":"Privacy"},{"location":"about-grin/privacy/#privacy","text":"","title":"Privacy"},{"location":"about-grin/privacy/#overview","text":"Privacy is instrumental to a peer-to-peer electronic cash system. In its essence, cash cannot distinguish between users, it does not reveal the amounts transferred or owned by individuals, and it holds no bias to the history of a specific coin or person. Grin aims to preserve the user's privacy, while keeping in mind its core design principles of minimalism and scalability. That said, by cleverly employing Mimblewimble along with several other methods, it is able to achieve a relatively high level of anonymity for its users. This document sets to explore how and to what extent.","title":"Overview"},{"location":"about-grin/privacy/#amounts","text":"First, there are no amounts. A Mimblewimble implementation natively uses Confidential Transactions, meaning all amounts are hidden; They are provably impossible to uncover, yet easily verified. Even before anything else, simply hiding amounts makes any analysis significantly more challenging.","title":"Amounts"},{"location":"about-grin/privacy/#addresses","text":"Notably, there are no on-chain addresses either, as transaction building is interactive. Transactions hold minimal information, and each output is simply a commitment: a point on the curve. A transaction might look like this: transaction Inputs Outputs 08c482407fac2.....e335bf2f10d82 085cc6944467b.....a3f1d4274b79b 097b2588fd494.....494e43580476b Each transaction also carries rangeproofs and a kernel, but it's mostly irrelevant for this topic. The above illustrates a normal transaction of 1 input and 2 outputs. The outputs (an input is also a reference to an output) are commitments, a 33 byte blurb to any observer. There's no address to tie an identity to, and it's not clear which output is the change and which belongs to the receiver. In a Bitcoin-like system, there are multiple ways in which a user might (accidentally or intentionally) link an address to his identity. Consequently it is often trivial for analysis to link many of his addresses. Not only does his own privacy suffer, but also the entire network's privacy diminishes as a result. A Grin commitment is one unique output. An address may be used to create an unlimited amount of outputs. An interesting analogy could then be used to emphasize the difference: A commitment, once on-chain, is like a one-time-use address. Both of them only ever \"contain\" a single output. A commitment is not used to form transactions, unlike an address. A commitment is infact a result of a transaction after it was built peer-to-peer. This makes it significantly harder to link an identity to.","title":"Addresses"},{"location":"about-grin/privacy/#aggregation","text":"Furthermore, a key concept of Mimblewimble transactions is that several of them can be safely merged together, resulting in what looks like a single transaction. When done at the block level, every block essentially becomes one large transaction: block Inputs Outputs 08c482407fac2.....e335bf2f10d82 097b2588fd494.....494e43580476b 0857b6b7eb6a2.....a0a283ed35974 09f731e071316.....42dae69672dca 085e205dea687.....8b8aeac7562c6 085cc6944467b.....a3f1d4274b79b 09035d331b17a.....bb76238f605fb 094262a95a67a.....2f246f6ce60ce 0961ee1db49ad.....602489c9c4517 09cf2db66b748.....7327297b8e69c 09c2751af8fe9.....fc745808238b6 0900015eec3c1.....d52d78fca78de The outcome is a non-interactive CoinJoin with hidden amounts. It's called non-interactive since all transactions are aggregated into one without any coordination required between the different parties, as it's made possible at the protocol level. An observer knows how many transactions are included in the block, since each one carries a kernel, but nothing more. Any further information is impossible to obtain by looking at the chain.","title":"Aggregation"},{"location":"about-grin/privacy/#cut-through","text":"Another trick Mimblewimble sets the stage for, is to perform cut-through. In an example scenario where A sent funds to B , and then B sent them over to C , any trace of B 's involvement can be completely removed, such that the result is seen as A -> C . cut-through Inputs Outputs \u21d2 Inputs Outputs A B \u21d2 A B C \u21d2 C This is could be done at any level of transaction building; Before broadcast, during peer propagation, or in a block. While this trick's use cases are limited, it is a unique manifestation of the \"right to be forgotten\" in a blockchain.","title":"Cut-through"},{"location":"about-grin/privacy/#transaction-graph","text":"Despite the fact that chain analysis can extract very little (if any) information about users and outputs, it is possible to monitor peer-to-peer network activity and obtain the transactions before they're included in a block and aggregated with others. By setting up sniffing nodes connected to many peers, you can figure out which outputs are being spent by what transaction, allowing you to build a transaction graph, practically seperating the aggregation done at the block level. It's unclear at this points if meaningful information could be derived from this, as the trail of data stops there. ( paragraph not worded yet, WIP ) Grin has many methods that may drastically improve privacy such as payjoin, coinswap etc and the beauty about them is that unlike bitcoin, your coins arent tainted for participating in what is pretty obviously a specific mixing transaction. a payjoin/coinswap/aggregated tx looks exactly the same, nobody knows you took extra privacy precautions to obfuscate the transaction graph","title":"Transaction Graph"},{"location":"about-grin/privacy/#dandelion","text":"An important piece of information that commonly leaks is the IP address that originally sent the transaction. Normally, a transaction is just broadcasted to all connected peers and spreads quickly on the network, allowing for statistical analysis to deduce where it originated. In a peer-to-peer network, this might be hard as transactions are relayed, but over multiple transactions it becomes trivial. To tackle this issue, Grin employs Dandelion++ (originally proposed as a BIP), a protocol designed to hide a transcation's origin IP address. Dandelion has two phases; a stem phase and a fluff phase. Once a transaction is initially broadcasted, it enters the stem phase, in which it it hops between individual peers. At a random point, the transcation enters its fluff phase and is spread (fluffed) among the entire network. This makes it almost impossible to deduce a reliable IP address, and renders statistical analysis impractical. Moreover, Dandelion provides an additional benefit unique to Mimblewimble, as it allows for transactions to be aggregated at a very early stage. Right before a transaction beings it's fluff phase, it enters a 30s waiting period in which it will be aggregated with any other transactions it meets, thus obscuring linkability of inputs and outputs that a sniffing node may have learned. However it remains to be seen how much actual privacy is gained from aggregation before fluffing, as it depends on having many other transactions.","title":"Dandelion"},{"location":"about-grin/privacy/#afterword","text":"Privacy is complex and information leakage is surprisingly easy. Privacy-preserving systems need to be extremely strong to ensure reasonable amounts of protection. Unfortunately, they often fail in practice simply because they are cumbersome to use, causing people to revert to convenience. Grin is commited to long term privacy protection and will continue to advance in that direction, while remaining practical and accessible to all, regardless of a person's sophistication or available resources.","title":"Afterword"},{"location":"about-grin/proof-of-work/","text":"Proof of work is a concensus mechanism which allows anyone to extand the chain with additional blocks, by providing a piece of data that is both difficult to produce and easy to verify (according to certain parameters). Proof of work also serves the basis for the security and distribution of the coin. Grin has an average block time of 60 seconds and employs Cuckoo Cycle 1 , a memory bound proof of work algorithm, or more specifically, a variation of it named Cuckatoo that is meant to simplify ASICs. Cuckoo Cycle The algorithm finds length-42 cycles in a bipartite graph. The current (and final) Grin PoW is Cuckatoo32+, in which a graph must have atleast 2 32 + 2 32 nodes. For a comprehensive introduction, read here . Q: Why use a memory-hard proof of work? A: The point is that chips dominated by memory have rather different characteristics from computational chips; they run much cooler, dissipating less heat per unit of area. This shifts the mining cost from mostly opex (electricity) to mostly capex (hardware cost), which delays obsolescense and allows mining in places with higher electricity costs. Two Algorithms Grin has two PoW algorithms: Cuckatoo32+, The primary algorithm, meant to be ASIC-friendly . Begins at 10% and evolves to 100% over 2 years. Cuckaroo29, The secondary algorithm, aimed to be ASIC-resistant . Begins at 90% and decreases to 0% after 2 years. During the first 2 years of Grin, the algorithms gradually balance themselves to satisfy the current ratio, starting from 90/10 and eventually becoming 0/100, such that the only proof of work remaining after those 2 years would be Cuckatoo32+. This period included scheduled hardforks every 6 months, in which Cuckaroo29 was modified in order to interrupt possible ASIC development for it. The above simplifies a bit, since in practice Cuckatoo31+ was initially the primary PoW but was phased out completely after 18 months, for reasons we won\u2019t discuss here. You can read about it on this post . ASICs ASICs are special pieces of hardware especially designed to solve a specific proof of work algorithm as quickly and efficiently as possible. The common arguments against them are how they raise the barrier to entry for mining, and the centralization that may occur when a single ASIC manufacturer has complete market dominance. These issues are mostly solved once a mature, competitive market for ASICs appears. However, as apparent with Bitcoin, this natural proccess may take time. Grin\u2019s Cuckatoo32+ simplifies ASIC design in hope to reduce the time until they become widely distributed and accessible. The choice of upholding some ASIC-resistance in the first 2 years was made to ensure fair initial distribution, in which no single party has an unproportional mining advantage at launch, before the market becomes populated and competitive enough. Let\u2019s see why encouraging ASIC development might be benficial 2 in the first place: Security The security of a chain depends both on the amount of capital allocated to mine it (CAPEX), and on the costs of electricity & operation (OPEX). But, the CAPEX is only relevant if the the mining hardware's main function is to mine our specific chain, and are mostly useless otherwise. We want to avoid having the chain prone to attack by large hardware operators who own no stake in its success (no skin-in-the-game), since they can attack it and divert their hardware to other uses without incurring any loss to their capital. Therefore, to achieve optimal security, two conditions must be met: ASICs exist and perform significantly better than general-purpose hardware. The chain has the largest economic value for its specific ASIC. If the same proof of work is used by a bigger chain or serves another purpose, we encounter the same issue as described above. Inevitability There\u2019s increasingly more evidence that ASICs are inevitable, as dedicated hardware will always have ways in which it can improve upon general purpose hardware. While it is possible to make ASIC manufacturing more difficult, over a long period it is likely to end up as a centralizing force in it self, as it makes the chain vulnerable to secret ASIC operations 3 . Cuckoo Cycle \u21a9 ASICs and Decentralization FAQ \u21a9 The State of Cryptocurrency Mining \u21a9","title":"Proof of Work"},{"location":"about-grin/proof-of-work/#two-algorithms","text":"Grin has two PoW algorithms: Cuckatoo32+, The primary algorithm, meant to be ASIC-friendly . Begins at 10% and evolves to 100% over 2 years. Cuckaroo29, The secondary algorithm, aimed to be ASIC-resistant . Begins at 90% and decreases to 0% after 2 years. During the first 2 years of Grin, the algorithms gradually balance themselves to satisfy the current ratio, starting from 90/10 and eventually becoming 0/100, such that the only proof of work remaining after those 2 years would be Cuckatoo32+. This period included scheduled hardforks every 6 months, in which Cuckaroo29 was modified in order to interrupt possible ASIC development for it. The above simplifies a bit, since in practice Cuckatoo31+ was initially the primary PoW but was phased out completely after 18 months, for reasons we won\u2019t discuss here. You can read about it on this post .","title":"Two Algorithms"},{"location":"about-grin/proof-of-work/#asics","text":"ASICs are special pieces of hardware especially designed to solve a specific proof of work algorithm as quickly and efficiently as possible. The common arguments against them are how they raise the barrier to entry for mining, and the centralization that may occur when a single ASIC manufacturer has complete market dominance. These issues are mostly solved once a mature, competitive market for ASICs appears. However, as apparent with Bitcoin, this natural proccess may take time. Grin\u2019s Cuckatoo32+ simplifies ASIC design in hope to reduce the time until they become widely distributed and accessible. The choice of upholding some ASIC-resistance in the first 2 years was made to ensure fair initial distribution, in which no single party has an unproportional mining advantage at launch, before the market becomes populated and competitive enough. Let\u2019s see why encouraging ASIC development might be benficial 2 in the first place:","title":"ASICs"},{"location":"about-grin/proof-of-work/#security","text":"The security of a chain depends both on the amount of capital allocated to mine it (CAPEX), and on the costs of electricity & operation (OPEX). But, the CAPEX is only relevant if the the mining hardware's main function is to mine our specific chain, and are mostly useless otherwise. We want to avoid having the chain prone to attack by large hardware operators who own no stake in its success (no skin-in-the-game), since they can attack it and divert their hardware to other uses without incurring any loss to their capital. Therefore, to achieve optimal security, two conditions must be met: ASICs exist and perform significantly better than general-purpose hardware. The chain has the largest economic value for its specific ASIC. If the same proof of work is used by a bigger chain or serves another purpose, we encounter the same issue as described above.","title":"Security"},{"location":"about-grin/proof-of-work/#inevitability","text":"There\u2019s increasingly more evidence that ASICs are inevitable, as dedicated hardware will always have ways in which it can improve upon general purpose hardware. While it is possible to make ASIC manufacturing more difficult, over a long period it is likely to end up as a centralizing force in it self, as it makes the chain vulnerable to secret ASIC operations 3 . Cuckoo Cycle \u21a9 ASICs and Decentralization FAQ \u21a9 The State of Cryptocurrency Mining \u21a9","title":"Inevitability"},{"location":"about-grin/scalability/","text":"A Mimblewimble chain is massively-prunable, which allows it to stay lightweight and cheap to verify. Its core essence is this unique balance of privacy and scalability. Once an output is spent, there's no longer any need to keep it and it's removed from the chain. A 100 byte kernel is left for each transaction, forever proving it's validity. The result is, that in order to verify the entire history starting from the genesis block, only the kernels and the set of unspent outputs are needed. Let's illustrate a trail of transactions: (switch between tabs) Before Inputs Outputs t r a n s a c t i o n Coinbase A Kernel t r a n s a c t i o n A B Kernel C t r a n s a c t i o n B D Kernel Coinbase E F t r a n s a c t i o n D G Kernel E H Cut-through Inputs Outputs t r a n s a c t i o n Coinbase A Kernel t r a n s a c t i o n A B Kernel C t r a n s a c t i o n B D Kernel Coinbase E F t r a n s a c t i o n D G Kernel E H After Inputs Outputs t r a n s a c t i o n Coinbase Kernel t r a n s a c t i o n Kernel C t r a n s a c t i o n Kernel Coinbase F t r a n s a c t i o n G Kernel H An output is considered 'spent' once it is used as an input. As demonstrated above, every single input can dissappear as well as every spent output, leaving only a small kernel behind. What remains is only the set of unspent outputs and the set of kernels proving its validity. A full verifier needs the following data: The chain of headers List of unspent outputs Kernels An output is a 33 byte commitment accompanied by a 640 byte rangeproof. Following this logic, the chain mostly grows by the number of users, instead of the number of overall transactions. In fact, it often shrinks in size when more inputs are used than new outputs are created. Building, verifying and storing transactions requires minimal resources. Anyone can fully verify the chain on a phone or on cheap hardware, and run a node in areas with poor network connectivity. Comparison For Bitcoiners At the time of this writing, there were 560M Bitcoin transactions, taking up 300GB of space. Somebody who wants to verify the current state must replay each and every transacation. He will check millions of outputs to eventually derive the current set of 66M unspent outputs. Mimblewimble shrinks the transaction history such that a chain with Bitcoin's history would be kept at around 1/4 of its size. This difference becomes much more exciting if one remembers that Mimblewimble employs Confidential Transactions, so that each output requires a large rangeproof. If the current Bitcoin blockchain had hidden amounts, it's size would have been on the order of several terabyes.","title":"Scalability"},{"location":"about-grin/scalability/#comparison-for-bitcoiners","text":"At the time of this writing, there were 560M Bitcoin transactions, taking up 300GB of space. Somebody who wants to verify the current state must replay each and every transacation. He will check millions of outputs to eventually derive the current set of 66M unspent outputs. Mimblewimble shrinks the transaction history such that a chain with Bitcoin's history would be kept at around 1/4 of its size. This difference becomes much more exciting if one remembers that Mimblewimble employs Confidential Transactions, so that each output requires a large rangeproof. If the current Bitcoin blockchain had hidden amounts, it's size would have been on the order of several terabyes.","title":"Comparison For Bitcoiners"},{"location":"about-grin/story/","text":"Grin's Story Mimblewimble On Mon Aug 01 2016 a user named 'majorplayer' logged into the #bitcoin-wizards IRC channel, dropped a text file hosted on a Tor server and then dissappeared. The document 1 was titled MIMBLEWIMBLE and authored under the psuedonym Tom Elvis Jedusor. It described a protocol which is both private and extremely lightweight. Tom Elvis Jedusor is the French name for Tom Riddle (Lord Voldemort) from the Harry Potter book series. Mimblewimble is a tongue-tying spell. -!- majorplayer [...] has joined #bitcoin-wizards <majorplayer> hi, i have an idea for improving privacy in bitcoin. my friend who knows technology says this channel would have interest http://5pdcbgndmprm4wud.onion/mimblewimble.txt -!- majorplayer [...] has quit [Client Quit] Its title: MIMBLEWIMBLE Tom Elvis Jedusor 19 July, 2016 The following day, users nsh and andytoshi (Andrew Poelstra) began discussing the idea proposed in the paper. The anonymous writer left several un-answered questions in the document, along with a general lack of details, so there was much to discuss. The conversation included a memorable moment: <nsh> gotta be some way this is sneaky, otherwise it's too good to be true... <andytoshi> hah, yeah, i know the feeling On Oct 10 2016 , Andrew Poelstra published a follow-up paper 2 about Mimblewimble, which introduced several refinements to the original proposal and describes further its technical details. Grin On Oct 20 2016 , a pseudonymous developer using the name Ignotus Peverell, announced in the bitcoin wizards IRC channel that he began work on a minimal implementation of the protocol, which he named Grin. Ignotus Peverell is the wizard who was gifted the Cloak of Invisibility by Death. Grin is short for the Gringotts wizarding bank. 16:45 -!- igno_peverell [~user@104.238.169.137] has joined #bitcoin-wizards 16:47 < igno_peverell> I have a minimal implementation of MimbleWimble available. It's very far from complete but has the basics, included the summing of pedersen commitments: 16:47 < igno_peverell> https://github.com/ignopeverell/grin 16:47 < igno_peverell> Any feedback or review is greatly appreciated. Thanks! Igno was joined on github by other developers who took interest in the project, several of them bearing pseudonyms of other Harry Potter characters. While Mimblewimble serves as the foundation to transacting, it constitutes a relatively small part of a complete blockchain cryptocurrency, and many choices were yet to be made. Thus began the journey to develop a full working implementation. Launch Grin's genesis block was mined on January 15th, 2019. It was, and still is, young and experimental. It currently goes through rapid changes, as its first 2 years include agreed-upon hardforks in 6-months intervals. Several months after launch, Ignotus Peverell dissappeared and has yet to return. Developers distributed around the world are contributing to build Grin, some of them funded by donations to work on the project full-time. Governance and development will always remain completely transparent and open for every community member to join. The Mimblewimble Whitepaper \u21a9 Andrew Poelstra's Paper \u21a9","title":"Story"},{"location":"about-grin/story/#grins-story","text":"","title":"Grin's Story"},{"location":"about-grin/story/#mimblewimble","text":"On Mon Aug 01 2016 a user named 'majorplayer' logged into the #bitcoin-wizards IRC channel, dropped a text file hosted on a Tor server and then dissappeared. The document 1 was titled MIMBLEWIMBLE and authored under the psuedonym Tom Elvis Jedusor. It described a protocol which is both private and extremely lightweight. Tom Elvis Jedusor is the French name for Tom Riddle (Lord Voldemort) from the Harry Potter book series. Mimblewimble is a tongue-tying spell. -!- majorplayer [...] has joined #bitcoin-wizards <majorplayer> hi, i have an idea for improving privacy in bitcoin. my friend who knows technology says this channel would have interest http://5pdcbgndmprm4wud.onion/mimblewimble.txt -!- majorplayer [...] has quit [Client Quit] Its title: MIMBLEWIMBLE Tom Elvis Jedusor 19 July, 2016 The following day, users nsh and andytoshi (Andrew Poelstra) began discussing the idea proposed in the paper. The anonymous writer left several un-answered questions in the document, along with a general lack of details, so there was much to discuss. The conversation included a memorable moment: <nsh> gotta be some way this is sneaky, otherwise it's too good to be true... <andytoshi> hah, yeah, i know the feeling On Oct 10 2016 , Andrew Poelstra published a follow-up paper 2 about Mimblewimble, which introduced several refinements to the original proposal and describes further its technical details.","title":"Mimblewimble"},{"location":"about-grin/story/#grin","text":"On Oct 20 2016 , a pseudonymous developer using the name Ignotus Peverell, announced in the bitcoin wizards IRC channel that he began work on a minimal implementation of the protocol, which he named Grin. Ignotus Peverell is the wizard who was gifted the Cloak of Invisibility by Death. Grin is short for the Gringotts wizarding bank. 16:45 -!- igno_peverell [~user@104.238.169.137] has joined #bitcoin-wizards 16:47 < igno_peverell> I have a minimal implementation of MimbleWimble available. It's very far from complete but has the basics, included the summing of pedersen commitments: 16:47 < igno_peverell> https://github.com/ignopeverell/grin 16:47 < igno_peverell> Any feedback or review is greatly appreciated. Thanks! Igno was joined on github by other developers who took interest in the project, several of them bearing pseudonyms of other Harry Potter characters. While Mimblewimble serves as the foundation to transacting, it constitutes a relatively small part of a complete blockchain cryptocurrency, and many choices were yet to be made. Thus began the journey to develop a full working implementation.","title":"Grin"},{"location":"about-grin/story/#launch","text":"Grin's genesis block was mined on January 15th, 2019. It was, and still is, young and experimental. It currently goes through rapid changes, as its first 2 years include agreed-upon hardforks in 6-months intervals. Several months after launch, Ignotus Peverell dissappeared and has yet to return. Developers distributed around the world are contributing to build Grin, some of them funded by donations to work on the project full-time. Governance and development will always remain completely transparent and open for every community member to join. The Mimblewimble Whitepaper \u21a9 Andrew Poelstra's Paper \u21a9","title":"Launch"},{"location":"about-grin/transactions/","text":"Mimblewimble transactions are interactive, meaning both parties need some kind of interaction with each other to exchange the necessary data. This communication can happen in countless different ways, such as through a network, email, forum, social media, chat, letter, carrier pigeon etc. Let's see how a standard transaction flow looks like: An address, often referred to as a Slatepack Address , is provided by the receiver. It is important to note; This slatepack address is only used to support peer-to-peer interaction, and is completely different from the familiar on-chain address, as it's not part of the ledger. It is infact an ed25199 public key which serves a double role: A Tor hidden service address. Key to encrypt the data communicated between the sender and receiver. Sender begins building the transaction slate (a sheet of incomplete transaction data), encrypts it with the receiver's address (a public key), and passes it over. Receiver adds to the slate his own data and signature, and delivers it back. Sender finalizes the transaction by adding the final data and his own signature to the slate, thus completing the transaction building process. He can then post it to the chain. One nice side-effect of interactive transactions is that coins can't accidentally be sent into the \"void\" (a public key/address which nobody controls). How does it happen? The interaction between sender and receiver happens in one of two ways. Tor As mentioned earlier, the slatepack address is also used to derive a Tor address. By default, the sender's wallet will try to communicate with the receiver's wallet via Tor. If the connection succeeds, all the rest is done automatically by the two wallets and no manual action is required. The process is exactly as described above, but it all happens under the hood without further intervention. However, if the Tor connection between the wallets is not successful for whatever reason, Grin defaults to exchanging slate text messages, also called slatepacks, manually. Alternative Method: http Synchronous communication can also happen through normal http, but it requires opening port 3415 and thus might be complicated. We don't cover it here as this method will soon be deprecated. Slatepack Recall that slates are simply partial transactions. Slatepacks are slates encoded inside compact, neatly organized and encrypted text messages. Using this method, 2 nd and 3 rd steps, where the sender and receiver pass the slate to one another, would be done manually by exchanging these slatepack messages. To do so, almost every available communication channel will work; Email, chat, social media, letters, pigeons etc. Creativity is the limit. The address (public key) initally provided by the receiver will be used to the encrypt the slatepacks, so that only the transacting parties are able to see the data inside. Non-encrypted Slatepacks It is possible to skip the 1 st step (providing an address) and straight up send a non-encrypted slatepack to the receiver. Keep in mind that in this case, if the communication channel is compromised or public, observers may learn some transaction information. Invoice Invoice transactions are built much the same way, but with a different order where the receiver initiates the transaction by asking for a certain amount of coins. A slatepack address is provided by the sender (optional). Receiver creates an invoice, requesting to be paid the specified amount. In practice he starts building the transaction slate and writes a pre-determined amount into it. Sender decrypts the slate to confirm the amount he is about to pay, and adds his own data and siganture. Receiver finalizes the transaction building process and posts it to the chain.","title":"Transactions"},{"location":"about-grin/transactions/#how-does-it-happen","text":"The interaction between sender and receiver happens in one of two ways.","title":"How does it happen?"},{"location":"about-grin/transactions/#tor","text":"As mentioned earlier, the slatepack address is also used to derive a Tor address. By default, the sender's wallet will try to communicate with the receiver's wallet via Tor. If the connection succeeds, all the rest is done automatically by the two wallets and no manual action is required. The process is exactly as described above, but it all happens under the hood without further intervention. However, if the Tor connection between the wallets is not successful for whatever reason, Grin defaults to exchanging slate text messages, also called slatepacks, manually. Alternative Method: http Synchronous communication can also happen through normal http, but it requires opening port 3415 and thus might be complicated. We don't cover it here as this method will soon be deprecated.","title":"Tor"},{"location":"about-grin/transactions/#slatepack","text":"Recall that slates are simply partial transactions. Slatepacks are slates encoded inside compact, neatly organized and encrypted text messages. Using this method, 2 nd and 3 rd steps, where the sender and receiver pass the slate to one another, would be done manually by exchanging these slatepack messages. To do so, almost every available communication channel will work; Email, chat, social media, letters, pigeons etc. Creativity is the limit. The address (public key) initally provided by the receiver will be used to the encrypt the slatepacks, so that only the transacting parties are able to see the data inside. Non-encrypted Slatepacks It is possible to skip the 1 st step (providing an address) and straight up send a non-encrypted slatepack to the receiver. Keep in mind that in this case, if the communication channel is compromised or public, observers may learn some transaction information.","title":"Slatepack"},{"location":"about-grin/transactions/#invoice","text":"Invoice transactions are built much the same way, but with a different order where the receiver initiates the transaction by asking for a certain amount of coins. A slatepack address is provided by the sender (optional). Receiver creates an invoice, requesting to be paid the specified amount. In practice he starts building the transaction slate and writes a pre-determined amount into it. Sender decrypts the slate to confirm the amount he is about to pay, and adds his own data and siganture. Receiver finalizes the transaction building process and posts it to the chain.","title":"Invoice"},{"location":"getting-started/build/","text":"Read this in other languages: Espa\u00f1ol , Korean , \u65e5\u672c\u8a9e , \u7b80\u4f53\u4e2d\u6587 . Requirements Rust Install using rustup.rs : curl https://sh.rustup.rs -sSf | sh; source $HOME/.cargo/env If rust is already installed, you should update to the latest version by running rustup update . Grin currently does not support a minimum version of Rust, so it's recommended to build using the latest version. Dependencies git \u25cf tor \u25cf clang \u25cf ncurses and libs (ncurses, ncursesw5) \u25cf zlib libs (zlib1g-dev or zlib-devel) \u25cf pkg-config \u25cf libssl-dev \u25cf llvm \u25cf linux-headers (needed on Alpine linux) For Debian-based distributions (Ubuntu, Mint etc): apt install build-essential git tor cmake git libgit2-dev clang libncurses5-dev libncursesw5-dev zlib1g-dev pkg-config libssl-dev llvm For macOS: xcode-select --install brew install --with-toolchain llvm brew install pkg-config brew install openssl Build git clone https://github.com/mimblewimble/grin.git cd grin git checkout v4.0.2 cargo build --release Grin can also be built in debug mode (using the --debug or the --verbose flags) but this will render fast sync prohibitively slow due to the large overhead of cryptographic operations. Build errors \u21b4 Build error: Could not compile tokio-retry You might want to remove any previous rust installations to avoid conflicts. Use rustup to reinstall rust and cargo as described . NOTE: If you install rust or cargo with your package manager (most Linuxes anno 2017) you\u2019ll get too old versions. On Debian, you might have to manually compile cmake or get it from non-detault repositories. Build error: failed to select a version for \u2018serde_json\u2019 Run cargo update to fix this Build error: can\u2019t compile crate bitflags Chech rustc \u2013version and note that bitflags requires rust 1.21 or newer. Install via rustup and recommended you also remove any rust/cargo installed via your package manager. Build error: can\u2019t locate stdarg.h If librocksdb-sys fails to build, try symlinking stddef.h and stdarg.h from the gcc5 include directory. So probably from /usr/lib to /usr/include Build error: /usr/bin/ld: cannot find -lz On Ubuntu install the zlib development headers: apt install zlib1g-dev . Build error: /usr/bin/ld: cannot find -lncursesw On Ubuntu install the ncurses development headers: apt install libncursesw5-dev . What was built? Let's review what a succesfull build gets you. Binary target/release/grin is your main grin binary, located inside the build directory. To add it to your path, type: export PATH=`pwd`/target/release:$PATH You can then run grin from anywhere on your system. Data Files All data, configuration and log files created and used by grin are located by default in the hidden ~/.grin directory (under your user home directory). You can modify configuration values by editing the grin-server.toml file, located in ~/.grin/main/grin-server.toml . You can have grin create its data files in the current directory . To do this, run: grin server config This will generate a grin-server.toml file in the current directory. Running grin from a directory that contains grin-server.toml will use the values in that filem which will also be pre-configured to use the current directory for all of the node's data. Configuration Grin attempts to run with sensible defaults, and can be further configured via the grin-server.toml file, generated by grin on its first run. The file contains documentation on each available option. While it is recommended that you perform all grin server configuration via grin-server.toml , it's also possible to supply command line switches to grin that override any settings in the file. For help on grin commands and their switches, try: grin help grin server help grin client help Mining Once your grin node is up and running, you can start mining by building and running grin-miner against your node. For grin-miner to be able to communicate with your grin node, make sure that you have enable_stratum_server = true in your grin-server.toml configuration file and you have a wallet listener running ( grin-wallet listen ). Docker (Running Grin in a container) docker build -t grin -f etc/Dockerfile . For floonet, use etc/Dockerfile.floonet instead You can bind-mount your grin cache to run inside the container. docker run -it -d -v $HOME /.grin:/root/.grin grin If you prefer to use a docker named volume, you can pass -v dotgrin:/root/.grin instead. Using a named volume copies default configurations upon volume creation.","title":"Build"},{"location":"getting-started/build/#requirements","text":"","title":"Requirements"},{"location":"getting-started/build/#rust","text":"Install using rustup.rs : curl https://sh.rustup.rs -sSf | sh; source $HOME/.cargo/env If rust is already installed, you should update to the latest version by running rustup update . Grin currently does not support a minimum version of Rust, so it's recommended to build using the latest version.","title":"Rust"},{"location":"getting-started/build/#dependencies","text":"git \u25cf tor \u25cf clang \u25cf ncurses and libs (ncurses, ncursesw5) \u25cf zlib libs (zlib1g-dev or zlib-devel) \u25cf pkg-config \u25cf libssl-dev \u25cf llvm \u25cf linux-headers (needed on Alpine linux) For Debian-based distributions (Ubuntu, Mint etc): apt install build-essential git tor cmake git libgit2-dev clang libncurses5-dev libncursesw5-dev zlib1g-dev pkg-config libssl-dev llvm For macOS: xcode-select --install brew install --with-toolchain llvm brew install pkg-config brew install openssl","title":"Dependencies"},{"location":"getting-started/build/#build","text":"git clone https://github.com/mimblewimble/grin.git cd grin git checkout v4.0.2 cargo build --release Grin can also be built in debug mode (using the --debug or the --verbose flags) but this will render fast sync prohibitively slow due to the large overhead of cryptographic operations. Build errors \u21b4 Build error: Could not compile tokio-retry You might want to remove any previous rust installations to avoid conflicts. Use rustup to reinstall rust and cargo as described . NOTE: If you install rust or cargo with your package manager (most Linuxes anno 2017) you\u2019ll get too old versions. On Debian, you might have to manually compile cmake or get it from non-detault repositories. Build error: failed to select a version for \u2018serde_json\u2019 Run cargo update to fix this Build error: can\u2019t compile crate bitflags Chech rustc \u2013version and note that bitflags requires rust 1.21 or newer. Install via rustup and recommended you also remove any rust/cargo installed via your package manager. Build error: can\u2019t locate stdarg.h If librocksdb-sys fails to build, try symlinking stddef.h and stdarg.h from the gcc5 include directory. So probably from /usr/lib to /usr/include Build error: /usr/bin/ld: cannot find -lz On Ubuntu install the zlib development headers: apt install zlib1g-dev . Build error: /usr/bin/ld: cannot find -lncursesw On Ubuntu install the ncurses development headers: apt install libncursesw5-dev .","title":"Build"},{"location":"getting-started/build/#what-was-built","text":"Let's review what a succesfull build gets you.","title":"What was built?"},{"location":"getting-started/build/#binary","text":"target/release/grin is your main grin binary, located inside the build directory. To add it to your path, type: export PATH=`pwd`/target/release:$PATH You can then run grin from anywhere on your system.","title":"Binary"},{"location":"getting-started/build/#data-files","text":"All data, configuration and log files created and used by grin are located by default in the hidden ~/.grin directory (under your user home directory). You can modify configuration values by editing the grin-server.toml file, located in ~/.grin/main/grin-server.toml . You can have grin create its data files in the current directory . To do this, run: grin server config This will generate a grin-server.toml file in the current directory. Running grin from a directory that contains grin-server.toml will use the values in that filem which will also be pre-configured to use the current directory for all of the node's data.","title":"Data Files"},{"location":"getting-started/build/#configuration","text":"Grin attempts to run with sensible defaults, and can be further configured via the grin-server.toml file, generated by grin on its first run. The file contains documentation on each available option. While it is recommended that you perform all grin server configuration via grin-server.toml , it's also possible to supply command line switches to grin that override any settings in the file. For help on grin commands and their switches, try: grin help grin server help grin client help Mining Once your grin node is up and running, you can start mining by building and running grin-miner against your node. For grin-miner to be able to communicate with your grin node, make sure that you have enable_stratum_server = true in your grin-server.toml configuration file and you have a wallet listener running ( grin-wallet listen ).","title":"Configuration"},{"location":"getting-started/build/#docker","text":"(Running Grin in a container) docker build -t grin -f etc/Dockerfile . For floonet, use etc/Dockerfile.floonet instead You can bind-mount your grin cache to run inside the container. docker run -it -d -v $HOME /.grin:/root/.grin grin If you prefer to use a docker named volume, you can pass -v dotgrin:/root/.grin instead. Using a named volume copies default configurations upon volume creation.","title":"Docker"},{"location":"getting-started/community-wallets/","text":"Grin Wallets \u2003Grin++ GUI wallet and node written in C++ \u2003 Windows, Linux, macOS How to: send/receive Download Download at grinplusplus.github.io Troubleshooting Receive Copy your address ( grin1... ) and provide it to the other party. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are: The sender will provide you a Slatepack message. Paste it into the Slatepack box and click Receive. Copy the Slatepack message your wallet generates. Provide it to the sender. Done! The sender will finalize the transaction and post it to the network. Send Click send. Choose the amount of grins. Enter the receiver's address and send. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are: Copy the Slatepack message your wallet generates and provide it to the receiver (however you want). You should get a Slatepack message back from the receiver. Paste it into the Slatepack box and click Finalize. Done! Your wallet will now finalize the transaction and post it to the network. \u2003Niffler GUI wallet and node using the main implementation as back-end \u2003 Windows, Linux, macOS How to: send/receive Download Download at github.com/grinfans/niffler/releases (by clicking on one of the listed download links) Receive Click on Receive, then Slatepack address. Copy your address ( grin1... ) and provide it to the other party. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are:* The sender will provide you a Slatepack message. Click again on Receive, then on Create response slatepack. Paste it into the Slatepack box and click Create response slatepack. Copy the new Slatepack message your wallet generates. Provide it to the sender. Done! The sender will then finalize the transaction and post it to the network. Send Click on Send, then Create slatepack. Enter the address and amount, then Create slatepack. Copy the Slatepack message your wallet generates and provide it to the receiver (however you want). You should get a Slatepack message back from the receiver. Click on Send, then on Finalize. Paste the Slatepack message into the box and confirm. Done! Your wallet will now finalize the transaction and post it to the network. \u2003Ironbelly Mobile wallet \u2003 iOS, Android How to: send/receive Download Download at https://ironbelly.app Receive Soon Send Soon Related Services \u2003Grinnode.live Public GRIN API and sync service","title":"Community Wallets"},{"location":"getting-started/community-wallets/#grin-wallets","text":"","title":"Grin Wallets"},{"location":"getting-started/community-wallets/#grin","text":"GUI wallet and node written in C++ \u2003 Windows, Linux, macOS How to: send/receive Download Download at grinplusplus.github.io Troubleshooting Receive Copy your address ( grin1... ) and provide it to the other party. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are: The sender will provide you a Slatepack message. Paste it into the Slatepack box and click Receive. Copy the Slatepack message your wallet generates. Provide it to the sender. Done! The sender will finalize the transaction and post it to the network. Send Click send. Choose the amount of grins. Enter the receiver's address and send. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are: Copy the Slatepack message your wallet generates and provide it to the receiver (however you want). You should get a Slatepack message back from the receiver. Paste it into the Slatepack box and click Finalize. Done! Your wallet will now finalize the transaction and post it to the network.","title":"&emsp;Grin++"},{"location":"getting-started/community-wallets/#niffler","text":"GUI wallet and node using the main implementation as back-end \u2003 Windows, Linux, macOS How to: send/receive Download Download at github.com/grinfans/niffler/releases (by clicking on one of the listed download links) Receive Click on Receive, then Slatepack address. Copy your address ( grin1... ) and provide it to the other party. That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically. But if there's no Tor communication, next steps are:* The sender will provide you a Slatepack message. Click again on Receive, then on Create response slatepack. Paste it into the Slatepack box and click Create response slatepack. Copy the new Slatepack message your wallet generates. Provide it to the sender. Done! The sender will then finalize the transaction and post it to the network. Send Click on Send, then Create slatepack. Enter the address and amount, then Create slatepack. Copy the Slatepack message your wallet generates and provide it to the receiver (however you want). You should get a Slatepack message back from the receiver. Click on Send, then on Finalize. Paste the Slatepack message into the box and confirm. Done! Your wallet will now finalize the transaction and post it to the network.","title":"&emsp;Niffler"},{"location":"getting-started/community-wallets/#ironbelly","text":"Mobile wallet \u2003 iOS, Android How to: send/receive Download Download at https://ironbelly.app Receive Soon Send Soon","title":"&emsp;Ironbelly"},{"location":"getting-started/community-wallets/#related-services","text":"","title":"Related Services"},{"location":"getting-started/community-wallets/#grinnodelive","text":"Public GRIN API and sync service","title":"&emsp;Grinnode.live"},{"location":"getting-started/table-of-contents/","text":"Table of Contents Quickstart Install - Download and install the binaries Initialize - Set up a full node and wallet Receive - How to receive grins Send - How to send grins More Wallet Handbook - Complete user guide to grin-wallet. Community Wallets - List of wallets and how to use them. Build - How to build grin from source.","title":"Table of Contents"},{"location":"getting-started/table-of-contents/#table-of-contents","text":"","title":"Table of Contents"},{"location":"getting-started/table-of-contents/#quickstart","text":"Install - Download and install the binaries Initialize - Set up a full node and wallet Receive - How to receive grins Send - How to send grins","title":"Quickstart"},{"location":"getting-started/table-of-contents/#more","text":"Wallet Handbook - Complete user guide to grin-wallet. Community Wallets - List of wallets and how to use them. Build - How to build grin from source.","title":"More"},{"location":"getting-started/wallet-handbook/","text":"Wallet User Handbook Now that you've set up your node and learned how to form a simple transaction, let's get to know the wallet more deeply. The following document is an extremely comprehensive user guide to the reference Grin wallet implementation, grin-wallet v4.0.0 . GUI Wallet For instructions on how to do grin transactions with a graphical user interface, see community wallets . File Structure By default, grin will create all wallet files in the hidden directory .grin under your home directory (i.e. ~/.grin ). You can also create and use a wallet with data files in a custom directory, as will be explained later. A Grin wallet maintains its state in an LMDB database, with the master seed stored in a separate file. When creating a new wallet, the file structure should be as follows: [wallet directory] \u251c\u2500\u2500 grin-wallet.log \u251c\u2500\u2500 grin-wallet.toml \u251c\u2500\u2500 tor \u2514\u2500\u2500 wallet_data \u251c\u2500\u2500 db \u2502 \u2514\u2500\u2500 lmdb \u2502 \u2514\u2500\u2500 wallet.seed grin-wallet.toml contains configuration information for the wallet. You can modify values within to change ports, the address of your grin node, or logging values. wallet.seed is your master seed file; the private keys of all your outputs are derived from it, and it's contents are encrypted with your password. The seed file can be recovered using your seed phrase if you lose this file or forget your password. tor folder contains Tor configuration files used by the wallet listener. There should be no need to manipulate anything in this directory manually. Tor Configuration \u21b4 grin-wallet.toml contains a [tor] section used to configure values when sending or listening via TOR: use_tor_listener specifies whether the Tor listener should also be invoked when starting the wallet listener via listen (default = true). socks_proxy_addr contains the listening address of TOR's socks proxy port. This should generally be left alone. help grin-wallet help (or --help , -h ) will display all the commands and every global flag. To get additional info about a specific command type grin-wallet help [command] , e.g: grin-wallet help send init Prior to anything else, the wallet files need to be generated via the init command as follows: grin-wallet init You'll be prompted to enter a password for the new wallet. It will be used to encrypt your master.seed file and you'll be asked to type it on most wallet commands. By default, your wallet files will be placed into `~/.grin . Alternatively, if you'd like to run a wallet in a directory of your choice, you can create one in the current directory by using flag -h , e.g: grin-wallet init -h This will create all the needed data files, including grin-wallet.toml and wallet.seed , in the current directory. When running any grin-wallet command, grin will check the working directory if these files exist. If not, it will use the default location ~/.grin . Upon a successful init , your wallet will print a 24-word recovery phrase, which you should write down and store in a non-digital format. This phrase can be used to re-create your master seed file if it gets lost or corrupted, or if you forget the wallet password. If you'd prefer to use a 12-word recovery phrase, you can use the -s --short_wordlist flag. init --recover If you need to recreate your wallet from an existing seed, you can init a wallet with an existing recovery phrase using the -r --recover flag. The following example initializes a wallet in the current directory, prompting the user for a recovery phrase. grin-wallet init -hr File /home/tomriddle/wallet/grin-wallet.toml configured and created Please enter your recovery phrase: This command will recreate your wallet seed. On first run, the wallet will scan the entire chain and restore any outputs that belong to the you. recover The recover command is used to display the existing wallet's 24 (or 12) word recovery phrase. grin-wallet recover account The account command is used to manage wallet accounts. Let's print a list of your existing accounts: grin-wallet account Accounts could be thought of as somewhat similar to different bank accounts under the same name. Each account acts as a seperate wallet, but they are all derived from the your master seed. The default is created when you initialize the wallet, and is denoted as m/0/0 . Additional accounts form the path m/i/0 . To create a new account, pass the argument -c --create . grin-wallet account -c jedusor This will create a new account called 'jedusor'. All grin-wallet commands can then be passed the argument -a to specify an account for the command (otherwise the default account is used), e.g: grin-wallet -a jedusor info info The info command summarizes wallet account balance. grin-wallet info Password: ____ Wallet Summary Info - Account 'default' as of height 813137 ____ Confirmed Total | 5779.473029600 Awaiting Confirmation (< 10) | 0.000000000 Awaiting Finalization | 139.851133700 Locked by previous transaction | 389.859133700 -------------------------------- | ------------- Currently Spendable | 5779.473029600 Confirmed Total is your balance including both spendable coins and those awaiting confirmation. Awaiting Confirmation denotes the balance from transactions that have appeared on-chain, but for which your wallet is waiting a set number of blocks before treating them as spendable. Awaiting Finalization is the balance from transactions that have not yet appeared on-chain. This could be due to the other party not having broadcast the transaction yet. Also, when you are the sender of a transaction, your change output will be denoted in this field as well. Locked by previous transaction shows the amount of coins locked by a previous transaction you have made and that is currently awaiting finalization. This is usually made up both of the amount being sent and of the change outputs that are will be returned to your wallet. Once the transaction appears on-chain, this balance unlocks and the output that was used will become available for spending. listen The listen command opens up a Tor listener. grin-wallet listen Your wallet will listen for: Transactions with other parties Coinbase transactions from a mining server Tor hidden service will be automatically configured and the wallet will display your listening address. You can then provide this address to other users to send you funds via the send command. Until the process is cancelled with <Ctrl-C> , your wallet will listen for requests: Transactions with other parties Coinbase transactions from a mining server tor or tor.exe needs to be available on the system path. address The address command should be used when you don't have Tor available to receive. grin-wallet address This command outputs the same address as using the listen command. However, your address serves a triple purpose: If Tor is available, it will serve as your Tor onion address. A key to encrypt the Slatepack messages exchanged between you and your counterparty (more on that below). Payment proof identification. Address This is not the same concept of address that Bitcoin-based cryptocurrencies might use; A MimbleWimble chain has no addresses. send The send command is the method through which you begin an interactive transaction to send grins to somebody else. This can either be an immediate synchronous exchange, as happens when connectins the wallets via Tor, or it can be an asynchronous process, in which each step is done manually by exchanging easily copy-pastable strings called Slatepacks. The choice between the two methods is handled automatically by using send in the form of send -d <address> <amount> . grin-wallet send -d grin1dhvv9mvarqwl6fderuxp3qgl6qpphvc9p4u24347ec0mvvg6342q4w6x5r 180 This command tries to send 180 grins to the specified address via Tor. If both wallets are accessible, the transaction would be complete with no further steps needed. If the above communication fails, for whatever reason, your wallet will output a Slatepack message: BEGINSLATEPACK. HctgNGXrJDGFY3B KrEF1meAezGjxQ6 Z93QF6Ps2m9yKCQ LfhZvpDY9ZXViM7 nDoNeMvwtYV2crr 8gDqvYDmtRfLL3n Uabao7VyWR4AuYg TXQUSWU83kEhKmr bRtdRjvpisx1LYo 9cyZGfsgsd7ZvDJ KKZPHhcPe4Eivtv cMvee3nwFFY3ZnM SoULNaHVJ38h3tZ vMXQMoMLB17L53o Xy6QQjDaG8avUBt LQq2GfGRTiUPQgn vQwFzfZPVzVKNLk 5AFmUQFZtiVdTJV xHvc1BuAqcamerv Y76KVccPY3WGupy 4zWFpkjTH65XNiH XqQnkb3EA1iVrHc tyTJ1PWb6X6oV1k ktYiWBpatyTirRy CywPyjr6c8XLr4Q 9VoCedU5BcdFdMB ACqQTwjgVXqjHoS 58ZPKFitjeH67Ts ah6twcKtMaFmTXD i7JEQ7qV6cewgxH 2jwWFxbb98mye6A Lm9movc6Wer26L2 91WQD3cbVpAZLEs APFPtyxnWjv8n3W ZXFLR2TPZwGc5Vt zwFUPoyWfKXasQy VVV6tbKWEEhqAZR e34M7uEwfurpUUi 9812VFPY1qw3K9b ynwQXuXMuWQCUnU s1JqWqFgSQKENUP tGCK19dys9twghA FaAc7ZXQHdMbUoL sVxVfdjE94F1Wpj M7QAM5VZuaauHdQ Mt2erFyxJ5vsYSZ hgS553UKoQL5YWX E7oRNdMDkJV6VkL i55kAQc1vWvW9ce 3MoXiBT4TJ1SyNS NVZKxgk8c. ENDSLATEPACK. This message contains the data required for the receiver's wallet to process the transaction via the receive command. This Slatepack is also encypted for the recipient only, since you provided an address (which is a public key) by using the -d flag. If the receiver does not want, or is not able to provide an address, you could use command send without the -d --dest flag. grin-wallet send 180 In this case, your wallet will not look for a Tor service to contact, and instead simply output a non-encrypted Slatepack message which can be sent to anybody. more flags -m --manual if present, don't attempt to interact via Tor, only output Slatepack message. -f --fluff if present, ignore the dandelion relay protocol. Dandelion bounces your transactions directly through several nodes in a stem phase, after which the transaction randomly fluffs (broadcasted) to the rest of the network. -n --no_payment_proof if present, do not request the data required for a payment proof. This shortens the Slatepack message length. -e --estimate-selection if present, performs a \"dry-run\" of creating the transaction, without actually doing anything and locking the funds It then lists different output selection strategies (outlined below) and their possible effect on your wallet outputs, if chosen. -s --selection allows you to choose between two output selection strategies, small and all . The default startegy is small , which includes the minimum number of inputs to cover the amount, starting with the smallest value output. In contrast, using all consolidates all of your outputs into a single new output, thus reducing your wallet size, increasing operation speed and reducing the UTXO-set size of the chain. The downside is that the entire contents of your wallet remain locked until the transaction is validated on-chain, and all outputs are linked to one another, a detriment to your privacy. -b --ttl_blocks allows you to specify a number of blocks into the future, after which a wallet should refuse to process the transaction further. This can be useful for putting time limits on transaction finalization, but please note this is not enforced at the grin protocol level; it's up to individual wallets whether they wish to respect this flag. receive The receive command proccesses the Slatepack message provided by the sender. grin-wallet receive After entering the command, you'll be prompted to input the Slatepack. Then your wallet will output a another Slatepack message to provide the other party in order to finalize the transaction. Files When sending or receiving via Slatepacks, your wallet will create a text file containing the message it generated. Default path is ~/.grin/main/slatepacks . finalize The finalize command is the final step to any Slatepack transaction. grin-wallet finalize After entering the command, you'll be prompted to input the Slatepack message provided to you by the receiver. The transaction building process will then be finalized and your wallet will post it to the network. If the flag -n --nopost is present, the transaction would be finalized but not posted. post Manually post a finalized transaction to the network. Either type grin-wallet post and enter the Slatepack message into the prompt, or specify the file path using the -i flag. grin-wallet post -i \"~/.grin/main/slatepacks/my_tx.S3.slatepack/\" proof Grin's privacy and scalability mechanics mean users no longer have the ability to simply prove a transaction has happened by pointing to it on the chain. By default, whenever a transaction sent to a destination addres using -d , a payment proof is created. Payers can then use these proofs to resolve future payment disputes and prove they sent funds to the correct recipient. The sender can export the payment proof by specifying the transaction id ( -i ) (obtained by txs ) or the tx-UUID ( -t ), and choosing the path for the proof file, e.g: grin-wallet export_proof -i 4 \"~/Documents/proof.txt\" The sender can then provide this proof to any wallet for verification. grin-wallet verify_proof /path/proof.txt This will ensure that: The kernel for the transaction in the proof is validated and can be found on-chain. Both the sender and recipient's signatures correctly sign for the amount and the kernel. On top of that, if the receiver's address in the transaction belongs to the same wallet who's verifying, then the user will be informed as follows: grin-wallet verify_proof proof.txt Password: Payment proof's signatures are valid. The proof's recipient address belongs to this wallet. Command 'verify_proof' completed successfully invoice The invoice command sends an invoice transaction, in which the initiator requests an amount for payment, and sends that request to another party. Since invoice transactions require manual confirmation from the party paying the funds, they can only be created and sent to payers via Slatepack. grin-wallet invoice -d grin1dhvv9mvarqwl6fderuxp3qgl6qpphvc9p4u24347ec0mvvg6342q4w6x5r 60 This command will create an encypted (as -d is provided) invoice, requesting a payment of 60 grins. The resulting Slatepack can then be sent to the other party for the to pay . Upon receiving the back the Slatepack from the payer, the transaction can then be finalized and posted using the finalize command. pay After receiving an invoice request, the payer can use the pay command to decode (also decrypt if possible) the Slatepack and confirm the amount of coins being requested as payment. grin-wallet pay Please paste your encoded slatepack message: BEGINSLATEPACK. P9rVoTRyKdhVsuC a5SfwQMXbtsDBwD omfeWYWwkbK9AUD k2pZvpgeXmJSUcv y9Mi81ngsCrpW9r QW226CWwbxrSprJ cCJA9cACpguBHDj eExN8vuYc1SHj9B 2Xa1BPGB77kpY9q uG9eXmaeprY6CQt PAibwfMnwxVDJFU EeQfwwSnEUADkg3 wBYXcuSVTnfJ4Jj DnqawMkmAiWvhNm WLrdZ1Vh3P6TXP6 ZgJG9pRNi51mAtU 9soyVAgvFWoEpgn VA6suegVxTsWN1r V3LQHB7bjwX5Rwa yPfqhGTLwR. ENDSLATEPACK. This command will pay the amount specified in the invoice using your wallet's funds. After you confirm, the following will occur: * 10.000000000 of your wallet funds will be added to the transaction to pay this invoice. * The wallet will IMMEDIATELY attempt to send the resulting transaction to the wallet listening at: 'grin1ln4y82fw4urggk3hq0xkeqfhw3dfe6rhcv6a0v64uz4ny9epcc6qpuwx4k'. * If other wallet is not listening, the resulting transaction will output as a slatepack which you can manually send back to the invoice creator. Please review the above information carefully before proceeding To proceed, type the exact amount of the invoice as displayed above (or Q/q to quit) > To confirm the payment, type the exact amount in decimal, as 10.000000000 in this example, into the prompt. Your wallet will then fill out the transaction and return a Slatepack for you to provide back to the initiator, which they can then finalize . unpack Upon receiving a Slatepack message or file from a party, whether in an encrypted form or not, the unpack command decrypts and decodes it to a bare slate JSON format (the format used by the wallet to read and contruct transactions). grin-wallet unpack This prompts you for a Slatepack message. to decode a file, use the -i flag and provide the path. Result: SLATEPACK CONTENTS ------------------ { ... } ------------------ Slatepack is encrypted for this wallet DECRYPTED SLATEPACK ------------------- { ... } DECRYPTED SLATE --------------- { ... } Command 'unpack' completed successfully outputs To show a list of all your wallet's outputs, type: grin-wallet outputs allet Outputs - Account 'default' - Block Height: 814491 --------------------------------------------------------------------------------------------------------------------------------------------------------------- Output Commitment MMR Index Block Height Locked Until Status Coinbase? # Confirms Value Tx =============================================================================================================================================================== 08f4f062b99223d2d8a1ad1ae11085ab2d7b4f1bc603f9c29748f1b918861fdf23 7498573 743936 743936 Unspent false 70556 5198.081029600 1 --------------------------------------------------------------------------------------------------------------------------------------------------------------- 097fe8bf1ad6a792600d5e010d0b77c40b147ea122c176476259f100a48924d40c 7832632 790025 790025 Unspent false 24467 581.392000000 2 --------------------------------------------------------------------------------------------------------------------------------------------------------------- 08645896f150bfc70f36a602a7a5f41180ae8d5db42864f19f7257542cf2c7fc98 None 811501 0 Unspent false 2991 389.859133700 9 --------------------------------------------------------------------------------------------------------------------------------------------------------------- By default, only unspent outputs are listed. To show spent outputs, provide the -s flag. grin-wallet -s outputs txs Every time an action is performed in your wallet (send, receive, even if uncompleted), an entry is added to an internal transaction log containing vital information about the transaction. Because the Grin chain contains no identifying information whatsoever, this transaction log is necessary for your wallet to keep track of transactions. To view the contents of your transaction log, use the command: grin-wallet txs Transaction Log - Account 'default' - Block Height: 814448 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Id Type Shared Transaction Id Creation Time TTL Cutoff Height Confirmed? Confirmation Time Num. Num. Amount Amount Fee Net Payment Kernel Tx Inputs Outputs Credited Debited Difference Proof Data ===================================================================================================================================================================================================================================================================================== 0 Received Tx 2b2ffc5e-8fa0-4450-b270-078df29b3e23 2020-07-28 13:18:18 None true 2020-07-28 13:18:18 0 1 389.892 0.0 0.007 389.892 None ddec166399348a24d2893c025b4b4d4a058f81834a663284ba23fe0bd0ac025b4b Yes ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1 Sent Tx fd9b3035-73d0-4ea3-8c3e-5d45c512ad8b 2020-08-03 15:32:19 None true 2020-08-03 15:42:20 2 1 389.8591337 390.8661337 0.007 -1.007 Yes 0834a66310df8a8b43093c025b4b4d4a058f8188ee24d2809e338e0bd0ae9e2c2c Yes ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2 Sent Tx ea92fcce-8fa0-48d0-b270-078df2e22d24 2020-08-04 18:51:47 None false None 1 1 139.8511337 389.8591337 0.008 -250.008 None 09fd95b4e40ce1c2d67376d46dc37ddec1aa0ae50ca9934ba271fff0b47510c72f Yes - Cancelled ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- To see the inputs & outputs associated with a particular transaction, as well as the payment proof associated with the transaction, use the -i switch and specify the id of the transaction, e.g: grin-wallet txs -i 0 cancel Cancels an in-progress created transaction, freeing previously locked outputs for use again. grin-wallet cancel -i 2 To specify which transaction to cancel, use the -i flag along with the tx id (obtained by txs ) or the -t flag with the tx-UUID. scan The scan command will scan the entire UTXO-set from the node, identify which outputs are yours and update your wallet state. grin-wallet scan It should not usually be necessary to run the scan command manually, as the wallet continually scans the outputs on the chain. However, if for some reason you believe your outputs and transactions are in an inconsistent state, you can initiate a manual scan to attempt to fix or restore them. You could can also use the -d --delete-unconfirmed flag to cancel any transaction log entries and delete unconfirmed outputs. grin-wallet scan -d this command will also attempt to cancel any transaction log entries associated with any locked outputs and unlock the outputs. Additionally, the h --start-height flag lets specify a block height from which to start a manual scan. When initializing a wallet from an existing seed via the grin-wallet init -r command , this scan is performed automatically on first run. arguments There are several global wallet arguments which you can provide for every command. account To set the account for a wallet command, provide the -a argument. grin-wallet -a jedusor info password You could specify your password on the directly command line by providing the -p argument. Please note this will place your password in your shell's command history, so use this switch with caution. grin-wallet -p mypass info node The wallet needs to talk to a running grin node in order to remain up-to-date and verify its contents. By default, it tries to contact a node at 127.0.0.1:3413. To change this, either modify the value in the wallet's grin_wallet.toml file, or alternatively, you can provide the -r (se r ver) switch to wallet commands. grin-wallet -r \"http://192.168.0.2:1341\" info","title":"Wallet Handbook"},{"location":"getting-started/wallet-handbook/#wallet-user-handbook","text":"Now that you've set up your node and learned how to form a simple transaction, let's get to know the wallet more deeply. The following document is an extremely comprehensive user guide to the reference Grin wallet implementation, grin-wallet v4.0.0 . GUI Wallet For instructions on how to do grin transactions with a graphical user interface, see community wallets .","title":"Wallet User Handbook"},{"location":"getting-started/wallet-handbook/#file-structure","text":"By default, grin will create all wallet files in the hidden directory .grin under your home directory (i.e. ~/.grin ). You can also create and use a wallet with data files in a custom directory, as will be explained later. A Grin wallet maintains its state in an LMDB database, with the master seed stored in a separate file. When creating a new wallet, the file structure should be as follows: [wallet directory] \u251c\u2500\u2500 grin-wallet.log \u251c\u2500\u2500 grin-wallet.toml \u251c\u2500\u2500 tor \u2514\u2500\u2500 wallet_data \u251c\u2500\u2500 db \u2502 \u2514\u2500\u2500 lmdb \u2502 \u2514\u2500\u2500 wallet.seed grin-wallet.toml contains configuration information for the wallet. You can modify values within to change ports, the address of your grin node, or logging values. wallet.seed is your master seed file; the private keys of all your outputs are derived from it, and it's contents are encrypted with your password. The seed file can be recovered using your seed phrase if you lose this file or forget your password. tor folder contains Tor configuration files used by the wallet listener. There should be no need to manipulate anything in this directory manually. Tor Configuration \u21b4 grin-wallet.toml contains a [tor] section used to configure values when sending or listening via TOR: use_tor_listener specifies whether the Tor listener should also be invoked when starting the wallet listener via listen (default = true). socks_proxy_addr contains the listening address of TOR's socks proxy port. This should generally be left alone.","title":"File Structure"},{"location":"getting-started/wallet-handbook/#help","text":"grin-wallet help (or --help , -h ) will display all the commands and every global flag. To get additional info about a specific command type grin-wallet help [command] , e.g: grin-wallet help send","title":"help"},{"location":"getting-started/wallet-handbook/#init","text":"Prior to anything else, the wallet files need to be generated via the init command as follows: grin-wallet init You'll be prompted to enter a password for the new wallet. It will be used to encrypt your master.seed file and you'll be asked to type it on most wallet commands. By default, your wallet files will be placed into `~/.grin . Alternatively, if you'd like to run a wallet in a directory of your choice, you can create one in the current directory by using flag -h , e.g: grin-wallet init -h This will create all the needed data files, including grin-wallet.toml and wallet.seed , in the current directory. When running any grin-wallet command, grin will check the working directory if these files exist. If not, it will use the default location ~/.grin . Upon a successful init , your wallet will print a 24-word recovery phrase, which you should write down and store in a non-digital format. This phrase can be used to re-create your master seed file if it gets lost or corrupted, or if you forget the wallet password. If you'd prefer to use a 12-word recovery phrase, you can use the -s --short_wordlist flag.","title":"init"},{"location":"getting-started/wallet-handbook/#init-recover","text":"If you need to recreate your wallet from an existing seed, you can init a wallet with an existing recovery phrase using the -r --recover flag. The following example initializes a wallet in the current directory, prompting the user for a recovery phrase. grin-wallet init -hr File /home/tomriddle/wallet/grin-wallet.toml configured and created Please enter your recovery phrase: This command will recreate your wallet seed. On first run, the wallet will scan the entire chain and restore any outputs that belong to the you.","title":"init --recover"},{"location":"getting-started/wallet-handbook/#recover","text":"The recover command is used to display the existing wallet's 24 (or 12) word recovery phrase. grin-wallet recover","title":"recover"},{"location":"getting-started/wallet-handbook/#account","text":"The account command is used to manage wallet accounts. Let's print a list of your existing accounts: grin-wallet account Accounts could be thought of as somewhat similar to different bank accounts under the same name. Each account acts as a seperate wallet, but they are all derived from the your master seed. The default is created when you initialize the wallet, and is denoted as m/0/0 . Additional accounts form the path m/i/0 . To create a new account, pass the argument -c --create . grin-wallet account -c jedusor This will create a new account called 'jedusor'. All grin-wallet commands can then be passed the argument -a to specify an account for the command (otherwise the default account is used), e.g: grin-wallet -a jedusor info","title":"account"},{"location":"getting-started/wallet-handbook/#info","text":"The info command summarizes wallet account balance. grin-wallet info Password: ____ Wallet Summary Info - Account 'default' as of height 813137 ____ Confirmed Total | 5779.473029600 Awaiting Confirmation (< 10) | 0.000000000 Awaiting Finalization | 139.851133700 Locked by previous transaction | 389.859133700 -------------------------------- | ------------- Currently Spendable | 5779.473029600 Confirmed Total is your balance including both spendable coins and those awaiting confirmation. Awaiting Confirmation denotes the balance from transactions that have appeared on-chain, but for which your wallet is waiting a set number of blocks before treating them as spendable. Awaiting Finalization is the balance from transactions that have not yet appeared on-chain. This could be due to the other party not having broadcast the transaction yet. Also, when you are the sender of a transaction, your change output will be denoted in this field as well. Locked by previous transaction shows the amount of coins locked by a previous transaction you have made and that is currently awaiting finalization. This is usually made up both of the amount being sent and of the change outputs that are will be returned to your wallet. Once the transaction appears on-chain, this balance unlocks and the output that was used will become available for spending.","title":"info"},{"location":"getting-started/wallet-handbook/#listen","text":"The listen command opens up a Tor listener. grin-wallet listen Your wallet will listen for: Transactions with other parties Coinbase transactions from a mining server Tor hidden service will be automatically configured and the wallet will display your listening address. You can then provide this address to other users to send you funds via the send command. Until the process is cancelled with <Ctrl-C> , your wallet will listen for requests: Transactions with other parties Coinbase transactions from a mining server tor or tor.exe needs to be available on the system path.","title":"listen"},{"location":"getting-started/wallet-handbook/#address","text":"The address command should be used when you don't have Tor available to receive. grin-wallet address This command outputs the same address as using the listen command. However, your address serves a triple purpose: If Tor is available, it will serve as your Tor onion address. A key to encrypt the Slatepack messages exchanged between you and your counterparty (more on that below). Payment proof identification. Address This is not the same concept of address that Bitcoin-based cryptocurrencies might use; A MimbleWimble chain has no addresses.","title":"address"},{"location":"getting-started/wallet-handbook/#send","text":"The send command is the method through which you begin an interactive transaction to send grins to somebody else. This can either be an immediate synchronous exchange, as happens when connectins the wallets via Tor, or it can be an asynchronous process, in which each step is done manually by exchanging easily copy-pastable strings called Slatepacks. The choice between the two methods is handled automatically by using send in the form of send -d <address> <amount> . grin-wallet send -d grin1dhvv9mvarqwl6fderuxp3qgl6qpphvc9p4u24347ec0mvvg6342q4w6x5r 180 This command tries to send 180 grins to the specified address via Tor. If both wallets are accessible, the transaction would be complete with no further steps needed. If the above communication fails, for whatever reason, your wallet will output a Slatepack message: BEGINSLATEPACK. HctgNGXrJDGFY3B KrEF1meAezGjxQ6 Z93QF6Ps2m9yKCQ LfhZvpDY9ZXViM7 nDoNeMvwtYV2crr 8gDqvYDmtRfLL3n Uabao7VyWR4AuYg TXQUSWU83kEhKmr bRtdRjvpisx1LYo 9cyZGfsgsd7ZvDJ KKZPHhcPe4Eivtv cMvee3nwFFY3ZnM SoULNaHVJ38h3tZ vMXQMoMLB17L53o Xy6QQjDaG8avUBt LQq2GfGRTiUPQgn vQwFzfZPVzVKNLk 5AFmUQFZtiVdTJV xHvc1BuAqcamerv Y76KVccPY3WGupy 4zWFpkjTH65XNiH XqQnkb3EA1iVrHc tyTJ1PWb6X6oV1k ktYiWBpatyTirRy CywPyjr6c8XLr4Q 9VoCedU5BcdFdMB ACqQTwjgVXqjHoS 58ZPKFitjeH67Ts ah6twcKtMaFmTXD i7JEQ7qV6cewgxH 2jwWFxbb98mye6A Lm9movc6Wer26L2 91WQD3cbVpAZLEs APFPtyxnWjv8n3W ZXFLR2TPZwGc5Vt zwFUPoyWfKXasQy VVV6tbKWEEhqAZR e34M7uEwfurpUUi 9812VFPY1qw3K9b ynwQXuXMuWQCUnU s1JqWqFgSQKENUP tGCK19dys9twghA FaAc7ZXQHdMbUoL sVxVfdjE94F1Wpj M7QAM5VZuaauHdQ Mt2erFyxJ5vsYSZ hgS553UKoQL5YWX E7oRNdMDkJV6VkL i55kAQc1vWvW9ce 3MoXiBT4TJ1SyNS NVZKxgk8c. ENDSLATEPACK. This message contains the data required for the receiver's wallet to process the transaction via the receive command. This Slatepack is also encypted for the recipient only, since you provided an address (which is a public key) by using the -d flag. If the receiver does not want, or is not able to provide an address, you could use command send without the -d --dest flag. grin-wallet send 180 In this case, your wallet will not look for a Tor service to contact, and instead simply output a non-encrypted Slatepack message which can be sent to anybody.","title":"send"},{"location":"getting-started/wallet-handbook/#more-flags","text":"-m --manual if present, don't attempt to interact via Tor, only output Slatepack message. -f --fluff if present, ignore the dandelion relay protocol. Dandelion bounces your transactions directly through several nodes in a stem phase, after which the transaction randomly fluffs (broadcasted) to the rest of the network. -n --no_payment_proof if present, do not request the data required for a payment proof. This shortens the Slatepack message length. -e --estimate-selection if present, performs a \"dry-run\" of creating the transaction, without actually doing anything and locking the funds It then lists different output selection strategies (outlined below) and their possible effect on your wallet outputs, if chosen. -s --selection allows you to choose between two output selection strategies, small and all . The default startegy is small , which includes the minimum number of inputs to cover the amount, starting with the smallest value output. In contrast, using all consolidates all of your outputs into a single new output, thus reducing your wallet size, increasing operation speed and reducing the UTXO-set size of the chain. The downside is that the entire contents of your wallet remain locked until the transaction is validated on-chain, and all outputs are linked to one another, a detriment to your privacy. -b --ttl_blocks allows you to specify a number of blocks into the future, after which a wallet should refuse to process the transaction further. This can be useful for putting time limits on transaction finalization, but please note this is not enforced at the grin protocol level; it's up to individual wallets whether they wish to respect this flag.","title":"more flags"},{"location":"getting-started/wallet-handbook/#receive","text":"The receive command proccesses the Slatepack message provided by the sender. grin-wallet receive After entering the command, you'll be prompted to input the Slatepack. Then your wallet will output a another Slatepack message to provide the other party in order to finalize the transaction. Files When sending or receiving via Slatepacks, your wallet will create a text file containing the message it generated. Default path is ~/.grin/main/slatepacks .","title":"receive"},{"location":"getting-started/wallet-handbook/#finalize","text":"The finalize command is the final step to any Slatepack transaction. grin-wallet finalize After entering the command, you'll be prompted to input the Slatepack message provided to you by the receiver. The transaction building process will then be finalized and your wallet will post it to the network. If the flag -n --nopost is present, the transaction would be finalized but not posted.","title":"finalize"},{"location":"getting-started/wallet-handbook/#post","text":"Manually post a finalized transaction to the network. Either type grin-wallet post and enter the Slatepack message into the prompt, or specify the file path using the -i flag. grin-wallet post -i \"~/.grin/main/slatepacks/my_tx.S3.slatepack/\"","title":"post"},{"location":"getting-started/wallet-handbook/#proof","text":"Grin's privacy and scalability mechanics mean users no longer have the ability to simply prove a transaction has happened by pointing to it on the chain. By default, whenever a transaction sent to a destination addres using -d , a payment proof is created. Payers can then use these proofs to resolve future payment disputes and prove they sent funds to the correct recipient. The sender can export the payment proof by specifying the transaction id ( -i ) (obtained by txs ) or the tx-UUID ( -t ), and choosing the path for the proof file, e.g: grin-wallet export_proof -i 4 \"~/Documents/proof.txt\" The sender can then provide this proof to any wallet for verification. grin-wallet verify_proof /path/proof.txt This will ensure that: The kernel for the transaction in the proof is validated and can be found on-chain. Both the sender and recipient's signatures correctly sign for the amount and the kernel. On top of that, if the receiver's address in the transaction belongs to the same wallet who's verifying, then the user will be informed as follows: grin-wallet verify_proof proof.txt Password: Payment proof's signatures are valid. The proof's recipient address belongs to this wallet. Command 'verify_proof' completed successfully","title":"proof"},{"location":"getting-started/wallet-handbook/#invoice","text":"The invoice command sends an invoice transaction, in which the initiator requests an amount for payment, and sends that request to another party. Since invoice transactions require manual confirmation from the party paying the funds, they can only be created and sent to payers via Slatepack. grin-wallet invoice -d grin1dhvv9mvarqwl6fderuxp3qgl6qpphvc9p4u24347ec0mvvg6342q4w6x5r 60 This command will create an encypted (as -d is provided) invoice, requesting a payment of 60 grins. The resulting Slatepack can then be sent to the other party for the to pay . Upon receiving the back the Slatepack from the payer, the transaction can then be finalized and posted using the finalize command.","title":"invoice"},{"location":"getting-started/wallet-handbook/#pay","text":"After receiving an invoice request, the payer can use the pay command to decode (also decrypt if possible) the Slatepack and confirm the amount of coins being requested as payment. grin-wallet pay Please paste your encoded slatepack message: BEGINSLATEPACK. P9rVoTRyKdhVsuC a5SfwQMXbtsDBwD omfeWYWwkbK9AUD k2pZvpgeXmJSUcv y9Mi81ngsCrpW9r QW226CWwbxrSprJ cCJA9cACpguBHDj eExN8vuYc1SHj9B 2Xa1BPGB77kpY9q uG9eXmaeprY6CQt PAibwfMnwxVDJFU EeQfwwSnEUADkg3 wBYXcuSVTnfJ4Jj DnqawMkmAiWvhNm WLrdZ1Vh3P6TXP6 ZgJG9pRNi51mAtU 9soyVAgvFWoEpgn VA6suegVxTsWN1r V3LQHB7bjwX5Rwa yPfqhGTLwR. ENDSLATEPACK. This command will pay the amount specified in the invoice using your wallet's funds. After you confirm, the following will occur: * 10.000000000 of your wallet funds will be added to the transaction to pay this invoice. * The wallet will IMMEDIATELY attempt to send the resulting transaction to the wallet listening at: 'grin1ln4y82fw4urggk3hq0xkeqfhw3dfe6rhcv6a0v64uz4ny9epcc6qpuwx4k'. * If other wallet is not listening, the resulting transaction will output as a slatepack which you can manually send back to the invoice creator. Please review the above information carefully before proceeding To proceed, type the exact amount of the invoice as displayed above (or Q/q to quit) > To confirm the payment, type the exact amount in decimal, as 10.000000000 in this example, into the prompt. Your wallet will then fill out the transaction and return a Slatepack for you to provide back to the initiator, which they can then finalize .","title":"pay"},{"location":"getting-started/wallet-handbook/#unpack","text":"Upon receiving a Slatepack message or file from a party, whether in an encrypted form or not, the unpack command decrypts and decodes it to a bare slate JSON format (the format used by the wallet to read and contruct transactions). grin-wallet unpack This prompts you for a Slatepack message. to decode a file, use the -i flag and provide the path. Result: SLATEPACK CONTENTS ------------------ { ... } ------------------ Slatepack is encrypted for this wallet DECRYPTED SLATEPACK ------------------- { ... } DECRYPTED SLATE --------------- { ... } Command 'unpack' completed successfully","title":"unpack"},{"location":"getting-started/wallet-handbook/#outputs","text":"To show a list of all your wallet's outputs, type: grin-wallet outputs allet Outputs - Account 'default' - Block Height: 814491 --------------------------------------------------------------------------------------------------------------------------------------------------------------- Output Commitment MMR Index Block Height Locked Until Status Coinbase? # Confirms Value Tx =============================================================================================================================================================== 08f4f062b99223d2d8a1ad1ae11085ab2d7b4f1bc603f9c29748f1b918861fdf23 7498573 743936 743936 Unspent false 70556 5198.081029600 1 --------------------------------------------------------------------------------------------------------------------------------------------------------------- 097fe8bf1ad6a792600d5e010d0b77c40b147ea122c176476259f100a48924d40c 7832632 790025 790025 Unspent false 24467 581.392000000 2 --------------------------------------------------------------------------------------------------------------------------------------------------------------- 08645896f150bfc70f36a602a7a5f41180ae8d5db42864f19f7257542cf2c7fc98 None 811501 0 Unspent false 2991 389.859133700 9 --------------------------------------------------------------------------------------------------------------------------------------------------------------- By default, only unspent outputs are listed. To show spent outputs, provide the -s flag. grin-wallet -s outputs","title":"outputs"},{"location":"getting-started/wallet-handbook/#txs","text":"Every time an action is performed in your wallet (send, receive, even if uncompleted), an entry is added to an internal transaction log containing vital information about the transaction. Because the Grin chain contains no identifying information whatsoever, this transaction log is necessary for your wallet to keep track of transactions. To view the contents of your transaction log, use the command: grin-wallet txs Transaction Log - Account 'default' - Block Height: 814448 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Id Type Shared Transaction Id Creation Time TTL Cutoff Height Confirmed? Confirmation Time Num. Num. Amount Amount Fee Net Payment Kernel Tx Inputs Outputs Credited Debited Difference Proof Data ===================================================================================================================================================================================================================================================================================== 0 Received Tx 2b2ffc5e-8fa0-4450-b270-078df29b3e23 2020-07-28 13:18:18 None true 2020-07-28 13:18:18 0 1 389.892 0.0 0.007 389.892 None ddec166399348a24d2893c025b4b4d4a058f81834a663284ba23fe0bd0ac025b4b Yes ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1 Sent Tx fd9b3035-73d0-4ea3-8c3e-5d45c512ad8b 2020-08-03 15:32:19 None true 2020-08-03 15:42:20 2 1 389.8591337 390.8661337 0.007 -1.007 Yes 0834a66310df8a8b43093c025b4b4d4a058f8188ee24d2809e338e0bd0ae9e2c2c Yes ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2 Sent Tx ea92fcce-8fa0-48d0-b270-078df2e22d24 2020-08-04 18:51:47 None false None 1 1 139.8511337 389.8591337 0.008 -250.008 None 09fd95b4e40ce1c2d67376d46dc37ddec1aa0ae50ca9934ba271fff0b47510c72f Yes - Cancelled ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- To see the inputs & outputs associated with a particular transaction, as well as the payment proof associated with the transaction, use the -i switch and specify the id of the transaction, e.g: grin-wallet txs -i 0","title":"txs"},{"location":"getting-started/wallet-handbook/#cancel","text":"Cancels an in-progress created transaction, freeing previously locked outputs for use again. grin-wallet cancel -i 2 To specify which transaction to cancel, use the -i flag along with the tx id (obtained by txs ) or the -t flag with the tx-UUID.","title":"cancel"},{"location":"getting-started/wallet-handbook/#scan","text":"The scan command will scan the entire UTXO-set from the node, identify which outputs are yours and update your wallet state. grin-wallet scan It should not usually be necessary to run the scan command manually, as the wallet continually scans the outputs on the chain. However, if for some reason you believe your outputs and transactions are in an inconsistent state, you can initiate a manual scan to attempt to fix or restore them. You could can also use the -d --delete-unconfirmed flag to cancel any transaction log entries and delete unconfirmed outputs. grin-wallet scan -d this command will also attempt to cancel any transaction log entries associated with any locked outputs and unlock the outputs. Additionally, the h --start-height flag lets specify a block height from which to start a manual scan. When initializing a wallet from an existing seed via the grin-wallet init -r command , this scan is performed automatically on first run.","title":"scan"},{"location":"getting-started/wallet-handbook/#arguments","text":"There are several global wallet arguments which you can provide for every command.","title":"arguments"},{"location":"getting-started/wallet-handbook/#account_1","text":"To set the account for a wallet command, provide the -a argument. grin-wallet -a jedusor info","title":"account"},{"location":"getting-started/wallet-handbook/#password","text":"You could specify your password on the directly command line by providing the -p argument. Please note this will place your password in your shell's command history, so use this switch with caution. grin-wallet -p mypass info","title":"password"},{"location":"getting-started/wallet-handbook/#node","text":"The wallet needs to talk to a running grin node in order to remain up-to-date and verify its contents. By default, it tries to contact a node at 127.0.0.1:3413. To change this, either modify the value in the wallet's grin_wallet.toml file, or alternatively, you can provide the -r (se r ver) switch to wallet commands. grin-wallet -r \"http://192.168.0.2:1341\" info","title":"node"},{"location":"getting-started/quickstart/initialize/","text":"Initializing Node and Wallet Running a Grin Node The rest of the documentation is common for Linux, macOS and Windows. Running a Grin node is as simple as typing the command: grin You should see the following window: Congratulations! \ud83c\udf89 You are now running a Grin full node. The initial sync might take from 30 minutes to a few hours depending on your connection speed and CPU performance. If you have a good Internet connection, you can help strengthen the network by keeping your PC running with a grin node and port 3414 open . All data files will be created at the hidden folder ~/.grin (under your home directory). Inside this folder, of special interest is the file grin-server.toml which can be used to modify configuration options. Creating a Grin Wallet While your node is syncing, let's initalize a new Grin wallet. In the command prompt type the following: grin-wallet init Your wallet will now ask you to create a password. Most wallet commands will require it, so you'll be typing the password quite often. In order to hide it, your keyboard input will not be displayed. Please enter a password for your new wallet Password: Confirm Password: Next, the wallet will show your recovery-phrase: Your recovery phrase is: undo execute festival romance just void custom leopard balcony trick waste castle fire master lecture ordinary million slam wise oil whisper mechanic episode room This phrase is a list of 24 words which encode all the information needed to recover your wallet. If your computer breaks or your hard drive becomes corrupted, you can enter grin-wallet init -r and type the phrase to recover your grins. Store it safely, preferably in a non-digital format.","title":"Initialize"},{"location":"getting-started/quickstart/initialize/#initializing-node-and-wallet","text":"","title":"Initializing Node and Wallet"},{"location":"getting-started/quickstart/initialize/#running-a-grin-node","text":"The rest of the documentation is common for Linux, macOS and Windows. Running a Grin node is as simple as typing the command: grin You should see the following window: Congratulations! \ud83c\udf89 You are now running a Grin full node. The initial sync might take from 30 minutes to a few hours depending on your connection speed and CPU performance. If you have a good Internet connection, you can help strengthen the network by keeping your PC running with a grin node and port 3414 open . All data files will be created at the hidden folder ~/.grin (under your home directory). Inside this folder, of special interest is the file grin-server.toml which can be used to modify configuration options.","title":"Running a Grin Node"},{"location":"getting-started/quickstart/initialize/#creating-a-grin-wallet","text":"While your node is syncing, let's initalize a new Grin wallet. In the command prompt type the following: grin-wallet init Your wallet will now ask you to create a password. Most wallet commands will require it, so you'll be typing the password quite often. In order to hide it, your keyboard input will not be displayed. Please enter a password for your new wallet Password: Confirm Password: Next, the wallet will show your recovery-phrase: Your recovery phrase is: undo execute festival romance just void custom leopard balcony trick waste castle fire master lecture ordinary million slam wise oil whisper mechanic episode room This phrase is a list of 24 words which encode all the information needed to recover your wallet. If your computer breaks or your hard drive becomes corrupted, you can enter grin-wallet init -r and type the phrase to recover your grins. Store it safely, preferably in a non-digital format.","title":"Creating a Grin Wallet"},{"location":"getting-started/quickstart/install/","text":"Install GUI Wallet To use Grin with a graphical user interface, see community wallets . The Quickstart series will guide you in your first steps of installing a Grin node, creating a wallet, and making a transaction. We begin by downloading the precompiled binaries. grin - the Grin node. grin-wallet - the command-line wallet. First, choose your operating system: Linux macOS Windows Linux Go to grin.mw/download and download the tgz files of grin and grin-wallet by clicking on their name titles. Verify Release Type the following commands and compare the results against the respective SHA256 HASH displayed on the website. sha256sum grin-wallet- $VERSION -linux-amd64.tar.gz sha256sum grin- $VERSION -linux-amd64.tar.gz Replace $VESION with the appropriate version for each binary, e.g. v4.0.2 Next, in the terminal, navigate to the directory where the files were downloaded and type: sudo tar -C /usr/local/bin -xzf grin- $VERSION -linux-amd64.tar.gz --strip-components = 1 sudo tar -C /usr/local/bin -xzf grin-wallet- $VERSION -linux-amd64.tar.gz --strip-components = 1 libncursesw error \u21b4 If you have the following error when you start grin: grin: error while loading shared libraries: libncursesw.so.5: cannot open shared object file: No such file or directory Then install libncursesw5 : sudo apt install libncursesw5 And you're done! Snap Store You can also install everything as Snap package , however, note that you can't verify its content. To install, type: snap install grin When installed with Snap, grin-wallet is accessible using the grin.wallet command instead of grin-wallet . macOS The easiest way to install grin and grin-wallet on macOS is with homebrew . If you do not have homebrew installed, open the \"Terminal.app\" and paste the following line: /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \" This will install homebrew on your computer. Once it's finished, you can simply install the binaries: brew install grin grin-wallet Windows Go to grin.mw/download and download the zip files of grin and grin-wallet by clicking on their name titles. We recommend that you create a directory called Grin in C:\\Users\\%USER%\\AppData\\Local . The parent directory is where most user windows apps are installed, but if you want to put them somewhere else, that'll work too. In this directory, extract both binaries grin.exe and grin-wallet.exe . Then, add them to your path by typing in the terminal: set PATH=%PATH%;C:\\Users\\%USER%\\AppData\\Local Remember to replace %USER% That's it, you're done!","title":"Install"},{"location":"getting-started/quickstart/install/#install","text":"GUI Wallet To use Grin with a graphical user interface, see community wallets . The Quickstart series will guide you in your first steps of installing a Grin node, creating a wallet, and making a transaction. We begin by downloading the precompiled binaries. grin - the Grin node. grin-wallet - the command-line wallet. First, choose your operating system: Linux macOS Windows","title":"Install"},{"location":"getting-started/quickstart/install/#linux","text":"Go to grin.mw/download and download the tgz files of grin and grin-wallet by clicking on their name titles. Verify Release Type the following commands and compare the results against the respective SHA256 HASH displayed on the website. sha256sum grin-wallet- $VERSION -linux-amd64.tar.gz sha256sum grin- $VERSION -linux-amd64.tar.gz Replace $VESION with the appropriate version for each binary, e.g. v4.0.2 Next, in the terminal, navigate to the directory where the files were downloaded and type: sudo tar -C /usr/local/bin -xzf grin- $VERSION -linux-amd64.tar.gz --strip-components = 1 sudo tar -C /usr/local/bin -xzf grin-wallet- $VERSION -linux-amd64.tar.gz --strip-components = 1 libncursesw error \u21b4 If you have the following error when you start grin: grin: error while loading shared libraries: libncursesw.so.5: cannot open shared object file: No such file or directory Then install libncursesw5 : sudo apt install libncursesw5 And you're done!","title":"Linux"},{"location":"getting-started/quickstart/install/#snap-store","text":"You can also install everything as Snap package , however, note that you can't verify its content. To install, type: snap install grin When installed with Snap, grin-wallet is accessible using the grin.wallet command instead of grin-wallet .","title":"Snap Store"},{"location":"getting-started/quickstart/install/#macos","text":"The easiest way to install grin and grin-wallet on macOS is with homebrew . If you do not have homebrew installed, open the \"Terminal.app\" and paste the following line: /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \" This will install homebrew on your computer. Once it's finished, you can simply install the binaries: brew install grin grin-wallet","title":"macOS"},{"location":"getting-started/quickstart/install/#windows","text":"Go to grin.mw/download and download the zip files of grin and grin-wallet by clicking on their name titles. We recommend that you create a directory called Grin in C:\\Users\\%USER%\\AppData\\Local . The parent directory is where most user windows apps are installed, but if you want to put them somewhere else, that'll work too. In this directory, extract both binaries grin.exe and grin-wallet.exe . Then, add them to your path by typing in the terminal: set PATH=%PATH%;C:\\Users\\%USER%\\AppData\\Local Remember to replace %USER% That's it, you're done!","title":"Windows"},{"location":"getting-started/quickstart/receive/","text":"Receiving Grins Let's see how you can receive your first grins. Interactive Transactions The nature of Mimblewimble protocol means that the sender & receiver need to interact with one another, in some way or another, in order to form transactions . The first step is to generate an address: grin-wallet address Your address will look like this: grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 Give it to the sender. To understand what comes next, you should know there are two primary ways to interact with the other party: Tor and Slatepack . A Tor connection is attempted first, but if it isn't accessible (counterparty offline, or either party doesn't have Tor service installed), then Slatepack method is automatically chosen. Tor All you need to do is type: grin-wallet listen Done! This sets up your wallet to listen for incoming connections through Tor. Just let the sender know that your wallet is ready. You can type grin-wallet info to check your wallet balance. Slatepack Slatepacks are encoded text messages used to transfer the data required to form a transaction, and are an alternative to a hands-off method such as Tor. The messages are easily copy-pasted and can be transferred in any communication channel imaginable: email, forum, social media, chat, letter, carrier pigeon etc. The text you receive from the sender should look like this: BEGINSLATEPACK. HctgNGXrJDGFY3B KrEF1meAezGjxQ6 Z93QF6Ps2m9yKCQ LfhZvpDY9ZXViM7 nDoNeMvwtYV2crr 8gDqvYDmtRfLL3n Uabao7VyWR4AuYg TXQUSWU83kEhKmr bRtdRjvpisx1LYo 9cyZGfsgsd7ZvDJ KKZPHhcPe4Eivtv cMvee3nwFFY3ZnM SoULNaHVJ38h3tZ vMXQMoMLB17L53o Xy6QQjDaG8avUBt LQq2GfGRTiUPQgn vQwFzfZPVzVKNLk 5AFmUQFZtiVdTJV xHvc1BuAqcamerv Y76KVccPY3WGupy 4zWFpkjTH65XNiH XqQnkb3EA1iVrHc tyTJ1PWb6X6oV1k ktYiWBpatyTirRy CywPyjr6c8XLr4Q 9VoCedU5BcdFdMB ACqQTwjgVXqjHoS 58ZPKFitjeH67Ts ah6twcKtMaFmTXD i7JEQ7qV6cewgxH 2jwWFxbb98mye6A Lm9movc6Wer26L2 91WQD3cbVpAZLEs APFPtyxnWjv8n3W ZXFLR2TPZwGc5Vt zwFUPoyWfKXasQy VVV6tbKWEEhqAZR e34M7uEwfurpUUi 9812VFPY1qw3K9b ynwQXuXMuWQCUnU s1JqWqFgSQKENUP tGCK19dys9twghA FaAc7ZXQHdMbUoL sVxVfdjE94F1Wpj M7QAM5VZuaauHdQ Mt2erFyxJ5vsYSZ hgS553UKoQL5YWX E7oRNdMDkJV6VkL i55kAQc1vWvW9ce 3MoXiBT4TJ1SyNS NVZKxgk8c. ENDSLATEPACK. Your next step would be to type: grin-wallet receive Then enter the message you were sent into the prompt. Next, your own wallet will output a beautiful Slatepack message as well: Copy and send it to the other party, and that's it, you've completed your role! It's now in the hands of the sender to finalize and post the transaction to the network. You can tell when it's accepted by the chain by typing grin-wallet info and seeing if there's an amount waiting for confirmation.","title":"Receive"},{"location":"getting-started/quickstart/receive/#receiving-grins","text":"Let's see how you can receive your first grins. Interactive Transactions The nature of Mimblewimble protocol means that the sender & receiver need to interact with one another, in some way or another, in order to form transactions . The first step is to generate an address: grin-wallet address Your address will look like this: grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 Give it to the sender. To understand what comes next, you should know there are two primary ways to interact with the other party: Tor and Slatepack . A Tor connection is attempted first, but if it isn't accessible (counterparty offline, or either party doesn't have Tor service installed), then Slatepack method is automatically chosen.","title":"Receiving Grins"},{"location":"getting-started/quickstart/receive/#tor","text":"All you need to do is type: grin-wallet listen Done! This sets up your wallet to listen for incoming connections through Tor. Just let the sender know that your wallet is ready. You can type grin-wallet info to check your wallet balance.","title":"Tor"},{"location":"getting-started/quickstart/receive/#slatepack","text":"Slatepacks are encoded text messages used to transfer the data required to form a transaction, and are an alternative to a hands-off method such as Tor. The messages are easily copy-pasted and can be transferred in any communication channel imaginable: email, forum, social media, chat, letter, carrier pigeon etc. The text you receive from the sender should look like this: BEGINSLATEPACK. HctgNGXrJDGFY3B KrEF1meAezGjxQ6 Z93QF6Ps2m9yKCQ LfhZvpDY9ZXViM7 nDoNeMvwtYV2crr 8gDqvYDmtRfLL3n Uabao7VyWR4AuYg TXQUSWU83kEhKmr bRtdRjvpisx1LYo 9cyZGfsgsd7ZvDJ KKZPHhcPe4Eivtv cMvee3nwFFY3ZnM SoULNaHVJ38h3tZ vMXQMoMLB17L53o Xy6QQjDaG8avUBt LQq2GfGRTiUPQgn vQwFzfZPVzVKNLk 5AFmUQFZtiVdTJV xHvc1BuAqcamerv Y76KVccPY3WGupy 4zWFpkjTH65XNiH XqQnkb3EA1iVrHc tyTJ1PWb6X6oV1k ktYiWBpatyTirRy CywPyjr6c8XLr4Q 9VoCedU5BcdFdMB ACqQTwjgVXqjHoS 58ZPKFitjeH67Ts ah6twcKtMaFmTXD i7JEQ7qV6cewgxH 2jwWFxbb98mye6A Lm9movc6Wer26L2 91WQD3cbVpAZLEs APFPtyxnWjv8n3W ZXFLR2TPZwGc5Vt zwFUPoyWfKXasQy VVV6tbKWEEhqAZR e34M7uEwfurpUUi 9812VFPY1qw3K9b ynwQXuXMuWQCUnU s1JqWqFgSQKENUP tGCK19dys9twghA FaAc7ZXQHdMbUoL sVxVfdjE94F1Wpj M7QAM5VZuaauHdQ Mt2erFyxJ5vsYSZ hgS553UKoQL5YWX E7oRNdMDkJV6VkL i55kAQc1vWvW9ce 3MoXiBT4TJ1SyNS NVZKxgk8c. ENDSLATEPACK. Your next step would be to type: grin-wallet receive Then enter the message you were sent into the prompt. Next, your own wallet will output a beautiful Slatepack message as well: Copy and send it to the other party, and that's it, you've completed your role! It's now in the hands of the sender to finalize and post the transaction to the network. You can tell when it's accepted by the chain by typing grin-wallet info and seeing if there's an amount waiting for confirmation.","title":"Slatepack"},{"location":"getting-started/quickstart/send/","text":"Sending Grins To send grins, use the send command, and specify both the destination address ( -d ) and the amount. grin-wallet send -d [ address ] [ amount ] Example of sending 90 grins: grin-wallet send -d grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 90 Locked Outputs From now on and until confirmed in the chain, the outputs used in this transcation are locked . The wallets will interact through Tor and complete the process automatically. However, If the connection wasn't successful, your wallet will output a Slatepack message which you need to provide the receiver with. The receiver then uses the receive command to process it (as demonstrated earlier), and returns back to you a Slatepack he produced himself. Simply type the following command: grin-wallet finalize And enter into the prompt the last Slatepack message you were sent. Your wallet will complete the transaction building process and post it to the network, along with a fee, to be included in an upcoming block. Celebrate this milestone with an unapologizing smile \u30c4","title":"Send"},{"location":"getting-started/quickstart/send/#sending-grins","text":"To send grins, use the send command, and specify both the destination address ( -d ) and the amount. grin-wallet send -d [ address ] [ amount ] Example of sending 90 grins: grin-wallet send -d grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 90 Locked Outputs From now on and until confirmed in the chain, the outputs used in this transcation are locked . The wallets will interact through Tor and complete the process automatically. However, If the connection wasn't successful, your wallet will output a Slatepack message which you need to provide the receiver with. The receiver then uses the receive command to process it (as demonstrated earlier), and returns back to you a Slatepack he produced himself. Simply type the following command: grin-wallet finalize And enter into the prompt the last Slatepack message you were sent. Your wallet will complete the transaction building process and post it to the network, along with a fee, to be included in an upcoming block. Celebrate this milestone with an unapologizing smile \u30c4","title":"Sending Grins"},{"location":"wiki/archives/","text":"Archives Docs Talks Mimblewimble, Scaling Bitcoin'16 Mimblewimble, SF Bitcoin Developers`16 Mimblewimble, BPASE'17 Mimblewimble & Scriptless Scripts, RWC'18 A View on Grin, HCPP'19 , Slides Conference Playlists grincon0 grinconUS(0) grinAmsterdam grincon1 Podcasts [Bitcoin Wednesday] Introducing Mimblewimble and Grin @jaspervdm [Unchained] Grin: A More Private, Lighter Bitcoin @lehnberg @yeastplume [The Crypto Show] Mimblewimble with Andrew Poelstra and Peter Wuillie [What Bitcoin Did] Grin's Mimblewimble Implementation @yeastplume [Zero Knowledge] Grin @lehnberg [Captain Crypto Show] Grin @yeastplume [Let's Talk Bitcoin] Privacy with Mimblewimble @yeastplume @andreas @adam.b.levine Forum How to store Grin in cold storage? Coinbase outputs as regular outputs Use of NRD kernels in payment channels Emission Rate Thread , #2 , #3 Transaction Aggregation TX Graph Confidentality Response to Reavealing TX Graph Some Thoughts on Privacy Scheduled PoW upgrades proposal Choice of ASIC Resistant PoW for GPU miners Put later phase-outs on hold proposal All about C31 fade out, the C29 scale and C32 Genesis block message Queries about transaction aggregation Aggregate merkle proofs Sending a transaction to more parties than originally intended Reasoning behind block weight limit Hardforks on Grin v5.0.0 and beyond Play attacks and possible mitigations Replay attacks and possible mitigations Grin transactions user interactivity Eliminate finalize step On Igno's absence Being ASIC resistant or not Is there a potential hidden inflation problem Eliminating finalize step Pep talk for one sided transactions Medium Grin's Mythical Fair Launch Grin Money Explained Grin Transactions Explained, Step-by-Step What\u2019s inside a Grin Transaction File? Breaking Mimblewimble\u2019s Privacy Model Factual inaccuracies of \u201cBreaking Mimblewimble\u2019s Privacy Model\u201d General [Launchpad] Mimblewimble Mailing List Archive [Reddit] Mimblewimble introduced to r/bitcoin [Youtube] Aantonop Bitcoin Q&A: Mimblewimble and Dandelion [Coindesk] Harry Potter Characters Join Mimblewimble 2016 [Github] Meeting Notes [Github] Run a Grin node on Google cloud for free [Github] Automating and running Grin as a service RFCs [Github] All Accepted RFCs [Github] All Pending RFCs Privacy [Reddit] On Grin's Privacy Scripts [Launchpad] Scripting observations and Lightning Network implementation Proof of Work [GitHub] Fees in Mining [GitHub] Grin difficulty, C29, C31 fade out and C32 Security [Google] Replay Attacks Summary API [Forum] Postman Collection of Grin Node API Papers Confidential Assets OWAS Bulletproofs Cuckoo Cycle","title":"Archives"},{"location":"wiki/archives/#archives","text":"","title":"Archives"},{"location":"wiki/archives/#docs","text":"","title":"Docs"},{"location":"wiki/archives/#talks","text":"Mimblewimble, Scaling Bitcoin'16 Mimblewimble, SF Bitcoin Developers`16 Mimblewimble, BPASE'17 Mimblewimble & Scriptless Scripts, RWC'18 A View on Grin, HCPP'19 , Slides","title":"Talks"},{"location":"wiki/archives/#conference-playlists","text":"grincon0 grinconUS(0) grinAmsterdam grincon1","title":"Conference Playlists"},{"location":"wiki/archives/#podcasts","text":"[Bitcoin Wednesday] Introducing Mimblewimble and Grin @jaspervdm [Unchained] Grin: A More Private, Lighter Bitcoin @lehnberg @yeastplume [The Crypto Show] Mimblewimble with Andrew Poelstra and Peter Wuillie [What Bitcoin Did] Grin's Mimblewimble Implementation @yeastplume [Zero Knowledge] Grin @lehnberg [Captain Crypto Show] Grin @yeastplume [Let's Talk Bitcoin] Privacy with Mimblewimble @yeastplume @andreas @adam.b.levine","title":"Podcasts"},{"location":"wiki/archives/#forum","text":"How to store Grin in cold storage? Coinbase outputs as regular outputs Use of NRD kernels in payment channels Emission Rate Thread , #2 , #3 Transaction Aggregation TX Graph Confidentality Response to Reavealing TX Graph Some Thoughts on Privacy Scheduled PoW upgrades proposal Choice of ASIC Resistant PoW for GPU miners Put later phase-outs on hold proposal All about C31 fade out, the C29 scale and C32 Genesis block message Queries about transaction aggregation Aggregate merkle proofs Sending a transaction to more parties than originally intended Reasoning behind block weight limit Hardforks on Grin v5.0.0 and beyond Play attacks and possible mitigations Replay attacks and possible mitigations Grin transactions user interactivity Eliminate finalize step On Igno's absence Being ASIC resistant or not Is there a potential hidden inflation problem Eliminating finalize step Pep talk for one sided transactions","title":"Forum"},{"location":"wiki/archives/#medium","text":"Grin's Mythical Fair Launch Grin Money Explained Grin Transactions Explained, Step-by-Step What\u2019s inside a Grin Transaction File? Breaking Mimblewimble\u2019s Privacy Model Factual inaccuracies of \u201cBreaking Mimblewimble\u2019s Privacy Model\u201d","title":"Medium"},{"location":"wiki/archives/#general","text":"[Launchpad] Mimblewimble Mailing List Archive [Reddit] Mimblewimble introduced to r/bitcoin [Youtube] Aantonop Bitcoin Q&A: Mimblewimble and Dandelion [Coindesk] Harry Potter Characters Join Mimblewimble 2016 [Github] Meeting Notes [Github] Run a Grin node on Google cloud for free [Github] Automating and running Grin as a service","title":"General"},{"location":"wiki/archives/#rfcs","text":"[Github] All Accepted RFCs [Github] All Pending RFCs","title":"RFCs"},{"location":"wiki/archives/#privacy","text":"[Reddit] On Grin's Privacy","title":"Privacy"},{"location":"wiki/archives/#scripts","text":"[Launchpad] Scripting observations and Lightning Network implementation","title":"Scripts"},{"location":"wiki/archives/#proof-of-work","text":"[GitHub] Fees in Mining [GitHub] Grin difficulty, C29, C31 fade out and C32","title":"Proof of Work"},{"location":"wiki/archives/#security","text":"[Google] Replay Attacks Summary","title":"Security"},{"location":"wiki/archives/#api","text":"[Forum] Postman Collection of Grin Node API","title":"API"},{"location":"wiki/archives/#papers","text":"Confidential Assets OWAS Bulletproofs Cuckoo Cycle","title":"Papers"},{"location":"wiki/table-of-contents/","text":"Table of Contents This wiki contains an high level technical overview of Grin. For more details about the implentation, please look at the Grin documentation on docs.rs grin: api , core , chain , util , store , keychain , p2p , pool , config , servers . grin_wallet: wallet_api , wallet . Introduction Grin for Bitcoiners - Explaining Grin from a Bitcoiner's perspective Mimblewimble - A technical introduction to Mimblewimble Elliptic Curves Commitments Mimblewimble Transactions Slates Slatepack Payment Proofs Contracts Blocks Header Body Fees & Weight Chain State Merkle Mountain Ranges State & Pruning Chain Sync Miscellaneous Cuckoo Cycle Dandelion Switch Commitments Coinbase Maturity Rule NRD Kernels API Node API Stratum RPC Security Process Grin's Security Process Security Team Code Audits Services Slatepack Integration Guide List of Services More Archives","title":"Table of Contents"},{"location":"wiki/table-of-contents/#table-of-contents","text":"This wiki contains an high level technical overview of Grin. For more details about the implentation, please look at the Grin documentation on docs.rs grin: api , core , chain , util , store , keychain , p2p , pool , config , servers . grin_wallet: wallet_api , wallet .","title":"Table of Contents"},{"location":"wiki/table-of-contents/#introduction","text":"Grin for Bitcoiners - Explaining Grin from a Bitcoiner's perspective Mimblewimble - A technical introduction to Mimblewimble Elliptic Curves Commitments Mimblewimble","title":"Introduction"},{"location":"wiki/table-of-contents/#transactions","text":"Slates Slatepack Payment Proofs Contracts","title":"Transactions"},{"location":"wiki/table-of-contents/#blocks","text":"Header Body Fees & Weight","title":"Blocks"},{"location":"wiki/table-of-contents/#chain-state","text":"Merkle Mountain Ranges State & Pruning Chain Sync","title":"Chain State"},{"location":"wiki/table-of-contents/#miscellaneous","text":"Cuckoo Cycle Dandelion Switch Commitments Coinbase Maturity Rule NRD Kernels","title":"Miscellaneous"},{"location":"wiki/table-of-contents/#api","text":"Node API Stratum RPC","title":"API"},{"location":"wiki/table-of-contents/#security-process","text":"Grin's Security Process Security Team Code Audits","title":"Security Process"},{"location":"wiki/table-of-contents/#services","text":"Slatepack Integration Guide List of Services","title":"Services"},{"location":"wiki/table-of-contents/#more","text":"Archives","title":"More"},{"location":"wiki/api/node-api/","text":"Node API The API is Used to query a node about various information on the blockchain, networks and peers. By default, the API will listen on localhost:3413 . The API is started as the same time as the Grin node. This endpoint requires, by default, Basic Authentication . The username is grin . Node API v2 This API version uses jsonrpc for its requests. It is split up in a foreign API and an owner API. The documentation for these endpoints is automatically generated: Owner API Foreign API Basic auth passwords can be found in .api_secret / .foreign_api_secret files respectively. A complete Postman collection for the Grin Node API can be found here . Node API v1 Note: version 1 of the API will be deprecated in v4.0.0 and subsequently removed in v5.0.0. Users of this API are encouraged to upgrade to API v2. This API uses REST for its requests. To learn about what specific calls can be made read the node API v1 doc . Basic auth password can be found in .api_secret","title":"Node API"},{"location":"wiki/api/node-api/#node-api","text":"The API is Used to query a node about various information on the blockchain, networks and peers. By default, the API will listen on localhost:3413 . The API is started as the same time as the Grin node. This endpoint requires, by default, Basic Authentication . The username is grin .","title":"Node API"},{"location":"wiki/api/node-api/#node-api-v2","text":"This API version uses jsonrpc for its requests. It is split up in a foreign API and an owner API. The documentation for these endpoints is automatically generated: Owner API Foreign API Basic auth passwords can be found in .api_secret / .foreign_api_secret files respectively. A complete Postman collection for the Grin Node API can be found here .","title":"Node API v2"},{"location":"wiki/api/node-api/#node-api-v1","text":"Note: version 1 of the API will be deprecated in v4.0.0 and subsequently removed in v5.0.0. Users of this API are encouraged to upgrade to API v2. This API uses REST for its requests. To learn about what specific calls can be made read the node API v1 doc . Basic auth password can be found in .api_secret","title":"Node API v1"},{"location":"wiki/api/stratum-rpc/","text":"Stratum RPC Protocol Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . This document describes the current Stratum RPC protocol implemented in Grin. Messages In this section, we detail each message and the potential response. getjobtemplate A message initiated by the miner. Miner can request a job with this message. Request Field Content id ID of the request jsonrpc \"2.0\" method \"getjobtemplate\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"params\" : null } The response can be of two types: OK response Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"result\" :{ \"difficulty\" : 1 , \"height\" : 13726 , \"job_id\" : 4 , \"pre_pow\" : \"00010000000000003c4d0171369781424b39c81eb39de10cdf4a7cc27bbc6769203c7c9bc02cc6a1dfc6000000005b50f8210000000000395f123c6856055aab2369fe325c3d709b129dee5c96f2db60cdbc0dc123a80cb0b89e883ae2614f8dbd169888a95c0513b1ac7e069de82e5d479cf838281f7838b4bf75ea7c9222a1ad7406a4cab29af4e018c402f70dc8e9ef3d085169391c78741c656ec0f11f62d41b463c82737970afaa431c5cabb9b759cdfa52d761ac451276084366d1ba9efff2db9ed07eec1bcd8da352b32227f452dfa987ad249f689d9780000000000000b9e00000000000009954\" } } Error response If the node is syncing, it will send the following message: Field Content id ID of the request jsonrpc \"2.0\" method \"getjobtemplate\" error Example: { \"id\" : \"10\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"error\" :{ \"code\" : -32000 , \"message\" : \"Node is syncing - Please wait\" } } job A message initiated by the Stratum server. Stratum server will send job automatically to connected miners. The miner SHOULD interrupt current job if job_id = 0, and SHOULD replace the current job with this one after the current graph is complete. Request Field Content id ID of the request jsonrpc \"2.0\" method \"job\" params Int difficulty , height , job_id and string pre_pow Example: { \"id\" : \"Stratum\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"job\" , \"params\" :{ \"difficulty\" : 1 , \"height\" : 16375 , \"job_id\" : 5 , \"pre_pow\" : \"00010000000000003ff723bc8c987b0c594794a0487e52260c5343288749c7e288de95a80afa558c5fb8000000005b51f15f00000000003cadef6a45edf92d2520bf45cbd4f36b5ef283c53d8266bbe9aa1b8daaa1458ce5578fcb0978b3995dd00e3bfc5a9277190bb9407a30d66aec26ff55a2b50214b22cdc1f3894f27374f568b2fe94d857b6b3808124888dd5eff7e8de7e451ac805a4ebd6551fa7a529a1b9f35f761719ed41bfef6ab081defc45a64a374dfd8321feac083741f29207b044071d93904986fa322df610e210c543c2f95522c9bdaef5f598000000000000c184000000000000a0cf\" } } Response No response is required for this message. keepalive A message initiated by the miner in order to keep the connection alive. Request Field Content id ID of the request jsonrpc \"2.0\" method \"keepalive\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"keepalive\" , \"params\" : null } Response Field Content id ID of the request jsonrpc \"2.0\" method \"keepalive\" result \"ok\" error null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"keepalive\" , \"result\" : \"ok\" , \"error\" : null } login A message initiated by the miner. Miner can log in on a Grin Stratum server with a login, password and agent (usually statically set by the miner program). Request Field Content id ID of the request jsonrpc \"2.0\" method \"login\" params Strings: login, pass and agent Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"login\" , \"params\" :{ \"login\" : \"login\" , \"pass\" : \"password\" , \"agent\" : \"grin-miner\" } } The response can be of two types: OK response Field Content id ID of the request jsonrpc \"2.0\" method \"login\" result \"ok\" error null Example: { \"id\" : \"1\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"login\" , \"result\" : \"ok\" , \"error\" : null } Error response Not yet implemented. Should return error -32500 \"Login first\" when login is required. status A message initiated by the miner. This message allows a miner to get the status of its current worker and the network. Request Field Content id ID of the request jsonrpc \"2.0\" method \"status\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"status\" , \"params\" : null } Response The response is the following: Field Content id ID of the request jsonrpc \"2.0\" method \"status\" result String id . Integers height , difficulty , accepted , rejected and stale error null Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"status\" , \"result\" :{ \"id\" : \"5\" , \"height\" : 13726 , \"difficulty\" : 1 , \"accepted\" : 0 , \"rejected\" : 0 , \"stale\" : 0 }, \"error\" : null } submit A message initiated by the miner. When a miner find a share, it will submit it to the node. Request The miner submit a solution to a job to the Stratum server. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" params Int edge_bits , nonce , height , job_id and array of integers pow Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"params\" :{ \"edge_bits\" : 29 , \"height\" : 16419 , \"job_id\" : 0 , \"nonce\" : 8895699060858340771 , \"pow\" :[ 4210040 , 10141596 , 13269632 , 24291934 , 28079062 , 84254573 , 84493890 , 100560174 , 100657333 , 120128285 , 130518226 , 140371663 , 142109188 , 159800646 , 163323737 , 171019100 , 176840047 , 191220010 , 192245584 , 198941444 , 209276164 , 216952635 , 217795152 , 225662613 , 230166736 , 231315079 , 248639876 , 263910393 , 293995691 , 298361937 , 326412694 , 330363619 , 414572127 , 424798984 , 426489226 , 466671748 , 466924466 , 490048497 , 495035248 , 496623057 , 502828197 , 532838434 ] } } The response can be of three types. OK response The share is accepted by the Stratum but is not a valid cuck(at)oo solution at the network target difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" result \"ok\" error null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"result\" : \"ok\" , \"error\" : null } Blockfound response The share is accepted by the Stratum and is a valid cuck(at)oo solution at the network target difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" result \"block - \" + hash of the block error null Example: { \"id\" : \"6\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"result\" : \"blockfound - 23025af9032de812d15228121d5e4b0e977d30ad8036ab07131104787b9dcf10\" , \"error\" : null } Error response The error response can be of two types: stale and rejected. Stale share error response The share is a valid solution to a previous job not the current one. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32503 , \"message\" : \"Solution submitted too late\" } } Rejected share error responses Two possibilities: the solution cannot be validated or the solution is of too low difficulty. Failed to validate solution error The submitted solution cannot be validated. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32502 , \"message\" : \"Failed to validate solution\" } } Share rejected due to low difficulty error The submitted solution is of too low difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32501 , \"message\" : \"Share rejected due to low difficulty\" } } Error Messages Grin Stratum protocol implementation contains the following error message: Error code Error Message -32000 Node is syncing - please wait -32500 Login first -32501 Share rejected due to low difficulty -32502 Failed to validate solution -32503 Solution Submitted too late -32600 Invalid Request -32601 Method not found Miner behavior Miners SHOULD, MAY or MUST respect the following rules: Miners SHOULD randomize the job nonce before starting Miners MUST continue mining the same job until the server sends a new one, though a miner MAY request a new job at any time Miners MUST NOT send an rpc response to a job request from the server Miners MAY set the RPC \"id\" and expect responses to have that same id Miners MAY send a keepalive message Miners MAY send a login request (to identify which miner finds shares / solutions in the logs), the login request MUST have all 3 params. Miners MUST return the supplied job_id with submit messages. Reference Implementation The current reference implementation is available at mimblewimble/grin-miner .","title":"Stratum RPC"},{"location":"wiki/api/stratum-rpc/#stratum-rpc-protocol","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . This document describes the current Stratum RPC protocol implemented in Grin.","title":"Stratum RPC Protocol"},{"location":"wiki/api/stratum-rpc/#messages","text":"In this section, we detail each message and the potential response.","title":"Messages"},{"location":"wiki/api/stratum-rpc/#getjobtemplate","text":"A message initiated by the miner. Miner can request a job with this message.","title":"getjobtemplate"},{"location":"wiki/api/stratum-rpc/#request","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"getjobtemplate\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"params\" : null } The response can be of two types:","title":"Request"},{"location":"wiki/api/stratum-rpc/#ok-response","text":"Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"result\" :{ \"difficulty\" : 1 , \"height\" : 13726 , \"job_id\" : 4 , \"pre_pow\" : \"00010000000000003c4d0171369781424b39c81eb39de10cdf4a7cc27bbc6769203c7c9bc02cc6a1dfc6000000005b50f8210000000000395f123c6856055aab2369fe325c3d709b129dee5c96f2db60cdbc0dc123a80cb0b89e883ae2614f8dbd169888a95c0513b1ac7e069de82e5d479cf838281f7838b4bf75ea7c9222a1ad7406a4cab29af4e018c402f70dc8e9ef3d085169391c78741c656ec0f11f62d41b463c82737970afaa431c5cabb9b759cdfa52d761ac451276084366d1ba9efff2db9ed07eec1bcd8da352b32227f452dfa987ad249f689d9780000000000000b9e00000000000009954\" } }","title":"OK response"},{"location":"wiki/api/stratum-rpc/#error-response","text":"If the node is syncing, it will send the following message: Field Content id ID of the request jsonrpc \"2.0\" method \"getjobtemplate\" error Example: { \"id\" : \"10\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"getjobtemplate\" , \"error\" :{ \"code\" : -32000 , \"message\" : \"Node is syncing - Please wait\" } }","title":"Error response"},{"location":"wiki/api/stratum-rpc/#job","text":"A message initiated by the Stratum server. Stratum server will send job automatically to connected miners. The miner SHOULD interrupt current job if job_id = 0, and SHOULD replace the current job with this one after the current graph is complete.","title":"job"},{"location":"wiki/api/stratum-rpc/#request_1","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"job\" params Int difficulty , height , job_id and string pre_pow Example: { \"id\" : \"Stratum\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"job\" , \"params\" :{ \"difficulty\" : 1 , \"height\" : 16375 , \"job_id\" : 5 , \"pre_pow\" : \"00010000000000003ff723bc8c987b0c594794a0487e52260c5343288749c7e288de95a80afa558c5fb8000000005b51f15f00000000003cadef6a45edf92d2520bf45cbd4f36b5ef283c53d8266bbe9aa1b8daaa1458ce5578fcb0978b3995dd00e3bfc5a9277190bb9407a30d66aec26ff55a2b50214b22cdc1f3894f27374f568b2fe94d857b6b3808124888dd5eff7e8de7e451ac805a4ebd6551fa7a529a1b9f35f761719ed41bfef6ab081defc45a64a374dfd8321feac083741f29207b044071d93904986fa322df610e210c543c2f95522c9bdaef5f598000000000000c184000000000000a0cf\" } }","title":"Request"},{"location":"wiki/api/stratum-rpc/#response","text":"No response is required for this message.","title":"Response"},{"location":"wiki/api/stratum-rpc/#keepalive","text":"A message initiated by the miner in order to keep the connection alive.","title":"keepalive"},{"location":"wiki/api/stratum-rpc/#request_2","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"keepalive\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"keepalive\" , \"params\" : null }","title":"Request"},{"location":"wiki/api/stratum-rpc/#response_1","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"keepalive\" result \"ok\" error null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"keepalive\" , \"result\" : \"ok\" , \"error\" : null }","title":"Response"},{"location":"wiki/api/stratum-rpc/#login","text":"A message initiated by the miner. Miner can log in on a Grin Stratum server with a login, password and agent (usually statically set by the miner program).","title":"login"},{"location":"wiki/api/stratum-rpc/#request_3","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"login\" params Strings: login, pass and agent Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"login\" , \"params\" :{ \"login\" : \"login\" , \"pass\" : \"password\" , \"agent\" : \"grin-miner\" } } The response can be of two types:","title":"Request"},{"location":"wiki/api/stratum-rpc/#ok-response_1","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"login\" result \"ok\" error null Example: { \"id\" : \"1\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"login\" , \"result\" : \"ok\" , \"error\" : null }","title":"OK response"},{"location":"wiki/api/stratum-rpc/#error-response_1","text":"Not yet implemented. Should return error -32500 \"Login first\" when login is required.","title":"Error response"},{"location":"wiki/api/stratum-rpc/#status","text":"A message initiated by the miner. This message allows a miner to get the status of its current worker and the network.","title":"status"},{"location":"wiki/api/stratum-rpc/#request_4","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"status\" params null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"status\" , \"params\" : null }","title":"Request"},{"location":"wiki/api/stratum-rpc/#response_2","text":"The response is the following: Field Content id ID of the request jsonrpc \"2.0\" method \"status\" result String id . Integers height , difficulty , accepted , rejected and stale error null Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"status\" , \"result\" :{ \"id\" : \"5\" , \"height\" : 13726 , \"difficulty\" : 1 , \"accepted\" : 0 , \"rejected\" : 0 , \"stale\" : 0 }, \"error\" : null }","title":"Response"},{"location":"wiki/api/stratum-rpc/#submit","text":"A message initiated by the miner. When a miner find a share, it will submit it to the node.","title":"submit"},{"location":"wiki/api/stratum-rpc/#request_5","text":"The miner submit a solution to a job to the Stratum server. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" params Int edge_bits , nonce , height , job_id and array of integers pow Example: { \"id\" : \"0\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"params\" :{ \"edge_bits\" : 29 , \"height\" : 16419 , \"job_id\" : 0 , \"nonce\" : 8895699060858340771 , \"pow\" :[ 4210040 , 10141596 , 13269632 , 24291934 , 28079062 , 84254573 , 84493890 , 100560174 , 100657333 , 120128285 , 130518226 , 140371663 , 142109188 , 159800646 , 163323737 , 171019100 , 176840047 , 191220010 , 192245584 , 198941444 , 209276164 , 216952635 , 217795152 , 225662613 , 230166736 , 231315079 , 248639876 , 263910393 , 293995691 , 298361937 , 326412694 , 330363619 , 414572127 , 424798984 , 426489226 , 466671748 , 466924466 , 490048497 , 495035248 , 496623057 , 502828197 , 532838434 ] } } The response can be of three types.","title":"Request"},{"location":"wiki/api/stratum-rpc/#ok-response_2","text":"The share is accepted by the Stratum but is not a valid cuck(at)oo solution at the network target difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" result \"ok\" error null Example: { \"id\" : \"2\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"result\" : \"ok\" , \"error\" : null }","title":"OK response"},{"location":"wiki/api/stratum-rpc/#blockfound-response","text":"The share is accepted by the Stratum and is a valid cuck(at)oo solution at the network target difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" result \"block - \" + hash of the block error null Example: { \"id\" : \"6\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"result\" : \"blockfound - 23025af9032de812d15228121d5e4b0e977d30ad8036ab07131104787b9dcf10\" , \"error\" : null }","title":"Blockfound response"},{"location":"wiki/api/stratum-rpc/#error-response_2","text":"The error response can be of two types: stale and rejected. Stale share error response The share is a valid solution to a previous job not the current one. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32503 , \"message\" : \"Solution submitted too late\" } } Rejected share error responses Two possibilities: the solution cannot be validated or the solution is of too low difficulty. Failed to validate solution error The submitted solution cannot be validated. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32502 , \"message\" : \"Failed to validate solution\" } } Share rejected due to low difficulty error The submitted solution is of too low difficulty. Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error Example: { \"id\" : \"5\" , \"jsonrpc\" : \"2.0\" , \"method\" : \"submit\" , \"error\" :{ \"code\" : -32501 , \"message\" : \"Share rejected due to low difficulty\" } }","title":"Error response"},{"location":"wiki/api/stratum-rpc/#error-messages","text":"Grin Stratum protocol implementation contains the following error message: Error code Error Message -32000 Node is syncing - please wait -32500 Login first -32501 Share rejected due to low difficulty -32502 Failed to validate solution -32503 Solution Submitted too late -32600 Invalid Request -32601 Method not found","title":"Error Messages"},{"location":"wiki/api/stratum-rpc/#miner-behavior","text":"Miners SHOULD, MAY or MUST respect the following rules: Miners SHOULD randomize the job nonce before starting Miners MUST continue mining the same job until the server sends a new one, though a miner MAY request a new job at any time Miners MUST NOT send an rpc response to a job request from the server Miners MAY set the RPC \"id\" and expect responses to have that same id Miners MAY send a keepalive message Miners MAY send a login request (to identify which miner finds shares / solutions in the logs), the login request MUST have all 3 params. Miners MUST return the supplied job_id with submit messages.","title":"Miner behavior"},{"location":"wiki/api/stratum-rpc/#reference-implementation","text":"The current reference implementation is available at mimblewimble/grin-miner .","title":"Reference Implementation"},{"location":"wiki/blocks/block-body/","text":"","title":"Body"},{"location":"wiki/blocks/block-header/","text":"Block Header General format of a Block Header in a MimbleWimble/Grin: Field Description Size version Version of the block 2 bytes height Height of this block since the genesis block (height 0) 8 bytes timestamp Timestamp at which the block was built 8 bytes prev_hash Hash of the block previous to this in the chain 32 bytes prev_root Root hash of the header MMR at the previous header 32 bytes output_root Merkle root of all the commitments in the TxHashSet 32 bytes range_proof_root Merkle root of all range proofs in the TxHashSet 32 bytes kernel_root Merkle root of all transaction kernels in the TxHashSet 32 bytes total_kernel_offset Total accumulated sum of kernel offsets since genesis block. 32 bytes output_mmr_size Total size of the output MMR after applying this block. 8 bytes kernel_mmr_size Total size of the kernel MMR after applying this block. 8 bytes Sub-Total: 226 bytes - - - pow Proof of work data For cuck(AR)oo 29: 174 bytes. For cuck(AT)oo 32: 189 bytes. Total: 400 bytes for C29 or 415 bytes for C32 PoW General format of a Proof Of Work in a MimbleWimble/Grin: Field Description Size total_difficulty Total accumulated difficulty since genesis block 8 bytes secondary_scaling Variable difficulty scaling factor for secondary proof of work 4 bytes nonce Nonce increment used to mine this block. 8 bytes proof Proof of work data cuckoo_size: 1byte cuckoo_solution of C29: 42\u221729 bits=153 bytes cuckoo_solution of C32: 42\u221732 bits=168 bytes Sub-Total: 174 bytes for C29 and 189 bytes for C32 Example Here is a principle example of a MimbleWimle/Grin block header. The related block is included in Mainnet chain block: 1869 . Offset Field Hex Value 0 version 0001 2 height 000000000000074d 10 timestamp 000000005c3ff107 18 prev_hash 00001915c97bfad5bf9bb30a1035771446770502a937bd16a8c8a8f1fc6db730 50 prev_root 2eb356e36c03f16796dd4a6eef8cbcbeabaade84eecf013516367b376d646db7 82 output_root b56ccc990181d04d57585d3f0163b4f636fe3208a024596d14221bfa7739e693 114 range_proof_root a341b87862f430f9dda5fd0b88be175b6cc81b5e84bf6882d98cc31750b5001a 146 kernel_root b3e9708378ef256d479c6b166ba0a56c26d1b2e985c5e48065dbaa8a1fa6e606 178 total_kernel_offset 0755f37fa67bc3d3f0a7eddec7117013be42afff3602e7480d7271fff92763f1 210 output_mmr_size 0000000000001445 218 kernel_mmr_size 0000000000001130 226 total_difficulty 00000108e24af3bb 234 secondary_scaling 00000473 238 nonce 712493895227b883 246 edge_bits 1d 247 edge_nonces 43c8d2e098ba28f4f3748aab7d8be1aab3353259e6c6d4c046293f1c2f92afe7c5868bc5007fc51bae789ab3776d7efefb71547144b70ae8e764921bad8cb821a0c5d2adb455e1c406e1b2e39a2db51d7c552e4c1dd78bde1eea91f0843da6b3f1cb86e4ccb93371452b66c0ab292cd42525bcbf832fe358a3b22bcf7615e8397516ad8135a709213a77347cf4de104df5585984df0246fa03 400","title":"Header"},{"location":"wiki/blocks/block-header/#block-header","text":"General format of a Block Header in a MimbleWimble/Grin: Field Description Size version Version of the block 2 bytes height Height of this block since the genesis block (height 0) 8 bytes timestamp Timestamp at which the block was built 8 bytes prev_hash Hash of the block previous to this in the chain 32 bytes prev_root Root hash of the header MMR at the previous header 32 bytes output_root Merkle root of all the commitments in the TxHashSet 32 bytes range_proof_root Merkle root of all range proofs in the TxHashSet 32 bytes kernel_root Merkle root of all transaction kernels in the TxHashSet 32 bytes total_kernel_offset Total accumulated sum of kernel offsets since genesis block. 32 bytes output_mmr_size Total size of the output MMR after applying this block. 8 bytes kernel_mmr_size Total size of the kernel MMR after applying this block. 8 bytes Sub-Total: 226 bytes - - - pow Proof of work data For cuck(AR)oo 29: 174 bytes. For cuck(AT)oo 32: 189 bytes. Total: 400 bytes for C29 or 415 bytes for C32","title":"Block Header"},{"location":"wiki/blocks/block-header/#pow","text":"General format of a Proof Of Work in a MimbleWimble/Grin: Field Description Size total_difficulty Total accumulated difficulty since genesis block 8 bytes secondary_scaling Variable difficulty scaling factor for secondary proof of work 4 bytes nonce Nonce increment used to mine this block. 8 bytes proof Proof of work data cuckoo_size: 1byte cuckoo_solution of C29: 42\u221729 bits=153 bytes cuckoo_solution of C32: 42\u221732 bits=168 bytes Sub-Total: 174 bytes for C29 and 189 bytes for C32","title":"PoW"},{"location":"wiki/blocks/block-header/#example","text":"Here is a principle example of a MimbleWimle/Grin block header. The related block is included in Mainnet chain block: 1869 . Offset Field Hex Value 0 version 0001 2 height 000000000000074d 10 timestamp 000000005c3ff107 18 prev_hash 00001915c97bfad5bf9bb30a1035771446770502a937bd16a8c8a8f1fc6db730 50 prev_root 2eb356e36c03f16796dd4a6eef8cbcbeabaade84eecf013516367b376d646db7 82 output_root b56ccc990181d04d57585d3f0163b4f636fe3208a024596d14221bfa7739e693 114 range_proof_root a341b87862f430f9dda5fd0b88be175b6cc81b5e84bf6882d98cc31750b5001a 146 kernel_root b3e9708378ef256d479c6b166ba0a56c26d1b2e985c5e48065dbaa8a1fa6e606 178 total_kernel_offset 0755f37fa67bc3d3f0a7eddec7117013be42afff3602e7480d7271fff92763f1 210 output_mmr_size 0000000000001445 218 kernel_mmr_size 0000000000001130 226 total_difficulty 00000108e24af3bb 234 secondary_scaling 00000473 238 nonce 712493895227b883 246 edge_bits 1d 247 edge_nonces 43c8d2e098ba28f4f3748aab7d8be1aab3353259e6c6d4c046293f1c2f92afe7c5868bc5007fc51bae789ab3776d7efefb71547144b70ae8e764921bad8cb821a0c5d2adb455e1c406e1b2e39a2db51d7c552e4c1dd78bde1eea91f0843da6b3f1cb86e4ccb93371452b66c0ab292cd42525bcbf832fe358a3b22bcf7615e8397516ad8135a709213a77347cf4de104df5585984df0246fa03 400","title":"Example"},{"location":"wiki/blocks/fees-mining/","text":"Economic Policy: Fees and Mining Reward (there are are several mentions oh weight and fees, one of them the document below written by igno in 2016, by you should probably wait until they're revisited (tromp rfc) before the last hard fork). WORK IN PROGRESS** Considerations Most cryptocurrencies rely on 2 important parameters: fees dictating the cost of transacting and block rewards compensating miners for securing the chain. Rewards also play the important role of being the only source of new money creation: the total amount of tokens in existence is the sum of every reward since the genesis block. No cryptocurrency so far has established a fee market that would allow to fully compensate for block rewards. Even bitcoin, with its fees significantly raising (as of Oct. 2016), is still far from reaching that goal. Given the current block space supply, bitcoin fees would have to raise by at least an order of magnitude, reaching $4 USD. Even then, the stability of the currency when mining is only payed out in fee is questionable 1 . We also note that the security provided by a large hashrate is desirable to all participants in a cryptocurrency's economy, and not only to active transactors. For all these reasons we favor a constant reward over time, remarking that it asymptotically leads to zero dilution 2 . However, any cryptocurrency needs to protect itself against malicious spamming attacks that would flood the network and bloat storage. Proof of work is an efficient and elegant way to do so but difficult to adopt due to the complex computing ecosystem a cryptocurrency evolves in (from mobile wallets to cheap super-computing). So transaction fees remain the simplest way to protect a blockchain against malicious spam. By acknowledging that transaction fees only act as spam prevention we gain a framework to gauge how they should be priced: proportionately to the cost incurred by the network when accepting and safekeeping the transaction. Fee Levels and Incentives Given that block reward is the only way new currency is introduced, and supply greatly influences value, it makes sense to price fees based on how much supply is injected in the system. It also makes sense to study this for Grin, to establish a fee baseline. We introduce the notion of fees per reward per minute. For example in Bitcoin, at this time the reward per minute is 1.25BTC. Transaction fees average 70 satoshis per byte for a fast confirmation, putting the average transaction price around 16,000 with a median transaction size of 230 bytes. So the fees for a transaction are priced at 0.00128% of the reward per minute. In Ethereum, factoring in the current gas price, the transaction fees are priced around 0.0028% of the reward per minute. It may come as a surprise that this number would be higher for Ethereum than Bitcoin, but keep in mind that it only factors supply and not demand. It also only reflects how fast supply is injected, not how much total supply is currently in existence. Nonetheless, these 2 numbers are surprisingly close, giving us a good baseline. http://randomwalker.info/publications/mining_CCS.pdf \u21a9 By introducing new currency, each block reward dilutes all existing participants, \u21a9","title":"Economic Policy: Fees and Mining Reward"},{"location":"wiki/blocks/fees-mining/#economic-policy-fees-and-mining-reward","text":"(there are are several mentions oh weight and fees, one of them the document below written by igno in 2016, by you should probably wait until they're revisited (tromp rfc) before the last hard fork). WORK IN PROGRESS**","title":"Economic Policy: Fees and Mining Reward"},{"location":"wiki/blocks/fees-mining/#considerations","text":"Most cryptocurrencies rely on 2 important parameters: fees dictating the cost of transacting and block rewards compensating miners for securing the chain. Rewards also play the important role of being the only source of new money creation: the total amount of tokens in existence is the sum of every reward since the genesis block. No cryptocurrency so far has established a fee market that would allow to fully compensate for block rewards. Even bitcoin, with its fees significantly raising (as of Oct. 2016), is still far from reaching that goal. Given the current block space supply, bitcoin fees would have to raise by at least an order of magnitude, reaching $4 USD. Even then, the stability of the currency when mining is only payed out in fee is questionable 1 . We also note that the security provided by a large hashrate is desirable to all participants in a cryptocurrency's economy, and not only to active transactors. For all these reasons we favor a constant reward over time, remarking that it asymptotically leads to zero dilution 2 . However, any cryptocurrency needs to protect itself against malicious spamming attacks that would flood the network and bloat storage. Proof of work is an efficient and elegant way to do so but difficult to adopt due to the complex computing ecosystem a cryptocurrency evolves in (from mobile wallets to cheap super-computing). So transaction fees remain the simplest way to protect a blockchain against malicious spam. By acknowledging that transaction fees only act as spam prevention we gain a framework to gauge how they should be priced: proportionately to the cost incurred by the network when accepting and safekeeping the transaction. Fee Levels and Incentives Given that block reward is the only way new currency is introduced, and supply greatly influences value, it makes sense to price fees based on how much supply is injected in the system. It also makes sense to study this for Grin, to establish a fee baseline. We introduce the notion of fees per reward per minute. For example in Bitcoin, at this time the reward per minute is 1.25BTC. Transaction fees average 70 satoshis per byte for a fast confirmation, putting the average transaction price around 16,000 with a median transaction size of 230 bytes. So the fees for a transaction are priced at 0.00128% of the reward per minute. In Ethereum, factoring in the current gas price, the transaction fees are priced around 0.0028% of the reward per minute. It may come as a surprise that this number would be higher for Ethereum than Bitcoin, but keep in mind that it only factors supply and not demand. It also only reflects how fast supply is injected, not how much total supply is currently in existence. Nonetheless, these 2 numbers are surprisingly close, giving us a good baseline. http://randomwalker.info/publications/mining_CCS.pdf \u21a9 By introducing new currency, each block reward dilutes all existing participants, \u21a9","title":"Considerations"},{"location":"wiki/chain-state/chain-sync/","text":"Chain Sync Read (part of) this in other languages: Korean . Read about fast sync in other languages: Espa\u00f1ol , Korean , \u7b80\u4f53\u4e2d\u6587 . We describe here the different methods used by a new node when joining the network to catch up with the latest chain state. We start with reminding the reader of the following assumptions, which are all characteristics of Grin or Mimblewimble: All block headers include the root hash of all unspent outputs in the chain at the time of that block. Inputs or outputs cannot be tampered with or forged without invalidating the whole block state. We intentionally only focus on major node types and high level algorithms that may impact the security model. Detailed heuristics that can provide some additional improvements (like header first), while useful, will not be mentioned in this document. Full History Syncing This model is the one used by full nodes on most major public blockchains. The new node has prior knowledge of the genesis block. It connects to other peers in the network and starts asking for blocks until it reaches the latest block known to its peers. The security model here is similar to Bitcoin. We're able to verify the whole chain, the total work, the validity of each block, their full content, etc. In addition, with Mimblewimble and full UTXO set commitments, even more integrity validation can be performed. We do not try to do any space or bandwidth optimization in this mode (for example, once validated the range proofs could possibly be deleted). The point here is to provide history archival and allow later checks and verifications to be made. However, such full history sync, also called Initial Block Download (IBD), is unnecessary for a new node to fully validate the Grin chain history, as most blocks may be only partially downloaded. Fast Sync We call fast sync the process of synchronizing a new node, or a node that hasn't been keeping up with the chain for a while, and bringing it up to the latest known most-worked block. In this model we try to optimize for very fast syncing while sacrificing as little security assumptions as possible. As a matter of fact, the security model is almost identical as a full history sync, despite requiring orders of magnitude less data to download. At a high level, a fast-sync goes through the following process: Sync all block headers on the most worked chain as advertized by other nodes. Also, pick a header sufficiently back from the chain head. This is called the node horizon as it's the furthest a node can reorganize its chain on a new fork if it were to occur without triggering another new full sync. Once all headers have are synced, Download the full state as it was at the horizon, including the unspent output, range proof and kernel data, as well as all corresponding MMRs. This is just one large zip file named txhashset . Validate the full state. Download full blocks since the horizon to reach the chain head. A new node is pre-configured with a horizon Z , which is a distance in number of blocks from the head. For example, if horizon Z=5000 and the head is at height H=23000 , the block at horizon is the block at height h=18000 on the most worked chain. The new node also has prior knowledge of the genesis block. It connects to other peers and learns about the head of the most worked chain. It asks for the block header at the horizon block, requiring peer agreement. If consensus is not reached at h = H - Z , the node gradually increases the horizon Z , moving h backward until consensus is reached. Then it gets the full UTXO set at the horizon block. With this information it can verify: The total difficulty on that chain (present in all block headers). The sum of all UTXO commitments equals the expected money supply. The root hash of all UTXOs match the root hash in the block header. Once the validation is done, the peer can download and validate the blocks content from the horizon up to the head. While this algorithm still works for very low values of Z (or in the extreme case where Z=1 ), low values may be problematic due to the normal forking activity that can occur on any blockchain. To prevent those problems and to increase the amount of locally validated work, we recommend values of Z of at least a few days worth of blocks, up to a few weeks. Security Discussion While this sync mode is simple to describe, it may seem non-obvious how it still can be secure. We describe here some possible attacks, how they're defeated and other possible failure scenarios. An attacker tries to forge the state at horizon This range of attacks attempt to have a node believe it is properly synchronized with the network when it's actually is in a forged state. Multiple strategies can be attempted: Completely fake but valid horizon state (including header and proof of work). Assuming at least one honest peer, neither the UTXO set root hash nor the block hash will match other peers' horizon states. Valid block header but faked UTXO set. The UTXO set root hash from the header will not match what the node calculates from the received UTXO set itself. Completely valid block with fake total difficulty, which could lead the node down a fake fork. The block hash changes if the total difficulty is changed, no honest peer will produce a valid head for that hash. A fork occurs that's older than the local UTXO history Our node downloaded the full UTXO set at horizon height. If a fork occurs on a block at an older horizon H+delta, the UTXO set can't be validated. In this situation the node has no choice but to put itself back in sync mode with a new horizon of Z'=Z+delta . Note that an alternate fork at Z+delta that has less work than our current head can safely be ignored, only a winning fork of total work greater than our head would. To do this resolution, every block header includes the total chain difficulty up to that block. The chain is permanently forked If a hard fork occurs, the network may become split, forcing new nodes to always push their horizon back to when the hard fork occurred. While this is not a problem for short-term hard forks, it may become an issue for long-term or permanent forks. To prevent this situation, peers should always be checked for hard fork related capabilities (a bitmask of features a peer exposes) on connection. Several nodes continuously give fake horizon blocks If a peer can't reach consensus on the header at h, it gradually moves back. In the degenerate case, rogue peers could force all new peers to always become full nodes (move back until genesis) by systematically preventing consensus and feeding fake headers. While this is a valid issue, several mitigation strategies exist: Peers must still provide valid block headers at horizon Z . This includes the proof of work. A group of block headers around the horizon could be asked to increase the cost of the attack. Differing block headers providing a proof of work significantly lower could be rejected. The user or node operator may be asked to confirm a block hash. In last resort, if none of the above strategies are effective, checkpoints could be used.","title":"Chain Sync"},{"location":"wiki/chain-state/chain-sync/#chain-sync","text":"Read (part of) this in other languages: Korean . Read about fast sync in other languages: Espa\u00f1ol , Korean , \u7b80\u4f53\u4e2d\u6587 . We describe here the different methods used by a new node when joining the network to catch up with the latest chain state. We start with reminding the reader of the following assumptions, which are all characteristics of Grin or Mimblewimble: All block headers include the root hash of all unspent outputs in the chain at the time of that block. Inputs or outputs cannot be tampered with or forged without invalidating the whole block state. We intentionally only focus on major node types and high level algorithms that may impact the security model. Detailed heuristics that can provide some additional improvements (like header first), while useful, will not be mentioned in this document.","title":"Chain Sync"},{"location":"wiki/chain-state/chain-sync/#full-history-syncing","text":"This model is the one used by full nodes on most major public blockchains. The new node has prior knowledge of the genesis block. It connects to other peers in the network and starts asking for blocks until it reaches the latest block known to its peers. The security model here is similar to Bitcoin. We're able to verify the whole chain, the total work, the validity of each block, their full content, etc. In addition, with Mimblewimble and full UTXO set commitments, even more integrity validation can be performed. We do not try to do any space or bandwidth optimization in this mode (for example, once validated the range proofs could possibly be deleted). The point here is to provide history archival and allow later checks and verifications to be made. However, such full history sync, also called Initial Block Download (IBD), is unnecessary for a new node to fully validate the Grin chain history, as most blocks may be only partially downloaded.","title":"Full History Syncing"},{"location":"wiki/chain-state/chain-sync/#fast-sync","text":"We call fast sync the process of synchronizing a new node, or a node that hasn't been keeping up with the chain for a while, and bringing it up to the latest known most-worked block. In this model we try to optimize for very fast syncing while sacrificing as little security assumptions as possible. As a matter of fact, the security model is almost identical as a full history sync, despite requiring orders of magnitude less data to download. At a high level, a fast-sync goes through the following process: Sync all block headers on the most worked chain as advertized by other nodes. Also, pick a header sufficiently back from the chain head. This is called the node horizon as it's the furthest a node can reorganize its chain on a new fork if it were to occur without triggering another new full sync. Once all headers have are synced, Download the full state as it was at the horizon, including the unspent output, range proof and kernel data, as well as all corresponding MMRs. This is just one large zip file named txhashset . Validate the full state. Download full blocks since the horizon to reach the chain head. A new node is pre-configured with a horizon Z , which is a distance in number of blocks from the head. For example, if horizon Z=5000 and the head is at height H=23000 , the block at horizon is the block at height h=18000 on the most worked chain. The new node also has prior knowledge of the genesis block. It connects to other peers and learns about the head of the most worked chain. It asks for the block header at the horizon block, requiring peer agreement. If consensus is not reached at h = H - Z , the node gradually increases the horizon Z , moving h backward until consensus is reached. Then it gets the full UTXO set at the horizon block. With this information it can verify: The total difficulty on that chain (present in all block headers). The sum of all UTXO commitments equals the expected money supply. The root hash of all UTXOs match the root hash in the block header. Once the validation is done, the peer can download and validate the blocks content from the horizon up to the head. While this algorithm still works for very low values of Z (or in the extreme case where Z=1 ), low values may be problematic due to the normal forking activity that can occur on any blockchain. To prevent those problems and to increase the amount of locally validated work, we recommend values of Z of at least a few days worth of blocks, up to a few weeks.","title":"Fast Sync"},{"location":"wiki/chain-state/chain-sync/#security-discussion","text":"While this sync mode is simple to describe, it may seem non-obvious how it still can be secure. We describe here some possible attacks, how they're defeated and other possible failure scenarios.","title":"Security Discussion"},{"location":"wiki/chain-state/chain-sync/#an-attacker-tries-to-forge-the-state-at-horizon","text":"This range of attacks attempt to have a node believe it is properly synchronized with the network when it's actually is in a forged state. Multiple strategies can be attempted: Completely fake but valid horizon state (including header and proof of work). Assuming at least one honest peer, neither the UTXO set root hash nor the block hash will match other peers' horizon states. Valid block header but faked UTXO set. The UTXO set root hash from the header will not match what the node calculates from the received UTXO set itself. Completely valid block with fake total difficulty, which could lead the node down a fake fork. The block hash changes if the total difficulty is changed, no honest peer will produce a valid head for that hash.","title":"An attacker tries to forge the state at horizon"},{"location":"wiki/chain-state/chain-sync/#a-fork-occurs-thats-older-than-the-local-utxo-history","text":"Our node downloaded the full UTXO set at horizon height. If a fork occurs on a block at an older horizon H+delta, the UTXO set can't be validated. In this situation the node has no choice but to put itself back in sync mode with a new horizon of Z'=Z+delta . Note that an alternate fork at Z+delta that has less work than our current head can safely be ignored, only a winning fork of total work greater than our head would. To do this resolution, every block header includes the total chain difficulty up to that block.","title":"A fork occurs that's older than the local UTXO history"},{"location":"wiki/chain-state/chain-sync/#the-chain-is-permanently-forked","text":"If a hard fork occurs, the network may become split, forcing new nodes to always push their horizon back to when the hard fork occurred. While this is not a problem for short-term hard forks, it may become an issue for long-term or permanent forks. To prevent this situation, peers should always be checked for hard fork related capabilities (a bitmask of features a peer exposes) on connection.","title":"The chain is permanently forked"},{"location":"wiki/chain-state/chain-sync/#several-nodes-continuously-give-fake-horizon-blocks","text":"If a peer can't reach consensus on the header at h, it gradually moves back. In the degenerate case, rogue peers could force all new peers to always become full nodes (move back until genesis) by systematically preventing consensus and feeding fake headers. While this is a valid issue, several mitigation strategies exist: Peers must still provide valid block headers at horizon Z . This includes the proof of work. A group of block headers around the horizon could be asked to increase the cost of the attack. Differing block headers providing a proof of work significantly lower could be rejected. The user or node operator may be asked to confirm a block hash. In last resort, if none of the above strategies are effective, checkpoints could be used.","title":"Several nodes continuously give fake horizon blocks"},{"location":"wiki/chain-state/merkle-mountain-range/","text":"Merkle Mountain Ranges (MMR) Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . Structure For the original document describing the motivation for choosing MMR as the merkle structure for Grin, read here . Merkle Mountain Ranges 1 are an alternative to Merkle trees 2 . While the latter relies on perfectly balanced binary trees, the former can be seen either as list of perfectly balance binary trees or a single binary tree that would have been truncated from the top right. A Merkle Mountain Range (MMR) is strictly append-only: elements are added from the left to the right, adding a parent as soon as 2 children exist, filling up the range accordingly. Grin employs MMR to stores kernels, outputs and rangeproofs, each in its own dedicated tree. Let's illustrates a range with 11 inserted leaves and total size 19, where each node is annotated with its order of insertion. Height 3 14 / \\ / \\ / \\ / \\ 2 6 13 / \\ / \\ 1 2 5 9 12 17 / \\ / \\ / \\ / \\ / \\ 0 0 1 3 4 7 8 10 11 15 16 18 This can be represented as a flat list, here storing the height of each node at their position of insertion: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 0 0 1 0 0 1 2 0 0 1 0 0 1 2 3 0 0 1 0 The structure can be fully described simply from its size (19). It's also fairly simple, using fast binary operations, to navigate within a MMR. Given a node's position n , we can compute its height, the position of its parent, its siblings, etc. Hashing and Bagging Just like with Merkle trees, parent nodes in a MMR have for value the hash of their 2 children. Grin uses the Blake2b hash function throughout, and always prepends the node's position in the MMR before hashing to avoid collisions. So for a leaf l at index n storing data D (in the case of an output, the data is its Pedersen commitment, for example), we have: Node(l) = Blake2b(n | D) And for any parent p at index m : Node(p) = Blake2b(m | Node(left_child(p)) | Node(right_child(p))) Contrarily to a Merkle tree, a MMR generally has no single root by construction so we need a method to compute one (otherwise it would defeat the purpose of using a hash tree). This process is called \"bagging the peaks\" 1 . First, we identify the peaks of the MMR; we will define one method of doing so here. We first write another small example MMR but with the indexes written as binary (instead of decimal), starting from 1: Height 2 111 / \\ 1 11 110 1010 / \\ / \\ / \\ 0 1 10 100 101 1000 1001 1011 This MMR has 11 nodes and its peaks are at position 111 (7), 1010 (10) and 1011 (11). We first notice how the first leftmost peak is always going to be the highest and always \"all ones\" when expressed in binary. Therefore that peak will have a position of the form 2^n - 1 and will always be the largest such position that is inside the MMR (its position is lesser than the total size). We process iteratively for a MMR of size 11: 2^0 - 1 = 0, and 0 < 11 2^1 - 1 = 1, and 1 < 11 2^2 - 1 = 3, and 3 < 11 2^3 - 1 = 7, and 7 < 11 2^4 - 1 = 15, and 15 is not < 11 (This can also be calculated non-iteratively as 2^(binary logarithm of size + 1) - 1 Therefore the first peak is 7. To find the next peak, we then need to \"jump\" to its right sibling. If that node is not in the MMR (and it won't), take its left child. If that child is not in the MMR either, keep taking its left child until we have a node that exists in our MMR. Once we find that next peak, keep repeating the process until we're at the last node. All these operations are very simple. Jumping to the right sibling of a node at height h is adding 2^(h+1) - 1 to its position. Taking its left child is subtracting 2^h . Finally, once all the positions of the peaks are known, \"bagging\" the peaks consists of hashing them iteratively from the right, using the total size of the MMR as prefix. For a MMR of size N with 3 peaks p1, p2 and p3 we get the final top peak: P = Blake2b(N | Blake2b(N | Node(p3) | Node(p2)) | Node(p1)) Pruning In Grin, a lot of the data that gets hashed and stored in MMRs can eventually be removed. As this happens, the presence of some leaf hashes in the corresponding MMRs become unnecessary and their hash can be removed. When enough leaves are removed, the presence of their parents may become unnecessary as well. We can therefore prune a significant part of a MMR from the removal of its leaves. Pruning a MMR relies on a simple iterative process. X is first initialized as the leaf we wish to prune. Prune X . If X has a sibling, stop here. If 'X' has no sibling, assign the parent of X as X . To visualize the result, starting from our first MMR example and removing leaves [0, 3, 4, 8, 16] leads to the following pruned MMR: Height 3 14 / \\ / \\ / \\ / \\ 2 6 13 / / \\ 1 2 9 12 17 \\ / / \\ / 0 1 7 10 11 15 18 Merkle Proof In the example above, the leaf nodes are 1, 2, 4, 5, 8, 9, 11, 12. Only these nodes hash actual data, while non-leaf nodes are simply hashes of their children. Output Set MMR Let's define the functionality of generating a Merkle proof for a given entry, OutX , in the total output set MMR. A Merkle proof consists of the following: Hash of the leaf node representing OutX . Hash of the overall root of the tree. A list of hashes representing all the MMR peaks (they match the overall root when hashed together). A list of sibling hashes to construct branch from node outX to its peak. A list of sibling positions (left/right) to allow the branch to be reconstructed correctly. A Merkle proof allows us to: Prove inclusion of the node beneath its peak. Prove the peaks combine to form the overall root hash. Prove inclusion of an (unspent) output for a given block_header by verifying the utxo_root matches the root of the Merkle proof If an output is unspent at a given block header, then it is at least as old as that block. Coinbase Output The wallet maintains a Merkle proof (and corresponding block hash) for each unspent coinbase output. Spending a coinbase output requires the block hash and Merkle proof to be provided in the input. these are used to verify coinbase maturity (without requiring full block data for verification) merkle-mountain-range , Peter Todd \u21a9 \u21a9 Merkle Tree , Wikipedia \u21a9","title":"Merkle Mountain Ranges"},{"location":"wiki/chain-state/merkle-mountain-range/#merkle-mountain-ranges-mmr","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 .","title":"Merkle Mountain Ranges (MMR)"},{"location":"wiki/chain-state/merkle-mountain-range/#structure","text":"For the original document describing the motivation for choosing MMR as the merkle structure for Grin, read here . Merkle Mountain Ranges 1 are an alternative to Merkle trees 2 . While the latter relies on perfectly balanced binary trees, the former can be seen either as list of perfectly balance binary trees or a single binary tree that would have been truncated from the top right. A Merkle Mountain Range (MMR) is strictly append-only: elements are added from the left to the right, adding a parent as soon as 2 children exist, filling up the range accordingly. Grin employs MMR to stores kernels, outputs and rangeproofs, each in its own dedicated tree. Let's illustrates a range with 11 inserted leaves and total size 19, where each node is annotated with its order of insertion. Height 3 14 / \\ / \\ / \\ / \\ 2 6 13 / \\ / \\ 1 2 5 9 12 17 / \\ / \\ / \\ / \\ / \\ 0 0 1 3 4 7 8 10 11 15 16 18 This can be represented as a flat list, here storing the height of each node at their position of insertion: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 0 0 1 0 0 1 2 0 0 1 0 0 1 2 3 0 0 1 0 The structure can be fully described simply from its size (19). It's also fairly simple, using fast binary operations, to navigate within a MMR. Given a node's position n , we can compute its height, the position of its parent, its siblings, etc.","title":"Structure"},{"location":"wiki/chain-state/merkle-mountain-range/#hashing-and-bagging","text":"Just like with Merkle trees, parent nodes in a MMR have for value the hash of their 2 children. Grin uses the Blake2b hash function throughout, and always prepends the node's position in the MMR before hashing to avoid collisions. So for a leaf l at index n storing data D (in the case of an output, the data is its Pedersen commitment, for example), we have: Node(l) = Blake2b(n | D) And for any parent p at index m : Node(p) = Blake2b(m | Node(left_child(p)) | Node(right_child(p))) Contrarily to a Merkle tree, a MMR generally has no single root by construction so we need a method to compute one (otherwise it would defeat the purpose of using a hash tree). This process is called \"bagging the peaks\" 1 . First, we identify the peaks of the MMR; we will define one method of doing so here. We first write another small example MMR but with the indexes written as binary (instead of decimal), starting from 1: Height 2 111 / \\ 1 11 110 1010 / \\ / \\ / \\ 0 1 10 100 101 1000 1001 1011 This MMR has 11 nodes and its peaks are at position 111 (7), 1010 (10) and 1011 (11). We first notice how the first leftmost peak is always going to be the highest and always \"all ones\" when expressed in binary. Therefore that peak will have a position of the form 2^n - 1 and will always be the largest such position that is inside the MMR (its position is lesser than the total size). We process iteratively for a MMR of size 11: 2^0 - 1 = 0, and 0 < 11 2^1 - 1 = 1, and 1 < 11 2^2 - 1 = 3, and 3 < 11 2^3 - 1 = 7, and 7 < 11 2^4 - 1 = 15, and 15 is not < 11 (This can also be calculated non-iteratively as 2^(binary logarithm of size + 1) - 1 Therefore the first peak is 7. To find the next peak, we then need to \"jump\" to its right sibling. If that node is not in the MMR (and it won't), take its left child. If that child is not in the MMR either, keep taking its left child until we have a node that exists in our MMR. Once we find that next peak, keep repeating the process until we're at the last node. All these operations are very simple. Jumping to the right sibling of a node at height h is adding 2^(h+1) - 1 to its position. Taking its left child is subtracting 2^h . Finally, once all the positions of the peaks are known, \"bagging\" the peaks consists of hashing them iteratively from the right, using the total size of the MMR as prefix. For a MMR of size N with 3 peaks p1, p2 and p3 we get the final top peak: P = Blake2b(N | Blake2b(N | Node(p3) | Node(p2)) | Node(p1))","title":"Hashing and Bagging"},{"location":"wiki/chain-state/merkle-mountain-range/#pruning","text":"In Grin, a lot of the data that gets hashed and stored in MMRs can eventually be removed. As this happens, the presence of some leaf hashes in the corresponding MMRs become unnecessary and their hash can be removed. When enough leaves are removed, the presence of their parents may become unnecessary as well. We can therefore prune a significant part of a MMR from the removal of its leaves. Pruning a MMR relies on a simple iterative process. X is first initialized as the leaf we wish to prune. Prune X . If X has a sibling, stop here. If 'X' has no sibling, assign the parent of X as X . To visualize the result, starting from our first MMR example and removing leaves [0, 3, 4, 8, 16] leads to the following pruned MMR: Height 3 14 / \\ / \\ / \\ / \\ 2 6 13 / / \\ 1 2 9 12 17 \\ / / \\ / 0 1 7 10 11 15 18","title":"Pruning"},{"location":"wiki/chain-state/merkle-mountain-range/#merkle-proof","text":"In the example above, the leaf nodes are 1, 2, 4, 5, 8, 9, 11, 12. Only these nodes hash actual data, while non-leaf nodes are simply hashes of their children.","title":"Merkle Proof"},{"location":"wiki/chain-state/merkle-mountain-range/#output-set-mmr","text":"Let's define the functionality of generating a Merkle proof for a given entry, OutX , in the total output set MMR. A Merkle proof consists of the following: Hash of the leaf node representing OutX . Hash of the overall root of the tree. A list of hashes representing all the MMR peaks (they match the overall root when hashed together). A list of sibling hashes to construct branch from node outX to its peak. A list of sibling positions (left/right) to allow the branch to be reconstructed correctly. A Merkle proof allows us to: Prove inclusion of the node beneath its peak. Prove the peaks combine to form the overall root hash. Prove inclusion of an (unspent) output for a given block_header by verifying the utxo_root matches the root of the Merkle proof If an output is unspent at a given block header, then it is at least as old as that block. Coinbase Output The wallet maintains a Merkle proof (and corresponding block hash) for each unspent coinbase output. Spending a coinbase output requires the block hash and Merkle proof to be provided in the input. these are used to verify coinbase maturity (without requiring full block data for verification) merkle-mountain-range , Peter Todd \u21a9 \u21a9 Merkle Tree , Wikipedia \u21a9","title":"Output Set MMR"},{"location":"wiki/chain-state/merkle-structures%28old%29/","text":"Merkle Structures Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . Mimblewimble is designed for users to verify the state of the system given only pruned data. To achieve this goal, all transaction data is committed to the blockchain by means of Merkle trees which should support efficient updates and serialization even when pruned. Also, almost all transaction data (inputs, outputs, excesses and excess proofs) have the ability to be summed in some way, so it makes sense to treat Merkle sum trees as the default option, and address the sums here. A design goal of Grin is that all structures be as easy to implement and as simple as possible. Mimblewimble introduces a lot of new cryptography so it should be made as easy to understand as possible. Its validation rules are simple to specify (no scripts) and Grin is written in a language with very explicit semantics, so simplicity is also good to achieve well-understood consensus rules. Merkle Trees There are four Merkle trees committed to by each block: Total Output Set Each object is one of two things: a commitment indicating an unspent output or a NULL marker indicating a spent one. It is a sum-tree over all unspent outputs (spent ones contribute nothing to the sum). The output set should reflect the state of the chain after the current block has taken effect. The root sum should be equal to the sum of all excesses since the genesis. Design requirements: Efficient additions and updating from unspent to spent. Efficient proofs that a specific output was spent. Efficient storage of diffs between UTXO roots. Efficient tree storage even with missing data, even with millions of entries. If a node commits to NULL, it has no unspent children and its data should eventually be able to be dropped forever. Support for serialization and efficient merging of pruned trees from partial archival nodes. Output witnesses This tree mirrors the total output set but has rangeproofs in place of commitments. It is never updated, only appended to, and does not sum over anything. When an output is spent it is sufficient to prune its rangeproof from the tree rather than deleting it. Design requirements: Support for serialization and efficient merging of pruned trees from partial archival nodes. Inputs and Outputs Each object is one of two things: an input (unambiguous reference to an old transaction output), or an output (a (commitment, rangeproof) pair). It is a sum-tree over the commitments of outputs, and the negatives of the commitments of inputs. Input references are hashes of old commitments. It is a consensus rule that all unspent outputs must be unique. The root sum should be equal to the sum of excesses for this block. See the next section. In general, validators will see either 100% of this Merkle tree or 0% of it, so it is compatible with any design. Design requirements: Efficient inclusion proofs, for proof-of-publication. Excesses Each object is of the form (excess, signature). It is a sum tree over the excesses. In general, validators will always see 100% of this tree, so it is not even necessary to have a Merkle structure at all. However, to support partial archival nodes in the future we want to support efficient pruning. Design requirements: Support for serialization and efficient merging of pruned trees from partial archival nodes. Proposed Merkle Structure The following design is proposed for all trees: a sum-MMR where every node sums a count of its children as well as the data it is supposed to sum. The result is that every node commits to the count of all its children. MMRs, or Merkle Mountain Ranges The six design criteria for the output set are: Efficient insert/updates Immediate (as is proof-of-inclusion). This is true for any balanced Merkle tree design. Efficient proof-of-spentness Grin itself does not need proof-of-spentness but it is a good thing to support in the future for SPV clients. The children-counts imply an index of each object in the tree, which does not change because insertions happen only at the far right of the tree. This allows permanent proof-of-spentness, even if an identical output is later added to the tree, and prevents false proofs even for identical outputs. These properties are hard to achieve for a non-insertion-ordered tree. Efficient storage of diffs Storing complete blocks should be sufficient for this. Updates are obviously as easy to undo as they are to do, and since blocks are always processed in order, rewinding them during reorgs is as simple as removing a contiguous set of outputs from the right of the tree. (This should be even faster than repeated deletions in a tree designed to support deletions.) Efficient tree storage even with missing data To update the root hash when random outputs are spent, we do not want to need to store or compute the entire tree. Instead we can store only the hashes at depth 20, say, of which there will be at most a million. Then each update only needs to recompute hashes above this depth (Bitcoin has less than 2^29 outputs in its history, so this means computing a tree of size 2^9 = 512 for each update) and after all updates are done, the root hash can be recomputed. This depth is configurable and may be changed as the output set grows, or depending on available disk space. This is doable for any Merkle tree but may be complicated by PATRICIA trees or other prefix trees, depending how depth is computed. Dropping spent coins Since coins never go from spent to unspent, the data on spent coins is not needed for any more updates or lookups. Efficient serialization of pruned trees Since every node has a count of its children, validators can determine the structure of the tree without needing all the hashes, and can determine which nodes are siblings, and so on. In the output set each node also commits to a sum of its unspent children, so a validator knows if it is missing data on unspent coins by checking whether or not this sum on a pruned node is zero. Algorithms (To appear alongside an implementation.) Storage The sum tree data structure allows the efficient storage of the output set and output witnesses while allowing immediate retrieval of a root hash or root sum (when applicable). However, the tree must contain every output commitment and witness hash in the system. This data is too big to be permanently stored in memory and too costly to be rebuilt from scratch at every restart, even if we consider pruning (at this time, Bitcoin has over 50M UTXOs which would require at least 3.2GB, assuming a couple hashes per UTXO). So we need an efficient way to store this data structure on disk. Another limitation of a hash tree is that, given a key (i.e. an output commitment), it's impossible to find the leaf in the tree associated with that key. We can't walk down the tree from the root in any meaningful way. So an additional index over the whole key space is required. As an MMR is an append only binary tree, we can find a key in the tree by its insertion position. So a full index of keys inserted in the tree (i.e. an output commitment) to their insertion positions is also required.","title":"Merkle Structures"},{"location":"wiki/chain-state/merkle-structures%28old%29/#merkle-structures","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . Mimblewimble is designed for users to verify the state of the system given only pruned data. To achieve this goal, all transaction data is committed to the blockchain by means of Merkle trees which should support efficient updates and serialization even when pruned. Also, almost all transaction data (inputs, outputs, excesses and excess proofs) have the ability to be summed in some way, so it makes sense to treat Merkle sum trees as the default option, and address the sums here. A design goal of Grin is that all structures be as easy to implement and as simple as possible. Mimblewimble introduces a lot of new cryptography so it should be made as easy to understand as possible. Its validation rules are simple to specify (no scripts) and Grin is written in a language with very explicit semantics, so simplicity is also good to achieve well-understood consensus rules.","title":"Merkle Structures"},{"location":"wiki/chain-state/merkle-structures%28old%29/#merkle-trees","text":"There are four Merkle trees committed to by each block:","title":"Merkle Trees"},{"location":"wiki/chain-state/merkle-structures%28old%29/#total-output-set","text":"Each object is one of two things: a commitment indicating an unspent output or a NULL marker indicating a spent one. It is a sum-tree over all unspent outputs (spent ones contribute nothing to the sum). The output set should reflect the state of the chain after the current block has taken effect. The root sum should be equal to the sum of all excesses since the genesis. Design requirements: Efficient additions and updating from unspent to spent. Efficient proofs that a specific output was spent. Efficient storage of diffs between UTXO roots. Efficient tree storage even with missing data, even with millions of entries. If a node commits to NULL, it has no unspent children and its data should eventually be able to be dropped forever. Support for serialization and efficient merging of pruned trees from partial archival nodes.","title":"Total Output Set"},{"location":"wiki/chain-state/merkle-structures%28old%29/#output-witnesses","text":"This tree mirrors the total output set but has rangeproofs in place of commitments. It is never updated, only appended to, and does not sum over anything. When an output is spent it is sufficient to prune its rangeproof from the tree rather than deleting it. Design requirements: Support for serialization and efficient merging of pruned trees from partial archival nodes.","title":"Output witnesses"},{"location":"wiki/chain-state/merkle-structures%28old%29/#inputs-and-outputs","text":"Each object is one of two things: an input (unambiguous reference to an old transaction output), or an output (a (commitment, rangeproof) pair). It is a sum-tree over the commitments of outputs, and the negatives of the commitments of inputs. Input references are hashes of old commitments. It is a consensus rule that all unspent outputs must be unique. The root sum should be equal to the sum of excesses for this block. See the next section. In general, validators will see either 100% of this Merkle tree or 0% of it, so it is compatible with any design. Design requirements: Efficient inclusion proofs, for proof-of-publication.","title":"Inputs and Outputs"},{"location":"wiki/chain-state/merkle-structures%28old%29/#excesses","text":"Each object is of the form (excess, signature). It is a sum tree over the excesses. In general, validators will always see 100% of this tree, so it is not even necessary to have a Merkle structure at all. However, to support partial archival nodes in the future we want to support efficient pruning. Design requirements: Support for serialization and efficient merging of pruned trees from partial archival nodes.","title":"Excesses"},{"location":"wiki/chain-state/merkle-structures%28old%29/#proposed-merkle-structure","text":"The following design is proposed for all trees: a sum-MMR where every node sums a count of its children as well as the data it is supposed to sum. The result is that every node commits to the count of all its children. MMRs, or Merkle Mountain Ranges The six design criteria for the output set are:","title":"Proposed Merkle Structure"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-insertupdates","text":"Immediate (as is proof-of-inclusion). This is true for any balanced Merkle tree design.","title":"Efficient insert/updates"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-proof-of-spentness","text":"Grin itself does not need proof-of-spentness but it is a good thing to support in the future for SPV clients. The children-counts imply an index of each object in the tree, which does not change because insertions happen only at the far right of the tree. This allows permanent proof-of-spentness, even if an identical output is later added to the tree, and prevents false proofs even for identical outputs. These properties are hard to achieve for a non-insertion-ordered tree.","title":"Efficient proof-of-spentness"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-storage-of-diffs","text":"Storing complete blocks should be sufficient for this. Updates are obviously as easy to undo as they are to do, and since blocks are always processed in order, rewinding them during reorgs is as simple as removing a contiguous set of outputs from the right of the tree. (This should be even faster than repeated deletions in a tree designed to support deletions.)","title":"Efficient storage of diffs"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-tree-storage-even-with-missing-data","text":"To update the root hash when random outputs are spent, we do not want to need to store or compute the entire tree. Instead we can store only the hashes at depth 20, say, of which there will be at most a million. Then each update only needs to recompute hashes above this depth (Bitcoin has less than 2^29 outputs in its history, so this means computing a tree of size 2^9 = 512 for each update) and after all updates are done, the root hash can be recomputed. This depth is configurable and may be changed as the output set grows, or depending on available disk space. This is doable for any Merkle tree but may be complicated by PATRICIA trees or other prefix trees, depending how depth is computed.","title":"Efficient tree storage even with missing data"},{"location":"wiki/chain-state/merkle-structures%28old%29/#dropping-spent-coins","text":"Since coins never go from spent to unspent, the data on spent coins is not needed for any more updates or lookups.","title":"Dropping spent coins"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-serialization-of-pruned-trees","text":"Since every node has a count of its children, validators can determine the structure of the tree without needing all the hashes, and can determine which nodes are siblings, and so on. In the output set each node also commits to a sum of its unspent children, so a validator knows if it is missing data on unspent coins by checking whether or not this sum on a pruned node is zero.","title":"Efficient serialization of pruned trees"},{"location":"wiki/chain-state/merkle-structures%28old%29/#algorithms","text":"(To appear alongside an implementation.)","title":"Algorithms"},{"location":"wiki/chain-state/merkle-structures%28old%29/#storage","text":"The sum tree data structure allows the efficient storage of the output set and output witnesses while allowing immediate retrieval of a root hash or root sum (when applicable). However, the tree must contain every output commitment and witness hash in the system. This data is too big to be permanently stored in memory and too costly to be rebuilt from scratch at every restart, even if we consider pruning (at this time, Bitcoin has over 50M UTXOs which would require at least 3.2GB, assuming a couple hashes per UTXO). So we need an efficient way to store this data structure on disk. Another limitation of a hash tree is that, given a key (i.e. an output commitment), it's impossible to find the leaf in the tree associated with that key. We can't walk down the tree from the root in any meaningful way. So an additional index over the whole key space is required. As an MMR is an append only binary tree, we can find a key in the tree by its insertion position. So a full index of keys inserted in the tree (i.e. an output commitment) to their insertion positions is also required.","title":"Storage"},{"location":"wiki/chain-state/state-and-pruning/","text":"State and Pruning Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . State Storage Recall that the Grin chain includes the following data: Outputs, which include for each output: A Pedersen commitment (33 bytes). A range proof (640KB). Inputs, which are just output references (32 bytes). Transaction kernels, which include for each transaction: The excess commitment sum for the transaction (33 bytes). A signature generated with the excess (~70 bytes). A block header with a valid proof of work and roots of the Merkle trees. Each node maintains 3 MMRs: An output set MMR. Rangeproofs MMR. Transaction kernels MMR. All outputs, rangeproofs and kernels are added in their respective MMRs in the order they occur in each block (recall that block data is required to be sorted). Pruning As outputs get spent, both their commitment and rangeproof data can be removed. In addition, the corresponding output and range proof MMRs can be pruned of their hash entires. PMMR A pruned MMR is referred to as a PMMR. Following pruning, the full state of the chain consists of the following data: The unspent output set (UTXO). A rangeproof for each unspent output. All transaction kernels. In addition, all block headers are required to anchor the above state with a valid proof of work (the state corresponds to the most worked chain). Validation Pruning removes as much data as possible while keeping all the guarantees of a full Mimblewimble-style validation. This is necessary to keep a pruning node state's sane, but also on first fast sync, where only the minimum amount of data is sent to a new node. The full validation of the chain state requires that: All kernel signatures verify against their public keys (excess commitments). The sum of all UTXO commitments minus the supply is a valid public key. The sum of all kernel public keys equals the above public key (sum of UTXO commitments minus supply). The root hashes of the UTXO PMMR, the range proofs PMMR and the kernels MMR match a block header with a valid proof of work chain. All range proofs are valid. While not necessary to validate the full chain state, accepting and validating new blocks also requires the output features (coinbase or plain), making the full output data necessary for all UTXOs. At minimum, this requires the following data: The block headers chain. All kernels, in order of inclusion in the chain. This also allows the reconstruction of the kernel MMR. All unspent outputs. The UTXO MMR and the range proof MMR (to learn the hashes of pruned data).","title":"State & Pruning"},{"location":"wiki/chain-state/state-and-pruning/#state-and-pruning","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 .","title":"State and Pruning"},{"location":"wiki/chain-state/state-and-pruning/#state-storage","text":"Recall that the Grin chain includes the following data: Outputs, which include for each output: A Pedersen commitment (33 bytes). A range proof (640KB). Inputs, which are just output references (32 bytes). Transaction kernels, which include for each transaction: The excess commitment sum for the transaction (33 bytes). A signature generated with the excess (~70 bytes). A block header with a valid proof of work and roots of the Merkle trees. Each node maintains 3 MMRs: An output set MMR. Rangeproofs MMR. Transaction kernels MMR. All outputs, rangeproofs and kernels are added in their respective MMRs in the order they occur in each block (recall that block data is required to be sorted).","title":"State Storage"},{"location":"wiki/chain-state/state-and-pruning/#pruning","text":"As outputs get spent, both their commitment and rangeproof data can be removed. In addition, the corresponding output and range proof MMRs can be pruned of their hash entires. PMMR A pruned MMR is referred to as a PMMR. Following pruning, the full state of the chain consists of the following data: The unspent output set (UTXO). A rangeproof for each unspent output. All transaction kernels. In addition, all block headers are required to anchor the above state with a valid proof of work (the state corresponds to the most worked chain).","title":"Pruning"},{"location":"wiki/chain-state/state-and-pruning/#validation","text":"Pruning removes as much data as possible while keeping all the guarantees of a full Mimblewimble-style validation. This is necessary to keep a pruning node state's sane, but also on first fast sync, where only the minimum amount of data is sent to a new node. The full validation of the chain state requires that: All kernel signatures verify against their public keys (excess commitments). The sum of all UTXO commitments minus the supply is a valid public key. The sum of all kernel public keys equals the above public key (sum of UTXO commitments minus supply). The root hashes of the UTXO PMMR, the range proofs PMMR and the kernels MMR match a block header with a valid proof of work chain. All range proofs are valid. While not necessary to validate the full chain state, accepting and validating new blocks also requires the output features (coinbase or plain), making the full output data necessary for all UTXOs. At minimum, this requires the following data: The block headers chain. All kernels, in order of inclusion in the chain. This also allows the reconstruction of the kernel MMR. All unspent outputs. The UTXO MMR and the range proof MMR (to learn the hashes of pruned data).","title":"Validation"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/","text":"Technical Introduction to Mimblewimble Tongue Tying for Everyone This document is targeted at readers with a good understanding of blockchains and basic cryptography. With that in mind, we attempt to explain the technical buildup of Mimblewimble and how it's applied in Grin. We hope this document is understandable to most technically-minded readers. Our objective is to encourage you to get interested in Grin and contribute in any way possible. To achieve this objective, we will introduce the main concepts required for a good understanding of Grin as a Mimblewimble implementation. We will start with a brief description of some relevant properties of Elliptic Curve Cryptography (ECC) to lay the foundation on which Grin is based and then describe all the key elements of a Mimblewimble blockchain's transactions and blocks. Tiny Bits of Elliptic Curves We start with a brief primer on Elliptic Curve Cryptography, reviewing just the properties necessary to understand how Mimblewimble works and without delving too much into the intricacies of ECC. For readers who would want to dive deeper into those assumptions, there are other opportunities to learn more . An Elliptic Curve for the purpose of cryptography is simply a large set of points that we will call C . These points can be added, subtracted, or multiplied by integers (also called scalars). Given such a point H , an integer k and using the scalar multiplication operation we can compute k*H , which is also a point on curve C . Given another integer j we can also calculate (k+j)*H , which equals k*H + j*H . The addition and scalar multiplication operations on an elliptic curve maintain the commutative and associative properties of addition and multiplication: (k+j)*H = k*H + j*H In ECC, if we pick a very large number k as a private key, k*H is considered the corresponding public key. Even if one knows the value of the public key k*H , deducing k is close to impossible (or said differently, while multiplication is trivial, \"division\" by curve points is extremely difficult). The previous formula (k+j)*H = k*H + j*H , with k and j both private keys, demonstrates that a public key obtained from the addition of two private keys ( (k+j)*H ) is identical to the addition of the public keys for each of those two private keys ( k*H + j*H ). In the Bitcoin blockchain, Hierarchical Deterministic wallets heavily rely on this principle. Mimblewimble and the Grin implementation do as well. Transacting with Mimblewimble The structure of transactions demonstrates a crucial tenet of Mimblewimble: strong privacy and confidentiality guarantees. The validation of Mimblewimble transactions relies on two basic properties: Verification of zero sums. The sum of outputs minus inputs always equals zero, proving that the transaction did not create new funds, without revealing the actual amounts . Possession of private keys. Like with most other cryptocurrencies, ownership of transaction outputs is guaranteed by the possession of ECC private keys. However, the proof that an entity owns those private keys is not achieved by directly signing the transaction. The next sections on balance, ownership, change and proofs details how those two fundamental properties are achieved. Balance Building upon the properties of ECC we described above, one can obscure the values in a transaction. If v is the value of a transaction input or output and H a point on the elliptic curve C , we can simply embed v*H instead of v in a transaction. This works because using the ECC operations, we can still validate that the sum of the outputs of a transaction equals the sum of inputs: v1 + v2 = v3 => v1*H + v2*H = v3*H Verifying this property on every transaction allows the protocol to verify that a transaction doesn't create money out of thin air, without knowing what the actual values are. However, there are a finite number of usable values (transaction amounts) and one could try every single one of them to guess the value of the transaction. In addition, knowing v1 (from a previous transaction for example) and the resulting v1*H reveals all outputs with value v1 across the blockchain. For these reasons, we introduce a second point G on the same elliptic curve (practically G is just another generator point on the same curve group as H ) and a private key r used as a blinding factor . An input or output value in a transaction can then be expressed as: r*G + v*H Where: r is a private key used as a blinding factor, G is a point on the elliptic curve C and their product r*G is the public key for r (using G as generator point). v is the value of an input or output and H is another point on the elliptic curve C , together producing another public key v*H (using H as generator point). Neither v nor r can be deduced, leveraging the fundamental properties of Elliptic Curve Cryptography. r*G + v*H is called a Pedersen Commitment . As an example, let's assume we want to build a transaction with two inputs and one output. We have (ignoring fees): vi1 and vi2 as input values. vo3 as output value. Such that: vi1 + vi2 = vo3 Generating a private key as a blinding factor for each input value and replacing each value with their respective Pedersen Commitments in the previous equation, we obtain: (ri1*G + vi1*H) + (ri2*G + vi2*H) = (ro3*G + vo3*H) Which as a consequence requires that: ri1 + ri2 = ro3 This is the first pillar of Mimblewimble: the arithmetic required to validate a transaction can be done without knowing any of the values. As a final note, this idea is actually derived from Greg Maxwell's Confidential Transactions , which is itself derived from an Adam Back proposal for homomorphic values applied to Bitcoin. Ownership In the previous section we introduced a private key as a blinding factor to obscure the transaction's values. The second insight of Mimblewimble is that this private key can be leveraged to prove ownership of the value. Alice sends you 3 coins and to obscure that amount, you chose 28 as your blinding factor (note that in practice, the blinding factor being a private key, it's an extremely large number). Somewhere on the blockchain, the following output appears and should only be spendable by you: X = 28*G + 3*H X , the result of the addition, is visible by everyone. The value 3 is only known to you and Alice, and 28 is only known to you. To transfer those 3 coins again, the protocol requires 28 to be known somehow. To demonstrate how this works, let's say you want to transfer those 3 same coins to Carol. You need to build a simple transaction such that: Xi => Y Where Xi is an input that spends your X output and Y is Carol's output. There is no way to build such a transaction and balance it without knowing your private key of 28. Indeed, if Carol is to balance this transaction, she needs to know both the value sent and your private key so that: Y - Xi = (28*G + 3*H) - (28*G + 3*H) = 0*G + 0*H By checking that everything has been zeroed out, we can again make sure that no new money has been created. Wait! Stop! Now you know the private key in Carol's output (which, in this case, must be the same as yours to balance out) and so you could steal the money back from Carol! To solve this, Carol uses a private key of her choosing. She picks 113 say, and what ends up on the blockchain is: Y - Xi = (113*G + 3*H) - (28*G + 3*H) = 85*G + 0*H Now the transaction no longer sums to zero and we have an excess value (85), which is the result of the summation of all blinding factors. Because 85*G is a valid public key for the generator point G the input and output values must sum to zero and the transaction is thus valid, since x*G + y*H is a valid public key for generator point G if and only if y = 0 . So all the protocol needs to verify is that ( Y - Xi ) is a valid public key for generator point G and that the transacting parties collectively can produce its private key (85 in the above example). The simplest way to do so is to require a signature built with the excess value (85), which then ensures that: The transacting parties collectively can produce the private key (the excess value) The sum of the outputs minus the inputs are zero (because only a valid public key will check against the signature). This signature, attached to every transaction, together with some additional data (like mining fees), is called a transaction kernel and is checked by all validators. Some Finer Points This section elaborates on the building of transactions by discussing how change is introduced and the requirement for range proofs so all values are proven to be non-negative. Neither of these are absolutely required to understand Mimblewimble and Grin, so if you're in a hurry, feel free to jump straight to Putting It All Together . Change Let's say you only want to send 2 coins to Carol from the 3 you received from Alice. To do this you would send the remaining 1 coin back to yourself as change. You generate another private key (say 12) as a blinding factor to protect your change output. Carol uses her own private key as before. Change output: 12*G + 1*H Carol's output: 113*G + 2*H What ends up on the blockchain is something very similar to before. And the signature is again built with the excess value, 97 in this example. (12*G + 1*H) + (113*G + 2*H) - (28*G + 3*H) = 97*G + 0*H Range Proofs In all the above calculations, we rely on the transaction values to always be positive. The introduction of negative amounts would be extremely problematic as one could create new funds in every transaction. For example, one could create a transaction with an input of 2 and outputs of 5 and -3 and still obtain a well-balanced transaction. This can't be easily detected because even if x is negative, the corresponding point x*H on the curve looks like any other. To solve this problem, Mimblewimble leverages another cryptographic concept (also coming from Confidential Transactions) called range proofs: a proof that a number falls within a given range, without revealing the number. We won't elaborate on the range proof, but you just need to know that for any r*G + v*H we can build a proof that will show that v is greater than zero and does not overflow. It's also important to note that range proofs for both the blinding factor and the values are needed. The reason for this is that it prevents a censoring attack where a third party would be able to lock UTXOs without knowing their private keys by creating a transaction such as the following: Carol's UTXO: 113*G + 2*H Attacker's output: (113 + 99)*G + 2*H which can be signed by the attacker because Carol's blinding factor cancels out in the equation Y - Xi : Y - Xi = ((113 + 99)*G + 2*H) - (113*G + 2*H) = 99*G This output ( (113 + 99)*G + 2*H ) requires that both the numbers 113 and 99 are known in order to be spent; the attacker would thus have successfully locked Carol's UTXO. The requirement for a range proof for the blinding factor prevents this because the attacker doesn't know the number 113 and thus neither (113 + 99). A more detailed description of range proofs is further detailed in the range proof paper . Putting It All Together A Mimblewimble transaction includes the following: A set of inputs, that reference and spend a set of previous outputs. A set of new outputs that include: A value and a blinding factor (which is just a new private key) multiplied on a curve and summed to be r*G + v*H . A range proof that among other things shows that v is non-negative. An transaction fee in cleartext. A signature whose private key is computed by taking the excess value (the sum of all output values plus the fee, minus the input values). Blocks and Chain State We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create money and proof of ownership is established through private keys. The Mimblewimble block format builds on this by introducing one additional concept: cut-through . With this addition, a Mimblewimble chain gains: Extremely good scalability, as the great majority of transaction data can be eliminated over time, without compromising security. Further anonymity by mixing and removing transaction data. Transaction Aggregation Recall that a transaction consists of the following: a set of inputs that reference and spent a set of previous outputs a set of new outputs a transaction kernel consisting of: kernel excess (the public key of the excess value) transaction signature whose public key is the kernel excess A transaction is validated by determining that the kernel excess is a valid public key: (42*G + 1*H) + (99*G + 2*H) - (113*G + 3*H) = 28*G + 0*H The public key in this example is 28*G . We can say the following is true for any valid transaction (ignoring fees for simplicity): sum(outputs) - sum(inputs) = kernel_excess The same holds true for blocks themselves once we realize a block is simply a set of aggregated inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs from it and equating the resulting Pedersen commitment to the sum of the kernel excesses: sum(outputs) - sum(inputs) = sum(kernel_excess) Simplifying slightly, (again ignoring transaction fees) we can say that Mimblewimble blocks can be treated exactly as Mimblewimble transactions. Kernel Offsets There is a subtle problem with Mimblewimble blocks and transactions as described above. It is possible (and in some cases trivial) to reconstruct the constituent transactions in a block. This is clearly bad for privacy. This is the \"subset\" problem: given a set of inputs, outputs, and transaction kernels a subset of these will recombine to reconstruct a valid transaction. Consider the following two transactions: (in1, in2) -> (out1), (kern1) (in3) -> (out2), (kern2) We can aggregate them into the following block (or aggregate transaction): (in1, in2, in3) -> (out1, out2), (kern1, kern2) It is trivially easy to try all possible permutations to recover one of the transactions (where it successfully sums to zero): (in1, in2) -> (out1), (kern1) We also know that everything remaining can be used to reconstruct the other valid transaction: (in3) -> (out2), (kern2) Remember that the kernel excess r*G simply is the public key of the excess value r . To mitigate this we redefine the kernel excess from r*G to (r-kernel_offset)*G and distribute the kernel offset to be included with every transaction kernel. The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the commitments sum to zero: sum(outputs) - sum(inputs) = r*G = (r-kernel_offset)*G + kernel_offset*G or alternatively sum(outputs) - sum(inputs) = kernel_excess + kernel_offset*G For a commitment r*G + 0*H with the offset a , the transaction is signed with (r-a) and a is published so that r*G can be calculated in order to verify the validity of the transaction. During block construction all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block. The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved. sum(outputs) - sum(inputs) = sum(kernel_excess) + kernel_offset*G Cut-through Blocks let miners assemble multiple transactions into a single set that's added to the chain. In the following block representations, containing 3 transactions, we only show inputs and outputs of transactions. Inputs reference outputs they spend. An output included in a previous block is marked with a lower-case x. I1 ( x1 ) --- O1 |- O2 I2 ( x2 ) --- O3 I3 ( O2 ) -| I4 ( O3 ) --- O4 |- O5 We notice the two following properties: Within this block, some outputs are directly spent by following inputs ( I3 spends O2 and I4 spends O3 ). The structure of each transaction does not actually matter. Since all transactions individually sum to zero, the sum of all transaction inputs and outputs must be zero. Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels ) and that the whole block did not create any coins (other than what's allowed as the mining reward). Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block: I1(x1) | O1 I2(x2) | O4 | O5 Note that all transaction structure has been eliminated and the order of inputs and outputs does not matter anymore. However, the sum of all inputs and outputs is still guaranteed to be zero. A block is simply built from: A block header. The list of inputs remaining after cut-through. The list of outputs remaining after cut-through. A single kernel offset to cover the full block. The transaction kernels containing, for each transaction: The public key r*G obtained from the summation of all inputs and outputs. The signatures generated using the excess value. The mining fee. When structured this way, a Mimblewimble block offers extremely good privacy guarantees: Intermediate (cut-through) transactions will be represented only by their transaction kernels. All outputs look the same: very large numbers that are impossible to meaningfully differentiate from one another. If someone wants to exclude a specific output, they'd have to exclude all. All transaction structure has been removed, making it impossible to tell which inputs and outputs match. And yet, it all still validates! Cut-through All The Way Going back to the previous example block, outputs x1 and x2 , spent by I1 and I2 , must have appeared previously in the blockchain. So after the addition of this block, those outputs as well as I1 and I2 can also be removed from the blockchain as they now are intermediate transactions. We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information: The total amount of coins created by mining in the chain. The complete set of unspent outputs. The transactions kernels for each transaction. The first piece of information can be deduced just using the block height. Both the UTXOs and the transaction kernels are extremely compact. This has two important consequences: The blockchain a node needs to maintain is very small (on the order of a few gigabytes for a bitcoin-sized blockchain, and potentially optimizable to a few hundreds of megabytes). When a new node joins the network the amount of information that needs to be transferred is very small. In addition, the UTXO set cannot be tampered with. Adding or removing even one input or output would change the sum of the transactions to be something other than zero. Conclusion In this document we covered the basic principles that underlie a Mimblewimble blockchain. By using the addition properties of Elliptic Curve Cryptography, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers.","title":"Technical Introduction to Mimblewimble"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#technical-introduction-to-mimblewimble","text":"","title":"Technical Introduction to Mimblewimble"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#tongue-tying-for-everyone","text":"This document is targeted at readers with a good understanding of blockchains and basic cryptography. With that in mind, we attempt to explain the technical buildup of Mimblewimble and how it's applied in Grin. We hope this document is understandable to most technically-minded readers. Our objective is to encourage you to get interested in Grin and contribute in any way possible. To achieve this objective, we will introduce the main concepts required for a good understanding of Grin as a Mimblewimble implementation. We will start with a brief description of some relevant properties of Elliptic Curve Cryptography (ECC) to lay the foundation on which Grin is based and then describe all the key elements of a Mimblewimble blockchain's transactions and blocks.","title":"Tongue Tying for Everyone"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#tiny-bits-of-elliptic-curves","text":"We start with a brief primer on Elliptic Curve Cryptography, reviewing just the properties necessary to understand how Mimblewimble works and without delving too much into the intricacies of ECC. For readers who would want to dive deeper into those assumptions, there are other opportunities to learn more . An Elliptic Curve for the purpose of cryptography is simply a large set of points that we will call C . These points can be added, subtracted, or multiplied by integers (also called scalars). Given such a point H , an integer k and using the scalar multiplication operation we can compute k*H , which is also a point on curve C . Given another integer j we can also calculate (k+j)*H , which equals k*H + j*H . The addition and scalar multiplication operations on an elliptic curve maintain the commutative and associative properties of addition and multiplication: (k+j)*H = k*H + j*H In ECC, if we pick a very large number k as a private key, k*H is considered the corresponding public key. Even if one knows the value of the public key k*H , deducing k is close to impossible (or said differently, while multiplication is trivial, \"division\" by curve points is extremely difficult). The previous formula (k+j)*H = k*H + j*H , with k and j both private keys, demonstrates that a public key obtained from the addition of two private keys ( (k+j)*H ) is identical to the addition of the public keys for each of those two private keys ( k*H + j*H ). In the Bitcoin blockchain, Hierarchical Deterministic wallets heavily rely on this principle. Mimblewimble and the Grin implementation do as well.","title":"Tiny Bits of Elliptic Curves"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#transacting-with-mimblewimble","text":"The structure of transactions demonstrates a crucial tenet of Mimblewimble: strong privacy and confidentiality guarantees. The validation of Mimblewimble transactions relies on two basic properties: Verification of zero sums. The sum of outputs minus inputs always equals zero, proving that the transaction did not create new funds, without revealing the actual amounts . Possession of private keys. Like with most other cryptocurrencies, ownership of transaction outputs is guaranteed by the possession of ECC private keys. However, the proof that an entity owns those private keys is not achieved by directly signing the transaction. The next sections on balance, ownership, change and proofs details how those two fundamental properties are achieved.","title":"Transacting with Mimblewimble"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#balance","text":"Building upon the properties of ECC we described above, one can obscure the values in a transaction. If v is the value of a transaction input or output and H a point on the elliptic curve C , we can simply embed v*H instead of v in a transaction. This works because using the ECC operations, we can still validate that the sum of the outputs of a transaction equals the sum of inputs: v1 + v2 = v3 => v1*H + v2*H = v3*H Verifying this property on every transaction allows the protocol to verify that a transaction doesn't create money out of thin air, without knowing what the actual values are. However, there are a finite number of usable values (transaction amounts) and one could try every single one of them to guess the value of the transaction. In addition, knowing v1 (from a previous transaction for example) and the resulting v1*H reveals all outputs with value v1 across the blockchain. For these reasons, we introduce a second point G on the same elliptic curve (practically G is just another generator point on the same curve group as H ) and a private key r used as a blinding factor . An input or output value in a transaction can then be expressed as: r*G + v*H Where: r is a private key used as a blinding factor, G is a point on the elliptic curve C and their product r*G is the public key for r (using G as generator point). v is the value of an input or output and H is another point on the elliptic curve C , together producing another public key v*H (using H as generator point). Neither v nor r can be deduced, leveraging the fundamental properties of Elliptic Curve Cryptography. r*G + v*H is called a Pedersen Commitment . As an example, let's assume we want to build a transaction with two inputs and one output. We have (ignoring fees): vi1 and vi2 as input values. vo3 as output value. Such that: vi1 + vi2 = vo3 Generating a private key as a blinding factor for each input value and replacing each value with their respective Pedersen Commitments in the previous equation, we obtain: (ri1*G + vi1*H) + (ri2*G + vi2*H) = (ro3*G + vo3*H) Which as a consequence requires that: ri1 + ri2 = ro3 This is the first pillar of Mimblewimble: the arithmetic required to validate a transaction can be done without knowing any of the values. As a final note, this idea is actually derived from Greg Maxwell's Confidential Transactions , which is itself derived from an Adam Back proposal for homomorphic values applied to Bitcoin.","title":"Balance"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#ownership","text":"In the previous section we introduced a private key as a blinding factor to obscure the transaction's values. The second insight of Mimblewimble is that this private key can be leveraged to prove ownership of the value. Alice sends you 3 coins and to obscure that amount, you chose 28 as your blinding factor (note that in practice, the blinding factor being a private key, it's an extremely large number). Somewhere on the blockchain, the following output appears and should only be spendable by you: X = 28*G + 3*H X , the result of the addition, is visible by everyone. The value 3 is only known to you and Alice, and 28 is only known to you. To transfer those 3 coins again, the protocol requires 28 to be known somehow. To demonstrate how this works, let's say you want to transfer those 3 same coins to Carol. You need to build a simple transaction such that: Xi => Y Where Xi is an input that spends your X output and Y is Carol's output. There is no way to build such a transaction and balance it without knowing your private key of 28. Indeed, if Carol is to balance this transaction, she needs to know both the value sent and your private key so that: Y - Xi = (28*G + 3*H) - (28*G + 3*H) = 0*G + 0*H By checking that everything has been zeroed out, we can again make sure that no new money has been created. Wait! Stop! Now you know the private key in Carol's output (which, in this case, must be the same as yours to balance out) and so you could steal the money back from Carol! To solve this, Carol uses a private key of her choosing. She picks 113 say, and what ends up on the blockchain is: Y - Xi = (113*G + 3*H) - (28*G + 3*H) = 85*G + 0*H Now the transaction no longer sums to zero and we have an excess value (85), which is the result of the summation of all blinding factors. Because 85*G is a valid public key for the generator point G the input and output values must sum to zero and the transaction is thus valid, since x*G + y*H is a valid public key for generator point G if and only if y = 0 . So all the protocol needs to verify is that ( Y - Xi ) is a valid public key for generator point G and that the transacting parties collectively can produce its private key (85 in the above example). The simplest way to do so is to require a signature built with the excess value (85), which then ensures that: The transacting parties collectively can produce the private key (the excess value) The sum of the outputs minus the inputs are zero (because only a valid public key will check against the signature). This signature, attached to every transaction, together with some additional data (like mining fees), is called a transaction kernel and is checked by all validators.","title":"Ownership"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#some-finer-points","text":"This section elaborates on the building of transactions by discussing how change is introduced and the requirement for range proofs so all values are proven to be non-negative. Neither of these are absolutely required to understand Mimblewimble and Grin, so if you're in a hurry, feel free to jump straight to Putting It All Together .","title":"Some Finer Points"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#change","text":"Let's say you only want to send 2 coins to Carol from the 3 you received from Alice. To do this you would send the remaining 1 coin back to yourself as change. You generate another private key (say 12) as a blinding factor to protect your change output. Carol uses her own private key as before. Change output: 12*G + 1*H Carol's output: 113*G + 2*H What ends up on the blockchain is something very similar to before. And the signature is again built with the excess value, 97 in this example. (12*G + 1*H) + (113*G + 2*H) - (28*G + 3*H) = 97*G + 0*H","title":"Change"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#range-proofs","text":"In all the above calculations, we rely on the transaction values to always be positive. The introduction of negative amounts would be extremely problematic as one could create new funds in every transaction. For example, one could create a transaction with an input of 2 and outputs of 5 and -3 and still obtain a well-balanced transaction. This can't be easily detected because even if x is negative, the corresponding point x*H on the curve looks like any other. To solve this problem, Mimblewimble leverages another cryptographic concept (also coming from Confidential Transactions) called range proofs: a proof that a number falls within a given range, without revealing the number. We won't elaborate on the range proof, but you just need to know that for any r*G + v*H we can build a proof that will show that v is greater than zero and does not overflow. It's also important to note that range proofs for both the blinding factor and the values are needed. The reason for this is that it prevents a censoring attack where a third party would be able to lock UTXOs without knowing their private keys by creating a transaction such as the following: Carol's UTXO: 113*G + 2*H Attacker's output: (113 + 99)*G + 2*H which can be signed by the attacker because Carol's blinding factor cancels out in the equation Y - Xi : Y - Xi = ((113 + 99)*G + 2*H) - (113*G + 2*H) = 99*G This output ( (113 + 99)*G + 2*H ) requires that both the numbers 113 and 99 are known in order to be spent; the attacker would thus have successfully locked Carol's UTXO. The requirement for a range proof for the blinding factor prevents this because the attacker doesn't know the number 113 and thus neither (113 + 99). A more detailed description of range proofs is further detailed in the range proof paper .","title":"Range Proofs"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#putting-it-all-together","text":"A Mimblewimble transaction includes the following: A set of inputs, that reference and spend a set of previous outputs. A set of new outputs that include: A value and a blinding factor (which is just a new private key) multiplied on a curve and summed to be r*G + v*H . A range proof that among other things shows that v is non-negative. An transaction fee in cleartext. A signature whose private key is computed by taking the excess value (the sum of all output values plus the fee, minus the input values).","title":"Putting It All Together"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#blocks-and-chain-state","text":"We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create money and proof of ownership is established through private keys. The Mimblewimble block format builds on this by introducing one additional concept: cut-through . With this addition, a Mimblewimble chain gains: Extremely good scalability, as the great majority of transaction data can be eliminated over time, without compromising security. Further anonymity by mixing and removing transaction data.","title":"Blocks and Chain State"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#transaction-aggregation","text":"Recall that a transaction consists of the following: a set of inputs that reference and spent a set of previous outputs a set of new outputs a transaction kernel consisting of: kernel excess (the public key of the excess value) transaction signature whose public key is the kernel excess A transaction is validated by determining that the kernel excess is a valid public key: (42*G + 1*H) + (99*G + 2*H) - (113*G + 3*H) = 28*G + 0*H The public key in this example is 28*G . We can say the following is true for any valid transaction (ignoring fees for simplicity): sum(outputs) - sum(inputs) = kernel_excess The same holds true for blocks themselves once we realize a block is simply a set of aggregated inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs from it and equating the resulting Pedersen commitment to the sum of the kernel excesses: sum(outputs) - sum(inputs) = sum(kernel_excess) Simplifying slightly, (again ignoring transaction fees) we can say that Mimblewimble blocks can be treated exactly as Mimblewimble transactions.","title":"Transaction Aggregation"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#kernel-offsets","text":"There is a subtle problem with Mimblewimble blocks and transactions as described above. It is possible (and in some cases trivial) to reconstruct the constituent transactions in a block. This is clearly bad for privacy. This is the \"subset\" problem: given a set of inputs, outputs, and transaction kernels a subset of these will recombine to reconstruct a valid transaction. Consider the following two transactions: (in1, in2) -> (out1), (kern1) (in3) -> (out2), (kern2) We can aggregate them into the following block (or aggregate transaction): (in1, in2, in3) -> (out1, out2), (kern1, kern2) It is trivially easy to try all possible permutations to recover one of the transactions (where it successfully sums to zero): (in1, in2) -> (out1), (kern1) We also know that everything remaining can be used to reconstruct the other valid transaction: (in3) -> (out2), (kern2) Remember that the kernel excess r*G simply is the public key of the excess value r . To mitigate this we redefine the kernel excess from r*G to (r-kernel_offset)*G and distribute the kernel offset to be included with every transaction kernel. The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the commitments sum to zero: sum(outputs) - sum(inputs) = r*G = (r-kernel_offset)*G + kernel_offset*G or alternatively sum(outputs) - sum(inputs) = kernel_excess + kernel_offset*G For a commitment r*G + 0*H with the offset a , the transaction is signed with (r-a) and a is published so that r*G can be calculated in order to verify the validity of the transaction. During block construction all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block. The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved. sum(outputs) - sum(inputs) = sum(kernel_excess) + kernel_offset*G","title":"Kernel Offsets"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#cut-through","text":"Blocks let miners assemble multiple transactions into a single set that's added to the chain. In the following block representations, containing 3 transactions, we only show inputs and outputs of transactions. Inputs reference outputs they spend. An output included in a previous block is marked with a lower-case x. I1 ( x1 ) --- O1 |- O2 I2 ( x2 ) --- O3 I3 ( O2 ) -| I4 ( O3 ) --- O4 |- O5 We notice the two following properties: Within this block, some outputs are directly spent by following inputs ( I3 spends O2 and I4 spends O3 ). The structure of each transaction does not actually matter. Since all transactions individually sum to zero, the sum of all transaction inputs and outputs must be zero. Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels ) and that the whole block did not create any coins (other than what's allowed as the mining reward). Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block: I1(x1) | O1 I2(x2) | O4 | O5 Note that all transaction structure has been eliminated and the order of inputs and outputs does not matter anymore. However, the sum of all inputs and outputs is still guaranteed to be zero. A block is simply built from: A block header. The list of inputs remaining after cut-through. The list of outputs remaining after cut-through. A single kernel offset to cover the full block. The transaction kernels containing, for each transaction: The public key r*G obtained from the summation of all inputs and outputs. The signatures generated using the excess value. The mining fee. When structured this way, a Mimblewimble block offers extremely good privacy guarantees: Intermediate (cut-through) transactions will be represented only by their transaction kernels. All outputs look the same: very large numbers that are impossible to meaningfully differentiate from one another. If someone wants to exclude a specific output, they'd have to exclude all. All transaction structure has been removed, making it impossible to tell which inputs and outputs match. And yet, it all still validates!","title":"Cut-through"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#cut-through-all-the-way","text":"Going back to the previous example block, outputs x1 and x2 , spent by I1 and I2 , must have appeared previously in the blockchain. So after the addition of this block, those outputs as well as I1 and I2 can also be removed from the blockchain as they now are intermediate transactions. We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information: The total amount of coins created by mining in the chain. The complete set of unspent outputs. The transactions kernels for each transaction. The first piece of information can be deduced just using the block height. Both the UTXOs and the transaction kernels are extremely compact. This has two important consequences: The blockchain a node needs to maintain is very small (on the order of a few gigabytes for a bitcoin-sized blockchain, and potentially optimizable to a few hundreds of megabytes). When a new node joins the network the amount of information that needs to be transferred is very small. In addition, the UTXO set cannot be tampered with. Adding or removing even one input or output would change the sum of the transactions to be something other than zero.","title":"Cut-through All The Way"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#conclusion","text":"In this document we covered the basic principles that underlie a Mimblewimble blockchain. By using the addition properties of Elliptic Curve Cryptography, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers.","title":"Conclusion"},{"location":"wiki/introduction/grin-for-bitcoiners/","text":"Grin for Bitcoiners Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . Privacy and Fungibility There are 3 main properties of Grin transactions that make them private: There are no addresses. There are no amounts. 2 transactions, one spending the other, can be merged in a block to form only one, removing all intermediary information. The 2 first properties mean that all transactions are indistinguishable from one another. Unless you directly participated in the transaction, all inputs and outputs look like random pieces of data (in lingo, they're all random curve points). Moreover, there are no more transactions in a block. A Grin block looks just like one giant transaction and all original association between inputs and outputs is lost. Scalability As explained in the previous section, thanks to the Mimblewimble transaction and block format we can merge transactions when an output is directly spent by the input of another. It's as if when Alice gives money to Bob, and then Bob gives it all to Carol, Bob was never involved and his transaction is actually never even seen on the blockchain. Pushing that further, between blocks, most outputs end up being spent sooner or later by another input. So all spent outputs can be safely removed . And the whole blockchain can be stored, downloaded and fully verified in just a few gigabytes or less (assuming a number of transactions similar to bitcoin). This means that the Grin blockchain scales with the number of users (unspent outputs), not the number of transactions. At the moment, there is one caveat to that: a small piece of data (called a kernel , about 100 bytes) needs to stay around for each transaction. But we're working on optimizing that as well. Scripting Maybe you've heard that Mimblewimble doesn't support scripts. And in some way, that's true. But thanks to cryptographic trickery , many contracts that in Bitcoin would require a script can be achieved with Grin using properties of Elliptic Curve Cryptography. So far, we know how to do: Multi-signature transactions. Atomic swaps. Time-locked transactions and outputs. Lightning Network Emission Rate Bitcoin's 10 minute block time has its initial 50 btc reward cut in half every 4 years until there are 21 million bitcoin in circulation. Grin's emission rate is linear, meaning it never drops. The block reward is currently set at 60 grin with a block goal of 60 seconds. This still works because 1) dilution trends toward zero and 2) a non-negligible amount of coins gets lost or destroyed every year. FAQ Wait, what!? No address? Nope, no address. All outputs in Grin are unique and have no common data with any previous output. Instead of relying on a known address to send money, transactions have to be built interactively, with two (or more) wallets exchanging data with one another. This interaction does not require both parties to be online at the same time . Practically speaking, there are many ways for two programs to interact privately and securely. This interaction could even take place over email or Signal (or carrier pigeons). If transaction information gets removed, can I just cheat and create money? No, and this is where Mimblewimble and Grin shine. Confidential transactions are a form of homomorphic encryption . Without revealing any amount, Grin can verify that the sum of all transaction inputs equal the sum of transaction outputs, plus the fee. Going even further, comparing the sum of all money created by mining with the total sum of money that's being held, Grin nodes can check the correctness of the total money supply. If I listen to transaction relay, can't I just figure out who they belong to before being cut-through? You can figure out which outputs are being spent by which transaction, but the trail of data stops here. All inputs and outputs look like random pieces of data, so you can't tell if the money was transferred, still belongs to the same person, which output is the actual transfer and which is the change, etc. Grin transactions are built with no identifiable piece of information . In addition, Grin leverages Dandelion relay , which provides additional anonymity as to which IP or client the transaction originated from, and allows for transactions to be aggregated. What about the quantum computaggedon? In every Grin output, we also include a bit of hashed data, which is quantum safe. If quantum computing was to become a reality, we can safely introduce additional verification that would protect existing coins from being hacked. How does all this magic work? Click Next down below.","title":"Grin for Bitcoiners"},{"location":"wiki/introduction/grin-for-bitcoiners/#grin-for-bitcoiners","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 .","title":"Grin for Bitcoiners"},{"location":"wiki/introduction/grin-for-bitcoiners/#privacy-and-fungibility","text":"There are 3 main properties of Grin transactions that make them private: There are no addresses. There are no amounts. 2 transactions, one spending the other, can be merged in a block to form only one, removing all intermediary information. The 2 first properties mean that all transactions are indistinguishable from one another. Unless you directly participated in the transaction, all inputs and outputs look like random pieces of data (in lingo, they're all random curve points). Moreover, there are no more transactions in a block. A Grin block looks just like one giant transaction and all original association between inputs and outputs is lost.","title":"Privacy and Fungibility"},{"location":"wiki/introduction/grin-for-bitcoiners/#scalability","text":"As explained in the previous section, thanks to the Mimblewimble transaction and block format we can merge transactions when an output is directly spent by the input of another. It's as if when Alice gives money to Bob, and then Bob gives it all to Carol, Bob was never involved and his transaction is actually never even seen on the blockchain. Pushing that further, between blocks, most outputs end up being spent sooner or later by another input. So all spent outputs can be safely removed . And the whole blockchain can be stored, downloaded and fully verified in just a few gigabytes or less (assuming a number of transactions similar to bitcoin). This means that the Grin blockchain scales with the number of users (unspent outputs), not the number of transactions. At the moment, there is one caveat to that: a small piece of data (called a kernel , about 100 bytes) needs to stay around for each transaction. But we're working on optimizing that as well.","title":"Scalability"},{"location":"wiki/introduction/grin-for-bitcoiners/#scripting","text":"Maybe you've heard that Mimblewimble doesn't support scripts. And in some way, that's true. But thanks to cryptographic trickery , many contracts that in Bitcoin would require a script can be achieved with Grin using properties of Elliptic Curve Cryptography. So far, we know how to do: Multi-signature transactions. Atomic swaps. Time-locked transactions and outputs. Lightning Network","title":"Scripting"},{"location":"wiki/introduction/grin-for-bitcoiners/#emission-rate","text":"Bitcoin's 10 minute block time has its initial 50 btc reward cut in half every 4 years until there are 21 million bitcoin in circulation. Grin's emission rate is linear, meaning it never drops. The block reward is currently set at 60 grin with a block goal of 60 seconds. This still works because 1) dilution trends toward zero and 2) a non-negligible amount of coins gets lost or destroyed every year.","title":"Emission Rate"},{"location":"wiki/introduction/grin-for-bitcoiners/#faq","text":"","title":"FAQ"},{"location":"wiki/introduction/grin-for-bitcoiners/#wait-what-no-address","text":"Nope, no address. All outputs in Grin are unique and have no common data with any previous output. Instead of relying on a known address to send money, transactions have to be built interactively, with two (or more) wallets exchanging data with one another. This interaction does not require both parties to be online at the same time . Practically speaking, there are many ways for two programs to interact privately and securely. This interaction could even take place over email or Signal (or carrier pigeons).","title":"Wait, what!? No address?"},{"location":"wiki/introduction/grin-for-bitcoiners/#if-transaction-information-gets-removed-can-i-just-cheat-and-create-money","text":"No, and this is where Mimblewimble and Grin shine. Confidential transactions are a form of homomorphic encryption . Without revealing any amount, Grin can verify that the sum of all transaction inputs equal the sum of transaction outputs, plus the fee. Going even further, comparing the sum of all money created by mining with the total sum of money that's being held, Grin nodes can check the correctness of the total money supply.","title":"If transaction information gets removed, can I just cheat and create money?"},{"location":"wiki/introduction/grin-for-bitcoiners/#if-i-listen-to-transaction-relay-cant-i-just-figure-out-who-they-belong-to-before-being-cut-through","text":"You can figure out which outputs are being spent by which transaction, but the trail of data stops here. All inputs and outputs look like random pieces of data, so you can't tell if the money was transferred, still belongs to the same person, which output is the actual transfer and which is the change, etc. Grin transactions are built with no identifiable piece of information . In addition, Grin leverages Dandelion relay , which provides additional anonymity as to which IP or client the transaction originated from, and allows for transactions to be aggregated.","title":"If I listen to transaction relay, can't I just figure out who they belong to before being cut-through?"},{"location":"wiki/introduction/grin-for-bitcoiners/#what-about-the-quantum-computaggedon","text":"In every Grin output, we also include a bit of hashed data, which is quantum safe. If quantum computing was to become a reality, we can safely introduce additional verification that would protect existing coins from being hacked.","title":"What about the quantum computaggedon?"},{"location":"wiki/introduction/grin-for-bitcoiners/#how-does-all-this-magic-work","text":"Click Next down below.","title":"How does all this magic work?"},{"location":"wiki/introduction/mimblewimble/commitments/","text":"Commitments In cryptography a Commitment (or commitment scheme) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public). The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person. They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \"committed\" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing. They have two important properties: Hiding - Nobody but the committer can see or infer the actual value behind the commitment. Binding - The committer can't change the value after the commitment is published. ECC can be used to create a commitment. Let\u2019s say we want to commit to the value 8 . commit (8) -> 8*G To everybody else, our commitment 8*G just looks like a random point, and we publish it. Some time later we reveal our value. reveal 8 And now any observer could multiply our stated value 8, by the public point G and verify that their result is equal to the commitment we published ealier. verify (8, commitment) == 8*G ? --> True/False However, there\u2019s a major issue. If our value is within a small range, which is typically the case, it\u2019s simple for anybody to find out what value we committed to, even if we don\u2019t reveal it; By trying out (brute-forcing) different values, they can find the one value that, when multiplied by G , matches the original commitment. Example Say we're betting on how many goals a team would score by the end of the year. Our guess is 23, and we commit to it by publishing the commitment 23*G . Problem is, it would be trivial for anybody to uncover our guess simply by trying to commit to 1, 2, 3, 4 etc and checking each result if it's equal to our commitment. In this case, our value will be revealed after only 23 simple steps. What\u2019s the solution? Blinding Factor The issue is solved by adding a blinding factor r, which is a random 256-bit integer (range 0 to 2^256, same as a typical private key) used to blind the value so that it can\u2019t be guessed and uncovered. We could try adding the blinding factor by comitting (8+r)*G and then revealing 8 and r . But, doing so breaks the binding property of the commitment, because instead of revealing value 8 and blinding factor r , we could reveal 7 and r+1 or any other value. Therefore, we require a different method to include r . Pedersen Commitments Introducing G \u2019s twin, H . H is another generator point, distinct from G (note how it\u2019s the next letter in the alphabet). Both are nothing-up-my-sleeve-points, meaning nobody knows n such that n*G = H . Using H we can blind the value while keeping the commitment binding. r*G + v*H This specific form of commitement is called a Pedersen Commitment. A Mimblewimble output is just a Pedersen Commitment , as we\u2019ll soon see. Its values are as follows: r is the blinding factor, and r*G is the public key point for r (using G as generator point). v is the value committed, and v*H is the public key point for v (using H as generator point). Homomorphic Commitments Commitments with homomorphic properties means you can perform calculations on encrypted values without decrypting them first. The result of the computation is a commitment which is identical to the result if the operations had been performed on the unencrypted values. They allow us to do as follows: commit (x) \u21d2 C 1 commit (y) \u21d2 C 2 commit (x+y) \u21d2 Z = C 1 + C 2 f we add two commitments to each other, the result would be an entirely new, valid commitment, which actually commits to the value x + y . So we\u2019re able to perform a math operation (addition) unto encrypted data (commitments) while keeping the underlying values \u201cintact\u201d. Elliptic curve commitments indeed have these homomorphic properties. We can do the following: x*G + y*G => (x + y)*G Notice how we add two different curve points and the result is a different point, which is a commitment to the sum of the values we\u2019re hiding. Similarly, we can add up two Pedersen Commitments. First let's create two of them: C 1 = r 1 G + v 1 H C 2 = r 2 G + v 2 H The point Z (remember a commitment is simply a point on the curve) is the result of addition between points C 1 and C 2 . Z = C1 + C2 Z = r1*G + r2*G + v1*H + v2*H So we can calculate what Z is: Z = (r1 + r2)*G + (v1 + v2)*H Hence point Z is a pedersen commitment that is the sum of commitments C 1 and C 2 . This is the foundation for the Elliptic-curve algebra used in Mimblewimble to prove both ownership of outputs (coins) and non-inflation. Finessing commitments \u21a9","title":"Commitments"},{"location":"wiki/introduction/mimblewimble/commitments/#commitments","text":"In cryptography a Commitment (or commitment scheme) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public). The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person. They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \"committed\" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing. They have two important properties: Hiding - Nobody but the committer can see or infer the actual value behind the commitment. Binding - The committer can't change the value after the commitment is published. ECC can be used to create a commitment. Let\u2019s say we want to commit to the value 8 . commit (8) -> 8*G To everybody else, our commitment 8*G just looks like a random point, and we publish it. Some time later we reveal our value. reveal 8 And now any observer could multiply our stated value 8, by the public point G and verify that their result is equal to the commitment we published ealier. verify (8, commitment) == 8*G ? --> True/False However, there\u2019s a major issue. If our value is within a small range, which is typically the case, it\u2019s simple for anybody to find out what value we committed to, even if we don\u2019t reveal it; By trying out (brute-forcing) different values, they can find the one value that, when multiplied by G , matches the original commitment. Example Say we're betting on how many goals a team would score by the end of the year. Our guess is 23, and we commit to it by publishing the commitment 23*G . Problem is, it would be trivial for anybody to uncover our guess simply by trying to commit to 1, 2, 3, 4 etc and checking each result if it's equal to our commitment. In this case, our value will be revealed after only 23 simple steps. What\u2019s the solution?","title":"Commitments"},{"location":"wiki/introduction/mimblewimble/commitments/#blinding-factor","text":"The issue is solved by adding a blinding factor r, which is a random 256-bit integer (range 0 to 2^256, same as a typical private key) used to blind the value so that it can\u2019t be guessed and uncovered. We could try adding the blinding factor by comitting (8+r)*G and then revealing 8 and r . But, doing so breaks the binding property of the commitment, because instead of revealing value 8 and blinding factor r , we could reveal 7 and r+1 or any other value. Therefore, we require a different method to include r .","title":"Blinding Factor"},{"location":"wiki/introduction/mimblewimble/commitments/#pedersen-commitments","text":"Introducing G \u2019s twin, H . H is another generator point, distinct from G (note how it\u2019s the next letter in the alphabet). Both are nothing-up-my-sleeve-points, meaning nobody knows n such that n*G = H . Using H we can blind the value while keeping the commitment binding. r*G + v*H This specific form of commitement is called a Pedersen Commitment. A Mimblewimble output is just a Pedersen Commitment , as we\u2019ll soon see. Its values are as follows: r is the blinding factor, and r*G is the public key point for r (using G as generator point). v is the value committed, and v*H is the public key point for v (using H as generator point).","title":"Pedersen Commitments"},{"location":"wiki/introduction/mimblewimble/commitments/#homomorphic-commitments","text":"Commitments with homomorphic properties means you can perform calculations on encrypted values without decrypting them first. The result of the computation is a commitment which is identical to the result if the operations had been performed on the unencrypted values. They allow us to do as follows: commit (x) \u21d2 C 1 commit (y) \u21d2 C 2 commit (x+y) \u21d2 Z = C 1 + C 2 f we add two commitments to each other, the result would be an entirely new, valid commitment, which actually commits to the value x + y . So we\u2019re able to perform a math operation (addition) unto encrypted data (commitments) while keeping the underlying values \u201cintact\u201d. Elliptic curve commitments indeed have these homomorphic properties. We can do the following: x*G + y*G => (x + y)*G Notice how we add two different curve points and the result is a different point, which is a commitment to the sum of the values we\u2019re hiding. Similarly, we can add up two Pedersen Commitments. First let's create two of them: C 1 = r 1 G + v 1 H C 2 = r 2 G + v 2 H The point Z (remember a commitment is simply a point on the curve) is the result of addition between points C 1 and C 2 . Z = C1 + C2 Z = r1*G + r2*G + v1*H + v2*H So we can calculate what Z is: Z = (r1 + r2)*G + (v1 + v2)*H Hence point Z is a pedersen commitment that is the sum of commitments C 1 and C 2 . This is the foundation for the Elliptic-curve algebra used in Mimblewimble to prove both ownership of outputs (coins) and non-inflation. Finessing commitments \u21a9","title":"Homomorphic Commitments"},{"location":"wiki/introduction/mimblewimble/ecc/","text":"Preface The following three-part series is intended for those who wish to understand what goes on inside Mimblewimble and Grin. We try to make this objective more accessible by going through the cryptographic primitives required to know first, without diving into proofs and specifics. Once those are in order, we connect everything explain how Mimblewimble works. Elliptic Curves Commitments Mimblewimble For the original introduction (along with many translations), refer to here . Elliptic Curve Cryptography Mimblewimble relies entirely on Elliptic-curve cryptography (ECC), an approach to public-key cryptography. Put simply, given an algebraic curve of the form y^2 = x^3 + ax + b , pairs of private and public keys can be derived. Picking a private key and computing its correspnding public key is trivial, but the reverse operation public key -> private key is called the discrete logarithm problem , and is considered to be computationally infeasible. Let's review the basics. Operations These are the relevant mathematical operations we can do on Elliptic-curve points. Addition - Given two points, we can add them to one another (or subtract) and the result would be a new point on the curve. Multiplication - Given a point, we can multiply it any number of times. Addition Given three aligned points P , Q and R , their sum is always 0. We treat this as an inherent property of elliptic curves. P + Q + R = 0 We can then write it as: P + Q = -R So that adding the two points P and Q results in -R, the inverse of R. If we draw a line passing through P and Q, this line will cross a third point on the curve, R (so that P, Q and R are aligned). If we take the inverse of this point, which is simply the one symmetric to it about the x-axis, we have found the result of adding two curve points, P + Q. Let\u2019s illustrate: In other words, addition of points is basically hopping around on the curve to a different, seemingly random point; It looks random unless you know the exact operation performed to reach it. Multiplication We can\u2019t multiply a point by another point, but we can multiply a point by a number (scalar). Multiplying point P by scalar k would simply require adding point P onto it self k times. This operation is easily demonstrated by assigning k=2 so that k*P = P+P . To illustrate how it would look like on the curve, we draw a tangent line. You can imagine that the line intersects three points, whereas two of them are P , such that: P + P = -R To calculate 8*P for e.g. wouldn\u2019t take 8 operations, but only 3; you can find 2*P , then add it onto itself, and then add 4*P onto itself, for the final result of 8*P . Key Pairs An ECC system defines a publicly known constant curve point called the generator point, G . The generator point is used to compute any public key. A key pair consists of: Private key k \u2013 A randomly chosen 256-bit integer (scalar). Public key P \u2013 An Elliptic-curve point derived by multiplying generator point G by the private key. And more clearly, a public key (of private key k ) is as follows: P = k*G This is easy to compute. But, if everybody knows points P and G, can they find out what k is? The answer is no; The difficulty of getting from one point to another is precisely the definition of the Elliptic curve discrete logarithm problem. Secp256k1 The specific Elliptic curve that Grin employs is rust-secp256k1 (y 2 = x 3 + 7) using Schnorr signature scheme. Elliptic Curve Cryptography: a gentle introduction \u21a9 A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography \u21a9 Cryptography: From Mathematical Magic to Secure Communication \u21a9","title":"Elliptic Curves"},{"location":"wiki/introduction/mimblewimble/ecc/#elliptic-curve-cryptography","text":"Mimblewimble relies entirely on Elliptic-curve cryptography (ECC), an approach to public-key cryptography. Put simply, given an algebraic curve of the form y^2 = x^3 + ax + b , pairs of private and public keys can be derived. Picking a private key and computing its correspnding public key is trivial, but the reverse operation public key -> private key is called the discrete logarithm problem , and is considered to be computationally infeasible. Let's review the basics.","title":"Elliptic Curve Cryptography"},{"location":"wiki/introduction/mimblewimble/ecc/#operations","text":"These are the relevant mathematical operations we can do on Elliptic-curve points. Addition - Given two points, we can add them to one another (or subtract) and the result would be a new point on the curve. Multiplication - Given a point, we can multiply it any number of times.","title":"Operations"},{"location":"wiki/introduction/mimblewimble/ecc/#addition","text":"Given three aligned points P , Q and R , their sum is always 0. We treat this as an inherent property of elliptic curves. P + Q + R = 0 We can then write it as: P + Q = -R So that adding the two points P and Q results in -R, the inverse of R. If we draw a line passing through P and Q, this line will cross a third point on the curve, R (so that P, Q and R are aligned). If we take the inverse of this point, which is simply the one symmetric to it about the x-axis, we have found the result of adding two curve points, P + Q. Let\u2019s illustrate: In other words, addition of points is basically hopping around on the curve to a different, seemingly random point; It looks random unless you know the exact operation performed to reach it.","title":"Addition"},{"location":"wiki/introduction/mimblewimble/ecc/#multiplication","text":"We can\u2019t multiply a point by another point, but we can multiply a point by a number (scalar). Multiplying point P by scalar k would simply require adding point P onto it self k times. This operation is easily demonstrated by assigning k=2 so that k*P = P+P . To illustrate how it would look like on the curve, we draw a tangent line. You can imagine that the line intersects three points, whereas two of them are P , such that: P + P = -R To calculate 8*P for e.g. wouldn\u2019t take 8 operations, but only 3; you can find 2*P , then add it onto itself, and then add 4*P onto itself, for the final result of 8*P .","title":"Multiplication"},{"location":"wiki/introduction/mimblewimble/ecc/#key-pairs","text":"An ECC system defines a publicly known constant curve point called the generator point, G . The generator point is used to compute any public key. A key pair consists of: Private key k \u2013 A randomly chosen 256-bit integer (scalar). Public key P \u2013 An Elliptic-curve point derived by multiplying generator point G by the private key. And more clearly, a public key (of private key k ) is as follows: P = k*G This is easy to compute. But, if everybody knows points P and G, can they find out what k is? The answer is no; The difficulty of getting from one point to another is precisely the definition of the Elliptic curve discrete logarithm problem. Secp256k1 The specific Elliptic curve that Grin employs is rust-secp256k1 (y 2 = x 3 + 7) using Schnorr signature scheme. Elliptic Curve Cryptography: a gentle introduction \u21a9 A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography \u21a9 Cryptography: From Mathematical Magic to Secure Communication \u21a9","title":"Key Pairs"},{"location":"wiki/introduction/mimblewimble/mimblewimble/","text":"Mimblewimble For the original introduction (along with many translations), refer to here . Earlier we demonstrated how a public key obtained from the addition of two private keys r and v , resulting in (v+r)*G , is identical to the addition of the public keys of each individual private key, r*G + v*G . Mimblewimble and Grin heavily rely on this principle. Transactions Every transaction has to prove two basic things: Zero sum - The sum of outputs minus inputs should always equal zero, proving that a transaction did not create new coins, without revealing the actual amounts. Possession of private keys - ownership of outputs is guaranteed by the possession of ECC private keys. However, the proof that an entity owns those private keys is not achieved by directly signing the transaction, as with most other cryptocurrencies. Going next, we'll examine how those two fundemental properties are achieved. Amounts Building upon the ECC princple desrcibed above, we can obscure the values in a transaction. If v is the amount value of an input or output and H is a generator point on the elliptic curve, we can simply embed v*H instead of v in a transaction. This works because using the ECC operations, we can validate that the sum of values in outputs, equals to the sum of values in inputs. If we subtract those sums (outputs minus inputs), the result would be 0. transaction Hidden Inputs Outputs v 1 H v 2 H v 3 H Transparent Inputs Outputs v 1 v 2 v 3 v3*H + v2*H - v3*H = (v3 + v2 - v1)*H = 0*H Recall that an input is just a reference to a past output being spent, so each input is practically an output. Verifying this property on every transaction allows the protocol to confirm that a transaction doesn't create money out of thin air, without knowing what the actual values are. However, we encounter a familiar issue; There are a finite number of usable values (amounts) and one could try every single one of them to guess the value of the transaction. Blinding Factor We introduce a blinding factor r , also used as a private key (explained later). Along with it we use a second generator point, G , on the same elliptic curve. Then, an output is expressed as: r*G + v*H r is both a blinding factor and a private key, and its public key is r*G (using G as a generator point). v is the value of an output, and its public key is v*H (using H as a generator point). The form of a Mimblewimble output is a Pedersen Commitment. Neither v nor r can be deduced, but the commiter can prove knowledge of them. We include r to obtain the following transaction. transaction Inputs Outputs r 1 G + v 1 H r 2 G + v 2 H r 3 G + v 3 H (r2*G + v2*H) + (r3*G + v3*H) - (r1*G + v1*H) = (r2 + r3 - r1)*G + 0*H Ownership In the previous section we introduced a blinding factor to obscure the transaction's values. Another insight of Mimblewimble is that this blinding factor can be leveraged to prove ownership of the value, serving also as a private key to an output. Let's illustrate this using an example: Alice sends 3 coins to Bob , and to obscure the amount, Bob chooses 28 as his blinding factor (in practice it's an extremely large number). The following output appears on the blockchain and is only spendable by Bob. X = 28*G + 3*H X is a commitment visible by everyone. The value 3 is only known to Bob and Alice, while 28 is only known to Bob. To transfer those 3 coins again, the protocol requires 28 to be known. Let's say Bob wants to send the 3 coins to Carol . He needs to build a simple transaction where Xi is his input, and Y is Carol's new output. For the transcation to be valid, proving no new coins were created, subtracting the input from the output should result in 0. Y - Xi = 0*G + 0*H = 0 If we want this transaction to sum to 0, it would look like this: Inputs Outputs 28*G + 3*H 28*G + 3*H Remember that a blinding factor also acts as a private key. But wait. We just introduced a major problem. Bob knows Carol's new blinding factor, so he can spend her output and steal it. To solve this, Carol chooses her own blinding factor, 114 . The transaction on the blockchain would then look like this: transaction Inputs Outputs 28*G + 3*H 114*G + 3*H Y - Xi = (114*G + 3*H) - (28*G + 3*H) = 86*G + 0*H Now the transaction no longer sums to zero and we have an excess value 86 . The excess value of a transaction is the sum of all outputs blinding factors, minus the sum of all inputs blinding factors, r o - r i . In this case, simply 114-28 = 86 . Then how does the protocol verify that values equal to 0? The transaction is only legitimate if Y - Xi is a valid public key for generator point G; which is the case only if Y - Xi = ... 0*H . In other words, if the values don't sum to 0, the result is recognized as an invalid public key for G. This can be verified by requiring the transactors to build a (schnorr) signature together with the excess value 86 , which ensures that: The transacting parties can collectively produce the excess value (since it's the private key of their joint signature). The sum of the outputs minus the inputs is 0, because only a valid public key for G will check against the signature. This signature, along with a commitment to the excess value (86*G, which serves as a public key to verify the signature), is called a transcation kernel. Change Let's say Bob wants to send only 2 of his coins to Carol. To do this he would send the remaining 1 coin back to back to himself, by creating an output he controls. Bob generates a private key 13 as a blinding factor for his change output. Carol uses the same private key as before. transaction with change Inputs Outputs 28*G + 3*H 114*G + 2*H 13*G + 1*H (114*G + 2*H) + (13*G + 1*H) - (28*G + 3*H) = 99*G + 0*H The signature is again built with the excess value, 99 in this example. Rangeproofs Previously, we assumed output values to always be positive. However, by introducing negative amounts, a transcation could be balanced out, for example, with an input of 2 and outputs of 5 and -3 . This can't be detected as the values would still equal to zero. A rangeproof is therefore attached to every output and proves that its value isn't negative and that its size is restricted so it doesn't overflow. We won't elaborate on this here. Putting it all together A Mimblewimble transaction includes the following: full transaction Inputs Outputs 28*G + 3*H Rangeproof 114*G + 2*H Rangeproof 13*G + 1*H Rangeproof Kernel : TX fee Signature Kernel excess Set of inputs, that reference and spend a set of previous outputs. Set of new outputs that each includes: Value and a blinding factor (a new private key), both multiplied on a curve and summed up to r*G + v*H . Rangeproof that, among other things, shows that v is non-negative. Kernel consisting of: Transaction fee in plain text. Transaction signature signed by the excess value (and verifies with the kernel excess). Kernel excess, which is the public key corresponding to the excess value (computed by sum of outputs + fee - sum of inputs ) Blocks and Chain We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create money and proof of ownership is established through private keys. The Mimblewimble block format builds on this by introducing one additional concept: cut-through. With this addition, a Mimblewimble chain gains: Extremely good scalability, as the great majority of transaction data can be eliminated over time, without compromising security. Further anonymity by mixing and removing transaction data. Transaction Aggregation While the kernel excess of a transaction can be computed by anyone, there is a major benefit in including it in every transaction's kernel, as it allows for aggregation within blocks. The following is true for any valid transcation (ignoring fees). transaction: sum(outputs) - sum(inputs) = kernel_excess The same holds true for blocks themselves once we realize a block is simply an extanded set of inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs from it, and the result would be a commitment equal to the sum of the kernel excesses. block: sum(outputs) - sum(inputs) = sum(kernel_excess) Simplifying slightly (ignoring transaction fees), we can see how a Mimblewimble block can be treated exactly as single transaction. Similarly, transactions could be aggregated before block construction and thus enter the mempool at an already aggregated state. The Dandelion stem phase does so automatically when possible, and it could also be done manually and potentially through different aggregation services. Kernel Offsets There is a subtle problem with Mimblewimble blocks and transactions as described above, which needs to be addressed. Given a set of inputs, outputs and transaction kernels, a subset of these will combine to reconstruct a valid transaction. Consider the two following transcations: 1 2 (in1, in2) -> (out1) | (kern1) (in3) -> (out2, out3) | (kern2) We can aggregate them into a block (or simply another transcation): aggregated block/transaction Inputs Outputs Kernels in1 out1 kern1 in2 out2 kern2 in3 out3 Initially it seems that the two original transactions are indistinguishable from one another within the new transaction. However, it is trivial to try all possible combinations of inputs/outputs, and find the way in which they succesfully sum to one of the kernel excesses, such that in our example: (in1, in2) - (out1) = (excess_kern1) (in3) - (out2 + out3) = (excess_kern2) We're able to easily uncover the original form of both transactions. Then how do we solve this? Remember that the kernel excess r*G is simply the public key of the excess value r . To address this issue we introduce a kernel offset and redefine a transaction's kernel excess from r*G to (r-kernel_offset)*G . The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the sum of the commitments is valid: sum(outputs) - sum(inputs) + (kernel_offset)*G = (r + kernel_offset)*G If the sum of a transaction's inputs and outputs is the commitment r*G + 0*H , the transactors generate offset a and the transaction is signed with (r-a) instead of r . But, r*G could still be computed to verify the validity of the transaction because given the new form of kernel excess (r-a)*G and the offset a . The verifier computes a*G and calculates: `kernel_excess + kernel_offset*G = sum(blinding_factors) Translated to: (r-a)*G + a*G = r*G Given r*G the transaction can then be validated. During aggregation, all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block (or aggregated transaction). The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved. Cut-through Blocks let miners assemble multiple transactions into a single set that's added to the chain. Inputs reference outputs they spend, which are shown as in(output_spent) in the following example. non-cut-through block Inputs Outputs in1(prev_out) out1 out2 in2(prev_out) out3 in3(out2) in4(out3) out4 out5 We notice the two following properties: Within this block, some outputs are immediately spent by following inputs (e.g. in3 spends out2). The structure of each transaction does not actually matter. Since all transaction values individually sum to zero, then the collective sum of all inputs and outputs must be zero. Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels) and that the whole block did not create any coins, other than what's allowed as the mining reward. Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block: cut-through block Inputs Outputs in1(prev_out) out1 in2(prev_out) out4 out5 All transaction structure has been eliminated and the order of inputs and outputs does not matter anymore, while the sum of all inputs and outputs values is still guaranteed to be zero. A block is simply built from: Block header. Set of inputs remaining after cut-through. Set of outputs remaining after cut-through. A single kernel offset (sum of all kernel offsets) to cover the full block. The transaction kernels containing, for each transaction: The public key `(r-a)*G , which is the (modified) kernel excess. The signatures generated using the (modified) excess value (r-a) as the signing private key. Mining fee. The block contents satisfy: sum(outputs) - sum(inputs) = sum(kernel_excess) + sum(kernel_offset)*G = (r-a)*G + a*G And it all still validates. Cut-through Everything Going back to the previous example block, outputs prev_out1, prev_out2 , which were spent by in01, in02 respectively, must have appeared previously in the blockchain. After the addition of this new block, those past outputs as well as in01, in02 can also be removed from the blockchain as they now are intermediate transactions. All that's needed to remain is the set of currently unspent outputs out01, out02, out05 . We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information: The total amount of coins created by mining in the chain. The complete set of unspent outputs. The transactions kernels for each transaction. The extension of this idea is that all the way from the genesis block to the latest block, every input is deleted along with its referenced output. Both the set of unspent outputs (UTXO) and transaction kernels are extremely compact. This has important consequences; The blockchain a node needs to maintain is very small, as well as the amount of information that needs to be transferred when a new node joins the network. Conclusion We covered the basic principles that underlie Mimblewimble. By using addition of elliptic curve points, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers. Further reading on how transactions are constructed: Grin Transactions Explained, Step-by-Step What\u2019s inside a Grin Transaction File?","title":"Mimblewimble"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#mimblewimble","text":"For the original introduction (along with many translations), refer to here . Earlier we demonstrated how a public key obtained from the addition of two private keys r and v , resulting in (v+r)*G , is identical to the addition of the public keys of each individual private key, r*G + v*G . Mimblewimble and Grin heavily rely on this principle.","title":"Mimblewimble"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#transactions","text":"Every transaction has to prove two basic things: Zero sum - The sum of outputs minus inputs should always equal zero, proving that a transaction did not create new coins, without revealing the actual amounts. Possession of private keys - ownership of outputs is guaranteed by the possession of ECC private keys. However, the proof that an entity owns those private keys is not achieved by directly signing the transaction, as with most other cryptocurrencies. Going next, we'll examine how those two fundemental properties are achieved.","title":"Transactions"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#amounts","text":"Building upon the ECC princple desrcibed above, we can obscure the values in a transaction. If v is the amount value of an input or output and H is a generator point on the elliptic curve, we can simply embed v*H instead of v in a transaction. This works because using the ECC operations, we can validate that the sum of values in outputs, equals to the sum of values in inputs. If we subtract those sums (outputs minus inputs), the result would be 0. transaction Hidden Inputs Outputs v 1 H v 2 H v 3 H Transparent Inputs Outputs v 1 v 2 v 3 v3*H + v2*H - v3*H = (v3 + v2 - v1)*H = 0*H Recall that an input is just a reference to a past output being spent, so each input is practically an output. Verifying this property on every transaction allows the protocol to confirm that a transaction doesn't create money out of thin air, without knowing what the actual values are. However, we encounter a familiar issue; There are a finite number of usable values (amounts) and one could try every single one of them to guess the value of the transaction.","title":"Amounts"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#blinding-factor","text":"We introduce a blinding factor r , also used as a private key (explained later). Along with it we use a second generator point, G , on the same elliptic curve. Then, an output is expressed as: r*G + v*H r is both a blinding factor and a private key, and its public key is r*G (using G as a generator point). v is the value of an output, and its public key is v*H (using H as a generator point). The form of a Mimblewimble output is a Pedersen Commitment. Neither v nor r can be deduced, but the commiter can prove knowledge of them. We include r to obtain the following transaction. transaction Inputs Outputs r 1 G + v 1 H r 2 G + v 2 H r 3 G + v 3 H (r2*G + v2*H) + (r3*G + v3*H) - (r1*G + v1*H) = (r2 + r3 - r1)*G + 0*H","title":"Blinding Factor"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#ownership","text":"In the previous section we introduced a blinding factor to obscure the transaction's values. Another insight of Mimblewimble is that this blinding factor can be leveraged to prove ownership of the value, serving also as a private key to an output. Let's illustrate this using an example: Alice sends 3 coins to Bob , and to obscure the amount, Bob chooses 28 as his blinding factor (in practice it's an extremely large number). The following output appears on the blockchain and is only spendable by Bob. X = 28*G + 3*H X is a commitment visible by everyone. The value 3 is only known to Bob and Alice, while 28 is only known to Bob. To transfer those 3 coins again, the protocol requires 28 to be known. Let's say Bob wants to send the 3 coins to Carol . He needs to build a simple transaction where Xi is his input, and Y is Carol's new output. For the transcation to be valid, proving no new coins were created, subtracting the input from the output should result in 0. Y - Xi = 0*G + 0*H = 0 If we want this transaction to sum to 0, it would look like this: Inputs Outputs 28*G + 3*H 28*G + 3*H Remember that a blinding factor also acts as a private key. But wait. We just introduced a major problem. Bob knows Carol's new blinding factor, so he can spend her output and steal it. To solve this, Carol chooses her own blinding factor, 114 . The transaction on the blockchain would then look like this: transaction Inputs Outputs 28*G + 3*H 114*G + 3*H Y - Xi = (114*G + 3*H) - (28*G + 3*H) = 86*G + 0*H Now the transaction no longer sums to zero and we have an excess value 86 . The excess value of a transaction is the sum of all outputs blinding factors, minus the sum of all inputs blinding factors, r o - r i . In this case, simply 114-28 = 86 . Then how does the protocol verify that values equal to 0? The transaction is only legitimate if Y - Xi is a valid public key for generator point G; which is the case only if Y - Xi = ... 0*H . In other words, if the values don't sum to 0, the result is recognized as an invalid public key for G. This can be verified by requiring the transactors to build a (schnorr) signature together with the excess value 86 , which ensures that: The transacting parties can collectively produce the excess value (since it's the private key of their joint signature). The sum of the outputs minus the inputs is 0, because only a valid public key for G will check against the signature. This signature, along with a commitment to the excess value (86*G, which serves as a public key to verify the signature), is called a transcation kernel.","title":"Ownership"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#change","text":"Let's say Bob wants to send only 2 of his coins to Carol. To do this he would send the remaining 1 coin back to back to himself, by creating an output he controls. Bob generates a private key 13 as a blinding factor for his change output. Carol uses the same private key as before. transaction with change Inputs Outputs 28*G + 3*H 114*G + 2*H 13*G + 1*H (114*G + 2*H) + (13*G + 1*H) - (28*G + 3*H) = 99*G + 0*H The signature is again built with the excess value, 99 in this example.","title":"Change"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#rangeproofs","text":"Previously, we assumed output values to always be positive. However, by introducing negative amounts, a transcation could be balanced out, for example, with an input of 2 and outputs of 5 and -3 . This can't be detected as the values would still equal to zero. A rangeproof is therefore attached to every output and proves that its value isn't negative and that its size is restricted so it doesn't overflow. We won't elaborate on this here.","title":"Rangeproofs"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#putting-it-all-together","text":"A Mimblewimble transaction includes the following: full transaction Inputs Outputs 28*G + 3*H Rangeproof 114*G + 2*H Rangeproof 13*G + 1*H Rangeproof Kernel : TX fee Signature Kernel excess Set of inputs, that reference and spend a set of previous outputs. Set of new outputs that each includes: Value and a blinding factor (a new private key), both multiplied on a curve and summed up to r*G + v*H . Rangeproof that, among other things, shows that v is non-negative. Kernel consisting of: Transaction fee in plain text. Transaction signature signed by the excess value (and verifies with the kernel excess). Kernel excess, which is the public key corresponding to the excess value (computed by sum of outputs + fee - sum of inputs )","title":"Putting it all together"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#blocks-and-chain","text":"We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create money and proof of ownership is established through private keys. The Mimblewimble block format builds on this by introducing one additional concept: cut-through. With this addition, a Mimblewimble chain gains: Extremely good scalability, as the great majority of transaction data can be eliminated over time, without compromising security. Further anonymity by mixing and removing transaction data.","title":"Blocks and Chain"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#transaction-aggregation","text":"While the kernel excess of a transaction can be computed by anyone, there is a major benefit in including it in every transaction's kernel, as it allows for aggregation within blocks. The following is true for any valid transcation (ignoring fees). transaction: sum(outputs) - sum(inputs) = kernel_excess The same holds true for blocks themselves once we realize a block is simply an extanded set of inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs from it, and the result would be a commitment equal to the sum of the kernel excesses. block: sum(outputs) - sum(inputs) = sum(kernel_excess) Simplifying slightly (ignoring transaction fees), we can see how a Mimblewimble block can be treated exactly as single transaction. Similarly, transactions could be aggregated before block construction and thus enter the mempool at an already aggregated state. The Dandelion stem phase does so automatically when possible, and it could also be done manually and potentially through different aggregation services.","title":"Transaction Aggregation"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#kernel-offsets","text":"There is a subtle problem with Mimblewimble blocks and transactions as described above, which needs to be addressed. Given a set of inputs, outputs and transaction kernels, a subset of these will combine to reconstruct a valid transaction. Consider the two following transcations: 1 2 (in1, in2) -> (out1) | (kern1) (in3) -> (out2, out3) | (kern2) We can aggregate them into a block (or simply another transcation): aggregated block/transaction Inputs Outputs Kernels in1 out1 kern1 in2 out2 kern2 in3 out3 Initially it seems that the two original transactions are indistinguishable from one another within the new transaction. However, it is trivial to try all possible combinations of inputs/outputs, and find the way in which they succesfully sum to one of the kernel excesses, such that in our example: (in1, in2) - (out1) = (excess_kern1) (in3) - (out2 + out3) = (excess_kern2) We're able to easily uncover the original form of both transactions. Then how do we solve this? Remember that the kernel excess r*G is simply the public key of the excess value r . To address this issue we introduce a kernel offset and redefine a transaction's kernel excess from r*G to (r-kernel_offset)*G . The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the sum of the commitments is valid: sum(outputs) - sum(inputs) + (kernel_offset)*G = (r + kernel_offset)*G If the sum of a transaction's inputs and outputs is the commitment r*G + 0*H , the transactors generate offset a and the transaction is signed with (r-a) instead of r . But, r*G could still be computed to verify the validity of the transaction because given the new form of kernel excess (r-a)*G and the offset a . The verifier computes a*G and calculates: `kernel_excess + kernel_offset*G = sum(blinding_factors) Translated to: (r-a)*G + a*G = r*G Given r*G the transaction can then be validated. During aggregation, all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block (or aggregated transaction). The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved.","title":"Kernel Offsets"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#cut-through","text":"Blocks let miners assemble multiple transactions into a single set that's added to the chain. Inputs reference outputs they spend, which are shown as in(output_spent) in the following example. non-cut-through block Inputs Outputs in1(prev_out) out1 out2 in2(prev_out) out3 in3(out2) in4(out3) out4 out5 We notice the two following properties: Within this block, some outputs are immediately spent by following inputs (e.g. in3 spends out2). The structure of each transaction does not actually matter. Since all transaction values individually sum to zero, then the collective sum of all inputs and outputs must be zero. Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels) and that the whole block did not create any coins, other than what's allowed as the mining reward. Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block: cut-through block Inputs Outputs in1(prev_out) out1 in2(prev_out) out4 out5 All transaction structure has been eliminated and the order of inputs and outputs does not matter anymore, while the sum of all inputs and outputs values is still guaranteed to be zero. A block is simply built from: Block header. Set of inputs remaining after cut-through. Set of outputs remaining after cut-through. A single kernel offset (sum of all kernel offsets) to cover the full block. The transaction kernels containing, for each transaction: The public key `(r-a)*G , which is the (modified) kernel excess. The signatures generated using the (modified) excess value (r-a) as the signing private key. Mining fee. The block contents satisfy: sum(outputs) - sum(inputs) = sum(kernel_excess) + sum(kernel_offset)*G = (r-a)*G + a*G And it all still validates.","title":"Cut-through"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#cut-through-everything","text":"Going back to the previous example block, outputs prev_out1, prev_out2 , which were spent by in01, in02 respectively, must have appeared previously in the blockchain. After the addition of this new block, those past outputs as well as in01, in02 can also be removed from the blockchain as they now are intermediate transactions. All that's needed to remain is the set of currently unspent outputs out01, out02, out05 . We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information: The total amount of coins created by mining in the chain. The complete set of unspent outputs. The transactions kernels for each transaction. The extension of this idea is that all the way from the genesis block to the latest block, every input is deleted along with its referenced output. Both the set of unspent outputs (UTXO) and transaction kernels are extremely compact. This has important consequences; The blockchain a node needs to maintain is very small, as well as the amount of information that needs to be transferred when a new node joins the network.","title":"Cut-through Everything"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#conclusion","text":"We covered the basic principles that underlie Mimblewimble. By using addition of elliptic curve points, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers. Further reading on how transactions are constructed: Grin Transactions Explained, Step-by-Step What\u2019s inside a Grin Transaction File?","title":"Conclusion"},{"location":"wiki/miscellaneous/coinbase-maturity-rule/","text":"Coinbase Maturity Rule (aka Output Lock Heights) Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 . Overview Coinbase outputs (block rewards & fees) are \"locked\" and require 1,440 confirmations (i.e 24 hours worth of blocks added to the chain) before they mature sufficiently to be spendable. This is to reduce the risk of later txs being reversed if a chain reorganization occurs. Bitcoin does something very similar, requiring 100 confirmations (Bitcoin blocks are every 10 minutes, Grin blocks are every 60 seconds) before mining rewards can be spent. Grin enforces coinbase maturity in both the transaction pool and the block validation pipeline. A transaction containing an input spending a coinbase output cannot be added to the transaction pool until it has sufficiently matured. Similarly a block is invalid if it contains an input spending a coinbase output before it has sufficiently matured. The maturity rule only applies to coinbase outputs, regular transaction outputs have an effective lock height of zero. Mimblewimble Output Lock Height An output consists of: Features (currently coinbase vs. non-coinbase) Commitment rG+vH Rangeproof To spend a regular transaction output two conditions must be met. We need to show the output has not been previously spent and we need to prove ownership of the output. A Grin transaction consists of the following: A set of inputs, each referencing a previous output being spent. A set of new outputs that include - A value v and a blinding factor (private key) r multiplied on a curve and summed to be rG+vH A range proof that shows that v is non-negative. An explicit transaction fee in the clear. A signature, computed by taking the excess blinding value (the sum of all outputs plus the fee, minus the inputs) and using it as the private key. We can show the output is unspent by looking for the commitment in the current Output set. The Output set is authoritative; if the output exists in the Output set we know it has not yet been spent. If an output does not exist in the Output set we know it has either never existed, or that it previously existed and has been spent (we will not necessarily know which). To prove ownership we can verify the transaction signature. We can only have signed the transaction if the transaction sums to zero and we know both v and r . Knowing v and r we can uniquely identify the output (via its commitment) and we can prove ownership of the output by validating the signature on the original coinbase transaction. Grin does not permit duplicate commitments to exist in the Output set at the same time. But once an output is spent it is removed from the Output set and a duplicate commitment can be added back into the Output set. This is not necessarily recommended but Grin must handle this situation in a way that does not break consensus across the network. Several things complicate this situation - It is possible for two blocks to have identical rewards, particularly for the case of empty blocks, but also possible for non-empty blocks with transaction fees. It is possible for a non-coinbase output to have the same value as a coinbase output. It is possible (but not recommended) for a miner to reuse private keys. Grin does not allow duplicate commitments to exist in the Output set simultaneously. But the Output set is specific to the state of a particular chain fork. It is possible for duplicate identical commitments to exist simultaneously on different concurrent forks. And these duplicate commitments may have different \"lock heights\" at which they mature and become spendable on the different forks. Output O 1 from block B 1 spendable at height h 1 (on fork f 1 ) Output O 1 ' from block B 2 spendable at height h 2 (on fork f 2 ) The complication here is that input I 1 will spend either O 1 or O 1 ' depending on which fork the block containing I 1 exists on. And crucially I 1 may be valid at a particular block height on one fork but not the other. Said another way - a commitment may refer to multiple outputs, all of which may have different lock heights. And we must ensure we correctly identify which output is actually being spent and that the coinbase maturity rules are correctly enforced based on the current chain state. A coinbase output, locked with the coinbase maturity rule at a specific lock height, cannot be uniquely identified, and cannot be safely spent by their commitment alone. To spend a coinbase output we need to know one additional piece of information - The block the coinbase output originated from Given this, we can verify the height of the block and derive the \"lock height\" of the output (+ 1,000 blocks).","title":"Coinbase Maturity Rule"},{"location":"wiki/miscellaneous/coinbase-maturity-rule/#coinbase-maturity-rule-aka-output-lock-heights","text":"Read this in other languages: Korean , \u7b80\u4f53\u4e2d\u6587 .","title":"Coinbase Maturity Rule (aka Output Lock Heights)"},{"location":"wiki/miscellaneous/coinbase-maturity-rule/#overview","text":"Coinbase outputs (block rewards & fees) are \"locked\" and require 1,440 confirmations (i.e 24 hours worth of blocks added to the chain) before they mature sufficiently to be spendable. This is to reduce the risk of later txs being reversed if a chain reorganization occurs. Bitcoin does something very similar, requiring 100 confirmations (Bitcoin blocks are every 10 minutes, Grin blocks are every 60 seconds) before mining rewards can be spent. Grin enforces coinbase maturity in both the transaction pool and the block validation pipeline. A transaction containing an input spending a coinbase output cannot be added to the transaction pool until it has sufficiently matured. Similarly a block is invalid if it contains an input spending a coinbase output before it has sufficiently matured. The maturity rule only applies to coinbase outputs, regular transaction outputs have an effective lock height of zero.","title":"Overview"},{"location":"wiki/miscellaneous/coinbase-maturity-rule/#mimblewimble-output-lock-height","text":"An output consists of: Features (currently coinbase vs. non-coinbase) Commitment rG+vH Rangeproof To spend a regular transaction output two conditions must be met. We need to show the output has not been previously spent and we need to prove ownership of the output. A Grin transaction consists of the following: A set of inputs, each referencing a previous output being spent. A set of new outputs that include - A value v and a blinding factor (private key) r multiplied on a curve and summed to be rG+vH A range proof that shows that v is non-negative. An explicit transaction fee in the clear. A signature, computed by taking the excess blinding value (the sum of all outputs plus the fee, minus the inputs) and using it as the private key. We can show the output is unspent by looking for the commitment in the current Output set. The Output set is authoritative; if the output exists in the Output set we know it has not yet been spent. If an output does not exist in the Output set we know it has either never existed, or that it previously existed and has been spent (we will not necessarily know which). To prove ownership we can verify the transaction signature. We can only have signed the transaction if the transaction sums to zero and we know both v and r . Knowing v and r we can uniquely identify the output (via its commitment) and we can prove ownership of the output by validating the signature on the original coinbase transaction. Grin does not permit duplicate commitments to exist in the Output set at the same time. But once an output is spent it is removed from the Output set and a duplicate commitment can be added back into the Output set. This is not necessarily recommended but Grin must handle this situation in a way that does not break consensus across the network. Several things complicate this situation - It is possible for two blocks to have identical rewards, particularly for the case of empty blocks, but also possible for non-empty blocks with transaction fees. It is possible for a non-coinbase output to have the same value as a coinbase output. It is possible (but not recommended) for a miner to reuse private keys. Grin does not allow duplicate commitments to exist in the Output set simultaneously. But the Output set is specific to the state of a particular chain fork. It is possible for duplicate identical commitments to exist simultaneously on different concurrent forks. And these duplicate commitments may have different \"lock heights\" at which they mature and become spendable on the different forks. Output O 1 from block B 1 spendable at height h 1 (on fork f 1 ) Output O 1 ' from block B 2 spendable at height h 2 (on fork f 2 ) The complication here is that input I 1 will spend either O 1 or O 1 ' depending on which fork the block containing I 1 exists on. And crucially I 1 may be valid at a particular block height on one fork but not the other. Said another way - a commitment may refer to multiple outputs, all of which may have different lock heights. And we must ensure we correctly identify which output is actually being spent and that the coinbase maturity rules are correctly enforced based on the current chain state. A coinbase output, locked with the coinbase maturity rule at a specific lock height, cannot be uniquely identified, and cannot be safely spent by their commitment alone. To spend a coinbase output we need to know one additional piece of information - The block the coinbase output originated from Given this, we can verify the height of the block and derive the \"lock height\" of the output (+ 1,000 blocks).","title":"Mimblewimble Output Lock Height"},{"location":"wiki/miscellaneous/cuckoo-cycle/","text":"Cuckoo Cycle Read this document in other languages: Korean . This document is meant to outline, at a level suitable for someone without prior knowledge, the algorithms and processes currently involved in Grin's Proof-of-Work system. We'll start with a general overview of cycles in a graph and the Cuckoo Cycle algorithm which forms the basis of Grin's proof-of-work. We'll then move on to Grin-specific details, which will outline the other systems that combine with Cuckoo Cycle to form the entirety of mining in Grin. Graphs and Cuckoo Cycle Grin's basic Proof-of-Work algorithm is called Cuckoo Cycle, which is specifically designed to be resistant to Bitcoin style hardware arms-races. It is primarily a memory bound algorithm, which (at least in theory) means that solution time is bound by memory bandwidth rather than raw processor or GPU speed. As such, mining Cuckoo Cycle solutions should be viable on most commodity hardware, and require far less energy than most other GPU, CPU or ASIC-bound proof of work algorithms. The Cuckoo Cycle POW is the work of John Tromp, and the most up-to-date documentation and implementations can be found in his github repository . The white paper is the best source of further technical details. Cycles in a Graph Cuckoo Cycle is an algorithm meant to detect cycles in a bipartite graph of N nodes and M edges. In plain terms, a bipartite graph is one in which edges (i.e. lines connecting nodes) travel only between 2 separate groups of nodes. In the case of the Cuckoo hashtable in Cuckoo Cycle, one side of the graph is an array numbered with odd indices (up to the size of the graph), and the other is numbered with even indices. A node is simply a numbered 'space' on either side of the Cuckoo Table, and an Edge is a line connecting two nodes on opposite sides. The simple graph below denotes just such a graph, with 4 nodes on the 'even' side (top), 4 nodes on the odd side (bottom) and zero Edges (i.e. no lines connecting any nodes.) A graph of 8 Nodes with Zero Edges Let's throw a few Edges into the graph now, randomly: 8 Nodes with 4 Edges, no solution We now have a randomly-generated graph with 8 nodes (N) and 4 edges (M), or an NxM graph where N=8 and M=4. Our basic Proof-of-Work is now concerned with finding 'cycles' of a certain length within this random graph, or, put simply, a series of connected nodes starting and ending on the same node. So, if we were looking for a cycle of length 4 (a path connecting 4 nodes, starting and ending on the same node), one cannot be detected in this graph. Adjusting the number of Edges M relative to the number of Nodes N changes the difficulty of the cycle-finding problem, and the probability that a cycle exists in the current graph. For instance, if our POW problem were concerned with finding a cycle of length 4 in the graph, the current difficulty of 4/8 (M/N) would mean that all 4 edges would need to be randomly generated in a perfect cycle (from 0-5-4-1-0) in order for there to be a solution. Let's add a few more edges, again at random: 8 Nodes with 7 Edges Where we can find a cycle: Cycle Found from 0-5-4-1-0 If you increase the number of edges relative to the number of nodes, you increase the probability that a solution exists. With a few more edges added to the graph above, a cycle of length 4 has appeared from 0-5-4-1-0, and the graph has a solution. Thus, modifying the ratio M/N changes the number of expected occurrences of a cycle for a graph with randomly generated edges. For a small graph such as the one above, determining whether a cycle of a certain length exists is trivial. But as the graphs get larger, detecting such cycles becomes more difficult. For instance, does this graph have a cycle of length 8, i.e. 8 connected nodes starting and ending on the same node? Meat-space Cycle Detection exercise The answer is left as an exercise to the reader, but the overall takeaways are: Detecting cycles in a graph becomes more difficult exercise as the size of a graph grows. The probability of a cycle of a given length in a graph increases as M/N becomes larger, i.e. you add more edges relative to the number of nodes in a graph. Cuckoo Cycle The Cuckoo Cycle algorithm is a specialized algorithm designed to solve exactly this problem, and it does so by inserting values into a structure called a 'Cuckoo Hashtable' according to a hash which maps nodes into possible locations in two separate arrays. This document won't go into detail on the base algorithm, as it's outlined plainly enough in section 5 of the white paper . There are also several variants on the algorithm that make various speed/memory tradeoffs, again beyond the scope of this document. However, there are a few details following from the above that we need to keep in mind before going on to more technical aspects of Grin's proof-of-work. The 'random' edges in the graph demonstrated above are not actually random but are generated by putting edge indices (0..N) through a seeded hash function, SIPHASH. Each edge index is put through the SIPHASH function twice to create two edge endpoints, with the first input value being 2 * edge_index, and the second 2 * edge_index+1. The seed for this function is based on a hash of a block header, outlined further below. The 'Proof' created by this algorithm is a set of nonces that generate a cycle of length 42, which can be trivially validated by other peers. Two main parameters, as explained above, are passed into the Cuckoo Cycle algorithm that affect the probability of a solution, and the time it takes to search the graph for a solution: The M/N ratio outlined above, which controls the number of edges relative to the size of the graph. Cuckoo Cycle fixes M at N/2, which limits the number of cycles to a few at most. The size of the graph itself How these parameters interact in practice is looked at in more detail below . Now, (hopefully) armed with a basic understanding of what the Cuckoo Cycle algorithm is intended to do, as well as the parameters that affect how difficult it is to find a solution, we move on to the other portions of Grin's POW system. Mining in Grin The Cuckoo Cycle outlined above forms the basis of Grin's mining process, however Grin uses two variantion of Cuckoo Cycle in tandem with several other systems to create a Proof-of-Work. for GPUs: Cuckaroo on 2^29 edges Tweaked every 6 months to maitain ASIC resistance. 90% of rewards at launch, linearly decreasing to 0% in 2 years. Variant of Cuckoo that enforces Mean mining. Takes 5.5GB of memory (perhaps 4GB with slowdown). for ASICs: Cuckatoo on 2^31 or more edge Variant of Cuckoo that simplifies ASIC design. 10% of rewards at launch, linearly increasing to 100% in 2 years. Takes 512 MB of memory, with random single-bit accesses to half. Mean mineable in high memory GPUs. Smoothly transitions to 2^32 or more by July 2020, called Cuckatoo32+ (explained why here ) Additional Difficulty Control In order to provide additional difficulty control in a manner that meets the needs of a network with constantly evolving hashpower availability, a further Hashcash-based difficulty check is applied to potential solution sets as follows: If the Blake2b hash of a potential set of solution nonces (currently an array of 42 u32s representing the cycle nonces,) is less than an evolving difficulty target T, then the solution is considered valid. More precisely, the proof difficulty is calculated as the maximum target hash (2^256) divided by the current hash, rounded to give an integer. If this integer is larger than the evolving network difficulty, the POW is considered valid and the block is submit to the chain for validation. In other words, a potential proof, as well as containing a valid Cuckoo Cycle, also needs to hash to a value higher than the target difficulty. This difficulty is derived from: Evolving Network Difficulty The difficulty target is intended to evolve according to the available network hashpower, with the goal of keeping the average block solution time within range of a target (currently 60 seconds, though this is subject to change). The difficulty calculation is based on both Digishield and GravityWave family of difficulty computation, coming to something very close to ZCash. The reference difficulty is an average of the difficulty over a window of 23 blocks (the current consensus value). The corresponding timespan is calculated by using the difference between the median timestamps at the beginning and the end of the window. If the timespan is higher or lower than a certain range, (adjusted with a dampening factor to allow for normal variation,) then the difficulty is raised or lowered to a value aiming for the target block solve time. The Mining Loop All of these systems are put together in the mining loop, which attempts to create valid Proofs-of-Work to create the latest block in the chain. The following is an outline of what the main mining loop does during a single iteration: Get the latest chain state and build a block on top of it, which includes a Block Header with new values particular to this mining attempt: The latest target difficulty as selected by the evolving network difficulty algorithm A set of transactions available for validation selected from the transaction pool A coinbase transaction (which we're hoping to give to ourselves) The current timestamp A randomly generated nonce to add further randomness to the header's hash The merkle root of the UTXO set and fees Then, a sub-loop runs for a set amount of time, currently configured at 2 seconds, where the following happens: The new block header is hashed to create a hash value The cuckoo graph generator is initialized, which accepts as parameters: The hash of the potential block header, which is to be used as the key to a SIPHASH function that will generate pairs of locations for each element in a set of nonces 0..N in the graph. The size of the graph (a consensus value). An easiness value, (a consensus value) representing the M/N ratio described above denoting the probability of a solution appearing in the graph The Cuckoo Cycle detection algorithm tries to find a solution (i.e. a cycle of length 42) within the generated graph. If a cycle is found, a Blake2b hash of the proof is created and is compared to the current target difficulty, as outlined in Additional Difficulty Control above. If the Blake2b Hash difficulty is greater than or equal to the target difficulty, the block is sent to the transaction pool, propagated amongst peers for validation, and work begins on the next block. If the Blake2b Hash difficulty is less than the target difficulty, the proof is thrown out and the timed loop continues. If no solution is found, increment the nonce in the header by 1, and update the header's timestamp so the next iteration hashes a different value for seeding the next loop's graph generation step. If the loop times out with no solution found, start over again from the top, collecting new transactions and creating a new block altogether. Mining Loop Difficulty Control and Timing Controlling the overall difficulty of the mining loop requires finding a balance between the three values outlined above: Graph size (currently represented as a bit-shift value n representing a size of 2^n nodes, consensus value DEFAULT_SIZESHIFT). Smaller graphs can be exhaustively searched more quickly, but will also have fewer solutions for a given easiness value. A very small graph needs a higher easiness value to have the same chance to have a solution as a larger graph with a lower easiness value. The 'Easiness' consensus value, or the M/N ratio of the graph expressed as a percentage. The higher this value, the more likely it is a generated graph will contain a solution. In tandem with the above, the larger the graph, the more solutions it will contain for a given easiness value. The Cuckoo Cycle implementations fix this M to N/2, giving a ratio of 50% The evolving network difficulty hash. These values need to be carefully tweaked in order for the mining algorithm to find the right balance between the cuckoo graph size and the evolving difficulty. The POW needs to remain mostly Cuckoo Cycle based, but still allow for reasonably short block times that allow new transactions to be quickly processed. If the graph size is too low and the easiness too high, for instance, then many cuckoo cycle solutions can easily be found for a given block, and the POW will start to favour those who can hash faster, precisely what Cuckoo Cycle is trying to avoid. If the graph is too large and easiness too low, however, then it can potentially take any solver a long time to find a solution in a single graph, well outside a window in which you'd like to stop to collect new transactions. These values are currently set to 2^12 for the graph size and 50% (as fixed by Cuckoo Cycle) for the easiness value, however the size is only a temporary values for testing. The current miner implementation is very unoptimized, and the graph size will need to be changed as faster and more optimized Cuckoo Cycle algorithms are put in place. Pooling Capability Contrary to some existing concerns about Cuckoo Cycle's poolability, the POW implementation in Grin as described above is perfectly suited to a mining pool. While it may be difficult to prove efforts to solve a single graph in isolation, the combination of factors within Grin's proof-of-work combine to enforce a notion called 'progress-freeness', which enables 'poolability' as well as a level of fairness among all miners. Progress Freeness Progress-freeness is central to the 'poolability' of a proof-of-work, and is simply based on the idea that a solution to a POW problem can be found within a reasonable amount of time. For instance, if a blockchain has a one minute POW time and miners have to spend one minute on average to find a solution, this still satisfies the POW requirement but gives a strong advantage to big miners. In such a setup, small miners will generally lose at least one minute every time while larger miners can move on as soon as they find a solution. So in order to keep mining relatively progress-free, a POW that requires multiple solution attempts with each attempt taking a relatively small amount of time is desirable. Following from this, Grin's progress-freeness is due to the fact that a solution to a Cuckoo with Grin's default parameters can typically be found in under a second on most GPUs, and there is the additional requirement of the Blake2b difficulty check on top of that. Members of a pool are thus able to prove they're working on a solution to a block by submitting valid Cuckoo solutions (or a small bundle of them) that simply fall under the current network target difficulty.","title":"Cuckoo Cycle"},{"location":"wiki/miscellaneous/cuckoo-cycle/#cuckoo-cycle","text":"Read this document in other languages: Korean . This document is meant to outline, at a level suitable for someone without prior knowledge, the algorithms and processes currently involved in Grin's Proof-of-Work system. We'll start with a general overview of cycles in a graph and the Cuckoo Cycle algorithm which forms the basis of Grin's proof-of-work. We'll then move on to Grin-specific details, which will outline the other systems that combine with Cuckoo Cycle to form the entirety of mining in Grin.","title":"Cuckoo Cycle"},{"location":"wiki/miscellaneous/cuckoo-cycle/#graphs-and-cuckoo-cycle","text":"Grin's basic Proof-of-Work algorithm is called Cuckoo Cycle, which is specifically designed to be resistant to Bitcoin style hardware arms-races. It is primarily a memory bound algorithm, which (at least in theory) means that solution time is bound by memory bandwidth rather than raw processor or GPU speed. As such, mining Cuckoo Cycle solutions should be viable on most commodity hardware, and require far less energy than most other GPU, CPU or ASIC-bound proof of work algorithms. The Cuckoo Cycle POW is the work of John Tromp, and the most up-to-date documentation and implementations can be found in his github repository . The white paper is the best source of further technical details.","title":"Graphs and Cuckoo Cycle"},{"location":"wiki/miscellaneous/cuckoo-cycle/#cycles-in-a-graph","text":"Cuckoo Cycle is an algorithm meant to detect cycles in a bipartite graph of N nodes and M edges. In plain terms, a bipartite graph is one in which edges (i.e. lines connecting nodes) travel only between 2 separate groups of nodes. In the case of the Cuckoo hashtable in Cuckoo Cycle, one side of the graph is an array numbered with odd indices (up to the size of the graph), and the other is numbered with even indices. A node is simply a numbered 'space' on either side of the Cuckoo Table, and an Edge is a line connecting two nodes on opposite sides. The simple graph below denotes just such a graph, with 4 nodes on the 'even' side (top), 4 nodes on the odd side (bottom) and zero Edges (i.e. no lines connecting any nodes.) A graph of 8 Nodes with Zero Edges Let's throw a few Edges into the graph now, randomly: 8 Nodes with 4 Edges, no solution We now have a randomly-generated graph with 8 nodes (N) and 4 edges (M), or an NxM graph where N=8 and M=4. Our basic Proof-of-Work is now concerned with finding 'cycles' of a certain length within this random graph, or, put simply, a series of connected nodes starting and ending on the same node. So, if we were looking for a cycle of length 4 (a path connecting 4 nodes, starting and ending on the same node), one cannot be detected in this graph. Adjusting the number of Edges M relative to the number of Nodes N changes the difficulty of the cycle-finding problem, and the probability that a cycle exists in the current graph. For instance, if our POW problem were concerned with finding a cycle of length 4 in the graph, the current difficulty of 4/8 (M/N) would mean that all 4 edges would need to be randomly generated in a perfect cycle (from 0-5-4-1-0) in order for there to be a solution. Let's add a few more edges, again at random: 8 Nodes with 7 Edges Where we can find a cycle: Cycle Found from 0-5-4-1-0 If you increase the number of edges relative to the number of nodes, you increase the probability that a solution exists. With a few more edges added to the graph above, a cycle of length 4 has appeared from 0-5-4-1-0, and the graph has a solution. Thus, modifying the ratio M/N changes the number of expected occurrences of a cycle for a graph with randomly generated edges. For a small graph such as the one above, determining whether a cycle of a certain length exists is trivial. But as the graphs get larger, detecting such cycles becomes more difficult. For instance, does this graph have a cycle of length 8, i.e. 8 connected nodes starting and ending on the same node? Meat-space Cycle Detection exercise The answer is left as an exercise to the reader, but the overall takeaways are: Detecting cycles in a graph becomes more difficult exercise as the size of a graph grows. The probability of a cycle of a given length in a graph increases as M/N becomes larger, i.e. you add more edges relative to the number of nodes in a graph.","title":"Cycles in a Graph"},{"location":"wiki/miscellaneous/cuckoo-cycle/#cuckoo-cycle_1","text":"The Cuckoo Cycle algorithm is a specialized algorithm designed to solve exactly this problem, and it does so by inserting values into a structure called a 'Cuckoo Hashtable' according to a hash which maps nodes into possible locations in two separate arrays. This document won't go into detail on the base algorithm, as it's outlined plainly enough in section 5 of the white paper . There are also several variants on the algorithm that make various speed/memory tradeoffs, again beyond the scope of this document. However, there are a few details following from the above that we need to keep in mind before going on to more technical aspects of Grin's proof-of-work. The 'random' edges in the graph demonstrated above are not actually random but are generated by putting edge indices (0..N) through a seeded hash function, SIPHASH. Each edge index is put through the SIPHASH function twice to create two edge endpoints, with the first input value being 2 * edge_index, and the second 2 * edge_index+1. The seed for this function is based on a hash of a block header, outlined further below. The 'Proof' created by this algorithm is a set of nonces that generate a cycle of length 42, which can be trivially validated by other peers. Two main parameters, as explained above, are passed into the Cuckoo Cycle algorithm that affect the probability of a solution, and the time it takes to search the graph for a solution: The M/N ratio outlined above, which controls the number of edges relative to the size of the graph. Cuckoo Cycle fixes M at N/2, which limits the number of cycles to a few at most. The size of the graph itself How these parameters interact in practice is looked at in more detail below . Now, (hopefully) armed with a basic understanding of what the Cuckoo Cycle algorithm is intended to do, as well as the parameters that affect how difficult it is to find a solution, we move on to the other portions of Grin's POW system.","title":"Cuckoo Cycle"},{"location":"wiki/miscellaneous/cuckoo-cycle/#mining-in-grin","text":"The Cuckoo Cycle outlined above forms the basis of Grin's mining process, however Grin uses two variantion of Cuckoo Cycle in tandem with several other systems to create a Proof-of-Work. for GPUs: Cuckaroo on 2^29 edges Tweaked every 6 months to maitain ASIC resistance. 90% of rewards at launch, linearly decreasing to 0% in 2 years. Variant of Cuckoo that enforces Mean mining. Takes 5.5GB of memory (perhaps 4GB with slowdown). for ASICs: Cuckatoo on 2^31 or more edge Variant of Cuckoo that simplifies ASIC design. 10% of rewards at launch, linearly increasing to 100% in 2 years. Takes 512 MB of memory, with random single-bit accesses to half. Mean mineable in high memory GPUs. Smoothly transitions to 2^32 or more by July 2020, called Cuckatoo32+ (explained why here )","title":"Mining in Grin"},{"location":"wiki/miscellaneous/cuckoo-cycle/#additional-difficulty-control","text":"In order to provide additional difficulty control in a manner that meets the needs of a network with constantly evolving hashpower availability, a further Hashcash-based difficulty check is applied to potential solution sets as follows: If the Blake2b hash of a potential set of solution nonces (currently an array of 42 u32s representing the cycle nonces,) is less than an evolving difficulty target T, then the solution is considered valid. More precisely, the proof difficulty is calculated as the maximum target hash (2^256) divided by the current hash, rounded to give an integer. If this integer is larger than the evolving network difficulty, the POW is considered valid and the block is submit to the chain for validation. In other words, a potential proof, as well as containing a valid Cuckoo Cycle, also needs to hash to a value higher than the target difficulty. This difficulty is derived from:","title":"Additional Difficulty Control"},{"location":"wiki/miscellaneous/cuckoo-cycle/#evolving-network-difficulty","text":"The difficulty target is intended to evolve according to the available network hashpower, with the goal of keeping the average block solution time within range of a target (currently 60 seconds, though this is subject to change). The difficulty calculation is based on both Digishield and GravityWave family of difficulty computation, coming to something very close to ZCash. The reference difficulty is an average of the difficulty over a window of 23 blocks (the current consensus value). The corresponding timespan is calculated by using the difference between the median timestamps at the beginning and the end of the window. If the timespan is higher or lower than a certain range, (adjusted with a dampening factor to allow for normal variation,) then the difficulty is raised or lowered to a value aiming for the target block solve time.","title":"Evolving Network Difficulty"},{"location":"wiki/miscellaneous/cuckoo-cycle/#the-mining-loop","text":"All of these systems are put together in the mining loop, which attempts to create valid Proofs-of-Work to create the latest block in the chain. The following is an outline of what the main mining loop does during a single iteration: Get the latest chain state and build a block on top of it, which includes a Block Header with new values particular to this mining attempt: The latest target difficulty as selected by the evolving network difficulty algorithm A set of transactions available for validation selected from the transaction pool A coinbase transaction (which we're hoping to give to ourselves) The current timestamp A randomly generated nonce to add further randomness to the header's hash The merkle root of the UTXO set and fees Then, a sub-loop runs for a set amount of time, currently configured at 2 seconds, where the following happens: The new block header is hashed to create a hash value The cuckoo graph generator is initialized, which accepts as parameters: The hash of the potential block header, which is to be used as the key to a SIPHASH function that will generate pairs of locations for each element in a set of nonces 0..N in the graph. The size of the graph (a consensus value). An easiness value, (a consensus value) representing the M/N ratio described above denoting the probability of a solution appearing in the graph The Cuckoo Cycle detection algorithm tries to find a solution (i.e. a cycle of length 42) within the generated graph. If a cycle is found, a Blake2b hash of the proof is created and is compared to the current target difficulty, as outlined in Additional Difficulty Control above. If the Blake2b Hash difficulty is greater than or equal to the target difficulty, the block is sent to the transaction pool, propagated amongst peers for validation, and work begins on the next block. If the Blake2b Hash difficulty is less than the target difficulty, the proof is thrown out and the timed loop continues. If no solution is found, increment the nonce in the header by 1, and update the header's timestamp so the next iteration hashes a different value for seeding the next loop's graph generation step. If the loop times out with no solution found, start over again from the top, collecting new transactions and creating a new block altogether.","title":"The Mining Loop"},{"location":"wiki/miscellaneous/cuckoo-cycle/#mining-loop-difficulty-control-and-timing","text":"Controlling the overall difficulty of the mining loop requires finding a balance between the three values outlined above: Graph size (currently represented as a bit-shift value n representing a size of 2^n nodes, consensus value DEFAULT_SIZESHIFT). Smaller graphs can be exhaustively searched more quickly, but will also have fewer solutions for a given easiness value. A very small graph needs a higher easiness value to have the same chance to have a solution as a larger graph with a lower easiness value. The 'Easiness' consensus value, or the M/N ratio of the graph expressed as a percentage. The higher this value, the more likely it is a generated graph will contain a solution. In tandem with the above, the larger the graph, the more solutions it will contain for a given easiness value. The Cuckoo Cycle implementations fix this M to N/2, giving a ratio of 50% The evolving network difficulty hash. These values need to be carefully tweaked in order for the mining algorithm to find the right balance between the cuckoo graph size and the evolving difficulty. The POW needs to remain mostly Cuckoo Cycle based, but still allow for reasonably short block times that allow new transactions to be quickly processed. If the graph size is too low and the easiness too high, for instance, then many cuckoo cycle solutions can easily be found for a given block, and the POW will start to favour those who can hash faster, precisely what Cuckoo Cycle is trying to avoid. If the graph is too large and easiness too low, however, then it can potentially take any solver a long time to find a solution in a single graph, well outside a window in which you'd like to stop to collect new transactions. These values are currently set to 2^12 for the graph size and 50% (as fixed by Cuckoo Cycle) for the easiness value, however the size is only a temporary values for testing. The current miner implementation is very unoptimized, and the graph size will need to be changed as faster and more optimized Cuckoo Cycle algorithms are put in place.","title":"Mining Loop Difficulty Control and Timing"},{"location":"wiki/miscellaneous/cuckoo-cycle/#pooling-capability","text":"Contrary to some existing concerns about Cuckoo Cycle's poolability, the POW implementation in Grin as described above is perfectly suited to a mining pool. While it may be difficult to prove efforts to solve a single graph in isolation, the combination of factors within Grin's proof-of-work combine to enforce a notion called 'progress-freeness', which enables 'poolability' as well as a level of fairness among all miners.","title":"Pooling Capability"},{"location":"wiki/miscellaneous/cuckoo-cycle/#progress-freeness","text":"Progress-freeness is central to the 'poolability' of a proof-of-work, and is simply based on the idea that a solution to a POW problem can be found within a reasonable amount of time. For instance, if a blockchain has a one minute POW time and miners have to spend one minute on average to find a solution, this still satisfies the POW requirement but gives a strong advantage to big miners. In such a setup, small miners will generally lose at least one minute every time while larger miners can move on as soon as they find a solution. So in order to keep mining relatively progress-free, a POW that requires multiple solution attempts with each attempt taking a relatively small amount of time is desirable. Following from this, Grin's progress-freeness is due to the fact that a solution to a Cuckoo with Grin's default parameters can typically be found in under a second on most GPUs, and there is the additional requirement of the Blake2b difficulty check on top of that. Members of a pool are thus able to prove they're working on a solution to a block by submitting valid Cuckoo solutions (or a small bundle of them) that simply fall under the current network target difficulty.","title":"Progress Freeness"},{"location":"wiki/miscellaneous/dandelion/","text":"Dandelion++ in Grin: Privacy-Preserving Transaction Aggregation and Propagation Read this document in other languages: Korean [out of date]. Introduction The Dandelion++ protocol for broadcasting transactions, proposed by Fanti et al. (Sigmetrics 2018) 1 , intends to defend against deanonymization attacks during transaction propagation. In Grin, it also provides an opportunity to aggregate transactions before they are broadcast to the entire network. This document describes the protocol and the simplified version of it that is implemented in Grin. In the following section, past research on the protocol is summarized. This is then followed by describing details of the Grin implementation; the objectives behind its inclusion, how the current implementation differs from the original paper, what some of the known limitations are, and outlining some areas of improvement for future work. Research The original version of Dandelion was introduced by Fanti et al. and presented at ACM Sigmetrics 2017 2 . On June 2017, a BIP 3 was proposed introducing a more practical and robust variant of Dandelion called Dandelion++, which was formalized into a paper in 2018 1 . The protocols are outlined at a high level here. For a more in-depth presentation with extensive literature references, please refer to the original papers. Motivation Dandelion was conceived as a way to mitigate large scale deanonymization attacks on the network layer of Bitcoin, made possible by the diffusion method for propagating transactions on the network. By deploying \"super-nodes\" that connect to a large number of honest nodes on the network, adversaries can listen to the transactions relayed by the honest nodes as they get diffused symmetrically on the network using epidemic flooding or diffusion. By observing the spreading dynamic of a transaction, it has been proven possible to link it (and therefore also the sender's Bitcoin address) to the originating IP address with a high degree of accuracy, and as a result de-anonymize users. Dandelion In the original paper 2 , a dandelion spreading protocol is introduced. Dandelion spreading propagation consists of two phases: first the anonymity phase, or the \u201cstem\u201d phase, and second the spreading phase, or the \u201cfluff\u201d phase, as illustrated in Figure 1. Figure 1. Dandelion phase illustration. \u250c-> F ... \u250c-> D --\u2524 | \u2514-> G ... A --[stem]--> B --[stem]--> C --[fluff]--\u2524 | \u250c-> H ... \u2514-> E --\u2524 \u2514-> I ... In the initial stem-phase , each node relays the transaction to a single randomly selected peer , constructing a line graph. Users then forward transactions along the same path on the graph. After a random number of hops along the stem, the transaction enters the fluff-phase , which behaves like ordinary diffusion. This means that even when an attacker can identify the originator of the fluff phase, it becomes more difficult to identify the source of the stem (and thus the original broadcaster of the transaction). Each individual node pseudorandomly selects if he is a stem or a fluff node at regular intervals, called epoch periods. Epochs are asynchronous, with each individual node keeping its own internal clock and starting a new epoch once a certain threshold has been reached. Thus, the constructed line graph is periodically re-generated randomly, at the expiry of each epoch, limiting an adversary's possibility to build knowledge of the graph. The 'Dandelion' name is derived from how the protocol resembles the spreading of the seeds of a dandelion. Dandelion++ In the Dandelion++ paper 1 , the authors build on the original concept further by defending against stronger adversaries that are allowed to disobey protocol. The original paper makes three ideal assumptions: All nodes obey protocol. Each node generates exactly one transaction. All nodes on the network run Dandelion. An adversary can violate these rules, and by doing so, break some of the anonymity properties. The modified Dandelion++ protocol makes small changes to many of the Dandelion choices, resulting in an exponentially more complex information space. This in turn makes it harder for an adversary to de-anonymize the network. The paper describes five types of attacks, and proposes specific updates to the original Dandelion protocol to mitigate against these, presented in Table A (here in summarized form). Table A. Summary of Dandelion++ changes Attack Solution Graph-learning 4-regular anonymity graph Intersection Pseudorandom forwarding Graph-construction Non-interactive construction Black-hole Random stem timers Partial deployment Blind stem selection Dandelion++ Algorithm As with the original Dandelion protocol, epochs are asynchronous, each node keeping track of its own epoch, which the suggested duration being in the order of 10 minutes. Anonymity Graph Rather than a line graph as per the original paper (which is 2-regular), a quasi-4-regular graph is constructed by a node at the beginning of each epoch: the node chooses (up to) two of its outbound peers uniformly at random as its dandelion++ relays . As a node enters into a new epoch, new dandelion++ relays are chosen. Figure 2. representation of a 4-regular graph. in1 out1 \\ / \\ / NodeX / \\ / \\ in2 out2 NodeX has four connections to other nodes, input nodes in1 and in2 , and output nodes out1 and out2 . 4-regular vs 2-regular graphs The choice between using 4-regular or 2-regular (line) graphs is not obvious. The authors note that it is difficult to construct an exact 4-regular graph within a fully-distributed network in practice. They outline a method to construct an approximate 4-regular graph in the paper. They also write: ... We recommend making the design decision between 4-regular graphs and line graphs based on the priorities of the system builders. If linkability of transactions is a first-order concern, then line graphs may be a better choice. Otherwise, we find that 4-regular graphs can give constant- order privacy benefits against adversaries with knowledge of the graph. Transaction forwarding (own) At the beginning of each epoch, NodeX picks one of out1 and out2 to use as a route to broadcast its own transactions through as a stem-phase transaction. The same route is used throughout the duration epoch, and NodeX always forwards (stems) its own transaction. Transaction forwarding (relay) At the start of each epoch, NodeX makes a choice to be either in fluff-mode or in stem-mode. This choice is made in pseudorandom fashion, with the paper suggesting it being computed from a hash of the node's own identity and epoch number. The probability of choosing to be in fluff-mode (or as the paper calls it, the path length parameter q ) is recommended to be q \u2264 0.2. Once the choice has been made whether to stem or to fluff, it applies to all relayed transactions passing through it during the epoch. in fluff-mode , NodeX is will broadcast any received transactions to the network using diffusion. in stem-mode , at the beginning of each epoch NodeX will map in1 to either out1 or out2 pseudorandomly, and similarly map in2 to either out1 or out2 in the same fashion. Based on this mapping, it will then forward all txs from in1 along the chosen route, and similarly forward all transactions from in2 along that route. The mapping persists throughout the duration of the epoch. Fail-safe mechanism For each stem-phase transaction that was sent or relayed, NodeX tracks whether it is seen again as a fluff-phase transaction within some random amount of time. If not, the node fluffs the transaction itself. This expiration timer is set by each stem-node upon receiving a transaction to forward, and is chosen randomly. Nodes are initialized with a timeout parameter T base . As per equation (7) in the paper, when a stem-node v receives a transaction, it sets an expiration time T out (v): T out (v) ~ current_time + exp(1/T base ) If the transaction is not received again by relay v before the expiry of T out (v), then it broadcasts the message using diffusion. This approach means that the if the transaction gets does not enter fluff-phase in time, the first stem-node to broadcast is approximately uniformly selected among all stem-nodes who have seen the transaction, rather than the originating node who created it. The paper also proceeds to specify the size of the initiating time out parameter T base as part of Proposition 3 in the paper: Proposition3. For a timeout parameter T base \u2265 (\u2212k(k\u22121)\u03b4 hop ) / 2 log(1\u2212\u03b5 ), where k , \u03b5 are parameters and \u03b4 hop is the time between each hop (e.g., network and/or internal node latency), transactions travel for k hops without any peer initiating diffusion with a probability of at least 1 \u2212 \u03b5 . Dandelion in Grin Objectives The choice to include Dandelion in Grin has two main motives behind it: Act as a countermeasure against mass de-anonymization attacks. Similar to Bitcoin, the Grin P2P network would be vulnerable to attackers deploying malicious \"super-nodes\" connecting to most peers on the network and monitoring transactions as they become diffused by their honest peers. This would allow a motivated actor to infer with a high degree of probability from which peer (IP address) transactions originate from, having negative privacy consequences. Aggregate transactions before they are being broadcast to the entire network. This is a benefit to blockchains that enable non-interactive CoinJoins on the protocol level, such as Mimblewimble. Despite its good privacy features, some input and output linking is still possible in Mimblewimble and Grin. 4 If you know which input spends to which output, it is possible to construct a transaction graph and follow a chain of transaction outputs (TXOs) as they are being spent. Aggregating transactions make this more difficult to carry out, as it becomes less clear which input spends to which output (Figure 3). In order for this to be effective, there needs to be a large anonymity set, i.e. many transactions to aggregate with one another. Dandelion enables this aggregation to occur before transactions are fluffed and diffused to the entire network. This adds obfuscation to the transaction graph, as a malicious observer who is not participating in the stemming or fluffing would not only need to figure out from where a transaction originated, but also which outputs and inputs out of a larger group should be attributed to the originating transaction. Figure 3. (switch between tabs) Not Aggregated Inputs Outputs Kernels t r a n s a c t i o n A X Kernel 1 Y t r a n s a c t i o n B Z Kernel 2 C Aggregated Inputs Outputs Kernels A X Kernel 1 B Y Kernel 2 C Z Current implementation Grin implements a simplified version of the Dandelion++ protocol. It's been improved several times, most recently in version 1.1.0 5 . Dandelion configuration options in grin-server.toml (default) #dandelion epoch duration epoch_secs = 600 #fluff and broadcast after embargo expires if tx not seen on network embargo_secs = 180 #dandelion aggregation period in secs aggregation_secs = 30 #dandelion stem probability (stem 90% of the time, fluff 10% of the time) stem_probability = 90 #always stem our (pushed via api) txs regardless of stem/fluff epoch (as per Dandelion++ paper) always_stem_our_txs = true DandelionEpoch tracks a node's current epoch. This is configurable via epoch_secs with default epoch set to last for 10 minutes. Epochs are set and tracked by nodes individually. At the beginning of an epoch, the node chooses a single connected peer at random to use as their outbound relay. At the beginning of an epoch, the node makes a decision whether to be in stem mode or in fluff mode. This decision lasts for the duration of the epoch. By default, this is a random choice, with the probability to be in stem mode set to 90%, which implies a fluff mode probability, q of 10%. The probability is configurable via DANDELION_STEM_PROBABILITY . The number of expected stem hops a transaction does before arriving to a fluff node is 1/q = 1/0.1 = 10 . Any transactions received from inbound peers or transactions originated from the node itself are first added to the node's stempool , which is a list of stem transactions, that each node keeps track of individually. Transactions are removed from the stempool if: The node fluffs the transaction itself. The node sees the transaction in question propagated through regular diffusion, i.e. from a different peer having \"fluffed\" it. The node receives a block containing this transaction, meaning that the transaction was propagated and included in a block. For each transaction added to the stempool, the node sets an embargo timer . This is set by default to 180 seconds, and is configurable via embargo_secs . A dandelion_monitor runs every 10 seconds and handles tasks. If the node is in stem mode , then: After being added to the stempool, received stem transactions are forwarded onto the their relay node as a stem transaction. As peers connect at random, it is possible they create a circular loop of connected stem mode nodes (i.e. A -> B -> C -> A ). Therefore, if a node receives a stem transaction from an inbound node that already exists in its own stempool, it will fluff it, broadcasting it using regular diffusion. dandelion_monitor checks for transactions in the node's stempool with an expired embargo timer, and broadcast those individually. If the node is in fluff mode , then: Transactions received from inbound nodes are kept in the stempool. dandelion_monitor checks in the stempool whether any transactions are older than 30 seconds (configurable as DANDELION_AGGREGATION_SECS ). If so, these are aggregated and then fluffed. Otherwise no action is taken, allowing for more stem transactions to aggregate in the stempool in time for the next triggering of dandelion_monitor . At the expiry of an epoch, all stem transactions remaining in the stem pool are aggregated and fluffed. Nodes stem their own transactions Regardless of whether the node is in fluff or stem mode, any transactions generated from the node itself are forwarded onwards to their relay node as a stem transaction. 6 Known limitations 2-regular graphs are used rather than 4-regular graphs as proposed by the paper. It's not clear what impact this has, the paper suggests a trade-off between general linkability of transactions and protection against adversaries who know the entire network graph. Additionally, unlike the Dandelion++ paper, the embargo timer is by default identical across all nodes. This means that during a black-hole attack where a malicious node withholds transactions, the node most likely to have its embargo timer expire and fluff the transaction will be the originating node, therefore exposing itself. Future work Randomized embargo timer according to the recommendations of the paper to make it more random which node fluffs an expired transaction. Evaluation of whether 4-regular graphs are preferred over 2-regular line graphs. Simulation of the current implementation to understand performance. References Dandelion++: Lightweight Cryptocurrency Networking with Formal Anonymity Guarantees (Sigmetrics'18) \u21a9 \u21a9 \u21a9 Dandelion: Redesigning the Bitcoin Network for Anonymity (Sigmetrics'17) \u21a9 \u21a9 Dandelion BIP \u21a9 Grin Privacy Primer \u21a9 #2628: Dandelion++ Rewrite \u21a9 #2876: Always stem local txs if configured that way (unless explicitly fluffed) \u21a9","title":"Dandelion"},{"location":"wiki/miscellaneous/dandelion/#dandelion-in-grin-privacy-preserving-transaction-aggregation-and-propagation","text":"Read this document in other languages: Korean [out of date].","title":"Dandelion++ in Grin: Privacy-Preserving Transaction Aggregation and Propagation"},{"location":"wiki/miscellaneous/dandelion/#introduction","text":"The Dandelion++ protocol for broadcasting transactions, proposed by Fanti et al. (Sigmetrics 2018) 1 , intends to defend against deanonymization attacks during transaction propagation. In Grin, it also provides an opportunity to aggregate transactions before they are broadcast to the entire network. This document describes the protocol and the simplified version of it that is implemented in Grin. In the following section, past research on the protocol is summarized. This is then followed by describing details of the Grin implementation; the objectives behind its inclusion, how the current implementation differs from the original paper, what some of the known limitations are, and outlining some areas of improvement for future work.","title":"Introduction"},{"location":"wiki/miscellaneous/dandelion/#research","text":"The original version of Dandelion was introduced by Fanti et al. and presented at ACM Sigmetrics 2017 2 . On June 2017, a BIP 3 was proposed introducing a more practical and robust variant of Dandelion called Dandelion++, which was formalized into a paper in 2018 1 . The protocols are outlined at a high level here. For a more in-depth presentation with extensive literature references, please refer to the original papers.","title":"Research"},{"location":"wiki/miscellaneous/dandelion/#motivation","text":"Dandelion was conceived as a way to mitigate large scale deanonymization attacks on the network layer of Bitcoin, made possible by the diffusion method for propagating transactions on the network. By deploying \"super-nodes\" that connect to a large number of honest nodes on the network, adversaries can listen to the transactions relayed by the honest nodes as they get diffused symmetrically on the network using epidemic flooding or diffusion. By observing the spreading dynamic of a transaction, it has been proven possible to link it (and therefore also the sender's Bitcoin address) to the originating IP address with a high degree of accuracy, and as a result de-anonymize users.","title":"Motivation"},{"location":"wiki/miscellaneous/dandelion/#dandelion","text":"In the original paper 2 , a dandelion spreading protocol is introduced. Dandelion spreading propagation consists of two phases: first the anonymity phase, or the \u201cstem\u201d phase, and second the spreading phase, or the \u201cfluff\u201d phase, as illustrated in Figure 1. Figure 1. Dandelion phase illustration. \u250c-> F ... \u250c-> D --\u2524 | \u2514-> G ... A --[stem]--> B --[stem]--> C --[fluff]--\u2524 | \u250c-> H ... \u2514-> E --\u2524 \u2514-> I ... In the initial stem-phase , each node relays the transaction to a single randomly selected peer , constructing a line graph. Users then forward transactions along the same path on the graph. After a random number of hops along the stem, the transaction enters the fluff-phase , which behaves like ordinary diffusion. This means that even when an attacker can identify the originator of the fluff phase, it becomes more difficult to identify the source of the stem (and thus the original broadcaster of the transaction). Each individual node pseudorandomly selects if he is a stem or a fluff node at regular intervals, called epoch periods. Epochs are asynchronous, with each individual node keeping its own internal clock and starting a new epoch once a certain threshold has been reached. Thus, the constructed line graph is periodically re-generated randomly, at the expiry of each epoch, limiting an adversary's possibility to build knowledge of the graph. The 'Dandelion' name is derived from how the protocol resembles the spreading of the seeds of a dandelion.","title":"Dandelion"},{"location":"wiki/miscellaneous/dandelion/#dandelion_1","text":"In the Dandelion++ paper 1 , the authors build on the original concept further by defending against stronger adversaries that are allowed to disobey protocol. The original paper makes three ideal assumptions: All nodes obey protocol. Each node generates exactly one transaction. All nodes on the network run Dandelion. An adversary can violate these rules, and by doing so, break some of the anonymity properties. The modified Dandelion++ protocol makes small changes to many of the Dandelion choices, resulting in an exponentially more complex information space. This in turn makes it harder for an adversary to de-anonymize the network. The paper describes five types of attacks, and proposes specific updates to the original Dandelion protocol to mitigate against these, presented in Table A (here in summarized form). Table A. Summary of Dandelion++ changes Attack Solution Graph-learning 4-regular anonymity graph Intersection Pseudorandom forwarding Graph-construction Non-interactive construction Black-hole Random stem timers Partial deployment Blind stem selection","title":"Dandelion++"},{"location":"wiki/miscellaneous/dandelion/#dandelion-algorithm","text":"As with the original Dandelion protocol, epochs are asynchronous, each node keeping track of its own epoch, which the suggested duration being in the order of 10 minutes.","title":"Dandelion++ Algorithm"},{"location":"wiki/miscellaneous/dandelion/#anonymity-graph","text":"Rather than a line graph as per the original paper (which is 2-regular), a quasi-4-regular graph is constructed by a node at the beginning of each epoch: the node chooses (up to) two of its outbound peers uniformly at random as its dandelion++ relays . As a node enters into a new epoch, new dandelion++ relays are chosen. Figure 2. representation of a 4-regular graph. in1 out1 \\ / \\ / NodeX / \\ / \\ in2 out2 NodeX has four connections to other nodes, input nodes in1 and in2 , and output nodes out1 and out2 . 4-regular vs 2-regular graphs The choice between using 4-regular or 2-regular (line) graphs is not obvious. The authors note that it is difficult to construct an exact 4-regular graph within a fully-distributed network in practice. They outline a method to construct an approximate 4-regular graph in the paper. They also write: ... We recommend making the design decision between 4-regular graphs and line graphs based on the priorities of the system builders. If linkability of transactions is a first-order concern, then line graphs may be a better choice. Otherwise, we find that 4-regular graphs can give constant- order privacy benefits against adversaries with knowledge of the graph.","title":"Anonymity Graph"},{"location":"wiki/miscellaneous/dandelion/#transaction-forwarding-own","text":"At the beginning of each epoch, NodeX picks one of out1 and out2 to use as a route to broadcast its own transactions through as a stem-phase transaction. The same route is used throughout the duration epoch, and NodeX always forwards (stems) its own transaction.","title":"Transaction forwarding (own)"},{"location":"wiki/miscellaneous/dandelion/#transaction-forwarding-relay","text":"At the start of each epoch, NodeX makes a choice to be either in fluff-mode or in stem-mode. This choice is made in pseudorandom fashion, with the paper suggesting it being computed from a hash of the node's own identity and epoch number. The probability of choosing to be in fluff-mode (or as the paper calls it, the path length parameter q ) is recommended to be q \u2264 0.2. Once the choice has been made whether to stem or to fluff, it applies to all relayed transactions passing through it during the epoch. in fluff-mode , NodeX is will broadcast any received transactions to the network using diffusion. in stem-mode , at the beginning of each epoch NodeX will map in1 to either out1 or out2 pseudorandomly, and similarly map in2 to either out1 or out2 in the same fashion. Based on this mapping, it will then forward all txs from in1 along the chosen route, and similarly forward all transactions from in2 along that route. The mapping persists throughout the duration of the epoch.","title":"Transaction forwarding (relay)"},{"location":"wiki/miscellaneous/dandelion/#fail-safe-mechanism","text":"For each stem-phase transaction that was sent or relayed, NodeX tracks whether it is seen again as a fluff-phase transaction within some random amount of time. If not, the node fluffs the transaction itself. This expiration timer is set by each stem-node upon receiving a transaction to forward, and is chosen randomly. Nodes are initialized with a timeout parameter T base . As per equation (7) in the paper, when a stem-node v receives a transaction, it sets an expiration time T out (v): T out (v) ~ current_time + exp(1/T base ) If the transaction is not received again by relay v before the expiry of T out (v), then it broadcasts the message using diffusion. This approach means that the if the transaction gets does not enter fluff-phase in time, the first stem-node to broadcast is approximately uniformly selected among all stem-nodes who have seen the transaction, rather than the originating node who created it. The paper also proceeds to specify the size of the initiating time out parameter T base as part of Proposition 3 in the paper: Proposition3. For a timeout parameter T base \u2265 (\u2212k(k\u22121)\u03b4 hop ) / 2 log(1\u2212\u03b5 ), where k , \u03b5 are parameters and \u03b4 hop is the time between each hop (e.g., network and/or internal node latency), transactions travel for k hops without any peer initiating diffusion with a probability of at least 1 \u2212 \u03b5 .","title":"Fail-safe mechanism"},{"location":"wiki/miscellaneous/dandelion/#dandelion-in-grin","text":"","title":"Dandelion in Grin"},{"location":"wiki/miscellaneous/dandelion/#objectives","text":"The choice to include Dandelion in Grin has two main motives behind it: Act as a countermeasure against mass de-anonymization attacks. Similar to Bitcoin, the Grin P2P network would be vulnerable to attackers deploying malicious \"super-nodes\" connecting to most peers on the network and monitoring transactions as they become diffused by their honest peers. This would allow a motivated actor to infer with a high degree of probability from which peer (IP address) transactions originate from, having negative privacy consequences. Aggregate transactions before they are being broadcast to the entire network. This is a benefit to blockchains that enable non-interactive CoinJoins on the protocol level, such as Mimblewimble. Despite its good privacy features, some input and output linking is still possible in Mimblewimble and Grin. 4 If you know which input spends to which output, it is possible to construct a transaction graph and follow a chain of transaction outputs (TXOs) as they are being spent. Aggregating transactions make this more difficult to carry out, as it becomes less clear which input spends to which output (Figure 3). In order for this to be effective, there needs to be a large anonymity set, i.e. many transactions to aggregate with one another. Dandelion enables this aggregation to occur before transactions are fluffed and diffused to the entire network. This adds obfuscation to the transaction graph, as a malicious observer who is not participating in the stemming or fluffing would not only need to figure out from where a transaction originated, but also which outputs and inputs out of a larger group should be attributed to the originating transaction. Figure 3. (switch between tabs) Not Aggregated Inputs Outputs Kernels t r a n s a c t i o n A X Kernel 1 Y t r a n s a c t i o n B Z Kernel 2 C Aggregated Inputs Outputs Kernels A X Kernel 1 B Y Kernel 2 C Z","title":"Objectives"},{"location":"wiki/miscellaneous/dandelion/#current-implementation","text":"Grin implements a simplified version of the Dandelion++ protocol. It's been improved several times, most recently in version 1.1.0 5 . Dandelion configuration options in grin-server.toml (default) #dandelion epoch duration epoch_secs = 600 #fluff and broadcast after embargo expires if tx not seen on network embargo_secs = 180 #dandelion aggregation period in secs aggregation_secs = 30 #dandelion stem probability (stem 90% of the time, fluff 10% of the time) stem_probability = 90 #always stem our (pushed via api) txs regardless of stem/fluff epoch (as per Dandelion++ paper) always_stem_our_txs = true DandelionEpoch tracks a node's current epoch. This is configurable via epoch_secs with default epoch set to last for 10 minutes. Epochs are set and tracked by nodes individually. At the beginning of an epoch, the node chooses a single connected peer at random to use as their outbound relay. At the beginning of an epoch, the node makes a decision whether to be in stem mode or in fluff mode. This decision lasts for the duration of the epoch. By default, this is a random choice, with the probability to be in stem mode set to 90%, which implies a fluff mode probability, q of 10%. The probability is configurable via DANDELION_STEM_PROBABILITY . The number of expected stem hops a transaction does before arriving to a fluff node is 1/q = 1/0.1 = 10 . Any transactions received from inbound peers or transactions originated from the node itself are first added to the node's stempool , which is a list of stem transactions, that each node keeps track of individually. Transactions are removed from the stempool if: The node fluffs the transaction itself. The node sees the transaction in question propagated through regular diffusion, i.e. from a different peer having \"fluffed\" it. The node receives a block containing this transaction, meaning that the transaction was propagated and included in a block. For each transaction added to the stempool, the node sets an embargo timer . This is set by default to 180 seconds, and is configurable via embargo_secs . A dandelion_monitor runs every 10 seconds and handles tasks. If the node is in stem mode , then: After being added to the stempool, received stem transactions are forwarded onto the their relay node as a stem transaction. As peers connect at random, it is possible they create a circular loop of connected stem mode nodes (i.e. A -> B -> C -> A ). Therefore, if a node receives a stem transaction from an inbound node that already exists in its own stempool, it will fluff it, broadcasting it using regular diffusion. dandelion_monitor checks for transactions in the node's stempool with an expired embargo timer, and broadcast those individually. If the node is in fluff mode , then: Transactions received from inbound nodes are kept in the stempool. dandelion_monitor checks in the stempool whether any transactions are older than 30 seconds (configurable as DANDELION_AGGREGATION_SECS ). If so, these are aggregated and then fluffed. Otherwise no action is taken, allowing for more stem transactions to aggregate in the stempool in time for the next triggering of dandelion_monitor . At the expiry of an epoch, all stem transactions remaining in the stem pool are aggregated and fluffed. Nodes stem their own transactions Regardless of whether the node is in fluff or stem mode, any transactions generated from the node itself are forwarded onwards to their relay node as a stem transaction. 6","title":"Current implementation"},{"location":"wiki/miscellaneous/dandelion/#known-limitations","text":"2-regular graphs are used rather than 4-regular graphs as proposed by the paper. It's not clear what impact this has, the paper suggests a trade-off between general linkability of transactions and protection against adversaries who know the entire network graph. Additionally, unlike the Dandelion++ paper, the embargo timer is by default identical across all nodes. This means that during a black-hole attack where a malicious node withholds transactions, the node most likely to have its embargo timer expire and fluff the transaction will be the originating node, therefore exposing itself.","title":"Known limitations"},{"location":"wiki/miscellaneous/dandelion/#future-work","text":"Randomized embargo timer according to the recommendations of the paper to make it more random which node fluffs an expired transaction. Evaluation of whether 4-regular graphs are preferred over 2-regular line graphs. Simulation of the current implementation to understand performance.","title":"Future work"},{"location":"wiki/miscellaneous/dandelion/#references","text":"Dandelion++: Lightweight Cryptocurrency Networking with Formal Anonymity Guarantees (Sigmetrics'18) \u21a9 \u21a9 \u21a9 Dandelion: Redesigning the Bitcoin Network for Anonymity (Sigmetrics'17) \u21a9 \u21a9 Dandelion BIP \u21a9 Grin Privacy Primer \u21a9 #2628: Dandelion++ Rewrite \u21a9 #2876: Always stem local txs if configured that way (unless explicitly fluffed) \u21a9","title":"References"},{"location":"wiki/miscellaneous/nrd-kernels/","text":"NRD Kernels Title: nrd-kernels Authors: Antioch Peverell Start date: Mar 24, 2020 RFC PR: mimblewimble/grin-rfcs#47 Tracking issue: mimblewimble/grin#3288 Summary Grin supports a limited implementation of \"relative timelocks\" with \"No Recent Duplicate\" (NRD) transaction kernels. Transactions can be constructed such that they share duplicate kernels. An NRD kernel instance is not valid within a specified number of blocks relative to a prior duplicate instance of the kernel. A minimum height difference must therefore exist between two instances of an NRD kernel. This provides the relative height lock between transactions. Motivation Relative timelocks are a prerequisite for robust payment channels. NRD kernels can be used to implement a revocable channel close mechanism. A mandatory revocation period can be introduced through a relative timelock between two transactions. Any attempt to close an old invalid channel state can be safely revoked during the revocation period. Recently, Ruben Somsen announced a design for [Succinct Atomic Swaps (SAS)] 10 reducing the number of on-chain transactions required to implement the swap. This design uses a combination of relative locks and [adaptor signatures] 11 . SAS would appear to be compatible with Grin/MW but with some caveats, namely the need for an additional transaction kernel as the NRD lock and the adaptor signature cannot co-exist on the same kernel. This is discussed in Unresolved questions below. Community-level explanation A minimum distance in block height is enforced between successive duplicate instances of a given NRD kernel. This can be used to enforce a relative lock height between two transactions. A transaction containing an NRD kernel will not be accepted as valid within the specified block height relative to any prior instance of the NRD kernel. Transactions can be constructed around an existing transaction kernel by introducing either an additional kernel or in some cases by simply adjusting the kernel offset. This allows NRD kernels to be used across any pair of transactions. The NRD kernel implementation aims for simplicity and a minimal approach to solving the problem of \"relative locks\". Grin does not support a general solution for arbitrary length locks between arbitrary kernels. The implementation is limited in scope to avoid adversely impacting performance and scalability. References between duplicate kernels are implicit , avoiding the need to store kernel references. Locks are limited in length to recent history, avoiding the need to inspect the full historical kernel set during verification. Reference-level explanation An NRD kernel is not valid within a specified number of blocks of a previous duplicate instance of the same NRD kernel. We define duplicate here as two NRD kernels sharing the same public excess commitment. NRD kernels with different excess commitments are not treated as duplicates. An NRD kernel and a non-NRD kernel (plain kernel, coinbase kernel etc.) sharing the same excess commitment are not treated as duplicates. An NRD kernel has an associated relative lock height. For a block B containing this kernel to be valid, no duplicate instance of the kernel can exist in the last RH blocks (up to and including B ), where RH is the relative lock height. For example, a transaction containing an NRD kernel with relative lock height 1440 (24 hours) is included in a block at height 1000000. This block is only valid if no duplicate instance of this kernel exists in any block from height 998561 (h-1439) to height 1000000 (h-0) inclusive. A duplicate instance is permitted at height 998560 (h-1440), with the transaction seen as valid. If no duplicate instance of the kernel exists within this range then the lock criteria is met. A kernel can be delayed by the existence of a previous kernel. The non-existence of a previous kernel has no impact on the lock criteria. Note that this implies the first singular occurrence of any NRD kernel meets the lock criteria trivially as it cannot, by definition, be locked by a previous kernel. Thus, the relative lock defaults to \"fail open\" semantics. Each node maintains an index of recent NRD kernels to enable efficient checking of NRD relative lock heights. Note we only need to index NRD locks and we only need to index those within recent history. Relative locks longer than 7 days are not valid. This is believed to be sufficient to cover all proposed use cases. The minimum value for a relative lock height is 1 meaning a prior instance of the kernel can exist in the previous block for the lock criteria to be met. An instance of the NRD kernel in the same block will invalidate the block as the lock criteria will not be met. NRD lock heights of 0 are invalid and it is never valid for two duplicate instances of the same NRD kernel to exist in the same block. It follows that two transactions containing duplicate instances of the same NRD kernel cannot be accepted as valid in the transaction pool concurrently. Current txpool behavior is \"first one wins\" semantics when receiving transactions and this will also apply to transactions containing NRD kernels. We plan to revisit this in a future \"fee\" RFC and plan to investigate the feasibility of introducing \"replace by fee\" semantics at that time. Grin supports \"rewind\" back through recent history to handle fork and chain reorg scenarios. 1 week of full blocks are maintained on each node and up to 10080 blocks can be rewound. To support relative lock heights each node must maintain an index over sufficient kernel history for an additional 10080 blocks beyond this rewind horizon. Each node should maintain 2 weeks of kernel history in the local NRD kernel index. This will cover the pathological case of a 1 week rewind and the validation of a 1 week long relative lock beyond that. The primary use case is for revocable payment channel close operations. We believe a 7 day period is more than sufficient for this. We do not require long, extended revocation periods and limiting this to a few days is preferable to keep the cost of verification low. The need for these revocable transactions to be included on chain should be low as these are only required in a non-cooperative situation but where required we want to minimize the cost of verification which must be performed across all nodes. The following kernel variants are supported in Grin - Plain Coinbase HeightLocked NoRecentDuplicate These are implemented as kernel \"feature\" variants - pub enum KernelFeatures { /// Plain kernel (default for Grin txs). Plain = 0, /// A coinbase kernel. Coinbase = 1, /// A kernel with an explicit absolute lock height. HeightLocked = 2, /// A relative height locked NRD kernel. NoRecentDuplicate = 3, } Each kernel variant includes feature specific data - # Plain { \"fee\": 8 } # Coinbase { # empty } # Height Locked { \"fee\": 8, \"lock_height\": 295800 } # No Recent Duplicate (NRD) { \"fee\": 8, \"relative_height\": 1440, } Note that NRD kernels require no additional data beyond that required for absolute height locked kernels. The reference to the previous kernel is implicit and based on a duplicate NRD kernel excess commitment. The maximum supported NRD relative_height is 10080 (7 days) and the relative height can be safely and conveniently represented as a u16 (2 bytes). This differs from absolute lock heights where u64 (8 bytes) is necessary to specify the lock height. The minimum supported NRD relative_height is 1 and a value of 0 is not valid. Two duplicate instances of a given NRD kernel cannot exist simultaneously in the same block. There must be a relative height of at least 1 block between them. Nodes on the Grin network currently support two serialization versions for transaction kernels - V1 \"fixed size kernels\" In V1 all kernels are serialized to the same \"fixed\" number of bytes: feature ( 1 byte ) | fee ( 8 bytes ) | additional_data ( 8 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 01 f7 8 a 40 | 00 00 00 00 00 00 05 A0 | 08 b1 ... 22 d8 | 33 11 ... b9 69 NRD kernels use the last 2 bytes of feature specific data for the relative lock height as big-endian u16. The first 6 bytes of feature specific data must be all zero: 00 00 00 00 00 00 05 A0 Note: absolute lock height (u64) and relative lock height (u16) have identical serialization in practice. V1 is supported for backward compatibility with nodes that do not support V2 \"variable size kernels\". V2 \"variable size kernels\" V2 kernels have been supported since Grin v2.1.0 and V2 supports the notion of \"variable size\" kernels. See [RFC-0005 \"Varible Size Kernels\"] 12 for details of this. NRD kernels include 8 bytes for the fee as big-endian u64 and 2 bytes for the relative lock height: feature ( 1 byte ) | fee ( 8 bytes ) | relative_height ( 2 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 00 6 a cf c0 | 05 A0 | 09 4 d ... bb 9 a | 09 c7 ... bd 54 In V2 relative lock height is 2 bytes as big-endian u16: 05 A0 Note: the serialization strategy is used for both network \"on the wire\" serialization of both transactions and full blocks, and local storage, both the database for full blocks and the kernel MMR backend files. Version negotiation occurs during the initial peer connection setup process and determines which version is used for p2p message serialization. If a node uses V2 serialization for the kernel MMR backend file then it will provide a V2 txhashset based on these underlying files. Kernel Signature Message Every kernel contains a signature proving the excess commitment is a commitment to zero. The message being signed includes the features, fee and other associated data to prevent malleability of the transaction kernel and the overall transaction. The transaction fee cannot be modified after signing, for example. For NRD kernels the message being signed is constructed as follows with the relative lock height serialized as 2 bytes. Hash(feature | fee | relative_height) Hash(03 | 00 00 00 00 01 f7 8a 40 | 05 A0) No additional data is introduced with NRD kernels beyond the 2 bytes representing the relative lock height. There is no opportunity to include arbitrary data. Any additional kernel included in a transaction is itself still a fully valid kernel. There is no explicit reference necessary that could be misused to include arbitrary data. An additional NRD kernel in a transaction will increase the \"weight\" of the transaction by this single additional kernel and allows for a simple way to deal with additional fees. A transaction with an additional kernel must provide additional fees to cover the additional \"weight\". NRD kernels cannot be added for free. Note that in some limited situations it is possible to replace a kernel with an NRD kernel. If the NRD lock can be introduced without adding an additional kernel then the fee does not have to be increased and the lock is effectively added for free. A transaction kernel consists of an excess commitment and an associated signature showing this excess is indeed a commitment to 0. A transaction with a single kernel can always be represented as a transaction with multiple kernels, provided the kernels excess commitments sum to the correct total excess. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment - rG + 0H This transaction can be represented as a pair of kernels with excess commitments - rG + 0H = (r'G + 0H) + (r-r'G + 0H) We take advantage of this to allow an arbitrary NRD kernel to be included in any transaction at construction time. Additionally the kernel offset included in each transaction can be used in certain situations to allow the replacement of a single transaction kernel with an NRD kernel without needing to introduce an additional kernel. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment and kernel offset - rG + 0H, o This transaction can be rewritten to use the NRD kernel - r'G + 0H, (o+r-r') These two \"degrees of freedom\", introducing multiple kernels and adjusting the kernel offset, allowing for flexibility to introduce an NRD kernel in a variety of ways. Introduce NRD kernel to transaction, compensate with additional kernel. Introduce NRD kernel to transaction, compensate with kernel offset. Payment Channel Implementation NRD kernels can be used to delay alternate \"branches\" of conflicting transactions, enabling a payment channel implementation. A payment channel is represented as a single multi-party output. Each channel state transition is represented as a pair of \"close\" and \"settle\" transactions with an NRD kernel enforcing a delay between them. Funds are held in an intermediate multi-party output while delayed. The NRD kernel is reused across both transactions by adjusting kernel offsets. X -> Y, K nrd_a \\ Y -> [Z a , Z b ], K nrd_a Alice closes the channel X with their \"close\" transaction. After a delay Alice can \"settle\" the funds out to Alice and Bob. Attribution of \"close\" and \"settle\" transactions for each channel state is provided through endpoint specific NRD kernels. This allows the other party to \"revoke\" old invalid state without the NRD delay. Each channel state transition involves a new pair of \"close\" and \"settle\" transactions for each participant along with a shared \"revoke\" transaction. The \"revoke\" transaction simply spends funds back to the channel output and a plain kernel suffices. [Z a , Z b ] -> X, K rev Alice attempts to close old invalid state ( Y 1 ): X -> Y 1 , K nrd_a1 Bob can immediately revoke and close current state ( Y 1 -> Y 2 ): Y 1 -> ~[Z a , Z b ]~, K nrd_b1 \\ ~[Z a , Z b ]~ -> X , K rev_1 \\ X -> Y 2 , K nrd_b2 \\ => Y 1 -> Y 2 , [K nrd_b1 , K rev_1 , K nrd_b2 ] Bob publishes only the final cut-through multi-kernel transaction ( Y 1 -> Y 2 ). Bob's individual settle transaction is not revealed. Neither party can self-revoke without introducing the NRD delay. The other party always has the opportunity to revoke first. Self-revocation cannot be used to lock funds up indefinitely. HF3 (July 2020) Rollout/Deployment The following rules will be enforced during rollout as part of HF3 - Assumptions: HF3 will occur at height 786,240. Blocks at height >= 786,240 will have block version >= 4. Block Specific Rules: A block containing NRD kernel(s) is only be valid if block version >= 4. A block containing NRD kernel(s) is only valid if all defined relative lock height rules are met. Two duplicate NRD kernel instances cannot exist in the same block. Transaction Specific Rules: A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless chain head version >= 4. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless chain head version >= 4. A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless it meets the defined relative lock height rule in the next block. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless it meets the defined relative lock height rule in the next block. Two duplicate NRD kernel instances cannot exist in the txpool/stempool concurrently. Weights & Fees For the purpose of block weight calculations, each kernel is treated as 3 \"weight units\" where each unit is approximately 32 bytes. This covers the excess commitment and the associated signature common across all kernel variants. The additional 2 bytes of \"relative height\" on NRD kernels are ignored for the purposes of calculating block weight. For the purpose of minimum transaction relay fees all kernels are treated as 1 \"fee unit\" with each unit being 1 milligrin. We plan to revisit the entire transaction fee structure in a future RFC. Kernel variants may affect the transaction fee calculations differently in the future. Drawbacks NRD kernels are a limited and restricted form of \"relative locks\" between kernels. These locks are limited to a period of 7 days and \"fail open\" beyond that window. This approach meets the requirements for limited revocable payment channel operations but there are likely to be use cases where this approach is not sufficient or unsuitable. While it would be nice to provide a fully general purpose solution that would allow arbitrary locks to be implemented, it does appear to be hard, if not impossible, to do this in Grin/MW. Rationale and alternatives Referencing historical data in Grin and in Mimblewimble in general is difficult due to the possibility of pruning historical data. It is not possible to reference old outputs once they are spent. Historical validators must have access to any referenced data to validate consensus rules. This leaves transaction kernels as the only available data to be referenced. While arbitrary historical kernels can be referenced this is not desirable as we do not want to impose additional constraints on nodes, requiring them to maintain historical data that would otherwise be prunable. An earlier design iteration was \"No Such Kernel Recently\" (NSKR) locks. Where NRD references were implicit, with duplicate kernel excess commitments, NSKR kernels referenced prior kernels explicitly. These explicit references were problematic for several reasons - Additional overhead, both local storage and network traffic due to the explicit references. Optimization by referencing prior kernel based on MMR position introduced a dependency on external data (kernels can no longer be validated in isolation). Permitting non-existence of references due to limited window of history, opened up a vector for \"spam\" where arbitrary data could be used in place of a valid reference. To prevent \"spam\" a signature can be used to verify the reference was indeed a valid commitment. By including a signature along with the commitment, the reference is effectively a full transaction kernel. The idea of using Merkle proofs to verify inclusion of a historical referenced kernel in the kernel MMR was also considered. This gets expensive both in terms of transaction size and increased verification cost. There is also the problem of position not yet being known at transaction creation time, necessitating Merkle proof generation at block creation time by miners which adds complexity. Prior art Bitcoin allows transaction inputs to be \"encumbered\" with a relative locktime based on the sequence number field. This restricts an input from spending the associated output until a certain number of blocks have passed. BIP112 describes the CHECKSEQUENCEVERIFY opcode in Bitcoin and BIP68 describes the underlying consensus changes around the sequence number field. [Timelock#CheckSequenceVerify (bitcoin wiki)] 6 [CheckSequenceVerify (bitcoin wiki)] 7 [Bitcoin BIP-0068] 8 [Bitcoin BIP-0112] 9 Note that relative locks in Bitcoin are based on transaction inputs and outputs , with inputs only able to spend outputs once confirmed beneath a certain number of blocks. We cannot do this in Grin due to the pruning of old data. Spent outputs will eventually be removed and cannot be relied upon as part of the validation process. Bitcoin encumbers individual outputs whereas in Grin we encumber transactions via the constituent transaction kernels. Unresolved questions Some investigation is still needed around the conditions necessary to allow a kernel to simply be reused with an adjustment to the kernel offset and where an additional kernel is necessary. An adjustment to the kernel offset will expose the private excess under certain conditions and cannot be done safely for all transactions. One outstanding question is what use cases are not covered by NRD kernels. We believe them to be sufficient for the revocable payment channel close mechanism. But they may not be sufficient for all use cases. [Succinct Atomic Swaps (SAS)] 10 describes the use of both relative locks and [adaptor signatures] 11 to implement atomic swaps with only two on-chain transactions. The secret associated with the adaptor signature is swapped to allow funds to be claimed while the relative lock locks funds prior to a refund being claimed. We note that NRD kernels and adaptor signatures are not directly compatible as a prior instance of an NRD kernel would have revealed the secret associated with the adaptor signature. That said we can produce transactions with multiple kernels and we can use this to isolate the adaptor signature on a separate kernel alongside an NRD kernel. It is an unresolved question if there is a way to modify the SAS protocol and avoid the need for these additional kernels in Grin/MW. References Original \"triggers\" mailing list post by Ruben Somsen \u21a9 \"No Such Kernel Recently\" post by John Tromp \u21a9 \"Duplicate Kernels\" post by Antioch \u21a9 \"NRD based payment channel\" post by John Tromp \u21a9 Earlier NSKR based payment channel design \u21a9 Timelock#CheckSequenceVerify (bitcoin wiki) \u21a9 CheckSequenceVerify (bitcoin wiki) \u21a9 Bitcoin BIP-0068 \u21a9 Bitcoin BIP-0112 \u21a9 Succinct Atomic Swaps by Ruben Somsen \u21a9 \u21a9 Scriptless Scripts \u21a9 \u21a9 RFC-0005 \"Variable Size Kernels\" \u21a9","title":"NRD Kernels"},{"location":"wiki/miscellaneous/nrd-kernels/#nrd-kernels","text":"Title: nrd-kernels Authors: Antioch Peverell Start date: Mar 24, 2020 RFC PR: mimblewimble/grin-rfcs#47 Tracking issue: mimblewimble/grin#3288","title":"NRD Kernels"},{"location":"wiki/miscellaneous/nrd-kernels/#summary","text":"Grin supports a limited implementation of \"relative timelocks\" with \"No Recent Duplicate\" (NRD) transaction kernels. Transactions can be constructed such that they share duplicate kernels. An NRD kernel instance is not valid within a specified number of blocks relative to a prior duplicate instance of the kernel. A minimum height difference must therefore exist between two instances of an NRD kernel. This provides the relative height lock between transactions.","title":"Summary"},{"location":"wiki/miscellaneous/nrd-kernels/#motivation","text":"Relative timelocks are a prerequisite for robust payment channels. NRD kernels can be used to implement a revocable channel close mechanism. A mandatory revocation period can be introduced through a relative timelock between two transactions. Any attempt to close an old invalid channel state can be safely revoked during the revocation period. Recently, Ruben Somsen announced a design for [Succinct Atomic Swaps (SAS)] 10 reducing the number of on-chain transactions required to implement the swap. This design uses a combination of relative locks and [adaptor signatures] 11 . SAS would appear to be compatible with Grin/MW but with some caveats, namely the need for an additional transaction kernel as the NRD lock and the adaptor signature cannot co-exist on the same kernel. This is discussed in Unresolved questions below.","title":"Motivation"},{"location":"wiki/miscellaneous/nrd-kernels/#community-level-explanation","text":"A minimum distance in block height is enforced between successive duplicate instances of a given NRD kernel. This can be used to enforce a relative lock height between two transactions. A transaction containing an NRD kernel will not be accepted as valid within the specified block height relative to any prior instance of the NRD kernel. Transactions can be constructed around an existing transaction kernel by introducing either an additional kernel or in some cases by simply adjusting the kernel offset. This allows NRD kernels to be used across any pair of transactions. The NRD kernel implementation aims for simplicity and a minimal approach to solving the problem of \"relative locks\". Grin does not support a general solution for arbitrary length locks between arbitrary kernels. The implementation is limited in scope to avoid adversely impacting performance and scalability. References between duplicate kernels are implicit , avoiding the need to store kernel references. Locks are limited in length to recent history, avoiding the need to inspect the full historical kernel set during verification.","title":"Community-level explanation"},{"location":"wiki/miscellaneous/nrd-kernels/#reference-level-explanation","text":"An NRD kernel is not valid within a specified number of blocks of a previous duplicate instance of the same NRD kernel. We define duplicate here as two NRD kernels sharing the same public excess commitment. NRD kernels with different excess commitments are not treated as duplicates. An NRD kernel and a non-NRD kernel (plain kernel, coinbase kernel etc.) sharing the same excess commitment are not treated as duplicates. An NRD kernel has an associated relative lock height. For a block B containing this kernel to be valid, no duplicate instance of the kernel can exist in the last RH blocks (up to and including B ), where RH is the relative lock height. For example, a transaction containing an NRD kernel with relative lock height 1440 (24 hours) is included in a block at height 1000000. This block is only valid if no duplicate instance of this kernel exists in any block from height 998561 (h-1439) to height 1000000 (h-0) inclusive. A duplicate instance is permitted at height 998560 (h-1440), with the transaction seen as valid. If no duplicate instance of the kernel exists within this range then the lock criteria is met. A kernel can be delayed by the existence of a previous kernel. The non-existence of a previous kernel has no impact on the lock criteria. Note that this implies the first singular occurrence of any NRD kernel meets the lock criteria trivially as it cannot, by definition, be locked by a previous kernel. Thus, the relative lock defaults to \"fail open\" semantics. Each node maintains an index of recent NRD kernels to enable efficient checking of NRD relative lock heights. Note we only need to index NRD locks and we only need to index those within recent history. Relative locks longer than 7 days are not valid. This is believed to be sufficient to cover all proposed use cases. The minimum value for a relative lock height is 1 meaning a prior instance of the kernel can exist in the previous block for the lock criteria to be met. An instance of the NRD kernel in the same block will invalidate the block as the lock criteria will not be met. NRD lock heights of 0 are invalid and it is never valid for two duplicate instances of the same NRD kernel to exist in the same block. It follows that two transactions containing duplicate instances of the same NRD kernel cannot be accepted as valid in the transaction pool concurrently. Current txpool behavior is \"first one wins\" semantics when receiving transactions and this will also apply to transactions containing NRD kernels. We plan to revisit this in a future \"fee\" RFC and plan to investigate the feasibility of introducing \"replace by fee\" semantics at that time. Grin supports \"rewind\" back through recent history to handle fork and chain reorg scenarios. 1 week of full blocks are maintained on each node and up to 10080 blocks can be rewound. To support relative lock heights each node must maintain an index over sufficient kernel history for an additional 10080 blocks beyond this rewind horizon. Each node should maintain 2 weeks of kernel history in the local NRD kernel index. This will cover the pathological case of a 1 week rewind and the validation of a 1 week long relative lock beyond that. The primary use case is for revocable payment channel close operations. We believe a 7 day period is more than sufficient for this. We do not require long, extended revocation periods and limiting this to a few days is preferable to keep the cost of verification low. The need for these revocable transactions to be included on chain should be low as these are only required in a non-cooperative situation but where required we want to minimize the cost of verification which must be performed across all nodes. The following kernel variants are supported in Grin - Plain Coinbase HeightLocked NoRecentDuplicate These are implemented as kernel \"feature\" variants - pub enum KernelFeatures { /// Plain kernel (default for Grin txs). Plain = 0, /// A coinbase kernel. Coinbase = 1, /// A kernel with an explicit absolute lock height. HeightLocked = 2, /// A relative height locked NRD kernel. NoRecentDuplicate = 3, } Each kernel variant includes feature specific data - # Plain { \"fee\": 8 } # Coinbase { # empty } # Height Locked { \"fee\": 8, \"lock_height\": 295800 } # No Recent Duplicate (NRD) { \"fee\": 8, \"relative_height\": 1440, } Note that NRD kernels require no additional data beyond that required for absolute height locked kernels. The reference to the previous kernel is implicit and based on a duplicate NRD kernel excess commitment. The maximum supported NRD relative_height is 10080 (7 days) and the relative height can be safely and conveniently represented as a u16 (2 bytes). This differs from absolute lock heights where u64 (8 bytes) is necessary to specify the lock height. The minimum supported NRD relative_height is 1 and a value of 0 is not valid. Two duplicate instances of a given NRD kernel cannot exist simultaneously in the same block. There must be a relative height of at least 1 block between them. Nodes on the Grin network currently support two serialization versions for transaction kernels - V1 \"fixed size kernels\" In V1 all kernels are serialized to the same \"fixed\" number of bytes: feature ( 1 byte ) | fee ( 8 bytes ) | additional_data ( 8 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 01 f7 8 a 40 | 00 00 00 00 00 00 05 A0 | 08 b1 ... 22 d8 | 33 11 ... b9 69 NRD kernels use the last 2 bytes of feature specific data for the relative lock height as big-endian u16. The first 6 bytes of feature specific data must be all zero: 00 00 00 00 00 00 05 A0 Note: absolute lock height (u64) and relative lock height (u16) have identical serialization in practice. V1 is supported for backward compatibility with nodes that do not support V2 \"variable size kernels\". V2 \"variable size kernels\" V2 kernels have been supported since Grin v2.1.0 and V2 supports the notion of \"variable size\" kernels. See [RFC-0005 \"Varible Size Kernels\"] 12 for details of this. NRD kernels include 8 bytes for the fee as big-endian u64 and 2 bytes for the relative lock height: feature ( 1 byte ) | fee ( 8 bytes ) | relative_height ( 2 bytes ) | excess commitment ( 33 bytes ) | signature ( 64 bytes ) 03 | 00 00 00 00 00 6 a cf c0 | 05 A0 | 09 4 d ... bb 9 a | 09 c7 ... bd 54 In V2 relative lock height is 2 bytes as big-endian u16: 05 A0 Note: the serialization strategy is used for both network \"on the wire\" serialization of both transactions and full blocks, and local storage, both the database for full blocks and the kernel MMR backend files. Version negotiation occurs during the initial peer connection setup process and determines which version is used for p2p message serialization. If a node uses V2 serialization for the kernel MMR backend file then it will provide a V2 txhashset based on these underlying files. Kernel Signature Message Every kernel contains a signature proving the excess commitment is a commitment to zero. The message being signed includes the features, fee and other associated data to prevent malleability of the transaction kernel and the overall transaction. The transaction fee cannot be modified after signing, for example. For NRD kernels the message being signed is constructed as follows with the relative lock height serialized as 2 bytes. Hash(feature | fee | relative_height) Hash(03 | 00 00 00 00 01 f7 8a 40 | 05 A0) No additional data is introduced with NRD kernels beyond the 2 bytes representing the relative lock height. There is no opportunity to include arbitrary data. Any additional kernel included in a transaction is itself still a fully valid kernel. There is no explicit reference necessary that could be misused to include arbitrary data. An additional NRD kernel in a transaction will increase the \"weight\" of the transaction by this single additional kernel and allows for a simple way to deal with additional fees. A transaction with an additional kernel must provide additional fees to cover the additional \"weight\". NRD kernels cannot be added for free. Note that in some limited situations it is possible to replace a kernel with an NRD kernel. If the NRD lock can be introduced without adding an additional kernel then the fee does not have to be increased and the lock is effectively added for free. A transaction kernel consists of an excess commitment and an associated signature showing this excess is indeed a commitment to 0. A transaction with a single kernel can always be represented as a transaction with multiple kernels, provided the kernels excess commitments sum to the correct total excess. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment - rG + 0H This transaction can be represented as a pair of kernels with excess commitments - rG + 0H = (r'G + 0H) + (r-r'G + 0H) We take advantage of this to allow an arbitrary NRD kernel to be included in any transaction at construction time. Additionally the kernel offset included in each transaction can be used in certain situations to allow the replacement of a single transaction kernel with an NRD kernel without needing to introduce an additional kernel. Given an existing NRD kernel with excess commitment - r'G + 0H And a transaction with single excess commitment and kernel offset - rG + 0H, o This transaction can be rewritten to use the NRD kernel - r'G + 0H, (o+r-r') These two \"degrees of freedom\", introducing multiple kernels and adjusting the kernel offset, allowing for flexibility to introduce an NRD kernel in a variety of ways. Introduce NRD kernel to transaction, compensate with additional kernel. Introduce NRD kernel to transaction, compensate with kernel offset.","title":"Reference-level explanation"},{"location":"wiki/miscellaneous/nrd-kernels/#payment-channel-implementation","text":"NRD kernels can be used to delay alternate \"branches\" of conflicting transactions, enabling a payment channel implementation. A payment channel is represented as a single multi-party output. Each channel state transition is represented as a pair of \"close\" and \"settle\" transactions with an NRD kernel enforcing a delay between them. Funds are held in an intermediate multi-party output while delayed. The NRD kernel is reused across both transactions by adjusting kernel offsets. X -> Y, K nrd_a \\ Y -> [Z a , Z b ], K nrd_a Alice closes the channel X with their \"close\" transaction. After a delay Alice can \"settle\" the funds out to Alice and Bob. Attribution of \"close\" and \"settle\" transactions for each channel state is provided through endpoint specific NRD kernels. This allows the other party to \"revoke\" old invalid state without the NRD delay. Each channel state transition involves a new pair of \"close\" and \"settle\" transactions for each participant along with a shared \"revoke\" transaction. The \"revoke\" transaction simply spends funds back to the channel output and a plain kernel suffices. [Z a , Z b ] -> X, K rev Alice attempts to close old invalid state ( Y 1 ): X -> Y 1 , K nrd_a1 Bob can immediately revoke and close current state ( Y 1 -> Y 2 ): Y 1 -> ~[Z a , Z b ]~, K nrd_b1 \\ ~[Z a , Z b ]~ -> X , K rev_1 \\ X -> Y 2 , K nrd_b2 \\ => Y 1 -> Y 2 , [K nrd_b1 , K rev_1 , K nrd_b2 ] Bob publishes only the final cut-through multi-kernel transaction ( Y 1 -> Y 2 ). Bob's individual settle transaction is not revealed. Neither party can self-revoke without introducing the NRD delay. The other party always has the opportunity to revoke first. Self-revocation cannot be used to lock funds up indefinitely. HF3 (July 2020) Rollout/Deployment The following rules will be enforced during rollout as part of HF3 - Assumptions: HF3 will occur at height 786,240. Blocks at height >= 786,240 will have block version >= 4. Block Specific Rules: A block containing NRD kernel(s) is only be valid if block version >= 4. A block containing NRD kernel(s) is only valid if all defined relative lock height rules are met. Two duplicate NRD kernel instances cannot exist in the same block. Transaction Specific Rules: A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless chain head version >= 4. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless chain head version >= 4. A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless it meets the defined relative lock height rule in the next block. A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless it meets the defined relative lock height rule in the next block. Two duplicate NRD kernel instances cannot exist in the txpool/stempool concurrently.","title":"Payment Channel Implementation"},{"location":"wiki/miscellaneous/nrd-kernels/#weights-fees","text":"For the purpose of block weight calculations, each kernel is treated as 3 \"weight units\" where each unit is approximately 32 bytes. This covers the excess commitment and the associated signature common across all kernel variants. The additional 2 bytes of \"relative height\" on NRD kernels are ignored for the purposes of calculating block weight. For the purpose of minimum transaction relay fees all kernels are treated as 1 \"fee unit\" with each unit being 1 milligrin. We plan to revisit the entire transaction fee structure in a future RFC. Kernel variants may affect the transaction fee calculations differently in the future.","title":"Weights &amp; Fees"},{"location":"wiki/miscellaneous/nrd-kernels/#drawbacks","text":"NRD kernels are a limited and restricted form of \"relative locks\" between kernels. These locks are limited to a period of 7 days and \"fail open\" beyond that window. This approach meets the requirements for limited revocable payment channel operations but there are likely to be use cases where this approach is not sufficient or unsuitable. While it would be nice to provide a fully general purpose solution that would allow arbitrary locks to be implemented, it does appear to be hard, if not impossible, to do this in Grin/MW.","title":"Drawbacks"},{"location":"wiki/miscellaneous/nrd-kernels/#rationale-and-alternatives","text":"Referencing historical data in Grin and in Mimblewimble in general is difficult due to the possibility of pruning historical data. It is not possible to reference old outputs once they are spent. Historical validators must have access to any referenced data to validate consensus rules. This leaves transaction kernels as the only available data to be referenced. While arbitrary historical kernels can be referenced this is not desirable as we do not want to impose additional constraints on nodes, requiring them to maintain historical data that would otherwise be prunable. An earlier design iteration was \"No Such Kernel Recently\" (NSKR) locks. Where NRD references were implicit, with duplicate kernel excess commitments, NSKR kernels referenced prior kernels explicitly. These explicit references were problematic for several reasons - Additional overhead, both local storage and network traffic due to the explicit references. Optimization by referencing prior kernel based on MMR position introduced a dependency on external data (kernels can no longer be validated in isolation). Permitting non-existence of references due to limited window of history, opened up a vector for \"spam\" where arbitrary data could be used in place of a valid reference. To prevent \"spam\" a signature can be used to verify the reference was indeed a valid commitment. By including a signature along with the commitment, the reference is effectively a full transaction kernel. The idea of using Merkle proofs to verify inclusion of a historical referenced kernel in the kernel MMR was also considered. This gets expensive both in terms of transaction size and increased verification cost. There is also the problem of position not yet being known at transaction creation time, necessitating Merkle proof generation at block creation time by miners which adds complexity.","title":"Rationale and alternatives"},{"location":"wiki/miscellaneous/nrd-kernels/#prior-art","text":"Bitcoin allows transaction inputs to be \"encumbered\" with a relative locktime based on the sequence number field. This restricts an input from spending the associated output until a certain number of blocks have passed. BIP112 describes the CHECKSEQUENCEVERIFY opcode in Bitcoin and BIP68 describes the underlying consensus changes around the sequence number field. [Timelock#CheckSequenceVerify (bitcoin wiki)] 6 [CheckSequenceVerify (bitcoin wiki)] 7 [Bitcoin BIP-0068] 8 [Bitcoin BIP-0112] 9 Note that relative locks in Bitcoin are based on transaction inputs and outputs , with inputs only able to spend outputs once confirmed beneath a certain number of blocks. We cannot do this in Grin due to the pruning of old data. Spent outputs will eventually be removed and cannot be relied upon as part of the validation process. Bitcoin encumbers individual outputs whereas in Grin we encumber transactions via the constituent transaction kernels.","title":"Prior art"},{"location":"wiki/miscellaneous/nrd-kernels/#unresolved-questions","text":"Some investigation is still needed around the conditions necessary to allow a kernel to simply be reused with an adjustment to the kernel offset and where an additional kernel is necessary. An adjustment to the kernel offset will expose the private excess under certain conditions and cannot be done safely for all transactions. One outstanding question is what use cases are not covered by NRD kernels. We believe them to be sufficient for the revocable payment channel close mechanism. But they may not be sufficient for all use cases. [Succinct Atomic Swaps (SAS)] 10 describes the use of both relative locks and [adaptor signatures] 11 to implement atomic swaps with only two on-chain transactions. The secret associated with the adaptor signature is swapped to allow funds to be claimed while the relative lock locks funds prior to a refund being claimed. We note that NRD kernels and adaptor signatures are not directly compatible as a prior instance of an NRD kernel would have revealed the secret associated with the adaptor signature. That said we can produce transactions with multiple kernels and we can use this to isolate the adaptor signature on a separate kernel alongside an NRD kernel. It is an unresolved question if there is a way to modify the SAS protocol and avoid the need for these additional kernels in Grin/MW.","title":"Unresolved questions"},{"location":"wiki/miscellaneous/nrd-kernels/#references","text":"Original \"triggers\" mailing list post by Ruben Somsen \u21a9 \"No Such Kernel Recently\" post by John Tromp \u21a9 \"Duplicate Kernels\" post by Antioch \u21a9 \"NRD based payment channel\" post by John Tromp \u21a9 Earlier NSKR based payment channel design \u21a9 Timelock#CheckSequenceVerify (bitcoin wiki) \u21a9 CheckSequenceVerify (bitcoin wiki) \u21a9 Bitcoin BIP-0068 \u21a9 Bitcoin BIP-0112 \u21a9 Succinct Atomic Swaps by Ruben Somsen \u21a9 \u21a9 Scriptless Scripts \u21a9 \u21a9 RFC-0005 \"Variable Size Kernels\" \u21a9","title":"References"},{"location":"wiki/miscellaneous/switch-commitments/","text":"Introduction to Switch Commitments Read this in other languages: \u7b80\u4f53\u4e2d\u6587 . General introduction In cryptography a Commitment (or commitment scheme ) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public). The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person. They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \" committed \" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing. Examples Hash Commitment A simple commitment scheme can be realized with a cryptographic hash function. For example: Alice and Bob want to play \"Guess my number\" and Alice comes up with with her really secret number 29 which Bob has to guess in the game, then before the game starts, Alice calculates: hash( 29 + r ) and publishes the result to Bob. The r is a randomly chosen Blinding Factor which is needed because otherwise Bob could just try hashing all the possible numbers for the game and compare the hashes. When the game is finished, Alice simply needs to publish her secret number 29 and the blinding factor r and Bob can calculate the hash himself and easily verify that Alice did not change the secret number during the game. Pedersen Commitment Other, more advanced commitment schemes can have additional properties. For example Mimblewimble and Confidential Transactions (CT) make heavy use of Pedersen Commitments , which are homomorphic commitments. Homomorphic in this context means that (speaking in the \"box\" metaphor from above) you can take two of these locked boxes ( box1 and box2 ) and somehow \" add \" them together, so that you get a single box as result (which still is locked), and if you open this single box later (like in the examples before) the secret it contains, is the sum of the secrets from box1 and box2 . While this \"box\" metaphor no longer seems to be reasonable in the real-world this is perfectly possible using the properties of operations on elliptic curves. Look into Introduction to Mimblewimble for further details on Pedersen Commitments and how they are used in Grin. Properties of commitment schemes: In general for any commitment scheme we can identify two important properties which can be weaker or stronger, depending on the type of commitment scheme: Hidingness (or Confidentiality): How good is the commitment scheme protecting the secret commitment. Or speaking in terms of our example from above: what would an attacker need to open the box (and learn the secret number) without having the key to unlock it? Bindingness: Is it possible at all (or how hard would it be) for an attacker to somehow find a different secret, which would produce the same commitment, so that the attacker could later open the commitment to a different secret, thus breaking the binding of the commitment. Security of these properties: For these two properties different security levels can be identified. The two most important combinations of these are perfectly binding and computationally hiding commitment schemes and computationally binding and perfectly hiding commitment schemes \" Computationally \" binding or hiding means that the property (bindingness/hidingness) is secured by the fact that the underlying mathematical problem is too hard to be solved with existing computing power in reasonable time (i.e. not breakable today as computational resources are bound in the real world). \" Perfectly \" binding or hiding means that even with infinite computing power it would be impossible to break the property (bindingness/hidingness). Mutual exclusivity: It is important to realize that it's impossible that any commitment scheme can be perfectly binding and perfectly hiding at the same time. This can be easily shown with a thought experiment: Imagine an attacker having infinite computing power, he could simply generate a commitment for all possible values (and blinding factors) until finding a pair that outputs the same commitment. If we further assume the commitment scheme is perfectly binding (meaning there cannot be two different values leading to the same commitment) this uniquely would identify the value within the commitment, thus breaking the hidingness. The same is true the other way around. If a commitment scheme is perfectly hiding there must exist several input values resulting in the same commitment (otherwise an attacker with infinite computing power could just try all possible values as described above). This concludes that the commitment scheme cannot be perfectly binding . Always a compromise The key take-away point is this: it's always a compromise , you can never have both properties ( hidingness and bindingness ) with perfect security. If one is perfectly secure then the other can be at most computationally secure (and the other way around). Considerations for cryptocurrencies Which roles do these properties play in the design of cryptocurrencies? Hidingness : In privacy oriented cryptocurrencies like Grin, commitment schemes are used to secure the contents of transactions. The sender commits to an amount of coins he sends, but for the general public the concrete amount should remain private (protected by the hidingness property of the commitment scheme). Bindingness : At the same time no transaction creator should ever be able to change his commitment to a different transaction amount later in time. If this would be possible, an attacker could spend more coins than previously committed to in an UTXO (unspent transaction output) and therefore inflate coins out of thin air. Even worse, as the amounts are hidden, this could go undetected. So there is a valid interest in having both of these properties always secured and never be violated. Even with the intent being that both of these properties will hold for the lifetime of a cryptocurrency, still a choice has to be made about which commitment scheme to use. A hard choice? Which one of these two properties needs to be perfectly safe and for which one it would be sufficient to be computationally safe? Or in other words: in case of a disaster, if the commitment scheme unexpectedly gets broken, which one of the two properties should be valued higher? Economical soundness (no hidden inflation possible) or ensured privacy (privacy will be preserved)? This seems like a hard to choice to make. If we look closer into this we realize that the commitment scheme only needs to be perfectly binding at the point in time when the scheme actually gets broken. Until then it will be safe even if it's only computationally binding. At the same time a privacy-oriented cryptocurrency needs to ensure the hidingness property forever . Unlike the binding property, which only is important at the time when a transaction is created and will not affect past transactions, the hidingness property must be ensured at all times. Otherwise, in the unfortunate case should the commitment scheme be broken, an attacker could go back in the chain and unblind past transactions, thus break the privacy property retroactively. Properties of Pedersen Commitments Pedersen Commitments are computationally binding and perfectly hiding as for a given commitment to the value v : v*H + r*G there may exist a pair of different values r1 and v1 such that the sum will be the same. Even if you have infinite computing power and could try all possible values, you would not be able to tell which one is the original one (thus perfectly hiding ). Introducing Switch Commitments So what can be done if the bindingness of the Pedersen Commitment unexpectedly gets broken? In general a cryptocurrency confronted with a broken commitment scheme could choose to change the scheme in use, but the problem with this approach would be that it requires to create new transaction outputs using the new scheme to make funds secure again. This would require every coin holder to move his coins into new transaction outputs. If coins are not moved into new outputs, they will not profit from the security of the new commitment scheme. Also, this has to happen before the scheme gets actually broken in the wild, otherwise the existing UTXOs no longer can be assumed to contain correct values. In this situation Switch Commitments offer a neat solution. These type of commitments allow changing the properties of the commitments just by changing the revealing / validating procedure without changing the way commitments are created. (You \" switch \" to a new validation scheme which is backwards compatible with commitments created long before the actual \" switch \"). How does this work in detail First let's introduce a new commitment scheme: The ElGamal commitment scheme is a commitment scheme similiar to Pedersen Commitments and it's perfectly binding (but only computationally hiding as we can never have both). It looks very similar to a Pedersen Commitment, with the addition of a new element, calculated by multiplying the blinding factor r with another generator point J : v*H + r*G , r*J So if we store the additional field r*J and ignore it for now, we can treat it like Pedersen Commitments, until we decide to also validate the full ElGamal commitment at some time in future. This is exactly what was implemented in an earlier version of Grin , before mainnet was launched. In detail: the hashed value of r*J ( switch_commit_hash ) was added to the transaction output, but this came with the burden of increasing the size of each output by 32 bytes. Fortunately, later on the Mimblewimble mailinglist Tim Ruffing came up with a really beautiful idea (initially suggested by Pieter Wuille), which offers the same advantages but doesn't need this extra storage of an additional element per transaction output: The idea is the following: A normal Pedersen commitment looks like this: v*H + r*G ( v is value of the input/output, r is a truly random blinding factor, and H and G are two generator points on the elliptic curve). If we adapt this by having r not being random itself, but using another random number r' and create the Pedersen Commitment: v*H + r*G such that: r = r' + hash( v*H + r'*G , r'*J ) (using the additional third generation point J on the curve) then r still is perfectly valid as a blinding factor, as it's still randomly distributed, but now we see that the part within the brackets of the hash function ( v*H + r'*G , r'*J ) is an ElGamal commitment . This neat idea lead to the removal of the switch commitment hash from the outputs in this (and following) pull requests as now it could be easily included into the Pedersen Commitments. This is how it is currently implemented in Grin. Pedersen commitments are used for the Confidential Transaction but instead of choosing the blinding factor r only by random, it is calculated by adding the hash of an ElGamal commitment to a random r' (see here in main_impl.h#L267 ). In general switch commitments were first described in the paper \"Switch Commitments: A Safety Switch for Confidential Transactions\" ). The \"switch\" in the name comes from the fact that you can virtually flip a \"switch\" in the future and simply by changing the validation procedure you can change the strength of the bindingness and hidingness property of your commitments and this even works in a backwards compatible way with commitments created today. Conclusion Grin uses Pedersen Commitments - like other privacy cryptocurrencies do as well - with the only difference that the random blinding factor r is created using the ElGamal commitment scheme. This might not seem like a big change on a first look, but it provides an important safety measure: Pedersen Commitments are already perfectly hiding so whatever happens, privacy will never be at risk without requiring any action from users. But in case of a disaster if the bindingness of the commitment scheme gets broken, then switch commitments can be enabled (via a soft fork) requiring that all new transactions prove that their commitment is not breaking the bindingness by validating the full ElGamal commitment. But in this case users would still have a choice: they can decide to continue to create new transactions, even if this might compromise their privacy (only on their last UTXOs) as the ElGamal commitment scheme is only computationally hiding, but at least they would still have access to their coins or users can decide to just leave the money alone, walk away and make no more transactions (but preserve their privacy, as their old transactions only validated the Pedersen commitment which is perfectly hiding) There are many cases where a privacy leak is much more dangerous to one's life than some cryptocurrency might be worth. But this is a decision that should be left up to the individual user and switch commitments enable this type of choice. It should be made clear that this is a safety measure meant to be enabled in case of a disaster. If advances in computing would put the hardness of the discrete log problem in question, a lot of other cryptographic systems, including other cryptocurrencies, will be in urgent need of updating their primitives to a future-proof system. The switch commitments just provide an additional layer of security if the bindingness of Pedersen commitments ever breaks unexpectedly.","title":"Switch Commitments"},{"location":"wiki/miscellaneous/switch-commitments/#introduction-to-switch-commitments","text":"Read this in other languages: \u7b80\u4f53\u4e2d\u6587 .","title":"Introduction to Switch Commitments"},{"location":"wiki/miscellaneous/switch-commitments/#general-introduction","text":"In cryptography a Commitment (or commitment scheme ) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public). The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person. They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \" committed \" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing.","title":"General introduction"},{"location":"wiki/miscellaneous/switch-commitments/#examples","text":"","title":"Examples"},{"location":"wiki/miscellaneous/switch-commitments/#hash-commitment","text":"A simple commitment scheme can be realized with a cryptographic hash function. For example: Alice and Bob want to play \"Guess my number\" and Alice comes up with with her really secret number 29 which Bob has to guess in the game, then before the game starts, Alice calculates: hash( 29 + r ) and publishes the result to Bob. The r is a randomly chosen Blinding Factor which is needed because otherwise Bob could just try hashing all the possible numbers for the game and compare the hashes. When the game is finished, Alice simply needs to publish her secret number 29 and the blinding factor r and Bob can calculate the hash himself and easily verify that Alice did not change the secret number during the game.","title":"Hash Commitment"},{"location":"wiki/miscellaneous/switch-commitments/#pedersen-commitment","text":"Other, more advanced commitment schemes can have additional properties. For example Mimblewimble and Confidential Transactions (CT) make heavy use of Pedersen Commitments , which are homomorphic commitments. Homomorphic in this context means that (speaking in the \"box\" metaphor from above) you can take two of these locked boxes ( box1 and box2 ) and somehow \" add \" them together, so that you get a single box as result (which still is locked), and if you open this single box later (like in the examples before) the secret it contains, is the sum of the secrets from box1 and box2 . While this \"box\" metaphor no longer seems to be reasonable in the real-world this is perfectly possible using the properties of operations on elliptic curves. Look into Introduction to Mimblewimble for further details on Pedersen Commitments and how they are used in Grin.","title":"Pedersen Commitment"},{"location":"wiki/miscellaneous/switch-commitments/#properties-of-commitment-schemes","text":"In general for any commitment scheme we can identify two important properties which can be weaker or stronger, depending on the type of commitment scheme: Hidingness (or Confidentiality): How good is the commitment scheme protecting the secret commitment. Or speaking in terms of our example from above: what would an attacker need to open the box (and learn the secret number) without having the key to unlock it? Bindingness: Is it possible at all (or how hard would it be) for an attacker to somehow find a different secret, which would produce the same commitment, so that the attacker could later open the commitment to a different secret, thus breaking the binding of the commitment.","title":"Properties of commitment schemes:"},{"location":"wiki/miscellaneous/switch-commitments/#security-of-these-properties","text":"For these two properties different security levels can be identified. The two most important combinations of these are perfectly binding and computationally hiding commitment schemes and computationally binding and perfectly hiding commitment schemes \" Computationally \" binding or hiding means that the property (bindingness/hidingness) is secured by the fact that the underlying mathematical problem is too hard to be solved with existing computing power in reasonable time (i.e. not breakable today as computational resources are bound in the real world). \" Perfectly \" binding or hiding means that even with infinite computing power it would be impossible to break the property (bindingness/hidingness).","title":"Security of these properties:"},{"location":"wiki/miscellaneous/switch-commitments/#mutual-exclusivity","text":"It is important to realize that it's impossible that any commitment scheme can be perfectly binding and perfectly hiding at the same time. This can be easily shown with a thought experiment: Imagine an attacker having infinite computing power, he could simply generate a commitment for all possible values (and blinding factors) until finding a pair that outputs the same commitment. If we further assume the commitment scheme is perfectly binding (meaning there cannot be two different values leading to the same commitment) this uniquely would identify the value within the commitment, thus breaking the hidingness. The same is true the other way around. If a commitment scheme is perfectly hiding there must exist several input values resulting in the same commitment (otherwise an attacker with infinite computing power could just try all possible values as described above). This concludes that the commitment scheme cannot be perfectly binding .","title":"Mutual exclusivity:"},{"location":"wiki/miscellaneous/switch-commitments/#always-a-compromise","text":"The key take-away point is this: it's always a compromise , you can never have both properties ( hidingness and bindingness ) with perfect security. If one is perfectly secure then the other can be at most computationally secure (and the other way around).","title":"Always a compromise"},{"location":"wiki/miscellaneous/switch-commitments/#considerations-for-cryptocurrencies","text":"Which roles do these properties play in the design of cryptocurrencies? Hidingness : In privacy oriented cryptocurrencies like Grin, commitment schemes are used to secure the contents of transactions. The sender commits to an amount of coins he sends, but for the general public the concrete amount should remain private (protected by the hidingness property of the commitment scheme). Bindingness : At the same time no transaction creator should ever be able to change his commitment to a different transaction amount later in time. If this would be possible, an attacker could spend more coins than previously committed to in an UTXO (unspent transaction output) and therefore inflate coins out of thin air. Even worse, as the amounts are hidden, this could go undetected. So there is a valid interest in having both of these properties always secured and never be violated. Even with the intent being that both of these properties will hold for the lifetime of a cryptocurrency, still a choice has to be made about which commitment scheme to use.","title":"Considerations for cryptocurrencies"},{"location":"wiki/miscellaneous/switch-commitments/#a-hard-choice","text":"Which one of these two properties needs to be perfectly safe and for which one it would be sufficient to be computationally safe? Or in other words: in case of a disaster, if the commitment scheme unexpectedly gets broken, which one of the two properties should be valued higher? Economical soundness (no hidden inflation possible) or ensured privacy (privacy will be preserved)? This seems like a hard to choice to make. If we look closer into this we realize that the commitment scheme only needs to be perfectly binding at the point in time when the scheme actually gets broken. Until then it will be safe even if it's only computationally binding. At the same time a privacy-oriented cryptocurrency needs to ensure the hidingness property forever . Unlike the binding property, which only is important at the time when a transaction is created and will not affect past transactions, the hidingness property must be ensured at all times. Otherwise, in the unfortunate case should the commitment scheme be broken, an attacker could go back in the chain and unblind past transactions, thus break the privacy property retroactively.","title":"A hard choice?"},{"location":"wiki/miscellaneous/switch-commitments/#properties-of-pedersen-commitments","text":"Pedersen Commitments are computationally binding and perfectly hiding as for a given commitment to the value v : v*H + r*G there may exist a pair of different values r1 and v1 such that the sum will be the same. Even if you have infinite computing power and could try all possible values, you would not be able to tell which one is the original one (thus perfectly hiding ).","title":"Properties of Pedersen Commitments"},{"location":"wiki/miscellaneous/switch-commitments/#introducing-switch-commitments","text":"So what can be done if the bindingness of the Pedersen Commitment unexpectedly gets broken? In general a cryptocurrency confronted with a broken commitment scheme could choose to change the scheme in use, but the problem with this approach would be that it requires to create new transaction outputs using the new scheme to make funds secure again. This would require every coin holder to move his coins into new transaction outputs. If coins are not moved into new outputs, they will not profit from the security of the new commitment scheme. Also, this has to happen before the scheme gets actually broken in the wild, otherwise the existing UTXOs no longer can be assumed to contain correct values. In this situation Switch Commitments offer a neat solution. These type of commitments allow changing the properties of the commitments just by changing the revealing / validating procedure without changing the way commitments are created. (You \" switch \" to a new validation scheme which is backwards compatible with commitments created long before the actual \" switch \").","title":"Introducing Switch Commitments"},{"location":"wiki/miscellaneous/switch-commitments/#how-does-this-work-in-detail","text":"First let's introduce a new commitment scheme: The ElGamal commitment scheme is a commitment scheme similiar to Pedersen Commitments and it's perfectly binding (but only computationally hiding as we can never have both). It looks very similar to a Pedersen Commitment, with the addition of a new element, calculated by multiplying the blinding factor r with another generator point J : v*H + r*G , r*J So if we store the additional field r*J and ignore it for now, we can treat it like Pedersen Commitments, until we decide to also validate the full ElGamal commitment at some time in future. This is exactly what was implemented in an earlier version of Grin , before mainnet was launched. In detail: the hashed value of r*J ( switch_commit_hash ) was added to the transaction output, but this came with the burden of increasing the size of each output by 32 bytes. Fortunately, later on the Mimblewimble mailinglist Tim Ruffing came up with a really beautiful idea (initially suggested by Pieter Wuille), which offers the same advantages but doesn't need this extra storage of an additional element per transaction output: The idea is the following: A normal Pedersen commitment looks like this: v*H + r*G ( v is value of the input/output, r is a truly random blinding factor, and H and G are two generator points on the elliptic curve). If we adapt this by having r not being random itself, but using another random number r' and create the Pedersen Commitment: v*H + r*G such that: r = r' + hash( v*H + r'*G , r'*J ) (using the additional third generation point J on the curve) then r still is perfectly valid as a blinding factor, as it's still randomly distributed, but now we see that the part within the brackets of the hash function ( v*H + r'*G , r'*J ) is an ElGamal commitment . This neat idea lead to the removal of the switch commitment hash from the outputs in this (and following) pull requests as now it could be easily included into the Pedersen Commitments. This is how it is currently implemented in Grin. Pedersen commitments are used for the Confidential Transaction but instead of choosing the blinding factor r only by random, it is calculated by adding the hash of an ElGamal commitment to a random r' (see here in main_impl.h#L267 ). In general switch commitments were first described in the paper \"Switch Commitments: A Safety Switch for Confidential Transactions\" ). The \"switch\" in the name comes from the fact that you can virtually flip a \"switch\" in the future and simply by changing the validation procedure you can change the strength of the bindingness and hidingness property of your commitments and this even works in a backwards compatible way with commitments created today.","title":"How does this work in detail"},{"location":"wiki/miscellaneous/switch-commitments/#conclusion","text":"Grin uses Pedersen Commitments - like other privacy cryptocurrencies do as well - with the only difference that the random blinding factor r is created using the ElGamal commitment scheme. This might not seem like a big change on a first look, but it provides an important safety measure: Pedersen Commitments are already perfectly hiding so whatever happens, privacy will never be at risk without requiring any action from users. But in case of a disaster if the bindingness of the commitment scheme gets broken, then switch commitments can be enabled (via a soft fork) requiring that all new transactions prove that their commitment is not breaking the bindingness by validating the full ElGamal commitment. But in this case users would still have a choice: they can decide to continue to create new transactions, even if this might compromise their privacy (only on their last UTXOs) as the ElGamal commitment scheme is only computationally hiding, but at least they would still have access to their coins or users can decide to just leave the money alone, walk away and make no more transactions (but preserve their privacy, as their old transactions only validated the Pedersen commitment which is perfectly hiding) There are many cases where a privacy leak is much more dangerous to one's life than some cryptocurrency might be worth. But this is a decision that should be left up to the individual user and switch commitments enable this type of choice. It should be made clear that this is a safety measure meant to be enabled in case of a disaster. If advances in computing would put the hardness of the discrete log problem in question, a lot of other cryptographic systems, including other cryptocurrencies, will be in urgent need of updating their primitives to a future-proof system. The switch commitments just provide an additional layer of security if the bindingness of Pedersen commitments ever breaks unexpectedly.","title":"Conclusion"},{"location":"wiki/security-process/code-audits/","text":"Code Audits Continued code reviews and audits are important for the security of Grin. As such, we highly encourage interested security researchers to: Review our code, even if no contributions are planned. Publish their findings in accordance with our responsible disclosure standard , even if no particular bug or vulnerability was found. We can all learn from new sets of eyes and benefit from increased scrutiny. While we may disagree with some small points of design or trade-offs, we will always do so respectfully. All code review and audit contributions are welcome regardless of depth, area or background of the contributor. Many contributions from many different perspectives can help ensure long term security for the Grin codebase. A complete list of PGP keys, canaries, CVEs and audits can be found in the grin-security repository. Past Audits Audit Results JP Aumasson, secp256k1 extensions report - status Coinspect, code audit v1.0.1 report - status Nym Seddon, code audit v4.0.0 report - status","title":"Code Audits"},{"location":"wiki/security-process/code-audits/#code-audits","text":"Continued code reviews and audits are important for the security of Grin. As such, we highly encourage interested security researchers to: Review our code, even if no contributions are planned. Publish their findings in accordance with our responsible disclosure standard , even if no particular bug or vulnerability was found. We can all learn from new sets of eyes and benefit from increased scrutiny. While we may disagree with some small points of design or trade-offs, we will always do so respectfully. All code review and audit contributions are welcome regardless of depth, area or background of the contributor. Many contributions from many different perspectives can help ensure long term security for the Grin codebase. A complete list of PGP keys, canaries, CVEs and audits can be found in the grin-security repository.","title":"Code Audits"},{"location":"wiki/security-process/code-audits/#past-audits","text":"Audit Results JP Aumasson, secp256k1 extensions report - status Coinspect, code audit v1.0.1 report - status Nym Seddon, code audit v4.0.0 report - status","title":"Past Audits"},{"location":"wiki/security-process/grin-security-process/","text":"Grin's Security Process Grin has a code of conduct and the handling of vulnerability disclosure is no exception. We are committed to conduct our security process in a professional and civil manner. Public shaming, under-reporting or misrepresentation of vulnerabilities will not be tolerated. Responsible Disclosure Standard Grin follows a community standard for responsible disclosure in cryptocurrency and related software. This document is a public commitment to following the standard. This standard provides detailed information for: Initial Contact : how the initial contact process works Giving Details : what details to include with your disclosure after receiving a response to your initial contact Setting Dates : details for when to release updates and publicize details of the issue Any expected deviations and necessary clarifications around the standard are explained in the following sections. Receiving Disclosures Grin is committed to working with researchers who submit security vulnerability notifications to us, to resolve those issues on an appropriate timeline and perform a coordinated release, giving credit to the reporter if they would like. Please submit issues to all of the following main points of contact for security related issues according to the initial contact and details guidelines. More information is available about the expected timelines for the full disclosure cycle . For all security related issues, Grin has 3 main points of contact : Daniel Lehnberg, daniel.lehnberg at protonmail.com PGP key hashmap, hashmap.dev at protonmail.com PGP key John Woeltz, joltz at protonmail.com PGP key Send all communications PGP encrypted to all parties. Sending Disclosures In the case where we become aware of security issues affecting other projects that has never affected Grin, our intention is to inform those projects of security issues on a best effort basis. In the case where we fix a security issue in Grin that also affects the following neighboring projects, our intention is to engage in responsible disclosures with them as described in the adopted standard , subject to the deviations described in the deviations section of this document. Bilateral Responsible Disclosure Agreements Grin does not currently have any established bilateral disclosure agreements. Recognition and Bug Bounties Grin's responsible disclosure standard includes some general language about Bounty Payments and Acknowledgements . Grin is a traditional open source project with limited to no direct funding . As such, we have little means with which to compensate security researchers for their contributions. We recognize this is a shame and intend to do our best to still make these worth while by: Advertising the vulnerability, the researchers, or their team on a public page linked from our website, with a links of their choosing. Acting as reference whenever this is needed. Setting up retroactive bounties whenever possible. There is not currently a formal bug bounty program for Grin as it would require a high level of resources and engagement to operate in good faith. More funding can help provide the necessary resources to run one in the future for the Grin community. Deviations from the Standard Grin is a technology that provides strong privacy with zero-knowledge commitments and rangeproofs. Due to the nature of the cryptography used, if a counterfeiting bug results it could be exploited without a way to identify which data was corrupted. This renders rollbacks or other fork-based attempted fixes ineffective. The standard describes reporters of vulnerabilities including full details of an issue, in order to reproduce it. This is necessary for instance in the case of an external researcher both demonstrating and proving that there really is a security issue, and that security issue really has the impact that they say it has - allowing the development team to accurately prioritize and resolve the issue. In the case of a counterfeiting or privacy-breaking bug, however, we might decide not to include those details with our reports to partners ahead of coordinated release, so long as we are sure that they are vulnerable. More Information Additional security-related information about the Grin project including previous audits, CVEs, canaries, signatures and PGP public keys can be found in the grin-security repository.","title":"Grin's Security Process"},{"location":"wiki/security-process/grin-security-process/#grins-security-process","text":"Grin has a code of conduct and the handling of vulnerability disclosure is no exception. We are committed to conduct our security process in a professional and civil manner. Public shaming, under-reporting or misrepresentation of vulnerabilities will not be tolerated.","title":"Grin's Security Process"},{"location":"wiki/security-process/grin-security-process/#responsible-disclosure-standard","text":"Grin follows a community standard for responsible disclosure in cryptocurrency and related software. This document is a public commitment to following the standard. This standard provides detailed information for: Initial Contact : how the initial contact process works Giving Details : what details to include with your disclosure after receiving a response to your initial contact Setting Dates : details for when to release updates and publicize details of the issue Any expected deviations and necessary clarifications around the standard are explained in the following sections.","title":"Responsible Disclosure Standard"},{"location":"wiki/security-process/grin-security-process/#receiving-disclosures","text":"Grin is committed to working with researchers who submit security vulnerability notifications to us, to resolve those issues on an appropriate timeline and perform a coordinated release, giving credit to the reporter if they would like. Please submit issues to all of the following main points of contact for security related issues according to the initial contact and details guidelines. More information is available about the expected timelines for the full disclosure cycle . For all security related issues, Grin has 3 main points of contact : Daniel Lehnberg, daniel.lehnberg at protonmail.com PGP key hashmap, hashmap.dev at protonmail.com PGP key John Woeltz, joltz at protonmail.com PGP key Send all communications PGP encrypted to all parties.","title":"Receiving Disclosures"},{"location":"wiki/security-process/grin-security-process/#sending-disclosures","text":"In the case where we become aware of security issues affecting other projects that has never affected Grin, our intention is to inform those projects of security issues on a best effort basis. In the case where we fix a security issue in Grin that also affects the following neighboring projects, our intention is to engage in responsible disclosures with them as described in the adopted standard , subject to the deviations described in the deviations section of this document.","title":"Sending Disclosures"},{"location":"wiki/security-process/grin-security-process/#bilateral-responsible-disclosure-agreements","text":"Grin does not currently have any established bilateral disclosure agreements.","title":"Bilateral Responsible Disclosure Agreements"},{"location":"wiki/security-process/grin-security-process/#recognition-and-bug-bounties","text":"Grin's responsible disclosure standard includes some general language about Bounty Payments and Acknowledgements . Grin is a traditional open source project with limited to no direct funding . As such, we have little means with which to compensate security researchers for their contributions. We recognize this is a shame and intend to do our best to still make these worth while by: Advertising the vulnerability, the researchers, or their team on a public page linked from our website, with a links of their choosing. Acting as reference whenever this is needed. Setting up retroactive bounties whenever possible. There is not currently a formal bug bounty program for Grin as it would require a high level of resources and engagement to operate in good faith. More funding can help provide the necessary resources to run one in the future for the Grin community.","title":"Recognition and Bug Bounties"},{"location":"wiki/security-process/grin-security-process/#deviations-from-the-standard","text":"Grin is a technology that provides strong privacy with zero-knowledge commitments and rangeproofs. Due to the nature of the cryptography used, if a counterfeiting bug results it could be exploited without a way to identify which data was corrupted. This renders rollbacks or other fork-based attempted fixes ineffective. The standard describes reporters of vulnerabilities including full details of an issue, in order to reproduce it. This is necessary for instance in the case of an external researcher both demonstrating and proving that there really is a security issue, and that security issue really has the impact that they say it has - allowing the development team to accurately prioritize and resolve the issue. In the case of a counterfeiting or privacy-breaking bug, however, we might decide not to include those details with our reports to partners ahead of coordinated release, so long as we are sure that they are vulnerable.","title":"Deviations from the Standard"},{"location":"wiki/security-process/grin-security-process/#more-information","text":"Additional security-related information about the Grin project including previous audits, CVEs, canaries, signatures and PGP public keys can be found in the grin-security repository.","title":"More Information"},{"location":"wiki/security-process/security-team/","text":"Security Team Title: security-team Authors: joltz Start date: Jan 22 2020 RFC PR: mimblewimble/grin-rfcs#39 Tracking issue: mimblewimble/grin-pm/#258 Summary The security team for Grin carries out the security priorities of the Grin community and core team, which are to be defined prior to formation of the team. The security team streamlines the security decision making process for the core team while maintaining a careful balance of security and transparency for the community. Motivation Improve transparency, efficiency, decisiveness and scalability around security-related decision making Dedicated support for security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work Increase confidence in the ecosystem for future contributions A clear and structured decision making process is needed to fully support the current security process as well as community initiatives such as bilateral disclosure agreements, bug bounty programs and future audit work. This process was previously maintained by the core team who had many areas of focus, leading to a lack of clarity, timeliness and ability to decisively execute on community security initiatives. The security team frees up core resources to focus on other important areas while expanding dedicated resources to security work, allowing the Grin ecosystem to continue to scale. A clear decision making structure around the security process instills confidence in the greater ecosystem and encourages projects, developers and users to continue to increase contributions of time and resources into Grin. Community-level explanation Grin's security team is responsible for making predefined security related decisions for the Grin project. This includes, but is not limited to, decisions about the specification and implementation of Grin's security processes. As much as possible Grin's security team carries out the security priorities of the community and core team in a transparent manner. There may be some unique security-related cases that require the security team to make some decisions in private to protect the security of Grin users. In these cases, once it is safe to do so, the security team is responsible for sharing as many details as possible with the community for transparency and accountability purposes. The primary day-to-day impact this will have on the community is making available structured support around security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work. The community and other teams will have regular opportunity to interact with, provide input to and receive input from the security team. Example Here we will walk through an example case that highlights how Grin's security team would operate, contrasting with the current process. In the example case, a vulnerability is disclosed to the disclosure contacts listed in Grin's security policy. It is shown that the community gains greater transparency into the decision making process and related outcomes with the proposed security team. Additionally the disclosure map is more tightly contained in the proposed process, resulting in less risk of vulnerability exploitation to the community. Previous Process Grin's security contacts make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, all details of the disclosure are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy Once the vulnerability is mitigated the core team may optionally share some of the details with the community Security Team Process Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, a conversation and plan of action is determined and executed by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated the security team must disclose all information that is not still security-critical with the community Reference-level explanation Grin's security team will be implemented as stated below. Membership Bootstrapped by existing security contacts (@lehnberg, @hashmap, @joltz) Minimum three, maximum five members Membership is recommended by the security team and approved by the core team All members must have relevant domain expertise in security, cryptography, the Grin codebase or Grin community All members must have high competency in maintaining personal operational security (keeping private keys secure, maintaining secure communications channels etc.) Membership is revoked by failure to update the canary, unanimous decision by team or decision from the core team Note if the core team engages in removing members from the security team without reasonable justification, the security team loses purpose, becomes ineffective and is relegated to useless security theater Decision Making Distinction between security-team decisions and security-related decisions : The security team is responsible for making predefined security-team decisions, not all possible ambiguous security-related decisions Decisions are made primarily with consideration to the security priorities outlined prior to the team's formation Unanimous approval of security team members is needed to make all impactful decisions Some decisions made must also be approved by the core team to be carried out: Adding/removing parties from disclosure agreements Adding members to the security team Updating the security policy In the event that the core team does not follow a security team recommendation, a reasonable explanation must be provided as to why the security recommendation was not followed Some decisions must be made without fully informing the core team of all details: When fixing a vulnerability requires a deviation from the standard In these cases not all information will be shared with core team, such as specific details to carry out an exploit, full impact and other relevant information that will create unnecessary risk if disclosed The core team must be notified of all cases of these decisions within a reasonable time frame that does not pose a security risk (e.g. after a fix is implemented) and provided with a reasonable explanation by the security team Vetoes Any member of the security team may veto an impactful security team decision The ability to veto an impactful security team decision is important to preserve the ability for members of the security team to make honest recommendations. Important and controversial decisions will be made and members of the security team need the ability to not sign their names to a decision they are not comfortable with that could have serious ramifications. These cases will be handled according to the Deadlocks section below. The security team should always strive to reach its own decisions. Constant vetoes and inability to reach unanimous decisions will dampen the advantages of the existence of the team and may render it obsolete. It is important to strike the right balance of different perspectives, expertise and reasonability in members to take advantage of the benefits that come with a diverse and functional security-related decision making process. Deadlocks Impactful security team decisions that can't be made unanimously by the security team will be made by the core team according to their decision making process If the core team is deadlocked, the decision made will be whichever decision, if any, will provide the end user with the greatest measure of security Deadlocks should be avoided at all costs. The inability of the security team to reach a unanimous decision based on the security priorities of Grin's community and core team should be a red flag to the community and core team for the health of the team. All members should be able to clearly discuss the factual merits of the options and reach a decision that is in the clear best possible interest for the security of Grin's ecosystem and users. Example By following the previous example in more detail, critical differences can be further explored between the current process and the proposed security team process in the handling of a unique case. In cases where fixing a vulnerability is so critical that it requires a deviation from the standard , the proposed process reduces the likelihood of the vulnerability being exploited with a focused decision making process and by restricting the details to essential persons only. Previous Process Grin's security contacts make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug All details of the disclosure, including the steps to carry out the exploit, are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy This conversation may take days or weeks as there is no particular decision making process for security-related issues Once the vulnerability is mitigated the core team may optionally share some of the details with the community Security Team Process Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug A conversation and plan of action is quickly and unanimously determined and executed on by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated, the security team must disclose all information that is not still security-critical with the community Drawbacks The core team is already busy and the formation and management of a security team may distract from other pressing and immediate issues Even though it decentralizes the core team, it potentially creates another point of centralization Adds resource overhead to the project that must be upheld (it is not acceptable to fail to follow through in security processes once established!) Possibly distracts from other important work- we don't want to spread attention too wide too early Adds bulk to Grin's governance structure The community may trust core more than a team to make critical security decisions Rationale and alternatives One alternative, currently in use, is adding the input of a security expert to the existing core decision making process This is better than nothing but we lose a few benefits without a dedicated security team: Strengthened security process: reduced likelihood of exploit leaks Improved transparency: there is currently little transparency around core's security decision making process Improved reaction times: informed, thoughtful, decisive actions with input from relevant experts only Possibility for security initiatives: clear decision making process for bilateral disclosure agreements, bug bounty programs, audit work Stronger commitments to the community, ecosystem and other projects: viable with a dedicated, clear decision making process Long-term scalability: extend capacity for security work to grow beyond the core team's attention capacity Another alternative is to rely on an open community to handle all incidents as they come in This is less desirable than both the previous process and security team process: Vulnerabilities would essentially be public before they can by mitigated There is no decision making team so mitigation actions may be slow and contentious There is no accountability to ensure that the responsible disclosure process is followed This model is much more transparent than other alternatives but comes with the unacceptable associated costs above Prior art grin-governance 1 and security-process 2 RFCs lay groundwork for the security-team RFC. Unresolved questions What are the security priorities of the Grin community and core team? (e.g. is privacy a higher priority than undetectable inflation?) Is this the most minimal model that can have long-term success for Grin's security-related decision making process? Is the single-veto model sufficient for a consistent, timely decision making process? Future possibilities Budget allocation and management Manage an allocated budget for possible initiatives Bug bounty programs Audits Full time contributors Development of security tooling Security team working groups Red team Blue team Audit team Bug bounty team Community outreach team Expanding security-team decisions Currently security-team decisions are restricted to predefined decisions around the security processes In the future security-team decisions can be expanded to include more security-related decisions References Grin's Governance RFC \u21a9 Grin's Security Proccess RFC \u21a9","title":"Security Team"},{"location":"wiki/security-process/security-team/#security-team","text":"Title: security-team Authors: joltz Start date: Jan 22 2020 RFC PR: mimblewimble/grin-rfcs#39 Tracking issue: mimblewimble/grin-pm/#258","title":"Security Team"},{"location":"wiki/security-process/security-team/#summary","text":"The security team for Grin carries out the security priorities of the Grin community and core team, which are to be defined prior to formation of the team. The security team streamlines the security decision making process for the core team while maintaining a careful balance of security and transparency for the community.","title":"Summary"},{"location":"wiki/security-process/security-team/#motivation","text":"Improve transparency, efficiency, decisiveness and scalability around security-related decision making Dedicated support for security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work Increase confidence in the ecosystem for future contributions A clear and structured decision making process is needed to fully support the current security process as well as community initiatives such as bilateral disclosure agreements, bug bounty programs and future audit work. This process was previously maintained by the core team who had many areas of focus, leading to a lack of clarity, timeliness and ability to decisively execute on community security initiatives. The security team frees up core resources to focus on other important areas while expanding dedicated resources to security work, allowing the Grin ecosystem to continue to scale. A clear decision making structure around the security process instills confidence in the greater ecosystem and encourages projects, developers and users to continue to increase contributions of time and resources into Grin.","title":"Motivation"},{"location":"wiki/security-process/security-team/#community-level-explanation","text":"Grin's security team is responsible for making predefined security related decisions for the Grin project. This includes, but is not limited to, decisions about the specification and implementation of Grin's security processes. As much as possible Grin's security team carries out the security priorities of the community and core team in a transparent manner. There may be some unique security-related cases that require the security team to make some decisions in private to protect the security of Grin users. In these cases, once it is safe to do so, the security team is responsible for sharing as many details as possible with the community for transparency and accountability purposes. The primary day-to-day impact this will have on the community is making available structured support around security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work. The community and other teams will have regular opportunity to interact with, provide input to and receive input from the security team.","title":"Community-level explanation"},{"location":"wiki/security-process/security-team/#example","text":"Here we will walk through an example case that highlights how Grin's security team would operate, contrasting with the current process. In the example case, a vulnerability is disclosed to the disclosure contacts listed in Grin's security policy. It is shown that the community gains greater transparency into the decision making process and related outcomes with the proposed security team. Additionally the disclosure map is more tightly contained in the proposed process, resulting in less risk of vulnerability exploitation to the community. Previous Process Grin's security contacts make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, all details of the disclosure are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy Once the vulnerability is mitigated the core team may optionally share some of the details with the community Security Team Process Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure If disclosure determined to be valid, a conversation and plan of action is determined and executed by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated the security team must disclose all information that is not still security-critical with the community","title":"Example"},{"location":"wiki/security-process/security-team/#reference-level-explanation","text":"Grin's security team will be implemented as stated below.","title":"Reference-level explanation"},{"location":"wiki/security-process/security-team/#membership","text":"Bootstrapped by existing security contacts (@lehnberg, @hashmap, @joltz) Minimum three, maximum five members Membership is recommended by the security team and approved by the core team All members must have relevant domain expertise in security, cryptography, the Grin codebase or Grin community All members must have high competency in maintaining personal operational security (keeping private keys secure, maintaining secure communications channels etc.) Membership is revoked by failure to update the canary, unanimous decision by team or decision from the core team Note if the core team engages in removing members from the security team without reasonable justification, the security team loses purpose, becomes ineffective and is relegated to useless security theater","title":"Membership"},{"location":"wiki/security-process/security-team/#decision-making","text":"Distinction between security-team decisions and security-related decisions : The security team is responsible for making predefined security-team decisions, not all possible ambiguous security-related decisions Decisions are made primarily with consideration to the security priorities outlined prior to the team's formation Unanimous approval of security team members is needed to make all impactful decisions Some decisions made must also be approved by the core team to be carried out: Adding/removing parties from disclosure agreements Adding members to the security team Updating the security policy In the event that the core team does not follow a security team recommendation, a reasonable explanation must be provided as to why the security recommendation was not followed Some decisions must be made without fully informing the core team of all details: When fixing a vulnerability requires a deviation from the standard In these cases not all information will be shared with core team, such as specific details to carry out an exploit, full impact and other relevant information that will create unnecessary risk if disclosed The core team must be notified of all cases of these decisions within a reasonable time frame that does not pose a security risk (e.g. after a fix is implemented) and provided with a reasonable explanation by the security team","title":"Decision Making"},{"location":"wiki/security-process/security-team/#vetoes","text":"Any member of the security team may veto an impactful security team decision The ability to veto an impactful security team decision is important to preserve the ability for members of the security team to make honest recommendations. Important and controversial decisions will be made and members of the security team need the ability to not sign their names to a decision they are not comfortable with that could have serious ramifications. These cases will be handled according to the Deadlocks section below. The security team should always strive to reach its own decisions. Constant vetoes and inability to reach unanimous decisions will dampen the advantages of the existence of the team and may render it obsolete. It is important to strike the right balance of different perspectives, expertise and reasonability in members to take advantage of the benefits that come with a diverse and functional security-related decision making process.","title":"Vetoes"},{"location":"wiki/security-process/security-team/#deadlocks","text":"Impactful security team decisions that can't be made unanimously by the security team will be made by the core team according to their decision making process If the core team is deadlocked, the decision made will be whichever decision, if any, will provide the end user with the greatest measure of security Deadlocks should be avoided at all costs. The inability of the security team to reach a unanimous decision based on the security priorities of Grin's community and core team should be a red flag to the community and core team for the health of the team. All members should be able to clearly discuss the factual merits of the options and reach a decision that is in the clear best possible interest for the security of Grin's ecosystem and users.","title":"Deadlocks"},{"location":"wiki/security-process/security-team/#example_1","text":"By following the previous example in more detail, critical differences can be further explored between the current process and the proposed security team process in the handling of a unique case. In cases where fixing a vulnerability is so critical that it requires a deviation from the standard , the proposed process reduces the likelihood of the vulnerability being exploited with a focused decision making process and by restricting the details to essential persons only. Previous Process Grin's security contacts make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug All details of the disclosure, including the steps to carry out the exploit, are shared with the entire core team With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy This conversation may take days or weeks as there is no particular decision making process for security-related issues Once the vulnerability is mitigated the core team may optionally share some of the details with the community Security Team Process Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure It is determined that the disclosed vulnerability is a critical inflation bug A conversation and plan of action is quickly and unanimously determined and executed on by the security team, following Grin's responsible disclosure policy Once the vulnerability is mitigated, the security team must disclose all information that is not still security-critical with the community","title":"Example"},{"location":"wiki/security-process/security-team/#drawbacks","text":"The core team is already busy and the formation and management of a security team may distract from other pressing and immediate issues Even though it decentralizes the core team, it potentially creates another point of centralization Adds resource overhead to the project that must be upheld (it is not acceptable to fail to follow through in security processes once established!) Possibly distracts from other important work- we don't want to spread attention too wide too early Adds bulk to Grin's governance structure The community may trust core more than a team to make critical security decisions","title":"Drawbacks"},{"location":"wiki/security-process/security-team/#rationale-and-alternatives","text":"One alternative, currently in use, is adding the input of a security expert to the existing core decision making process This is better than nothing but we lose a few benefits without a dedicated security team: Strengthened security process: reduced likelihood of exploit leaks Improved transparency: there is currently little transparency around core's security decision making process Improved reaction times: informed, thoughtful, decisive actions with input from relevant experts only Possibility for security initiatives: clear decision making process for bilateral disclosure agreements, bug bounty programs, audit work Stronger commitments to the community, ecosystem and other projects: viable with a dedicated, clear decision making process Long-term scalability: extend capacity for security work to grow beyond the core team's attention capacity Another alternative is to rely on an open community to handle all incidents as they come in This is less desirable than both the previous process and security team process: Vulnerabilities would essentially be public before they can by mitigated There is no decision making team so mitigation actions may be slow and contentious There is no accountability to ensure that the responsible disclosure process is followed This model is much more transparent than other alternatives but comes with the unacceptable associated costs above","title":"Rationale and alternatives"},{"location":"wiki/security-process/security-team/#prior-art","text":"grin-governance 1 and security-process 2 RFCs lay groundwork for the security-team RFC.","title":"Prior art"},{"location":"wiki/security-process/security-team/#unresolved-questions","text":"What are the security priorities of the Grin community and core team? (e.g. is privacy a higher priority than undetectable inflation?) Is this the most minimal model that can have long-term success for Grin's security-related decision making process? Is the single-veto model sufficient for a consistent, timely decision making process?","title":"Unresolved questions"},{"location":"wiki/security-process/security-team/#future-possibilities","text":"Budget allocation and management Manage an allocated budget for possible initiatives Bug bounty programs Audits Full time contributors Development of security tooling Security team working groups Red team Blue team Audit team Bug bounty team Community outreach team Expanding security-team decisions Currently security-team decisions are restricted to predefined decisions around the security processes In the future security-team decisions can be expanded to include more security-related decisions","title":"Future possibilities"},{"location":"wiki/security-process/security-team/#references","text":"Grin's Governance RFC \u21a9 Grin's Security Proccess RFC \u21a9","title":"References"},{"location":"wiki/services/list-of-services/","text":"List of Grin Services Exchanges Poloniex BitForex KuCoin Bittrex HitBTC Hotbit HBTC Gate.io Kaiserex BigONE TradeOgre Block Explorers Grinscan Grinmint Blockscan GrinExplorer Mining Pools GrinMint Sparkpool F2Pool WoolyPooly BTC.com 2Miners MinerGate","title":"List of Services"},{"location":"wiki/services/list-of-services/#list-of-grin-services","text":"","title":"List of Grin Services"},{"location":"wiki/services/list-of-services/#exchanges","text":"Poloniex BitForex KuCoin Bittrex HitBTC Hotbit HBTC Gate.io Kaiserex BigONE TradeOgre","title":"Exchanges"},{"location":"wiki/services/list-of-services/#block-explorers","text":"Grinscan Grinmint Blockscan GrinExplorer","title":"Block Explorers"},{"location":"wiki/services/list-of-services/#mining-pools","text":"GrinMint Sparkpool F2Pool WoolyPooly BTC.com 2Miners MinerGate","title":"Mining Pools"},{"location":"wiki/services/slatepack-integration/","text":"Slatepack Integration Guide Slatepack is a new transaction building standard for Grin designed to improve and simplify the transacting experience for all users. The full specification is available here Slatepack was introduced in v4.0.0. Wallets and services must fully support it by v5.0.0 (Jan 2021). Motivation Previously, users and exchanges had to decide between multiple transaction methods to find one that works for them. Transactions were commonly done through HTTPS, requiring users to open ports and configure firewalls, or with slate files which bring their own set of challenges. With Slatepack, a single standard needs to be supported. Summary The Slatepack standard eliminates the need for HTTPS or exchanging files. Instead, it introduces two methods: Synchronous commuication done through Tor (transaction is completed automatically similar to HTTPS). Asynchronous communication using Slatepack Messages, which are encoded transaction strings exchanged by a simple copy-paste. Additionally, Slatepack Addresses are introduced to facilitate the interaction between two wallets. No more endless support tickets Notice how the transactions can be completed without requiring additional help from exchange support staff; When needed, wallets resort to exchanging simple string messages to complete the interaction. This should drastically reduce time spent on support tickets related to troubles around transacting with Grin. Overview Slatepack Address A Slatepack address is a bech32 encoded address, similar to those used in Bitcoin. However, Slatepack addresses do not touch the network; they are used strictly for transaction building between two wallets, and never appear on-chain or represent ownership. Addresses are exchanged between parties to serve as instructions for how to complete the payment. Therefore, a Slatepack address serves a double prupose: It decodes to a Tor address. Acts as a key to encrypt the transaction data being communicated by Slatepack Messages (strings). example address grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 Since Slatepack addresses are bech32, they can easily be QR encoded. Tor (Synchronous Tx Completion) Any Slatepack address is decoded by the wallet as a Tor address , where the wallet will be listening. Therefore, if both the exchange's and the user's wallets are online and connected to Tor, payments will complete automatically (the receiver's wallet needs to listen). However, if a Tor connection between the two wallets can't be established (fails for any reason), or when a Slatepack address is not provided, the wallet will resort to exchanging Slatepack Messages for completing a transaction. Slatepack Messages (Asynchronous Tx Completion) The Slatepack standard automatically handles a failed Tor connection by outputting a Slatepack Message, which is an encoded transaction string to be exchanged manually by copy-paste. Given that the sender provides a destination address (always recommended even if Tor isn't desired), then the Slatepack Messages will be encrypted. Transaction Flow As an example, let's demonstrate the workflow of an exchange. (switch between tabs) Withdrawal Step Exchange User 1 Provide Slatepack Address 2 Send to Slatepack Address (send) 3 IF TOR FAILS : Copy message[1] 4 Paste message[1] 5 Copy message[2] 6 Paste message[2] (finalize) Withdrawal UI Deposit Step Exchange User 1 Provide Slatepack Address (address) 2 Send to Slatepack Address 3 IF TOR FAILS : Copy message[1] 4 Paste message[1] (receive) 5 Copy message[2] 6 Paste message[2] Deposit UI Exchange Integration Exchanges may consider several different paths for intergration: Exchanges may run Tor hidden services to automatically complete transactions, and also provide a user-interface for copy-pasting Slatepack Messages as a fallback mechanism. Some exchanges may not wish to have Tor running anywhere in their infrastructure. In this case, they may provide only the user-interface required for exchanging Slatepack Messages via copy and paste text boxes. Exchanges may provide unique Tor end points to serve as unique deposit addresses for each user. Payment proofs Grin's lack of on-chain addresses slightly complicates proving a transaction occured. In order to solve disputes and prove funds were sent to the correct wallet, seperate payment proofs are used. By default, whenever a transaction is sent to a destination Slatepack Address, a payment proof is created automatically. The sender (wallet who finalized tx) can export the payment proof by specifying the tx-id ( -i ) or tx-log-id ( -t ) of a transaction, and choosing the path for the proof file, e.g: grin-wallet export_proof -i 4 \"~/Documents/proof.txt\" He can then provide this proof to any wallet for verification. To verify: grin-wallet verify_proof /path/proof.txt This will ensure that: The kernel for the transaction in the proof is validated and can be found on-chain. Both the sender and recipient's signatures correctly sign for the amount and the kernel. Additionally, if the recipient of the transaction is the same wallet trying to verify it, then they will be informed as follows: grin-wallet verify_proof proof.txt Payment proof's signatures are valid. The proof's recipient address belongs to this wallet. Questions & Support For questions about the Slatepack standard or its implementation, send a message in @grincoin#support on Keybase. Technical Details See the full specification for complete technical details. Address A SlatepackAddress is a bech32 encoded ed25519 public key which maps to: A Tor onion address bech32 -> ed25519 -> onionv3 A derivable x25519 public key for optional encryption bech32 -> ed25519 -> x25519 Keys used in SlatepackAddresses are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys. Unique addresses (not yet supported) SlatepackAddress keys may be derived in parallel to the blinding factor derivation path, such that a unique address is derived for each new transaction. Message Formatting WORD_LENGTH : 15 characters Number of SimpleBase58Check encoded characters per word; chosen for human readability across device screen sizes LINE_BREAK : 200 words Number of words of WORD_LENGTH to include before inserting a newline; chosen for user friendliness in terminals and messaging applications MAX_STRING_SIZE : 1MB Maximum size for an armored SlatepackMessage string without requiring a file container If a SlatepackMessage exceeds this value it must be handled as a .slatepack file instead of a string This parameter chosen to cover as many cases as possible and still be supported by most clipboards Note that WORD_LENGTH and LINE_BREAK parameters are adjustable as a formatting convenience. Services and exchanges would be reasonable to support the Slatepack standard, without handling the rare file edge case (string >1MB). The SlatepackWorkflow establishes the steps followed to adhere to the standard: Try to establish connection via Tor Derive onion address from ED25519 public key decoded from the bech32 SlatepackAddress Attempt to complete the transaction via Tor and json-rpc as per the previous implementations If connection fails, proceed to step 2 Fall back to copy/paste (optionally encrypted) ascii-armored transaction strings known as SlatepackMessage If using encryption, derive encryption key: SlatepackAddress -> ed25519 public key -> x25519 public key Build ascii-armored string according to standard including SimpleBase58Check , appropriate binary encoding and framing A SlatepackMessage is a transaction string formatted for manual copy/paste transport. It contains the required components to build a transaction manually, similar to the transaction files previously supported but compacted for transport. Example: BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv pcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY GWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx wNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK.","title":"Slatepack Integration Guide"},{"location":"wiki/services/slatepack-integration/#slatepack-integration-guide","text":"Slatepack is a new transaction building standard for Grin designed to improve and simplify the transacting experience for all users. The full specification is available here Slatepack was introduced in v4.0.0. Wallets and services must fully support it by v5.0.0 (Jan 2021).","title":"Slatepack Integration Guide"},{"location":"wiki/services/slatepack-integration/#motivation","text":"Previously, users and exchanges had to decide between multiple transaction methods to find one that works for them. Transactions were commonly done through HTTPS, requiring users to open ports and configure firewalls, or with slate files which bring their own set of challenges. With Slatepack, a single standard needs to be supported.","title":"Motivation"},{"location":"wiki/services/slatepack-integration/#summary","text":"The Slatepack standard eliminates the need for HTTPS or exchanging files. Instead, it introduces two methods: Synchronous commuication done through Tor (transaction is completed automatically similar to HTTPS). Asynchronous communication using Slatepack Messages, which are encoded transaction strings exchanged by a simple copy-paste. Additionally, Slatepack Addresses are introduced to facilitate the interaction between two wallets. No more endless support tickets Notice how the transactions can be completed without requiring additional help from exchange support staff; When needed, wallets resort to exchanging simple string messages to complete the interaction. This should drastically reduce time spent on support tickets related to troubles around transacting with Grin.","title":"Summary"},{"location":"wiki/services/slatepack-integration/#overview","text":"","title":"Overview"},{"location":"wiki/services/slatepack-integration/#slatepack-address","text":"A Slatepack address is a bech32 encoded address, similar to those used in Bitcoin. However, Slatepack addresses do not touch the network; they are used strictly for transaction building between two wallets, and never appear on-chain or represent ownership. Addresses are exchanged between parties to serve as instructions for how to complete the payment. Therefore, a Slatepack address serves a double prupose: It decodes to a Tor address. Acts as a key to encrypt the transaction data being communicated by Slatepack Messages (strings). example address grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 Since Slatepack addresses are bech32, they can easily be QR encoded.","title":"Slatepack Address"},{"location":"wiki/services/slatepack-integration/#tor-synchronous-tx-completion","text":"Any Slatepack address is decoded by the wallet as a Tor address , where the wallet will be listening. Therefore, if both the exchange's and the user's wallets are online and connected to Tor, payments will complete automatically (the receiver's wallet needs to listen). However, if a Tor connection between the two wallets can't be established (fails for any reason), or when a Slatepack address is not provided, the wallet will resort to exchanging Slatepack Messages for completing a transaction.","title":"Tor (Synchronous Tx Completion)"},{"location":"wiki/services/slatepack-integration/#slatepack-messages-asynchronous-tx-completion","text":"The Slatepack standard automatically handles a failed Tor connection by outputting a Slatepack Message, which is an encoded transaction string to be exchanged manually by copy-paste. Given that the sender provides a destination address (always recommended even if Tor isn't desired), then the Slatepack Messages will be encrypted.","title":"Slatepack Messages (Asynchronous Tx Completion)"},{"location":"wiki/services/slatepack-integration/#transaction-flow","text":"As an example, let's demonstrate the workflow of an exchange. (switch between tabs) Withdrawal Step Exchange User 1 Provide Slatepack Address 2 Send to Slatepack Address (send) 3 IF TOR FAILS : Copy message[1] 4 Paste message[1] 5 Copy message[2] 6 Paste message[2] (finalize) Withdrawal UI Deposit Step Exchange User 1 Provide Slatepack Address (address) 2 Send to Slatepack Address 3 IF TOR FAILS : Copy message[1] 4 Paste message[1] (receive) 5 Copy message[2] 6 Paste message[2] Deposit UI","title":"Transaction Flow"},{"location":"wiki/services/slatepack-integration/#exchange-integration","text":"Exchanges may consider several different paths for intergration: Exchanges may run Tor hidden services to automatically complete transactions, and also provide a user-interface for copy-pasting Slatepack Messages as a fallback mechanism. Some exchanges may not wish to have Tor running anywhere in their infrastructure. In this case, they may provide only the user-interface required for exchanging Slatepack Messages via copy and paste text boxes. Exchanges may provide unique Tor end points to serve as unique deposit addresses for each user.","title":"Exchange Integration"},{"location":"wiki/services/slatepack-integration/#payment-proofs","text":"Grin's lack of on-chain addresses slightly complicates proving a transaction occured. In order to solve disputes and prove funds were sent to the correct wallet, seperate payment proofs are used. By default, whenever a transaction is sent to a destination Slatepack Address, a payment proof is created automatically. The sender (wallet who finalized tx) can export the payment proof by specifying the tx-id ( -i ) or tx-log-id ( -t ) of a transaction, and choosing the path for the proof file, e.g: grin-wallet export_proof -i 4 \"~/Documents/proof.txt\" He can then provide this proof to any wallet for verification. To verify: grin-wallet verify_proof /path/proof.txt This will ensure that: The kernel for the transaction in the proof is validated and can be found on-chain. Both the sender and recipient's signatures correctly sign for the amount and the kernel. Additionally, if the recipient of the transaction is the same wallet trying to verify it, then they will be informed as follows: grin-wallet verify_proof proof.txt Payment proof's signatures are valid. The proof's recipient address belongs to this wallet.","title":"Payment proofs"},{"location":"wiki/services/slatepack-integration/#questions-support","text":"For questions about the Slatepack standard or its implementation, send a message in @grincoin#support on Keybase.","title":"Questions &amp; Support"},{"location":"wiki/services/slatepack-integration/#technical-details","text":"See the full specification for complete technical details.","title":"Technical Details"},{"location":"wiki/services/slatepack-integration/#address","text":"A SlatepackAddress is a bech32 encoded ed25519 public key which maps to: A Tor onion address bech32 -> ed25519 -> onionv3 A derivable x25519 public key for optional encryption bech32 -> ed25519 -> x25519 Keys used in SlatepackAddresses are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys. Unique addresses (not yet supported) SlatepackAddress keys may be derived in parallel to the blinding factor derivation path, such that a unique address is derived for each new transaction.","title":"Address"},{"location":"wiki/services/slatepack-integration/#message-formatting","text":"WORD_LENGTH : 15 characters Number of SimpleBase58Check encoded characters per word; chosen for human readability across device screen sizes LINE_BREAK : 200 words Number of words of WORD_LENGTH to include before inserting a newline; chosen for user friendliness in terminals and messaging applications MAX_STRING_SIZE : 1MB Maximum size for an armored SlatepackMessage string without requiring a file container If a SlatepackMessage exceeds this value it must be handled as a .slatepack file instead of a string This parameter chosen to cover as many cases as possible and still be supported by most clipboards Note that WORD_LENGTH and LINE_BREAK parameters are adjustable as a formatting convenience. Services and exchanges would be reasonable to support the Slatepack standard, without handling the rare file edge case (string >1MB). The SlatepackWorkflow establishes the steps followed to adhere to the standard: Try to establish connection via Tor Derive onion address from ED25519 public key decoded from the bech32 SlatepackAddress Attempt to complete the transaction via Tor and json-rpc as per the previous implementations If connection fails, proceed to step 2 Fall back to copy/paste (optionally encrypted) ascii-armored transaction strings known as SlatepackMessage If using encryption, derive encryption key: SlatepackAddress -> ed25519 public key -> x25519 public key Build ascii-armored string according to standard including SimpleBase58Check , appropriate binary encoding and framing A SlatepackMessage is a transaction string formatted for manual copy/paste transport. It contains the required components to build a transaction manually, similar to the transaction files previously supported but compacted for transport. Example: BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv pcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY GWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx wNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK.","title":"Message Formatting"},{"location":"wiki/transactions/contracts/","text":"Contracts Read this in other languages: \u7b80\u4f53\u4e2d\u6587 This document describes smart contracts that can be setup using Grin even though its simplicity does not allow scripting. All of these types of contracts rely on a few basic Mimblewimble features, and compose them in increasingly clever ways. None of those constructs are fully original or invented by the authors of this document or the Grin developers. Most of the credit should be attributed to a long list of cryptographers and researchers. To name just a few: Torben Pryds Pedersen, Gregory Maxwell, Andrew Poelstra, John Tromp, Claus Peter Schnorr. We apologize in advance for all those we couldn't name and recognize that most computer science discoveries are incremental. Built-ins This section is meant as a reminder of some crucial features of the Grin chain. We assume some prior knowledge as to how these are constructed and used. Pedersen Commitments All outputs include a Pedersen commitment of the form r*G + v*H with r the blinding factor, v the value, and G and H two distinct generator points on the same curve group. Aggregate Signatures (a.k.a. Schnorr, MuSig) We suppose we have the SHA256 hash function and the same G curve as above. In its simplest form, an aggregate signature is built from: the message M to sign, in our case the transaction fee a private key x , with its matching public key x*G a nonce k just used for the purpose of building the signature We build the challenge e = SHA256(M | k*G | x*G) , and the scalar s = k + e * x . The full aggregate signature is then the pair (s, k*G) . The signature can be checked using the public key x*G , re-calculating e using M and k*G from the 2nd part of the signature pair and by verifying that s , the first part of the signature pair, satisfies: s*G = k*G + e * x*G In this simple case of someone sending a transaction to a receiver they trust (see later for the trustless case), an aggregate signature can be directly built for a Grin transaction by taking the above private key x to be the sum of output blinding factors minus the sum of input blinding factors. The resulting kernel is assembled from the aggregate signature generated using r and the public key r*G , and allows to verify non-inflation for all Grin transactions (and signs the fees). Because these signatures are built simply from a scalar and a public key, they can be used to construct a variety of contracts using \"simple\" arithmetic. Timelocked Transactions Absolute Timelocked Analogous to Bitcoin's nLockTime . A transaction can be time-locked with a few simple modifications. The message M to sign becomes the lock_height h at which the transaction becomes spendable, appended to the fee, such that M = fee | h . The lock height h is then included in the transaction kernel. If a block contains a kernel that includes a lock height greater than the current block height, it is rejected. Relative Timelocked We can extend the concept of an absolute locktime on a tx by including a (kernel) commitment that we can define the lock_height relative to. The lock_height would be relative to the block height where the referenced kernel was first included in the chain state. Tx2 can then be restricted such that it would only be valid to include it in a block once h blocks have passed after first seeing Tx1 (via the referenced kernel commitment). The message M to sign would need to include the following: The fee as before The lock_height h (as before but interpreted as a relative value) A referenced kernel commitment C M = fee | h | C For Tx2 to be accepted it would also need to include a Merkle proof identifying the block including C from Tx1. This proves the relative lock_height requirement has been met. Derived Contracts Trustless Transactions An aggregate (Schnorr) signature involving a single party is relatively simple but does not demonstrate the full flexibility of the construction. We show here how to generalize it for use in outputs involving multiple parties. As constructed in section 1.2, an aggregate signature requires trusting the receiving party. As Grin outputs are completely obscured by Pedersen Commitments, one cannot prove money was actually sent to the right party, hence a receiver could claim not having received anything. To solve this issue, we require the receiver to collaborate with the sender in building a transaction and specifically its kernel signature. Alice wants to pay Bob in grins. She starts the transaction building process: Alice selects her inputs and builds her change output. The sum of all blinding factors (change output minus inputs) is rs . Alice picks a random nonce ks and sends her partial transaction, ks*G and rs*G to Bob. Bob picks his own random nonce kr and the blinding factor for his output rr . Using rr , Bob adds his output to the transaction. Bob computes the message M = fee | lock_height , the Schnorr challenge e = SHA256(M | kr*G + ks*G | rr*G + rs*G) and finally his side of the signature sr = kr + e * rr . Bob sends sr , kr*G and rr*G to Alice. Alice computes e just like Bob did and can check that sr*G = kr*G + e*rr*G . Alice sends her side of the signature ss = ks + e * rs to Bob. Bob validates ss*G just like Alice did for sr*G in step 6 and can produce the final signature s = (ss + sr, ks*G + kr*G) as well as the final transaction kernel including s and the public key rr*G + rs*G . This protocol requires 3 data exchanges (Alice to Bob, Bob back to Alice, and finally Alice to Bob) and is therefore said to be interactive. However the interaction can be done over any medium and in any period of time, including the pony express over 2 weeks. This protocol can also be generalized to any number i of parties. On the first round, all the ki*G and ri*G are shared. On the 2nd round, everyone can compute e = SHA256(M | sum(ki*G) | sum(ri*G)) and their own signature si . Finally, a finalizing party can then gather all the partial signatures si , validate them and produce s = (sum(si), sum(ki*G)) . Multiparty Outputs (multisig) We describe here a way to build a transaction with an output that can only be spent when multiple parties approve it. This construction is very similar to the previous setup for trustless transactions, however in this case both the signature and a Pedersen Commitment need to be aggregated. This time, Alice wants to send funds such that both Bob and her need to agree to spend. Alice builds the transaction normally and adds the multiparty output such that: Bob picks a blinding factor rb and sends rb*G to Alice. Alice picks a blinding factor ra and builds the commitment C = ra*G + rb*G + v*H . She sends the commitment to Bob. Bob creates a range proof for v using C and rb and sends it to Alice. Alice generates her own range proof, aggregates it with Bob, finalizing the multiparty output Oab . The kernel is built following the same procedure as for Trustless Transactions. We observe that for that new output Oab , neither party know the whole blinding factor. To be able to build a transaction spending Oab, someone would need to know ra + rb to produce a kernel signature. To produce that spending kernel, Alice and Bob need to collaborate. This, again, is done using a protocol very close to Trustless Transactions. Multiparty Timelocks This contract is a building block for multiple other contracts. Here, Alice agrees to lock some funds to start a financial interaction with Bob and prove to Bob she has funds. The setup is the following: Alice builds a a 2-of-2 multiparty transaction with an output she shares with Bob, however she does not participate in building the kernel signature yet. Bob builds a refund transaction with Alice that sends the funds back to Alice using a timelock (for example 1440 blocks ahead, about 24h). Alice and Bob finish the 2-of-2 transaction by building the corresponding kernel and broadcast it. Now Alice and Bob are free to build additional transactions distributing the funds locked in the 2-of-2 output in any way they see fit. If Bob refuses to cooperate, Alice just needs to broadcast her refund transaction after the time lock expires. This contract can be trivially used for unidirectional payment channels. Conditional Output Timelocks Analogous to Bitcoin's CheckLockTimeVerify . We currently have unconditional lock_heights on txs (tx is not valid and will not be accepted until lock_height has passed). Private keys can be summed together. Key 3 = Key 1 + Key 2 Commitments can be summed together. C 3 = C 1 + C 2 Given unconditional locktimes on txs we can leverage these to give us conditional locktimes on outputs by \"entangling\" two outputs on two related txs together. We can construct two txs (Tx 1 , Tx 2 ) with two entangled outputs Out 1 and Out 2 such that - Out 1 (commitment C 1 ) is from Tx 1 and built using Key 1 Out 2 (commitment C 2 ) is from Tx 2 and built using Key 2 Tx 2 has an unconditional lock_height on it If we do this (and we can manage the keys as necessary) - Out 1 + Out 2 can only be spent as a pair using Key 3 They can only be spent after lock_height from Tx 2 Tx 1 (containing Out 1 ) can be broadcast, accepted and confirmed on-chain immediately. Tx 2 cannot be broadcast and accepted until lock_height has passed. So if Alice only knows K 3 and does not know Key 1 or Key 2 , then Out 1 can only be spent by Alice after lock_height has passed. If Bob on the other hand knows Key 2 then Out 1 can be spent by Bob immediately. We have a conditional timelock on Out 1 (confirmed, on-chain) where it can be spent either with Key 3 (after lock_height), or Key 2 immediately. (Relative) Conditional Output Timelocks Analogous to Bitcoin's CheckSequenceVerify . By combining \"Conditional Timelock on Output\" with \"(Relative) Timelocked Transactions\" we can encumber a confirmed output with a relative timelock (relative to a related tx kernel). Tx 1 (containing Out 1 ) can be broadcast, accepted and confirmed on-chain immediately. Tx 2 cannot be broadcast and accepted until the relative lock_height has passed, relative to the referenced kernel from the earlier Tx 1 . Atomic Swap This setup relies on a time locked contract combined with a check for 2 public keys. On Bitcoin this would be a 2-of-2 multisig, one public key being Alice's, the second being the hash of a preimage that Bob has to reveal. In this setup, we consider public key derivation x*G to be the hash function and by Bob revealing x , Alice can then produce an adequate signature proving she knows x (in addition to her own private key). Alice has grins and Bob has bitcoin. They would like to swap. We assume Bob created an output on the Bitcoin blockchain that allows spending either by Alice if she learns a hash pre-image x , or by Bob after time Tb . Alice is ready to send her grins to Bob if he reveals x . First, Alice sends her grins to a multiparty timelock contract with a refund time Ta < Tb . To send the 2-of-2 output to Bob and execute the swap, Alice and Bob start as if they were building a normal trustless transaction as specified in section 2.1. Alice picks a random nonce ks and her blinding sum rs and sends ks*G and rs*G to Bob. Bob picks a random blinding factor rr and a random nonce kr . However this time, instead of simply sending sr = kr + e * rr with his rr*G and kr*G , Bob sends sr' = kr + x + e * rr as well as x*G . Alice can validate that sr'*G = kr*G + x*G + rr*G . She can also check that Bob has money locked with x*G on the other chain. Alice sends back her ss = ks + e * xs as she normally would, now that she can also compute e = SHA256(M | ks*G + kr*G) . To complete the signature, Bob computes sr = kr + e * rr and the final signature is (sr + ss, kr*G + ks*G) . As soon as Bob broadcasts the final transaction to get his new grins, Alice can compute sr' - sr to get x . Notes on the Bitcoin setup Prior to completing the atomic swap, Bob needs to know Alice's public key. Bob would then create an output on the Bitcoin blockchain with a 2-of-2 multisig similar to alice_pubkey secret_pubkey 2 OP_CHECKMULTISIG . This should be wrapped in an OP_IF so Bob can get his money back after an agreed-upon time and all of this can even be wrapped in a P2SH. Here secret_pubkey is x*G from the previous section. To verify the output, Alice would take x*G , recreate the bitcoin script, hash it and check that her hash matches what's in the P2SH (step 2 in previous section). Once she gets x (step 6), she can build the 2 signatures necessary to spend the 2-of-2, having both private keys, and get her bitcoin. \"Relative Timelocks\" (Lightning Network) See No Recent Duplicate (NRD) transaction kernels for more details.","title":"Contracts"},{"location":"wiki/transactions/contracts/#contracts","text":"Read this in other languages: \u7b80\u4f53\u4e2d\u6587 This document describes smart contracts that can be setup using Grin even though its simplicity does not allow scripting. All of these types of contracts rely on a few basic Mimblewimble features, and compose them in increasingly clever ways. None of those constructs are fully original or invented by the authors of this document or the Grin developers. Most of the credit should be attributed to a long list of cryptographers and researchers. To name just a few: Torben Pryds Pedersen, Gregory Maxwell, Andrew Poelstra, John Tromp, Claus Peter Schnorr. We apologize in advance for all those we couldn't name and recognize that most computer science discoveries are incremental.","title":"Contracts"},{"location":"wiki/transactions/contracts/#built-ins","text":"This section is meant as a reminder of some crucial features of the Grin chain. We assume some prior knowledge as to how these are constructed and used.","title":"Built-ins"},{"location":"wiki/transactions/contracts/#pedersen-commitments","text":"All outputs include a Pedersen commitment of the form r*G + v*H with r the blinding factor, v the value, and G and H two distinct generator points on the same curve group.","title":"Pedersen Commitments"},{"location":"wiki/transactions/contracts/#aggregate-signatures-aka-schnorr-musig","text":"We suppose we have the SHA256 hash function and the same G curve as above. In its simplest form, an aggregate signature is built from: the message M to sign, in our case the transaction fee a private key x , with its matching public key x*G a nonce k just used for the purpose of building the signature We build the challenge e = SHA256(M | k*G | x*G) , and the scalar s = k + e * x . The full aggregate signature is then the pair (s, k*G) . The signature can be checked using the public key x*G , re-calculating e using M and k*G from the 2nd part of the signature pair and by verifying that s , the first part of the signature pair, satisfies: s*G = k*G + e * x*G In this simple case of someone sending a transaction to a receiver they trust (see later for the trustless case), an aggregate signature can be directly built for a Grin transaction by taking the above private key x to be the sum of output blinding factors minus the sum of input blinding factors. The resulting kernel is assembled from the aggregate signature generated using r and the public key r*G , and allows to verify non-inflation for all Grin transactions (and signs the fees). Because these signatures are built simply from a scalar and a public key, they can be used to construct a variety of contracts using \"simple\" arithmetic.","title":"Aggregate Signatures (a.k.a. Schnorr, MuSig)"},{"location":"wiki/transactions/contracts/#timelocked-transactions","text":"","title":"Timelocked Transactions"},{"location":"wiki/transactions/contracts/#absolute-timelocked","text":"Analogous to Bitcoin's nLockTime . A transaction can be time-locked with a few simple modifications. The message M to sign becomes the lock_height h at which the transaction becomes spendable, appended to the fee, such that M = fee | h . The lock height h is then included in the transaction kernel. If a block contains a kernel that includes a lock height greater than the current block height, it is rejected.","title":"Absolute Timelocked"},{"location":"wiki/transactions/contracts/#relative-timelocked","text":"We can extend the concept of an absolute locktime on a tx by including a (kernel) commitment that we can define the lock_height relative to. The lock_height would be relative to the block height where the referenced kernel was first included in the chain state. Tx2 can then be restricted such that it would only be valid to include it in a block once h blocks have passed after first seeing Tx1 (via the referenced kernel commitment). The message M to sign would need to include the following: The fee as before The lock_height h (as before but interpreted as a relative value) A referenced kernel commitment C M = fee | h | C For Tx2 to be accepted it would also need to include a Merkle proof identifying the block including C from Tx1. This proves the relative lock_height requirement has been met.","title":"Relative Timelocked"},{"location":"wiki/transactions/contracts/#derived-contracts","text":"","title":"Derived Contracts"},{"location":"wiki/transactions/contracts/#trustless-transactions","text":"An aggregate (Schnorr) signature involving a single party is relatively simple but does not demonstrate the full flexibility of the construction. We show here how to generalize it for use in outputs involving multiple parties. As constructed in section 1.2, an aggregate signature requires trusting the receiving party. As Grin outputs are completely obscured by Pedersen Commitments, one cannot prove money was actually sent to the right party, hence a receiver could claim not having received anything. To solve this issue, we require the receiver to collaborate with the sender in building a transaction and specifically its kernel signature. Alice wants to pay Bob in grins. She starts the transaction building process: Alice selects her inputs and builds her change output. The sum of all blinding factors (change output minus inputs) is rs . Alice picks a random nonce ks and sends her partial transaction, ks*G and rs*G to Bob. Bob picks his own random nonce kr and the blinding factor for his output rr . Using rr , Bob adds his output to the transaction. Bob computes the message M = fee | lock_height , the Schnorr challenge e = SHA256(M | kr*G + ks*G | rr*G + rs*G) and finally his side of the signature sr = kr + e * rr . Bob sends sr , kr*G and rr*G to Alice. Alice computes e just like Bob did and can check that sr*G = kr*G + e*rr*G . Alice sends her side of the signature ss = ks + e * rs to Bob. Bob validates ss*G just like Alice did for sr*G in step 6 and can produce the final signature s = (ss + sr, ks*G + kr*G) as well as the final transaction kernel including s and the public key rr*G + rs*G . This protocol requires 3 data exchanges (Alice to Bob, Bob back to Alice, and finally Alice to Bob) and is therefore said to be interactive. However the interaction can be done over any medium and in any period of time, including the pony express over 2 weeks. This protocol can also be generalized to any number i of parties. On the first round, all the ki*G and ri*G are shared. On the 2nd round, everyone can compute e = SHA256(M | sum(ki*G) | sum(ri*G)) and their own signature si . Finally, a finalizing party can then gather all the partial signatures si , validate them and produce s = (sum(si), sum(ki*G)) .","title":"Trustless Transactions"},{"location":"wiki/transactions/contracts/#multiparty-outputs-multisig","text":"We describe here a way to build a transaction with an output that can only be spent when multiple parties approve it. This construction is very similar to the previous setup for trustless transactions, however in this case both the signature and a Pedersen Commitment need to be aggregated. This time, Alice wants to send funds such that both Bob and her need to agree to spend. Alice builds the transaction normally and adds the multiparty output such that: Bob picks a blinding factor rb and sends rb*G to Alice. Alice picks a blinding factor ra and builds the commitment C = ra*G + rb*G + v*H . She sends the commitment to Bob. Bob creates a range proof for v using C and rb and sends it to Alice. Alice generates her own range proof, aggregates it with Bob, finalizing the multiparty output Oab . The kernel is built following the same procedure as for Trustless Transactions. We observe that for that new output Oab , neither party know the whole blinding factor. To be able to build a transaction spending Oab, someone would need to know ra + rb to produce a kernel signature. To produce that spending kernel, Alice and Bob need to collaborate. This, again, is done using a protocol very close to Trustless Transactions.","title":"Multiparty Outputs (multisig)"},{"location":"wiki/transactions/contracts/#multiparty-timelocks","text":"This contract is a building block for multiple other contracts. Here, Alice agrees to lock some funds to start a financial interaction with Bob and prove to Bob she has funds. The setup is the following: Alice builds a a 2-of-2 multiparty transaction with an output she shares with Bob, however she does not participate in building the kernel signature yet. Bob builds a refund transaction with Alice that sends the funds back to Alice using a timelock (for example 1440 blocks ahead, about 24h). Alice and Bob finish the 2-of-2 transaction by building the corresponding kernel and broadcast it. Now Alice and Bob are free to build additional transactions distributing the funds locked in the 2-of-2 output in any way they see fit. If Bob refuses to cooperate, Alice just needs to broadcast her refund transaction after the time lock expires. This contract can be trivially used for unidirectional payment channels.","title":"Multiparty Timelocks"},{"location":"wiki/transactions/contracts/#conditional-output-timelocks","text":"Analogous to Bitcoin's CheckLockTimeVerify . We currently have unconditional lock_heights on txs (tx is not valid and will not be accepted until lock_height has passed). Private keys can be summed together. Key 3 = Key 1 + Key 2 Commitments can be summed together. C 3 = C 1 + C 2 Given unconditional locktimes on txs we can leverage these to give us conditional locktimes on outputs by \"entangling\" two outputs on two related txs together. We can construct two txs (Tx 1 , Tx 2 ) with two entangled outputs Out 1 and Out 2 such that - Out 1 (commitment C 1 ) is from Tx 1 and built using Key 1 Out 2 (commitment C 2 ) is from Tx 2 and built using Key 2 Tx 2 has an unconditional lock_height on it If we do this (and we can manage the keys as necessary) - Out 1 + Out 2 can only be spent as a pair using Key 3 They can only be spent after lock_height from Tx 2 Tx 1 (containing Out 1 ) can be broadcast, accepted and confirmed on-chain immediately. Tx 2 cannot be broadcast and accepted until lock_height has passed. So if Alice only knows K 3 and does not know Key 1 or Key 2 , then Out 1 can only be spent by Alice after lock_height has passed. If Bob on the other hand knows Key 2 then Out 1 can be spent by Bob immediately. We have a conditional timelock on Out 1 (confirmed, on-chain) where it can be spent either with Key 3 (after lock_height), or Key 2 immediately.","title":"Conditional Output Timelocks"},{"location":"wiki/transactions/contracts/#relative-conditional-output-timelocks","text":"Analogous to Bitcoin's CheckSequenceVerify . By combining \"Conditional Timelock on Output\" with \"(Relative) Timelocked Transactions\" we can encumber a confirmed output with a relative timelock (relative to a related tx kernel). Tx 1 (containing Out 1 ) can be broadcast, accepted and confirmed on-chain immediately. Tx 2 cannot be broadcast and accepted until the relative lock_height has passed, relative to the referenced kernel from the earlier Tx 1 .","title":"(Relative) Conditional Output Timelocks"},{"location":"wiki/transactions/contracts/#atomic-swap","text":"This setup relies on a time locked contract combined with a check for 2 public keys. On Bitcoin this would be a 2-of-2 multisig, one public key being Alice's, the second being the hash of a preimage that Bob has to reveal. In this setup, we consider public key derivation x*G to be the hash function and by Bob revealing x , Alice can then produce an adequate signature proving she knows x (in addition to her own private key). Alice has grins and Bob has bitcoin. They would like to swap. We assume Bob created an output on the Bitcoin blockchain that allows spending either by Alice if she learns a hash pre-image x , or by Bob after time Tb . Alice is ready to send her grins to Bob if he reveals x . First, Alice sends her grins to a multiparty timelock contract with a refund time Ta < Tb . To send the 2-of-2 output to Bob and execute the swap, Alice and Bob start as if they were building a normal trustless transaction as specified in section 2.1. Alice picks a random nonce ks and her blinding sum rs and sends ks*G and rs*G to Bob. Bob picks a random blinding factor rr and a random nonce kr . However this time, instead of simply sending sr = kr + e * rr with his rr*G and kr*G , Bob sends sr' = kr + x + e * rr as well as x*G . Alice can validate that sr'*G = kr*G + x*G + rr*G . She can also check that Bob has money locked with x*G on the other chain. Alice sends back her ss = ks + e * xs as she normally would, now that she can also compute e = SHA256(M | ks*G + kr*G) . To complete the signature, Bob computes sr = kr + e * rr and the final signature is (sr + ss, kr*G + ks*G) . As soon as Bob broadcasts the final transaction to get his new grins, Alice can compute sr' - sr to get x . Notes on the Bitcoin setup Prior to completing the atomic swap, Bob needs to know Alice's public key. Bob would then create an output on the Bitcoin blockchain with a 2-of-2 multisig similar to alice_pubkey secret_pubkey 2 OP_CHECKMULTISIG . This should be wrapped in an OP_IF so Bob can get his money back after an agreed-upon time and all of this can even be wrapped in a P2SH. Here secret_pubkey is x*G from the previous section. To verify the output, Alice would take x*G , recreate the bitcoin script, hash it and check that her hash matches what's in the P2SH (step 2 in previous section). Once she gets x (step 6), she can build the 2 signatures necessary to spend the 2-of-2, having both private keys, and get her bitcoin.","title":"Atomic Swap"},{"location":"wiki/transactions/contracts/#relative-timelocks-lightning-network","text":"See No Recent Duplicate (NRD) transaction kernels for more details.","title":"\"Relative Timelocks\" (Lightning Network)"},{"location":"wiki/transactions/payment-proofs/","text":"Payment Proofs Title: payment-proofs Authors: David Burkett Start date: Nov 05 2019 RFC PR: mimblewimble/grin-rfcs#31 Tracking issue: mimblewimble/grin-wallet#230 Summary Support generating and validating payment proofs for sender-initiated (i.e. non-invoice) transactions. Motivation Bitcoin and other cryptocurrencies with transparent protocol-level addressing and immutable, unprunable blockchains can prove sender, receiver, and amounts of payments simply by pointing to the transaction in the blockchain. Grin's privacy and scalability means users no longer have this ability. This prevents some merchants from accepting Grin due to the high possibility of payment disputes that are unresolvable in the same way they are for transparent coins. This RFC changes the transaction building process where payers can require payees to create a \"proof\" they've received a payment before the payer finalizes and broadcasts the transaction. Community-level explanation From an end-user perspective, payers can require payees to prove receipt of funds as part of the transacting process. Payers can then use these \"proofs\" to resolve payment disputes and prove they sent funds to the correct payee. Reference-level explanation Slate changes A new (optional) structure ( payment_info ) will be added to transaction slates, along with a version increase. The payment_info structure will contain: sender_address - An ed25519 public key generated by the sender. receiver_address - An ed25519 public key for the receiver, typically the public key of the user's v3 onion address. receiver_signature - A signature of the sender_address, received amount, and kernel commitment that validates against the receiver_address . Generating proofs Receipt confirmations ( receiver_signature ) will be generated by the payee by providing an ED25519 signature of: (amount || kernel_commitment || sender_address) , using the private key of the receiver_address . The sender_signature can be generated for (amount || kernel_commitment || sender_address) using the private key of the sender_address . Sender will then create and store the following info, which can be considered the complete payment_proof : receiver_address receiver_signature amount kernel_commitment sender_address sender_signature Verifying Proofs This payment_proof can be provided by the sender at any time to convince a payee that a payment was made to them. The proof can be verified as follows: Ensure the kernel_commitment is confirmed on-chain. Verify that the receiver_address belongs to the payee. Verify that the receiver_signature is valid. Verify that the sender_signature is valid. Wallet actions init-send As part of the first step of the tx-building process, the sender/payer generates the sender_address using their keychain. The receiver_address and keychain path of the sender_address must be stored locally, along with the slate_id . The sender_address and receiver_address will then be added to the payment_proof structure of the slate. receive If the payment_proof structure exists on the slate, it is mandatory that the receiver_signature is generated and added to the slate as part of the receive tx-building step. finalize Using the slate_id , the sender can retrieve the original sender_address and receiver_address that were included in the slate, and verify that those fields remain unchanged. The sender must then validate the receiver_signature . If any of the original payment_proof slate fields were modified, or if the receiver_signature is invalid, the transaction must be rejected by the sender. Once the payment_info details have been validated, the sender can generate and store the payment_proof (See Generating Proofs above), and then finalize the transaction as normal. Drawbacks Increases the size of tx slates. Possibility of privacy leakage through address reuse. Rationale and alternatives This design works well with TOR tx building, yet is generic enough to work with all known transacting mechanisms. Prior art Wallet713 implements payment proofs for grinbox transactions, which our design adapts and builds on to work more seemlessly with onion addresses and with transaction building methods that don't inherently rely on addresses. Unresolved questions Can this be adapted to work for invoices? Future possibilities Payment proofs could potentially be added to invoice payments in the future, but at the cost of an additional round of communication. References Tx slate structure \u21a9 Beam's payment proof model \u21a9","title":"Payment Proofs"},{"location":"wiki/transactions/payment-proofs/#payment-proofs","text":"Title: payment-proofs Authors: David Burkett Start date: Nov 05 2019 RFC PR: mimblewimble/grin-rfcs#31 Tracking issue: mimblewimble/grin-wallet#230","title":"Payment Proofs"},{"location":"wiki/transactions/payment-proofs/#summary","text":"Support generating and validating payment proofs for sender-initiated (i.e. non-invoice) transactions.","title":"Summary"},{"location":"wiki/transactions/payment-proofs/#motivation","text":"Bitcoin and other cryptocurrencies with transparent protocol-level addressing and immutable, unprunable blockchains can prove sender, receiver, and amounts of payments simply by pointing to the transaction in the blockchain. Grin's privacy and scalability means users no longer have this ability. This prevents some merchants from accepting Grin due to the high possibility of payment disputes that are unresolvable in the same way they are for transparent coins. This RFC changes the transaction building process where payers can require payees to create a \"proof\" they've received a payment before the payer finalizes and broadcasts the transaction.","title":"Motivation"},{"location":"wiki/transactions/payment-proofs/#community-level-explanation","text":"From an end-user perspective, payers can require payees to prove receipt of funds as part of the transacting process. Payers can then use these \"proofs\" to resolve payment disputes and prove they sent funds to the correct payee.","title":"Community-level explanation"},{"location":"wiki/transactions/payment-proofs/#reference-level-explanation","text":"","title":"Reference-level explanation"},{"location":"wiki/transactions/payment-proofs/#slate-changes","text":"A new (optional) structure ( payment_info ) will be added to transaction slates, along with a version increase. The payment_info structure will contain: sender_address - An ed25519 public key generated by the sender. receiver_address - An ed25519 public key for the receiver, typically the public key of the user's v3 onion address. receiver_signature - A signature of the sender_address, received amount, and kernel commitment that validates against the receiver_address .","title":"Slate changes"},{"location":"wiki/transactions/payment-proofs/#generating-proofs","text":"Receipt confirmations ( receiver_signature ) will be generated by the payee by providing an ED25519 signature of: (amount || kernel_commitment || sender_address) , using the private key of the receiver_address . The sender_signature can be generated for (amount || kernel_commitment || sender_address) using the private key of the sender_address . Sender will then create and store the following info, which can be considered the complete payment_proof : receiver_address receiver_signature amount kernel_commitment sender_address sender_signature","title":"Generating proofs"},{"location":"wiki/transactions/payment-proofs/#verifying-proofs","text":"This payment_proof can be provided by the sender at any time to convince a payee that a payment was made to them. The proof can be verified as follows: Ensure the kernel_commitment is confirmed on-chain. Verify that the receiver_address belongs to the payee. Verify that the receiver_signature is valid. Verify that the sender_signature is valid.","title":"Verifying Proofs"},{"location":"wiki/transactions/payment-proofs/#wallet-actions","text":"","title":"Wallet actions"},{"location":"wiki/transactions/payment-proofs/#init-send","text":"As part of the first step of the tx-building process, the sender/payer generates the sender_address using their keychain. The receiver_address and keychain path of the sender_address must be stored locally, along with the slate_id . The sender_address and receiver_address will then be added to the payment_proof structure of the slate.","title":"init-send"},{"location":"wiki/transactions/payment-proofs/#receive","text":"If the payment_proof structure exists on the slate, it is mandatory that the receiver_signature is generated and added to the slate as part of the receive tx-building step.","title":"receive"},{"location":"wiki/transactions/payment-proofs/#finalize","text":"Using the slate_id , the sender can retrieve the original sender_address and receiver_address that were included in the slate, and verify that those fields remain unchanged. The sender must then validate the receiver_signature . If any of the original payment_proof slate fields were modified, or if the receiver_signature is invalid, the transaction must be rejected by the sender. Once the payment_info details have been validated, the sender can generate and store the payment_proof (See Generating Proofs above), and then finalize the transaction as normal.","title":"finalize"},{"location":"wiki/transactions/payment-proofs/#drawbacks","text":"Increases the size of tx slates. Possibility of privacy leakage through address reuse.","title":"Drawbacks"},{"location":"wiki/transactions/payment-proofs/#rationale-and-alternatives","text":"This design works well with TOR tx building, yet is generic enough to work with all known transacting mechanisms.","title":"Rationale and alternatives"},{"location":"wiki/transactions/payment-proofs/#prior-art","text":"Wallet713 implements payment proofs for grinbox transactions, which our design adapts and builds on to work more seemlessly with onion addresses and with transaction building methods that don't inherently rely on addresses.","title":"Prior art"},{"location":"wiki/transactions/payment-proofs/#unresolved-questions","text":"Can this be adapted to work for invoices?","title":"Unresolved questions"},{"location":"wiki/transactions/payment-proofs/#future-possibilities","text":"Payment proofs could potentially be added to invoice payments in the future, but at the cost of an additional round of communication.","title":"Future possibilities"},{"location":"wiki/transactions/payment-proofs/#references","text":"Tx slate structure \u21a9 Beam's payment proof model \u21a9","title":"References"},{"location":"wiki/transactions/range-proof-format/","text":"Rangeproof Format This document could use a re-write. secp256k1-zkp Bulletproof format Grin uses Bulletproofs , the currently most efficient range proofs which do not require a trusted setup. Implemented at mimblewimble/secp256k1-zkp , a fork of the Blockstream C library ElementsProject/secp256k1-zkp . In this document we explain how to recover the proof parameters from the output bytes. Note that we name the parameters as they are named in the C library, which might be slightly different than the paper in some cases. Here is a sample proof output taken from a Grin transaction: 0b1bdf235e9c438aab5c6d02d3fe8173304bc528a3330825fb2311fa60fcdd6bfb92a248e26f849aebd511d2b326fa34b7f3030517d2f8e08a9b3cac7fa9fd200d07a46ca6ec5af30ce569b1e5faf2acf525cf1ed90cbed74ab7378b9b3957f28635fe7440aac2dc2c4bf43265b6ad1bfa82fddd9a827c4e97a913ce451b9a66bb06d3c08e03e85e98c581bbdf8c852796371a4603b8d52b80a1f2e95bd5e2a91c7a00b4d4564d9586235a7858d9ce8a8888bead7d51be2dd802de5af2921e079586817fce16d36c7764af8b4bf133b56b39970d6a568bf9ff101e6d33409e7c3bb081df7425b276655be611941245ceaad529495a86bc0e3d0f8634a8acf65c34c4e244959a5098bd58285408945a247d2fd894e5b18027d698c7e494e4256110553df54babf90592fbdffa0138b6b5a2a423ea5e2ec4d8f852a33c271a73b10fed9e1ee8cb2db1e71311cacd9e1d0b6dbf6cfab15723ec3cac4cc52154fc9d532202a085238e756ad1fa804cce2a634decc1b348f6ff939f9f80187d85aa5c308224a505c75e7f58fc7f35424276db7956474c1895e23ac55f864f4177b59f3ce92ef8c99e011cf55e0cefc5635d2eaf573df29af057a19bb209392a8c0e29a4b77adad76d385422e7f1d06de2d4f14e61ac3619aa22ae5bc288bb41cb56ddb70bb39ae84d00eb0cb34b4063bb55a83b9fe52604e545adcd41beb6ce14cdff73a21beb7493fa443a34585b7d2927f608cad17aa5f0e8e154b14d35315f63dd3580e80d06d8be4039f58778967f7bf2cdd9020fbcc9fed799b8159814f6a261c568e8b59c59df3180efb9cc13c576bf313248c96fa867aba43a80e799ff19ac685d7208cea7944dc9dcba7a61f2809540ecd0711e76b601969bdc551845e0b11fb821871d00e417ad002a70353867db25fa647e98a0db4c3bbaf828d97fc66079ef0d First, we have two 32 byte scalars. These are the already negated versions of taux and mu. We negate them such that the verifier doesn't have to do it (rangeproof_impl.h 701-702). 0b1bdf235e9c438aab5c6d02d3fe8173304bc528a3330825fb2311fa60fcdd6b (5024686248162052924872973414517693136231035491146611931625298995470137089387) taux (negated) fb92a248e26f849aebd511d2b326fa34b7f3030517d2f8e08a9b3cac7fa9fd20 (113789604713728301456840843635921464549630649029317112794749678552821986360608) mu (negated) After that, we have 4 points, which represent commitments A, S, T1, T2. Points are encoded in a very smart way. We have one offset byte. We use this offset byte indicate the LSB of y, telling us if the points y value needs to be negated when recovered. If this is the case, the bit is set to 1 (starting at the LSB); otherwise, it is left at 0. If we have more then eight points, we need 2 bytes offset, if we have more then 16, then three, and so forth (rangeproof_impl.h 703). 0d offset 0000 1101 offset in binary From this, we can recover the 4 points. (using the standard compressed point version here with leading 02 or 03) We start reading at the LSB. 0307a46ca6ec5af30ce569b1e5faf2acf525cf1ed90cbed74ab7378b9b3957f286 A (03 because of the 1 bit in the offset) 0235fe7440aac2dc2c4bf43265b6ad1bfa82fddd9a827c4e97a913ce451b9a66bb S (02 here because of the 0 bit in the offset) 0306d3c08e03e85e98c581bbdf8c852796371a4603b8d52b80a1f2e95bd5e2a91c T1 037a00b4d4564d9586235a7858d9ce8a8888bead7d51be2dd802de5af2921e0795 T2 Next, we have the final value of the dot product which again is a 32-byte scalar ( inner_product_impl.h 811 ) 86817fce16d36c7764af8b4bf133b56b39970d6a568bf9ff101e6d33409e7c3b (60838727059453008536034129618950719358562694528830851223208761064459354405947) dot Then we have the final values (32-byte scalars) of the shrunk vectors a, b used in the inner product protocol. The library does not do the last round of the protocol, meaning it will stop when the vectors are of length two instead of length one. This is because every round creates two commitments Li and Ri. If we don't do the last round, we spare two commitments with the cost that our two vectors are of size two instead of one, which is more space-efficient, and we save computing time. ( inner_product_impl.h 835-836 ) b081df7425b276655be611941245ceaad529495a86bc0e3d0f8634a8acf65c34 (79836526842770413616887368822368313168206709119259360230886972660827215518772) a1 c4e244959a5098bd58285408945a247d2fd894e5b18027d698c7e494e4256110 (89053099110995010594661038229216983605420219413380810817771304480647904846096) b1 553df54babf90592fbdffa0138b6b5a2a423ea5e2ec4d8f852a33c271a73b10f (38556062768490931671602594328406809964645337276375001909352144464132590252303) a2 ed9e1ee8cb2db1e71311cacd9e1d0b6dbf6cfab15723ec3cac4cc52154fc9d53 (107477520278964342277912932357487306000871347661927764278313323679782451060051) b2 And last we have the commitments Li and Ri of every round. In Grin we create range proofs with a range of 0 to (2^64 -1). This means we have six rounds (log(64) = 6); however, since we stop early, we only do five rounds, so 10 points instead of 12. The implementation always computes L before R. ( inner_product_impl.h 627 ) Again we have an offset in which we specify how to recover y values. Now since we have more than eight points we need two bytes offset. We start reading at the LSB of the first byte and then go to the LSB of the second byte. ( inner_product_impl.h 839 ) 2202 offset 0010 0010 first offset byte (binary) 0000 0010 second offset byte (binary) 02a085238e756ad1fa804cce2a634decc1b348f6ff939f9f80187d85aa5c308224 L1 03a505c75e7f58fc7f35424276db7956474c1895e23ac55f864f4177b59f3ce92e R1 (03 because of the 1 at bit number 2 of first offset byte) 02f8c99e011cf55e0cefc5635d2eaf573df29af057a19bb209392a8c0e29a4b77a L2 02dad76d385422e7f1d06de2d4f14e61ac3619aa22ae5bc288bb41cb56ddb70bb3 R2 029ae84d00eb0cb34b4063bb55a83b9fe52604e545adcd41beb6ce14cdff73a21b L3 03eb7493fa443a34585b7d2927f608cad17aa5f0e8e154b14d35315f63dd3580e8 R3 (03 because of the 1 at bit number 6 of first offset byte) 020d06d8be4039f58778967f7bf2cdd9020fbcc9fed799b8159814f6a261c568e8 L4 02b59c59df3180efb9cc13c576bf313248c96fa867aba43a80e799ff19ac685d72 R4 0208cea7944dc9dcba7a61f2809540ecd0711e76b601969bdc551845e0b11fb821 L5 03871d00e417ad002a70353867db25fa647e98a0db4c3bbaf828d97fc66079ef0d R5 (03 because of the 1 at bit number 2 of second offset byte)","title":"Rangeproof Format"},{"location":"wiki/transactions/range-proof-format/#rangeproof-format","text":"This document could use a re-write.","title":"Rangeproof Format"},{"location":"wiki/transactions/range-proof-format/#secp256k1-zkp-bulletproof-format","text":"Grin uses Bulletproofs , the currently most efficient range proofs which do not require a trusted setup. Implemented at mimblewimble/secp256k1-zkp , a fork of the Blockstream C library ElementsProject/secp256k1-zkp . In this document we explain how to recover the proof parameters from the output bytes. Note that we name the parameters as they are named in the C library, which might be slightly different than the paper in some cases. Here is a sample proof output taken from a Grin transaction: 0b1bdf235e9c438aab5c6d02d3fe8173304bc528a3330825fb2311fa60fcdd6bfb92a248e26f849aebd511d2b326fa34b7f3030517d2f8e08a9b3cac7fa9fd200d07a46ca6ec5af30ce569b1e5faf2acf525cf1ed90cbed74ab7378b9b3957f28635fe7440aac2dc2c4bf43265b6ad1bfa82fddd9a827c4e97a913ce451b9a66bb06d3c08e03e85e98c581bbdf8c852796371a4603b8d52b80a1f2e95bd5e2a91c7a00b4d4564d9586235a7858d9ce8a8888bead7d51be2dd802de5af2921e079586817fce16d36c7764af8b4bf133b56b39970d6a568bf9ff101e6d33409e7c3bb081df7425b276655be611941245ceaad529495a86bc0e3d0f8634a8acf65c34c4e244959a5098bd58285408945a247d2fd894e5b18027d698c7e494e4256110553df54babf90592fbdffa0138b6b5a2a423ea5e2ec4d8f852a33c271a73b10fed9e1ee8cb2db1e71311cacd9e1d0b6dbf6cfab15723ec3cac4cc52154fc9d532202a085238e756ad1fa804cce2a634decc1b348f6ff939f9f80187d85aa5c308224a505c75e7f58fc7f35424276db7956474c1895e23ac55f864f4177b59f3ce92ef8c99e011cf55e0cefc5635d2eaf573df29af057a19bb209392a8c0e29a4b77adad76d385422e7f1d06de2d4f14e61ac3619aa22ae5bc288bb41cb56ddb70bb39ae84d00eb0cb34b4063bb55a83b9fe52604e545adcd41beb6ce14cdff73a21beb7493fa443a34585b7d2927f608cad17aa5f0e8e154b14d35315f63dd3580e80d06d8be4039f58778967f7bf2cdd9020fbcc9fed799b8159814f6a261c568e8b59c59df3180efb9cc13c576bf313248c96fa867aba43a80e799ff19ac685d7208cea7944dc9dcba7a61f2809540ecd0711e76b601969bdc551845e0b11fb821871d00e417ad002a70353867db25fa647e98a0db4c3bbaf828d97fc66079ef0d First, we have two 32 byte scalars. These are the already negated versions of taux and mu. We negate them such that the verifier doesn't have to do it (rangeproof_impl.h 701-702). 0b1bdf235e9c438aab5c6d02d3fe8173304bc528a3330825fb2311fa60fcdd6b (5024686248162052924872973414517693136231035491146611931625298995470137089387) taux (negated) fb92a248e26f849aebd511d2b326fa34b7f3030517d2f8e08a9b3cac7fa9fd20 (113789604713728301456840843635921464549630649029317112794749678552821986360608) mu (negated) After that, we have 4 points, which represent commitments A, S, T1, T2. Points are encoded in a very smart way. We have one offset byte. We use this offset byte indicate the LSB of y, telling us if the points y value needs to be negated when recovered. If this is the case, the bit is set to 1 (starting at the LSB); otherwise, it is left at 0. If we have more then eight points, we need 2 bytes offset, if we have more then 16, then three, and so forth (rangeproof_impl.h 703). 0d offset 0000 1101 offset in binary From this, we can recover the 4 points. (using the standard compressed point version here with leading 02 or 03) We start reading at the LSB. 0307a46ca6ec5af30ce569b1e5faf2acf525cf1ed90cbed74ab7378b9b3957f286 A (03 because of the 1 bit in the offset) 0235fe7440aac2dc2c4bf43265b6ad1bfa82fddd9a827c4e97a913ce451b9a66bb S (02 here because of the 0 bit in the offset) 0306d3c08e03e85e98c581bbdf8c852796371a4603b8d52b80a1f2e95bd5e2a91c T1 037a00b4d4564d9586235a7858d9ce8a8888bead7d51be2dd802de5af2921e0795 T2 Next, we have the final value of the dot product which again is a 32-byte scalar ( inner_product_impl.h 811 ) 86817fce16d36c7764af8b4bf133b56b39970d6a568bf9ff101e6d33409e7c3b (60838727059453008536034129618950719358562694528830851223208761064459354405947) dot Then we have the final values (32-byte scalars) of the shrunk vectors a, b used in the inner product protocol. The library does not do the last round of the protocol, meaning it will stop when the vectors are of length two instead of length one. This is because every round creates two commitments Li and Ri. If we don't do the last round, we spare two commitments with the cost that our two vectors are of size two instead of one, which is more space-efficient, and we save computing time. ( inner_product_impl.h 835-836 ) b081df7425b276655be611941245ceaad529495a86bc0e3d0f8634a8acf65c34 (79836526842770413616887368822368313168206709119259360230886972660827215518772) a1 c4e244959a5098bd58285408945a247d2fd894e5b18027d698c7e494e4256110 (89053099110995010594661038229216983605420219413380810817771304480647904846096) b1 553df54babf90592fbdffa0138b6b5a2a423ea5e2ec4d8f852a33c271a73b10f (38556062768490931671602594328406809964645337276375001909352144464132590252303) a2 ed9e1ee8cb2db1e71311cacd9e1d0b6dbf6cfab15723ec3cac4cc52154fc9d53 (107477520278964342277912932357487306000871347661927764278313323679782451060051) b2 And last we have the commitments Li and Ri of every round. In Grin we create range proofs with a range of 0 to (2^64 -1). This means we have six rounds (log(64) = 6); however, since we stop early, we only do five rounds, so 10 points instead of 12. The implementation always computes L before R. ( inner_product_impl.h 627 ) Again we have an offset in which we specify how to recover y values. Now since we have more than eight points we need two bytes offset. We start reading at the LSB of the first byte and then go to the LSB of the second byte. ( inner_product_impl.h 839 ) 2202 offset 0010 0010 first offset byte (binary) 0000 0010 second offset byte (binary) 02a085238e756ad1fa804cce2a634decc1b348f6ff939f9f80187d85aa5c308224 L1 03a505c75e7f58fc7f35424276db7956474c1895e23ac55f864f4177b59f3ce92e R1 (03 because of the 1 at bit number 2 of first offset byte) 02f8c99e011cf55e0cefc5635d2eaf573df29af057a19bb209392a8c0e29a4b77a L2 02dad76d385422e7f1d06de2d4f14e61ac3619aa22ae5bc288bb41cb56ddb70bb3 R2 029ae84d00eb0cb34b4063bb55a83b9fe52604e545adcd41beb6ce14cdff73a21b L3 03eb7493fa443a34585b7d2927f608cad17aa5f0e8e154b14d35315f63dd3580e8 R3 (03 because of the 1 at bit number 6 of first offset byte) 020d06d8be4039f58778967f7bf2cdd9020fbcc9fed799b8159814f6a261c568e8 L4 02b59c59df3180efb9cc13c576bf313248c96fa867aba43a80e799ff19ac685d72 R4 0208cea7944dc9dcba7a61f2809540ecd0711e76b601969bdc551845e0b11fb821 L5 03871d00e417ad002a70353867db25fa647e98a0db4c3bbaf828d97fc66079ef0d R5 (03 because of the 1 at bit number 2 of second offset byte)","title":"secp256k1-zkp Bulletproof format"},{"location":"wiki/transactions/slatepack/","text":"Slatepack Title: slatepack Authors: joltz Start date: May 07 2020 RFC PR: mimblewimble/grin-rfcs#55 Tracking issue: mimblewimble/grin-wallet#406 Summary Slatepack is a universal transaction standard for Grin. It is designed to provide a single coherent transaction building framework to improve both the user and developer experiences in the Grin ecosystem. All wallets and services are expected to fully support the Slatepack standard by the last scheduled hard fork in January 2021 to remain compatible. This document specifies the required components of the Slatepack standard and introduces them in the context of existing methods for transaction building in Grin. It assumes that Slatepack is the default supported transaction standard for Grin and is intended to operate under all conditions and edge cases. Slatepack is intended to be compatible with the objects and serialization methods defined in the Slate V4/Compact Slates RFC. This RFC is meant to replace the Slate Serialization , Armored Slates and Encrypted Slates RFCs. Motivation Without a comprehensive transaction building flow, users and services are left to make their own complicated decisions about firewalls, file handling and compatibility, risking their security, privacy and sanity. The objective of this RFC is to converge on a simple, universal, adoptable, secure and privacy preserving workflow standard for Grin transactions: Slatepack. Community-level explanation Slatepack changes the existing transaction building process in Grin in a few ways: Users, developers and services are no longer required to choose between many possible transaction methods to use and support: Slatepack is a universal Grin transaction standard The transport method decision now occurs automatically for the user by following the Slatepack standard There is only one synchronous method and one asynchronous method supported by default to keep things simple for developers and support workers Tor is the only synchronous transaction transport method that is currently supported in the Slatepack standard This happens \"under the hood\" by the wallet and the user only has to keep track of a SlatepackAddress for their counterparty If Tor is not successful, the transaction process automatically falls back to using an encrypted copy and pastable SlatepackMessage string to complete the transaction asynchronously The asynchronous method by default is now a copy and pastable SlatepackMessage string instead of a file SlatepackMessage is an ascii-armor string that supports encryption of its payload with a SlatepackAddress An encrypted SlatepackMessage is not meaningfully larger than a plain text SlatepackMessage with regard to transportability as proposed here The difference between synchronous and asynchronous transaction methods is abstracted away from the end user with the Slatepack standard grin-wallet send -d SlatepackAddress 1.337 will first try to send the Grin synchronously via Tor to the SlatepackAddress If that fails it will fall back to outputting an armored encrypted SlatepackMessage string for manual copy and paste transport Example SlatepackAddress : grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x Asynchronous transactions are now encrypted by default by knowing the SlatepackAddress of your counterparty(s) If a counterparty is unwilling or unable to provide a SlatepackAddress , a plain text SlatepackMessage can still be exchanged Sending a mobile Grin transaction should be as easy as scanning a simple QR encoded from a bech32 SlatepackAddress Or as easy as pasting the SlatepackAddress of your counterparty into your wallet for any other device Or if Tor is not accessible, or the receiving party is not online, as easy as copying and pasting a couple of SlatepackMessage strings with a counterparty in an alternative communication channel (email, forum, social media, instant messenger, generic web text box, carrier pigeon etc.) Reference-level explanation The Slatepack standard defines the three primary components: SlatepackAddress , SlatepackMessage and SlatepackWorkflow . The SlatepackAddress is a shareable bech32 encoded ed25519 public key that can be used both to route synchronous transactions and to encrypt asynchronous transactions . The SlatepackMessage is an easily copy and pastable ascii-armor string that contains an encrypted slate payload by default and is used in asynchronous transactions. The SlatepackWorkflow specifies how both of these components interact in a universally adoptable transaction standard for Grin. SlatepackAddress A SlatepackAddress is a bech32 encoded ed25519 public key and when shared with other parties is used to represent the ability to receive Grin transactions. grin-wallet already handles ed25519 keys for the v3 onion addresses in Tor transactions. These keys can be extended to be a general SlatepackAddress to allow a universal key format for both transport and encryption that is error-checked, QR friendly and easily human identifiable. Existing ed25519 public keys from the wallet are bech32 encoded with grin as the human-readable part to build a SlatepackAddress tgrin is the HRP for a floonet SlatepackAddress A SlatepackAddress can be decoded to its ed25519 public key which can then be mapped to an x25519 public key to be used for encryption By default, all wallets should generate a new SlatepackAddress for each transaction for improved user privacy and security. Wallets can optionally support the ability for a static, reusable receiving SlatepackAddress with a warning about the privacy risks of reusing these addresses. The exact proposal for the implementation of simulatenous active SlatepackAddresses to enforce address uniqueness by default according to this standard is left as an implementation detail to wallets to ensure that wallets can interactively receive Grin across many SlatepackAddresses simulataneously and efficiently. ed25519 keys are bech32 encoded as SlatepackAddresses rather than x25519 keys because the mapping from ed25519 to x25519 is more straightforward (x25519 public keys do not carry a v coordinate so they can map to two possible ed25519 public keys- this is solvable but using the ed25519 as the first order key avoids a potentially complex solution). Key Generation Keys used in SlatepackAddresses are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys used to derive Tor onion addresses. ed25519 keys used for a SlatepackAddress are derived from this second derivation path of the master seed. SlatepackAddress keys may be derived in parallel to the blinding factor derivation path such that a unique SlatepackAddress is derived each time a new blinding factor is derived for a transaction to satisfy the requirement for a unique SlatepackAddress to be used for each transaction by default. In a future update it may be desirable to encode the derivation path for the SlatepackAddress for a given encrypted SlatepackMessage somewhere so that the x25519 decryption keys can be derived without grinding down the path to find the right key to use. Example SlatepackAddress grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x SlatepackMessage A SlatepackMessage requires multiple layers of data and encoding. Serialization Grin slates are serialized as first order JSON objects. Binary serialization is done on those JSON objects. Before Slatepack, users could use both binary and JSON serialization for asynchronous transactions. With the Slatepack standard, all asynchronous transactions serialize the slate JSON objects as binary. JSON serialization for synchronous transactions (Tor) is still used as before. The Slatepack standard serialization choices are only relevant for asynchronous transaction methods. The details for the binary serialization of the most recent slates at the time of this writing can be found in the Slate V4 (Compact Slates) RFC. Future variations in slate binary serialization should be referenced in an RFC and may require the update of this document. Plain Text Metadata Plain text metadata is included with Slatepack messages to indicate how to handle the encryption if any for the slate data in addition to tracking versions for compatibility. It can be expanded in future versions with new fields that are safe to include as plain text. These fields are neither encrypted nor authenticated. \"slatepack\": [Major, Minor] Where [Major, Minor] are positive fixnum ints representing the Slatepack version used to build the SlatepackMessage \"mode\": int Where int is a positive fixnum int indicating the type of SlatepackMessage 0 == plain text 1 == encrypted Extendable to future new modes (e.g. multiparty) Indicates which additional metadata fields should be expected to follow \"sender\": SlatepackAddress Only used here where mode == 0 , otherwise this field is encrypted as described below Where SlatepackAddress is a bech32 encoded ed25519 public key generated by the sender's wallet For Slatepacks where the user does not wish to provide any SlatepackAddress a 0 value is used This value is used in the SlatepackWorkflow to attempt to complete the transaction via Tor and to otherwise encrypt a slate for asynchronous transport Encrypted Metadata Encrypted metadata is included with an encrypted SlatepackMessage to improve privacy for the sender of a Slatepack transaction in cases where Tor is not available. It is a basic structure containing the sender SlatepackAddress and potential recipients_list field for multiparty use to be encrypted by age. If these fields are included as plain text metadata, they would require an additional MAC field for authentication and reveal data that would be desirable to keep private. Note that recipients_list does not gain the same privacy advantages of the sender field because the values can be derived from the plain text data included in the age header with a bit of work. \"sender\": SlatepackAddress Used to complete the SlatepackWorkflow \"recipients_list\": vec<SlatepackAddress> Only included in multiparty encrypted mode for use in future versions Array of recipients such that each recipients SlatepackAddress in recipients_list matches their associated epk and emk by index in the age encryption header of the encrypted payload E.g. \"recipients_list\": [grin1a, grin1b] , \"age_header_recipients\": [(X25519, EPKa, EMKa), (X25519, EPKb, EMKb)] grin1a and (X25519, EPKa, EMKa) both belong to the same party as they are both at index 0 grin1b and (X25519, EPKb, EMKb) both belong to the same party as they are both at index 1 Encryption Slatepack encryption adheres to the cryptography decisions made by age . It supports a conversion from the ed25519 signing key type that grin-wallet already uses for Tor to a x25519 encryption key type that age uses for encryption. This allows us to avoid having to make new cryptography decisions to support encrypted slates with keys already used in grin-wallet. While Slatepack adheres to the cryptography decisions and payload structure choices made by age in its encrypted payloads, this data alone is not sufficient to handle all possible SlatepackWorkflow steps (because the age recipient header data contains x25519 keys, we want ed25519 keys for the workflow as key mapping in the other direction is not desirable). It should also be noted that a SlatepackAddress could be used to do generic age encryption by decoding the bech32 to the ed25519 public key and mapping that to its corresponding x25519 public key used in age. An age Address could also be used as a SlatepackAddress with some extra effort: bech32 decode to the x25519 public key and then follow Signal's lead to attempt to solve the problem of an x25519 key mapping to two ed25519 keys to give a single ed25519 public key to be used to build a SlatepackAddress by bech32 encoding with slatepack as the HRP. Payload (age Encryption) A binary serialized slate and associated Encrypted Metadata fields are concatenated and encrypted according to the age encryption specification. The steps taken here follow age as closely as possible to avoid losing any security properties. A fairly well-reviewed age library in rust is available to use for implementation. Any deviations in Slatepack encryption from the exact cryptography steps and decisions made in age are unintentional and should be corrected unless they are explicitly stated as a deviation from the cryptography decisions made by age. An encrypted Slatepack payload is built with the same steps as an encrypted age payload, where the X25519 keys are derived from a participants SlatepackAddress . E.g. age_encrypt(sender + slate_binary) where mode == 1 and sender is a valid SlatepackAddress Armor The payload that will be armored is an optionally encrypted, binary serialized Slatepack JSON object and any associated encrypted metadata. Armor is Framing wrapped around a SimpleBase58Check encoded Payload . Framing Armor uses specific Headers , Footers and Periods as Framing to contain its Payload . Header Supported Headers: BEGINSLATEPACK Regex: ^[>\\n\\r\\t ]*BEGINSLATEPACK[>\\n\\r\\t ]*$ Footer Supported Footers ENDSLATEPACK Regex: ^[>\\n\\r\\t ]*ENDSLATEPACK[>\\n\\r\\t ]*$ Periods All data of an armored slate up to the first . is the framing header All data after the first . and before the second . is the SimpleBase58Check encoded payload which contains the slate data All data after the second . and before the third . is the framing footer Any data after the third . is ignored Encoding SimpleBase58Check SlatepackMessage armor payloads are encoded similar to legacy bitcoin addresses, with the primary differences being that the SimpleBase58Check used here does not include version bytes and includes the error checking code at the beginning of the payload instead of at the end. SHA256(SHA256(SLATEPACK_MESSAGE_BINARY)) First four bytes from previous step are ERROR_CHECK_CODE Concatenate ERROR_CHECK_CODE + SLATEPACK_MESSAGE_BINARY Base58 encode the output from the previous step to complete the armor Payload It should be noted that the ERROR_CHECK_CODE does not have a robust error checking ability because a double sha256 hash is not a proper error check code and the encoding scheme itself was meant to be used for bitcoin addresses which are much smaller than slate payloads. A more robust error correction option was not chosen here because the consequences of the failure to detect an error are not as severe as they would be for a bitcoin address as further validation would need to occur for Grin. The purpose is to catch some characters being accidentally added or lost during armor transport rather than preventing a spend to an address we don't know the key to spend from. Formatting WORD_LENGTH : 15 Number of SimpleBase58Check encoded characters per word; chosen for human readability across device screen sizes LINE_BREAK : 200 words Number of words of WORD_LENGTH to include before inserting a newline; chosen for user friendliness in terminals and messaging applications MAX_STRING_SIZE : 1MB Maximum size for an armored SlatepackMessage string without requiring a file container If a SlatepackMessage exceeds this value it must be handled as a .slatepack file instead of a string This parameter chosen to cover as many cases as possible and still be supported by most clipboards WORD_LENGTH and LINE_BREAK parameters are adjustable as a formatting convenience. MAX_STRING_SIZE is fixed and cannot be exceeded without wrapping the armored SlatepackMessage in a .slatepack file. Edge Case: Large Slates (>1MB) Some slate payloads may be so large that they cannot be reliably handled across all clipboards. To handle these edge cases, a SlatepackMessage will be expected to be passed in a .slatepack file format in cases where Tor is unsuccessful and the armored SlatepackMessage string output would exceed 1MB. A file format was chosen as opposed to a multi-part message approach because messages are already written to file by default by grin-wallet and they are potentially simpler to handle from an implementation perspective. While wallets must support handling these edge cases to avoid all possible cases where a wallet cannot spend or receive a valid transaction, it would be reasonable for services and exchanges to support the Slatepack standard without the requirement of handling the rare file edge case. Example Slatepack JSON Object Mode 0: Plain Text In this plain text example, neither the sender nor the receiver wish to share a SlatepackAddress { \"slatepack\": [1, 0], \"mode\": 0, \"sender\": \"0\", \"payload\": <binary serialized slate> } Mode 1: Encrypted { \"slatepack\": [1, 0], \"mode\": 1, \"payload\": <age encrypted binary: sender slatepack address + binary serialized slate>, } Example SlatepackMessage BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv pcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY GWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx wNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK. SlatepackWorkflow Adoption of the Slatepack standard allows for a unified workflow that can still function without knowledge of a SlatepackAddress from a counterparty. With a SlatepackAddress grin-wallet send -d grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x 1.337 Sender wallet derives an onion v3 address from grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x and attempts to complete the transaction synchronously via Tor (Fallback) If the synchronous transaction fails, a SlatepackMessage string is encrypted to the SlatepackAddress and output for manual asynchronous transport by the user Without a SlatepackAddress grin-wallet send 1.337 A SlatepackMessage string is output for manual asynchronous transport by the user With QR Codes A QR-based SlatepackWorkflow will always begin with a standard QR size because they are encoded directly from a bech32 SlatepackAddress . This encoding simultaneously provides a derivable onion address to attempt a synchronous transaction ( bech32 -> ed25519 -> onionv3 ) and a derivable encryption key ( bech32 -> ed25519 -> x25519 ) to return an encrypted Slatepack string to complete the transaction asynchronously as a fallback. As a consequence, a SlatepackAddress must be revealed by the party producing a QR code in the SlatepackWorkflow . Receiver shares SlatepackAddress via QR Sender scans QR code and the transaction is completed synchronously via Tor by deriving the recipient's onion v3 address from their SlatepackAddress (Fallback) If the synchronous transaction fails, a SlatepackMessage string is output for manual asynchronous transport by the user With Three or More Parties Some possible future Slatepack transactions may require more than two parties to successfully build. These cases should not require any breaking changes to the core Slatepack standard workflow. The exact flow order (round-robin etc) will be defined by the accompanying RFCs that define the possible future multiple party slates themselves. In some cases, new slate versions may require (non-breaking) updates to this RFC. From there, the same standard Slatepack standard workflow of attempting to exchange the data via Tor first with an ascii armor fallback is still valid. For example, a future Slatepack version will add support for an array containing a SlatepackAddress for each party in the order desired to finish building the transaction. The wallet of each subsequent party will attempt to establish a connection with the next via Tor. In the event of a Tor failure it would be the responsibility of the most recent party to manually transport it to the next. In cases with many parties, the fallback method of the Slatepack standard could quickly become cumbersome if, for example, every third participant fails to achieve a Tor connection. Implementation Timeline Initial Slatepack implementation introduced with the July 2020 hard fork May or may not support encryption by default yet The proposed Slatepack standard is fully implemented and adopted as a universal transaction standard in last hard fork (Jan 2021) Slatepack is the default transaction standard in all wallets and services Drawbacks This puts a lot of eggs in one basket (if Slatepack fails there will likely be confusion returning to old methods) This may be a bit rushed to have where we want it before HF schedule Deprecating HTTP(S) is already a major change- by requiring the adoption of this completely new standard in addition we risk putting a lot of effort on the shoulders of existing services in the Grin ecosystem Rationale and alternatives By adding new options without simplifying the workflow for users we risk confusion and friction We could just add an option for copy and pastable slates instead of introducing an entirely new universal transaction flow standard Prior art Note that while previous asynchronous Mimblewimble transaction solutions require a relatively short TTL for a counterparty to successfully connect to their respective network before transactions fail (currently 72 hours for Tari DHT Network, 24 hours for Beam SBBS), Grin Slatepack transactions can remain valid indefinitely without spamming the network when using the ascii armor fallback. Tari Tari uses the Tari DHT Network to support asynchronous Mimblewimble transactions. This approach is comprehensive and comprises of the entire peer to peer messaging network, including both nodes and wallets. This is distinct from Slatepack which is strictly an approach to transaction building between wallet software, not general protocol messaging. Similar to Slatepack, Tari users derive a public key from their master seed (which is represented to users as emojis instead of bech32) and is used to look up peers in peer databases (as opposed to directly routing to a traditional Tor hidden service as in Slatepack). By default, Tari, like Slatepack, uses Tor for communication. While Slatepack and Tari both have addresses that decode to public keys used to find and communicate with counterparty wallets via Tor, they both handle the Tor failure case differently. Tari seems to rely on its custom DHT network to gracefully handle this at the cost of the complexity of a custom DHT layer. Slatepack falls back to an unopinionated, encrypted ascii armor string for the user to transport \"outside of the Grin network\" to complete the transaction. The advantage for Slatepack is significantly reduced complexity by using Tor directly with an unopinionated fallback mode. The disadvantage for Slatepack is that transactions don't \"magically\" just work if Tor communication is failing- they still require some effort from the user to transport the ascii armor themselves. Note that these details were taken from early documentation and not code- transactions in Tari may behave differently in practice. Beam Beam uses the SBBS gossip protocol to support asynchronous mimblewimble transactions. SBBS adds a nontrivial amount of complexity and attack surface to the core Beam software. In exchange, Beam receives a somewhat user-friendly mechanism for users to build transactions asynchronously. The asynchronous fallback method for Slatepack transactions is a simple ascii armor string that does not contain an opinion about a particular protocol with which to exchange the data. The advantage with the Slatepack method is that much less code is required to support these transactions which can improve the overall stability and security of the codebase running the Grin network. The disadvantage of this for Slatepack is that asynchronous transactions don't \"magically\" work- they still need to be between users via an outside channel (instant message, text box, email etc). Slatepack makes the tradeoff of slightly more work for the end user in exchange for a simpler and potentially more secure network for Grin. Unresolved questions How to handle key derivation harmoniously? What are unmentioned security considerations for using the same base key to both map to an onion address and map to an encryption key used in transactions? Related, what are unmentioned security considerations to SlatepackAddress reuse? Should we still use double-sha256 in SimpleBase58Check or take the opportunity to use a BCH or CRC code which may be more appropriate for error detection on slatepack messages? Is additional engineering desired here if there will always be further validation of the slate payload before a spend can occur? If addresses are not reused by default and since wallets need to be able to conduct multiple transactions in parallel, they need the ability to listen on all \"active\" addresses at the same time Future possibilities Extended to support future modes (payment channel, payjoin, multiple counterparties etc) An entirely different standard could be adopted in the future if non-interactive transactions become the default, eliminating the need for Slatepack It might be possible for a new standard to remain compatible with the existing SlatepackAddress to allow a more generic GrinAddress References Bitcoin BIP173 \u21a9 age - File Encryption Tool & Format \u21a9 age Rust library \u21a9 Ed25519 Keys \u21a9 Ed25519 to Curve25519 \u21a9 Using Ed25519 signing keys for encryption \u21a9 Armored Slates RFC \u21a9 Saltpack \u21a9 Tor v3 Specification \u21a9 Signal Docs XEdDSA \u21a9 How Tari Works \u21a9 Beam Docs SBBS \u21a9","title":"Slatepack"},{"location":"wiki/transactions/slatepack/#slatepack","text":"Title: slatepack Authors: joltz Start date: May 07 2020 RFC PR: mimblewimble/grin-rfcs#55 Tracking issue: mimblewimble/grin-wallet#406","title":"Slatepack"},{"location":"wiki/transactions/slatepack/#summary","text":"Slatepack is a universal transaction standard for Grin. It is designed to provide a single coherent transaction building framework to improve both the user and developer experiences in the Grin ecosystem. All wallets and services are expected to fully support the Slatepack standard by the last scheduled hard fork in January 2021 to remain compatible. This document specifies the required components of the Slatepack standard and introduces them in the context of existing methods for transaction building in Grin. It assumes that Slatepack is the default supported transaction standard for Grin and is intended to operate under all conditions and edge cases. Slatepack is intended to be compatible with the objects and serialization methods defined in the Slate V4/Compact Slates RFC. This RFC is meant to replace the Slate Serialization , Armored Slates and Encrypted Slates RFCs.","title":"Summary"},{"location":"wiki/transactions/slatepack/#motivation","text":"Without a comprehensive transaction building flow, users and services are left to make their own complicated decisions about firewalls, file handling and compatibility, risking their security, privacy and sanity. The objective of this RFC is to converge on a simple, universal, adoptable, secure and privacy preserving workflow standard for Grin transactions: Slatepack.","title":"Motivation"},{"location":"wiki/transactions/slatepack/#community-level-explanation","text":"Slatepack changes the existing transaction building process in Grin in a few ways: Users, developers and services are no longer required to choose between many possible transaction methods to use and support: Slatepack is a universal Grin transaction standard The transport method decision now occurs automatically for the user by following the Slatepack standard There is only one synchronous method and one asynchronous method supported by default to keep things simple for developers and support workers Tor is the only synchronous transaction transport method that is currently supported in the Slatepack standard This happens \"under the hood\" by the wallet and the user only has to keep track of a SlatepackAddress for their counterparty If Tor is not successful, the transaction process automatically falls back to using an encrypted copy and pastable SlatepackMessage string to complete the transaction asynchronously The asynchronous method by default is now a copy and pastable SlatepackMessage string instead of a file SlatepackMessage is an ascii-armor string that supports encryption of its payload with a SlatepackAddress An encrypted SlatepackMessage is not meaningfully larger than a plain text SlatepackMessage with regard to transportability as proposed here The difference between synchronous and asynchronous transaction methods is abstracted away from the end user with the Slatepack standard grin-wallet send -d SlatepackAddress 1.337 will first try to send the Grin synchronously via Tor to the SlatepackAddress If that fails it will fall back to outputting an armored encrypted SlatepackMessage string for manual copy and paste transport Example SlatepackAddress : grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x Asynchronous transactions are now encrypted by default by knowing the SlatepackAddress of your counterparty(s) If a counterparty is unwilling or unable to provide a SlatepackAddress , a plain text SlatepackMessage can still be exchanged Sending a mobile Grin transaction should be as easy as scanning a simple QR encoded from a bech32 SlatepackAddress Or as easy as pasting the SlatepackAddress of your counterparty into your wallet for any other device Or if Tor is not accessible, or the receiving party is not online, as easy as copying and pasting a couple of SlatepackMessage strings with a counterparty in an alternative communication channel (email, forum, social media, instant messenger, generic web text box, carrier pigeon etc.)","title":"Community-level explanation"},{"location":"wiki/transactions/slatepack/#reference-level-explanation","text":"The Slatepack standard defines the three primary components: SlatepackAddress , SlatepackMessage and SlatepackWorkflow . The SlatepackAddress is a shareable bech32 encoded ed25519 public key that can be used both to route synchronous transactions and to encrypt asynchronous transactions . The SlatepackMessage is an easily copy and pastable ascii-armor string that contains an encrypted slate payload by default and is used in asynchronous transactions. The SlatepackWorkflow specifies how both of these components interact in a universally adoptable transaction standard for Grin.","title":"Reference-level explanation"},{"location":"wiki/transactions/slatepack/#slatepackaddress","text":"A SlatepackAddress is a bech32 encoded ed25519 public key and when shared with other parties is used to represent the ability to receive Grin transactions. grin-wallet already handles ed25519 keys for the v3 onion addresses in Tor transactions. These keys can be extended to be a general SlatepackAddress to allow a universal key format for both transport and encryption that is error-checked, QR friendly and easily human identifiable. Existing ed25519 public keys from the wallet are bech32 encoded with grin as the human-readable part to build a SlatepackAddress tgrin is the HRP for a floonet SlatepackAddress A SlatepackAddress can be decoded to its ed25519 public key which can then be mapped to an x25519 public key to be used for encryption By default, all wallets should generate a new SlatepackAddress for each transaction for improved user privacy and security. Wallets can optionally support the ability for a static, reusable receiving SlatepackAddress with a warning about the privacy risks of reusing these addresses. The exact proposal for the implementation of simulatenous active SlatepackAddresses to enforce address uniqueness by default according to this standard is left as an implementation detail to wallets to ensure that wallets can interactively receive Grin across many SlatepackAddresses simulataneously and efficiently. ed25519 keys are bech32 encoded as SlatepackAddresses rather than x25519 keys because the mapping from ed25519 to x25519 is more straightforward (x25519 public keys do not carry a v coordinate so they can map to two possible ed25519 public keys- this is solvable but using the ed25519 as the first order key avoids a potentially complex solution).","title":"SlatepackAddress"},{"location":"wiki/transactions/slatepack/#key-generation","text":"Keys used in SlatepackAddresses are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys used to derive Tor onion addresses. ed25519 keys used for a SlatepackAddress are derived from this second derivation path of the master seed. SlatepackAddress keys may be derived in parallel to the blinding factor derivation path such that a unique SlatepackAddress is derived each time a new blinding factor is derived for a transaction to satisfy the requirement for a unique SlatepackAddress to be used for each transaction by default. In a future update it may be desirable to encode the derivation path for the SlatepackAddress for a given encrypted SlatepackMessage somewhere so that the x25519 decryption keys can be derived without grinding down the path to find the right key to use.","title":"Key Generation"},{"location":"wiki/transactions/slatepack/#example-slatepackaddress","text":"grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x","title":"Example SlatepackAddress"},{"location":"wiki/transactions/slatepack/#slatepackmessage","text":"A SlatepackMessage requires multiple layers of data and encoding.","title":"SlatepackMessage"},{"location":"wiki/transactions/slatepack/#serialization","text":"Grin slates are serialized as first order JSON objects. Binary serialization is done on those JSON objects. Before Slatepack, users could use both binary and JSON serialization for asynchronous transactions. With the Slatepack standard, all asynchronous transactions serialize the slate JSON objects as binary. JSON serialization for synchronous transactions (Tor) is still used as before. The Slatepack standard serialization choices are only relevant for asynchronous transaction methods. The details for the binary serialization of the most recent slates at the time of this writing can be found in the Slate V4 (Compact Slates) RFC. Future variations in slate binary serialization should be referenced in an RFC and may require the update of this document.","title":"Serialization"},{"location":"wiki/transactions/slatepack/#plain-text-metadata","text":"Plain text metadata is included with Slatepack messages to indicate how to handle the encryption if any for the slate data in addition to tracking versions for compatibility. It can be expanded in future versions with new fields that are safe to include as plain text. These fields are neither encrypted nor authenticated. \"slatepack\": [Major, Minor] Where [Major, Minor] are positive fixnum ints representing the Slatepack version used to build the SlatepackMessage \"mode\": int Where int is a positive fixnum int indicating the type of SlatepackMessage 0 == plain text 1 == encrypted Extendable to future new modes (e.g. multiparty) Indicates which additional metadata fields should be expected to follow \"sender\": SlatepackAddress Only used here where mode == 0 , otherwise this field is encrypted as described below Where SlatepackAddress is a bech32 encoded ed25519 public key generated by the sender's wallet For Slatepacks where the user does not wish to provide any SlatepackAddress a 0 value is used This value is used in the SlatepackWorkflow to attempt to complete the transaction via Tor and to otherwise encrypt a slate for asynchronous transport","title":"Plain Text Metadata"},{"location":"wiki/transactions/slatepack/#encrypted-metadata","text":"Encrypted metadata is included with an encrypted SlatepackMessage to improve privacy for the sender of a Slatepack transaction in cases where Tor is not available. It is a basic structure containing the sender SlatepackAddress and potential recipients_list field for multiparty use to be encrypted by age. If these fields are included as plain text metadata, they would require an additional MAC field for authentication and reveal data that would be desirable to keep private. Note that recipients_list does not gain the same privacy advantages of the sender field because the values can be derived from the plain text data included in the age header with a bit of work. \"sender\": SlatepackAddress Used to complete the SlatepackWorkflow \"recipients_list\": vec<SlatepackAddress> Only included in multiparty encrypted mode for use in future versions Array of recipients such that each recipients SlatepackAddress in recipients_list matches their associated epk and emk by index in the age encryption header of the encrypted payload E.g. \"recipients_list\": [grin1a, grin1b] , \"age_header_recipients\": [(X25519, EPKa, EMKa), (X25519, EPKb, EMKb)] grin1a and (X25519, EPKa, EMKa) both belong to the same party as they are both at index 0 grin1b and (X25519, EPKb, EMKb) both belong to the same party as they are both at index 1","title":"Encrypted Metadata"},{"location":"wiki/transactions/slatepack/#encryption","text":"Slatepack encryption adheres to the cryptography decisions made by age . It supports a conversion from the ed25519 signing key type that grin-wallet already uses for Tor to a x25519 encryption key type that age uses for encryption. This allows us to avoid having to make new cryptography decisions to support encrypted slates with keys already used in grin-wallet. While Slatepack adheres to the cryptography decisions and payload structure choices made by age in its encrypted payloads, this data alone is not sufficient to handle all possible SlatepackWorkflow steps (because the age recipient header data contains x25519 keys, we want ed25519 keys for the workflow as key mapping in the other direction is not desirable). It should also be noted that a SlatepackAddress could be used to do generic age encryption by decoding the bech32 to the ed25519 public key and mapping that to its corresponding x25519 public key used in age. An age Address could also be used as a SlatepackAddress with some extra effort: bech32 decode to the x25519 public key and then follow Signal's lead to attempt to solve the problem of an x25519 key mapping to two ed25519 keys to give a single ed25519 public key to be used to build a SlatepackAddress by bech32 encoding with slatepack as the HRP.","title":"Encryption"},{"location":"wiki/transactions/slatepack/#payload-age-encryption","text":"A binary serialized slate and associated Encrypted Metadata fields are concatenated and encrypted according to the age encryption specification. The steps taken here follow age as closely as possible to avoid losing any security properties. A fairly well-reviewed age library in rust is available to use for implementation. Any deviations in Slatepack encryption from the exact cryptography steps and decisions made in age are unintentional and should be corrected unless they are explicitly stated as a deviation from the cryptography decisions made by age. An encrypted Slatepack payload is built with the same steps as an encrypted age payload, where the X25519 keys are derived from a participants SlatepackAddress . E.g. age_encrypt(sender + slate_binary) where mode == 1 and sender is a valid SlatepackAddress","title":"Payload (age Encryption)"},{"location":"wiki/transactions/slatepack/#armor","text":"The payload that will be armored is an optionally encrypted, binary serialized Slatepack JSON object and any associated encrypted metadata. Armor is Framing wrapped around a SimpleBase58Check encoded Payload .","title":"Armor"},{"location":"wiki/transactions/slatepack/#framing","text":"Armor uses specific Headers , Footers and Periods as Framing to contain its Payload . Header Supported Headers: BEGINSLATEPACK Regex: ^[>\\n\\r\\t ]*BEGINSLATEPACK[>\\n\\r\\t ]*$ Footer Supported Footers ENDSLATEPACK Regex: ^[>\\n\\r\\t ]*ENDSLATEPACK[>\\n\\r\\t ]*$ Periods All data of an armored slate up to the first . is the framing header All data after the first . and before the second . is the SimpleBase58Check encoded payload which contains the slate data All data after the second . and before the third . is the framing footer Any data after the third . is ignored","title":"Framing"},{"location":"wiki/transactions/slatepack/#encoding-simplebase58check","text":"SlatepackMessage armor payloads are encoded similar to legacy bitcoin addresses, with the primary differences being that the SimpleBase58Check used here does not include version bytes and includes the error checking code at the beginning of the payload instead of at the end. SHA256(SHA256(SLATEPACK_MESSAGE_BINARY)) First four bytes from previous step are ERROR_CHECK_CODE Concatenate ERROR_CHECK_CODE + SLATEPACK_MESSAGE_BINARY Base58 encode the output from the previous step to complete the armor Payload It should be noted that the ERROR_CHECK_CODE does not have a robust error checking ability because a double sha256 hash is not a proper error check code and the encoding scheme itself was meant to be used for bitcoin addresses which are much smaller than slate payloads. A more robust error correction option was not chosen here because the consequences of the failure to detect an error are not as severe as they would be for a bitcoin address as further validation would need to occur for Grin. The purpose is to catch some characters being accidentally added or lost during armor transport rather than preventing a spend to an address we don't know the key to spend from.","title":"Encoding SimpleBase58Check"},{"location":"wiki/transactions/slatepack/#formatting","text":"WORD_LENGTH : 15 Number of SimpleBase58Check encoded characters per word; chosen for human readability across device screen sizes LINE_BREAK : 200 words Number of words of WORD_LENGTH to include before inserting a newline; chosen for user friendliness in terminals and messaging applications MAX_STRING_SIZE : 1MB Maximum size for an armored SlatepackMessage string without requiring a file container If a SlatepackMessage exceeds this value it must be handled as a .slatepack file instead of a string This parameter chosen to cover as many cases as possible and still be supported by most clipboards WORD_LENGTH and LINE_BREAK parameters are adjustable as a formatting convenience. MAX_STRING_SIZE is fixed and cannot be exceeded without wrapping the armored SlatepackMessage in a .slatepack file.","title":"Formatting"},{"location":"wiki/transactions/slatepack/#edge-case-large-slates-1mb","text":"Some slate payloads may be so large that they cannot be reliably handled across all clipboards. To handle these edge cases, a SlatepackMessage will be expected to be passed in a .slatepack file format in cases where Tor is unsuccessful and the armored SlatepackMessage string output would exceed 1MB. A file format was chosen as opposed to a multi-part message approach because messages are already written to file by default by grin-wallet and they are potentially simpler to handle from an implementation perspective. While wallets must support handling these edge cases to avoid all possible cases where a wallet cannot spend or receive a valid transaction, it would be reasonable for services and exchanges to support the Slatepack standard without the requirement of handling the rare file edge case.","title":"Edge Case: Large Slates (&gt;1MB)"},{"location":"wiki/transactions/slatepack/#example-slatepack-json-object","text":"","title":"Example Slatepack JSON Object"},{"location":"wiki/transactions/slatepack/#mode-0-plain-text","text":"In this plain text example, neither the sender nor the receiver wish to share a SlatepackAddress { \"slatepack\": [1, 0], \"mode\": 0, \"sender\": \"0\", \"payload\": <binary serialized slate> }","title":"Mode 0: Plain Text"},{"location":"wiki/transactions/slatepack/#mode-1-encrypted","text":"{ \"slatepack\": [1, 0], \"mode\": 1, \"payload\": <age encrypted binary: sender slatepack address + binary serialized slate>, }","title":"Mode 1: Encrypted"},{"location":"wiki/transactions/slatepack/#example-slatepackmessage","text":"BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv pcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY GWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx wNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK.","title":"Example SlatepackMessage"},{"location":"wiki/transactions/slatepack/#slatepackworkflow","text":"Adoption of the Slatepack standard allows for a unified workflow that can still function without knowledge of a SlatepackAddress from a counterparty.","title":"SlatepackWorkflow"},{"location":"wiki/transactions/slatepack/#with-a-slatepackaddress","text":"grin-wallet send -d grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x 1.337 Sender wallet derives an onion v3 address from grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x and attempts to complete the transaction synchronously via Tor (Fallback) If the synchronous transaction fails, a SlatepackMessage string is encrypted to the SlatepackAddress and output for manual asynchronous transport by the user","title":"With a SlatepackAddress"},{"location":"wiki/transactions/slatepack/#without-a-slatepackaddress","text":"grin-wallet send 1.337 A SlatepackMessage string is output for manual asynchronous transport by the user","title":"Without a SlatepackAddress"},{"location":"wiki/transactions/slatepack/#with-qr-codes","text":"A QR-based SlatepackWorkflow will always begin with a standard QR size because they are encoded directly from a bech32 SlatepackAddress . This encoding simultaneously provides a derivable onion address to attempt a synchronous transaction ( bech32 -> ed25519 -> onionv3 ) and a derivable encryption key ( bech32 -> ed25519 -> x25519 ) to return an encrypted Slatepack string to complete the transaction asynchronously as a fallback. As a consequence, a SlatepackAddress must be revealed by the party producing a QR code in the SlatepackWorkflow . Receiver shares SlatepackAddress via QR Sender scans QR code and the transaction is completed synchronously via Tor by deriving the recipient's onion v3 address from their SlatepackAddress (Fallback) If the synchronous transaction fails, a SlatepackMessage string is output for manual asynchronous transport by the user","title":"With QR Codes"},{"location":"wiki/transactions/slatepack/#with-three-or-more-parties","text":"Some possible future Slatepack transactions may require more than two parties to successfully build. These cases should not require any breaking changes to the core Slatepack standard workflow. The exact flow order (round-robin etc) will be defined by the accompanying RFCs that define the possible future multiple party slates themselves. In some cases, new slate versions may require (non-breaking) updates to this RFC. From there, the same standard Slatepack standard workflow of attempting to exchange the data via Tor first with an ascii armor fallback is still valid. For example, a future Slatepack version will add support for an array containing a SlatepackAddress for each party in the order desired to finish building the transaction. The wallet of each subsequent party will attempt to establish a connection with the next via Tor. In the event of a Tor failure it would be the responsibility of the most recent party to manually transport it to the next. In cases with many parties, the fallback method of the Slatepack standard could quickly become cumbersome if, for example, every third participant fails to achieve a Tor connection.","title":"With Three or More Parties"},{"location":"wiki/transactions/slatepack/#implementation-timeline","text":"Initial Slatepack implementation introduced with the July 2020 hard fork May or may not support encryption by default yet The proposed Slatepack standard is fully implemented and adopted as a universal transaction standard in last hard fork (Jan 2021) Slatepack is the default transaction standard in all wallets and services","title":"Implementation Timeline"},{"location":"wiki/transactions/slatepack/#drawbacks","text":"This puts a lot of eggs in one basket (if Slatepack fails there will likely be confusion returning to old methods) This may be a bit rushed to have where we want it before HF schedule Deprecating HTTP(S) is already a major change- by requiring the adoption of this completely new standard in addition we risk putting a lot of effort on the shoulders of existing services in the Grin ecosystem","title":"Drawbacks"},{"location":"wiki/transactions/slatepack/#rationale-and-alternatives","text":"By adding new options without simplifying the workflow for users we risk confusion and friction We could just add an option for copy and pastable slates instead of introducing an entirely new universal transaction flow standard","title":"Rationale and alternatives"},{"location":"wiki/transactions/slatepack/#prior-art","text":"Note that while previous asynchronous Mimblewimble transaction solutions require a relatively short TTL for a counterparty to successfully connect to their respective network before transactions fail (currently 72 hours for Tari DHT Network, 24 hours for Beam SBBS), Grin Slatepack transactions can remain valid indefinitely without spamming the network when using the ascii armor fallback.","title":"Prior art"},{"location":"wiki/transactions/slatepack/#tari","text":"Tari uses the Tari DHT Network to support asynchronous Mimblewimble transactions. This approach is comprehensive and comprises of the entire peer to peer messaging network, including both nodes and wallets. This is distinct from Slatepack which is strictly an approach to transaction building between wallet software, not general protocol messaging. Similar to Slatepack, Tari users derive a public key from their master seed (which is represented to users as emojis instead of bech32) and is used to look up peers in peer databases (as opposed to directly routing to a traditional Tor hidden service as in Slatepack). By default, Tari, like Slatepack, uses Tor for communication. While Slatepack and Tari both have addresses that decode to public keys used to find and communicate with counterparty wallets via Tor, they both handle the Tor failure case differently. Tari seems to rely on its custom DHT network to gracefully handle this at the cost of the complexity of a custom DHT layer. Slatepack falls back to an unopinionated, encrypted ascii armor string for the user to transport \"outside of the Grin network\" to complete the transaction. The advantage for Slatepack is significantly reduced complexity by using Tor directly with an unopinionated fallback mode. The disadvantage for Slatepack is that transactions don't \"magically\" just work if Tor communication is failing- they still require some effort from the user to transport the ascii armor themselves. Note that these details were taken from early documentation and not code- transactions in Tari may behave differently in practice.","title":"Tari"},{"location":"wiki/transactions/slatepack/#beam","text":"Beam uses the SBBS gossip protocol to support asynchronous mimblewimble transactions. SBBS adds a nontrivial amount of complexity and attack surface to the core Beam software. In exchange, Beam receives a somewhat user-friendly mechanism for users to build transactions asynchronously. The asynchronous fallback method for Slatepack transactions is a simple ascii armor string that does not contain an opinion about a particular protocol with which to exchange the data. The advantage with the Slatepack method is that much less code is required to support these transactions which can improve the overall stability and security of the codebase running the Grin network. The disadvantage of this for Slatepack is that asynchronous transactions don't \"magically\" work- they still need to be between users via an outside channel (instant message, text box, email etc). Slatepack makes the tradeoff of slightly more work for the end user in exchange for a simpler and potentially more secure network for Grin.","title":"Beam"},{"location":"wiki/transactions/slatepack/#unresolved-questions","text":"How to handle key derivation harmoniously? What are unmentioned security considerations for using the same base key to both map to an onion address and map to an encryption key used in transactions? Related, what are unmentioned security considerations to SlatepackAddress reuse? Should we still use double-sha256 in SimpleBase58Check or take the opportunity to use a BCH or CRC code which may be more appropriate for error detection on slatepack messages? Is additional engineering desired here if there will always be further validation of the slate payload before a spend can occur? If addresses are not reused by default and since wallets need to be able to conduct multiple transactions in parallel, they need the ability to listen on all \"active\" addresses at the same time","title":"Unresolved questions"},{"location":"wiki/transactions/slatepack/#future-possibilities","text":"Extended to support future modes (payment channel, payjoin, multiple counterparties etc) An entirely different standard could be adopted in the future if non-interactive transactions become the default, eliminating the need for Slatepack It might be possible for a new standard to remain compatible with the existing SlatepackAddress to allow a more generic GrinAddress","title":"Future possibilities"},{"location":"wiki/transactions/slatepack/#references","text":"Bitcoin BIP173 \u21a9 age - File Encryption Tool & Format \u21a9 age Rust library \u21a9 Ed25519 Keys \u21a9 Ed25519 to Curve25519 \u21a9 Using Ed25519 signing keys for encryption \u21a9 Armored Slates RFC \u21a9 Saltpack \u21a9 Tor v3 Specification \u21a9 Signal Docs XEdDSA \u21a9 How Tari Works \u21a9 Beam Docs SBBS \u21a9","title":"References"},{"location":"wiki/transactions/slates/","text":"Slates Title: slate-v4 (compact slates) Authors: Michael Cordner Start date: April 03 2020 RFC PR: mimblewimble/grin-rfcs#49 Tracking issue: mimblewimble/grin-wallet#317 Summary What is a slate? To exchange Grin, users must exchange transaction slates in one form or another. A transaction slate is a blob containing the necessary data to be included at each step of the transaction building process. This RFC describes the changes between version 3 and version 4 of the Slate transaction exchange format, which had the goal of reducing the contents of the Slate to be as minimal as possible. Motivation Previously, the definition of Slate versions up to V3 had been put together with no regard for its size or/and redundant/irrelevant content. In order to facilitate future exchange method possibilities, it's desirable to ensure the Slate is as compact as possible, particularly on the 'first leg' of a transaction exchange which only actually requires minimal information from the transaction initiator. This RFC aims to define the contents of a streamlined \"compact\" slate by: Removing all redundant or unnecessary Slate fields Shortening the names of many Slate fields Reducing the size of the Slate to at all phases of a transaction Defining an optional highly-minimized binary format for Slate output Although this RFC doesn't address any particular transaction exchange methods that might be facilitated by this streamlining, one could envisage possibilities such as: An exchange placing the entire initial slate in a QR code Encoding the initial slate as an easily-cut-and-paste chunk Community-level explanation There are two basic transaction workflows in a two-party Grin transaction: In the Basic workflow, a sender adds their inputs and change outputs to a transaction, and sends them, along with the fee, the amount and their signature data to the recipient. The recipient adds a output for the amount to the transaction, adds their signature data and returns to the sender, who completes the transaction and posts. In the Invoice workflow, the invoice creator adds a new output to a transaction, and sends the amount and signature data to the payer. The payer adds their inputs and change outputs to the transaction along with their signature data and fee information, then returns to the invoicer, who completes the transaction and posts. Although previous versions of the Slate included every party's complete inputs and outputs at every stage of the transaction, it is not technically necessary for the initiator to provide their inputs and outputs to the other party. It suffices for the initiator to store the input/output listing in their local transaction context, and only provide the amount, fee, excess and signature data to the other party. Recognising this, it is possible to ensure that the 'first-leg' of a transaction stage is extremely compact. For instance, version 3 of the Slate on transaction initiation may have looked something like the following: { \"version_info\": { \"version\": 3, \"orig_version\": 3, \"block_header_version\": 2 }, \"num_participants\": 2, \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"tx\": { \"offset\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"body\": { \"inputs\": [ { \"features\": \"Coinbase\", \"commit\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"features\": \"Coinbase\", \"commit\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ], \"outputs\": [ { \"features\": \"Plain\", \"commit\": \"0812276cc788e6870612296d926cba9f0e7b9810670710b5a6e6f1ba006d395774\", \"proof\": \"dcff6175390c602bfa92c2ffd1a9b2d84dcc9ea941f6f317bdd0f875244ef23e696fd17c71df79760ce5ce1a96aab1d15dd057358dc835e972febeb86d50ccec0dad7cfe0246d742eb753cf7b88c045d15bc7123f8cf7155647ccf663fca92a83c9a65d0ed756ea7ebffd2cac90c380a102ed9caaa355d175ed0bf58d3ac2f5e909d6c447dfc6b605e04925c2b17c33ebd1908c965a5541ea5d2ed45a0958e6402f89d7a56df1992e036d836e74017e73ccad5cb3a82b8e139e309792a31b15f3ffd72ed033253428c156c2b9799458a25c1da65b719780a22de7fe7f437ae2fccd22cf7ea357ab5aa66a5ef7d71fb0dc64aa0b5761f68278062bb39bb296c787e4cabc5e2a2933a416ce1c9a9696160386449c437e9120f7bb26e5b0e74d1f2e7d5bcd7aafb2a92b87d1548f1f911fb06af7bd6cc13cee29f7c9cb79021aed18186272af0e9d189ec107c81a8a3aeb4782b0d950e4881aa51b776bb6844b25bce97035b48a9bdb2aea3608687bcdd479d4fa998b5a839ff88558e4a29dff0ed13b55900abb5d439b70793d902ae9ad34587b18c919f6b875c91d14deeb1c373f5e76570d59a6549758f655f1128a54f162dfe8868e1587028e26ad91e528c5ae7ee9335fa58fb59022b5de29d80f0764a9917390d46db899acc6a5b416e25ecc9dccb7153646addcc81cadb5f0078febc7e05d7735aba494f39ef05697bbcc9b47b2ccc79595d75fc13c80678b5e237edce58d731f34c05b1ddcaa649acf2d865bbbc3ceda10508bcdd29d0496744644bf1c3516f6687dfeef5649c7dff90627d642739a59d91a8d1d0c4dc55d74a949e1074427664b467992c9e0f7d3af9d6ea79513e8946ddc0d356bac49878e64e6a95b0a30214214faf2ce317fa622ff3266b32a816e10a18e6d789a5da1f23e67b4f970a68a7bcd9e18825ee274b0483896a40\" } ], \"kernels\": [ { \"features\": \"Plain\", \"fee\": \"7000000\", \"lock_height\": \"0\", \"excess\": \"000000000000000000000000000000000000000000000000000000000000000000\", \"excess_sig\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } ] } }, \"amount\": \"60000000000\", \"fee\": \"7000000\", \"height\": \"5\", \"lock_height\": \"0\", \"ttl_cutoff_height\": null, \"payment_proof\": null, \"participant_data\": [ { \"id\": \"0\", \"public_blind_excess\": \"033ac2158fa0077f087de60c19d8e431753baa5b63b6e1477f05a2a6e7190d4592\", \"public_nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part_sig\": null, \"message\": null, \"message_sig\": null } ] } In version 4 of the Slate format, the initial Slate now looks like the following: { \"ver\": \"4:2\" \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"amt\": \"6000000000\", \"fee\": \"8000000\", \"sigs\": [ { \"xs\": \"023878ce845727f3a4ec76ca3f3db4b38a2d05d636b8c3632108b857fed63c96de\" \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ], } While a \"return\" slate might look something like the following: { \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S2\", \"off\": \"a4052c9200000001a6052c9200000002ed564fab50b75fc5ea32ce052fc9bebf\", \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part\": \"8f07ddd5e9f5179cff19486034181ed76505baaad53e5d994064127b56c5841b54735cb9ed2f59fb457144f7b1c8226d08b54cbdd0eb7e6492950751b0bb54f9\" } ], \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" } ] } The 'return' slate from the recipient to the originator is expected to be larger, as it must include the recipient's outputs/inputs and proofs (as the party who posts the transaction needs all of this information). However, compacting the slate at each stage of its journey allows for future possibilities that may have been more difficult in previous iterations of the slate format. For instance, an initiator taking Grin payments might be expected to be better equipped to receive Grin transactions. They could present the payer with an invoice transaction for the amount compacted to the size of a QR code, which the payer could scan, accept, and then post back to the invoicer's listening wallet infrastructure. Compacting the slate also acts as a minor privacy-enhancer by hiding the initiator's outputs from the other party. Reference-level explanation Slate Definition - JSON Entries prefixed with // denote fields that may be omitted, as well as their default assumed values. # denotes a comment for the purposes of illustration. Field ordering is canonical. { # These fields are always present \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", # These fields may or may not be present //\"num_parts: 2, //\"fee\": \"8000000\", //\"amt\": \"1000000000\", //\"feat\": 0, //\"ttl\": null, # Sigs is always present with at least one entry \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", // \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ] # These structs may or may not be present //\"coms\": null, //\"proof\": null, //\"feat_args\": null } A description of all fields and their meanings is as follows: Top-Level Slate Struct Fields Always ver - The slate version and supported block header version, separated by a : id - The slate's UUID, standard hex-string encoding for UUIDs sta - 2 character String representing the current stage of the the transaction. See Status Codes off - The running transaction offset total, hex-string encoded. All parties select a random offset at the beginning of the transaction and subtract their offset from the excess value of their outputs. They then subtract the value of the inputs from the offset when committing to inputs, updating the total offset before sending to the next stage. Optional (depending on state and transaction options) num_parts - The number of participants in the transaction, assumed to be 2 if omitted amt - The transaction amount as a string parseable as a u64. May be omitted on a return journey. fee - The transaction fee as a string parseable as a u64. May be omitted on a return journey, except during an invoice transaction. feat - Kernel Features ID. If omitted, kernel is assumed to be Plain (0). If set to 1 or otherwise, any arguments required for a particular kernel feature set will be found in the feat_args struct. ttl - Time to Live, or block height beyond which wallets should refuse to further process the transaction. Assumed 0 (no ttl) if omitted from the slate. Structs Always sigs - An array of signature data containing the signature information of the last participant. See Signature Data Optional (depending on state of transaction) proof - An optional payment proof request. See Payment Proof Data coms - The Transaction; (link) is removed from the slate in favour of including this top-level Slate field that can be used to reconstruct the transaction object as expected by the Grin node. See Transaction Object Fields feat_args - Optional arguments for Kernel features. Status Codes Valid values of the sta field and their meanings are: S1 - Standard (payer to payee) transaction flow, new transaction that incorporates the sender's inputs and change output(s), if any. Sender's signature nonce, excess (with kernel offset) is included and ready for sending to recipient. S2 - Standard transaction flow, recipient has created their outputs(s) and supplied their excess, nonce and partial signature, ready to return to recipient for completion. S3 - Standard transaction flow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting I1 - Invoice (payee to payer) transaction flow, new transaction that incorporates the Invoicer's output(s). Invoicer's signature nonce and excess (with kernel offset) is included and ready for sending to Invoicee. I2 - Invoice workflow, Invoicee has added their inputs and change output(s). Invoicee's signature, nonce and excess is included and ready for sending back to the invoicer. I3 - Invoice workflow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting Signature Data An entry in the sigs array is as follows: { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } The sigs struct contains is comprised of an array of participant signature data, with each entry comprising: * xs - Hex string encoded short form public key on the secp256k1 curve representing the public blind excess for the participants outputs subtracted from each party's part of the offset. * part - Hex string encoded Aggregated (Schnorr) secp2561k signature represeting the participant's partial sig. May be omitted if the participant does not yet have enough data to create it * nonce - Hex string encoded The public key of the nonce chosen by the participant for their partial signature The other party's sig entry is removed from the slate before sending it back to the transaction initiator during the S2 and I2 phases. Payment Proof Data If included, the proof structure is: \"proof\": { \"saddr\": \"7e008eb593ba17d116e282d6267a3c6aad87b910933ad34dfa4d7d2c92b6ba31\", // \"rsig\": null, \"raddr\": \"3a425bd5da5f0f78593251ede7fad0ecf7a95679d84b2cb405255d97ce068234\" } The proof struct is an optional payment proof request that must be filled out by the recipient if requested (only valid for basic transaction flow). Its fields are as follows: saddr - Hex string encoded short-form public key on the ed25519 curve, representing the sender's wallet address (see the payment proofs rfc for details. raddr - Hex string encoded short-form public key on the ed25519 curve represnting the recipient's wallet address rsig - Hex string encoded EdDSA ed25519 signature representing the recipient's payment-proof signature. Can be omitted if this has not yet been filled out Transaction Object Fields The V4 Version of the Slate contains its own separate representation of Grin's internal Transaction object. (Grin's internal transaction struct definition can be found here: Transaction ). Internally, the wallet will transform its representation into the format expected by the node while posting the transaction. The tx struct in a V4 Slate is removed, and is replaced instead by the following Top-Level fields. Wallets recreate the transaction object as expected by the Grin node from these fields before posting. coms is an array containing the outputs and inputs that have been added to the slate. These will appear during the I1 or S2 phases of a transaction. Each entry includes: f : The output features, assumed to be 'Plain' if omitted. 0 denotes Plain, 1 denotes Coinbase c : The output/input commitment, hex string Encoded p : The output's range proof, hex string Encoded. If this is included, the entry is assumed to be an output. If not, it is an input. When rebuilding the transaction kernel for the Node (done during the S3 or I3 phases,) the kernel is assumed to be 'Plain' unless the top-level feat field is non-zero. In this case, the kernel features are filled accordingly with any needed values from the feat_args struct. In a typical S3 phase, these fields may look something like: \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" }, { \"c\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"c\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ], Feature arguments Depending on the chosen Kernel Feature set, feat_args may be populated with arguments specific to the kernel. The exact arguments that will be present here depend on the value of feat . Currently, the only supported kernel is HeightLocked (value 1) which has the arguments: \"feat_args\": { \"lock_hgt\": \"2343234\" // For HeightLocked kernels (1) } Changes from existing V3 Slate Top-Level Slate Struct The version_info struct is removed, and is replaced with ver , which has the format \"[version]:[block header version]\" sta is added, with possible values S1|S2|S3|I1|I2|I3|NA num_participants is renamed to num_parts num_parts may be omitted from the slate. If omitted its value is assumed to be 2. amount is renamed to amt amt may be removed from the slate on the S2 phase of a transaction. fee may be removed from the slate on the S2 phase of a transaction. It may also be omitted when initiating an I1 transaction, and added during the I2 phase. lock_height is removed feat is added to the slate denoting the Kernel feature set. May be omitted from the slate if kernel is plain ttl_cutoff_height is renamed to ttl ttl may be omitted from the slate. If omitted its value is assumed to be 0 (no TTL). The participant_data struct is renamed to sigs tx is removed The coms (commitments) array is added, from which the final transaction object can be reconstructed The payment_proof struct is renamed to proof The feat_args struct is added, which may be populated for non-Plain kernels proof may be omitted from the slate if it is None (null), offset is added, which keeps track of the running offset total as it's modified by the participants Participant Data ( sigs ) public_blind_excess is renamed to xs public_nonce is renamed to nonce part_sig is renamed to part part may be omitted if it has not yet been filled out message is removed message_sig is removed id is removed. Parties can identify themselves via the keys stored in their transaction context Payment Proof Data ( proof ) The sender_address field is renamed to saddr The receiver_address field is renamed to raddr The receiver_signature field is renamed to rsig rsig may be omitted if it has not yet been filled out Pretty-Printing The examples above are pretty-printed for reference, but all Slates should remove all whitespace before sending to other parties. The whitespace and formatting can be re-added anywhere the Slate needs to be presented for debugging. Slate Definition - Binary While the JSON slate remains the first-order slate definition, and should be accepted by all wallets and APIs, wallets should also have the ability to transform slates between the JSON format and a reduced binary format suitable for armoring or direct transfer. The definition of the V4 binary slate format follows. All integer values are Big-Endian. Slate V4 Field type len notes ver.slate_version u16 2 ver.block_header_version u16 2 id Uuid 16 binary Uuid representation sta u8 1 See Status Byte offset BlindingFactor 32 Optional field status u8 1 See Optional Field Status num_parts u8 (1) If present amt u64 (8) If present fee u64 (8) If present feat u8 (1) If present ttl u64 (8) If present sigs entries struct varies See Sigs Entries Optional struct status u8 1 See Optional Struct Status coms entries struct (varies) If present. See Coms Entries proof struct (varies) If present. See Proof feat_args entries struct (varies) If present. See Feature Args Status Byte Encodes slate status ( sta ) field, mapped as follows: State value NA (Unknown) 0 S1 1 S2 2 S3 3 I1 4 I2 5 I3 6 Optional Field Status A bit field that denotes the presence or absence of the optional slate fields. Each bit is mapped to particular slate field as follows: Bit 7 6 5 4 3 2 1 0 field ttl feat fee amt num_parts If the corresponding field for a bit is 1, the field is present and must be read accordingly. Sigs Entries Sigs Entries contains a length-prefixed array of entries corresponding to the sigs struct. Field type len notes length u8 1 entries struct varies array of entries, see below Each Sigs Entry is structured as follows: Field type len notes complete flag u8 1 If non-zero, entry contains part xs secp256k1 Public Key 33 nonce secp256k1 Public Key 33 part secp256k1 AggSig (64) If present Optional Struct Status A bit field that denotes the presence or absence of the optional slate structures. Each bit is mapped to particular slate structure as follows: Bit 7 6 5 4 3 2 1 0 struct proof coms If the corresponding field for a struct is 1, the struct is present and must be read accordingly. Coms Entries Coms Entries contains a length-prefixed array of entries corresponding to the coms struct. Field type len notes length u16 2 entries struct varies array of entries, see below Each Coms Entry is structured as follows: Field type len notes output flag u8 1 If non-zero, entry is output and contains p (proof) f u8 1 features (1 = Coinbase, 0 = Plain) c Commitment 33 p Rangeproof 675 If present Proof Optional Payment proof, with fields as follows Proof Field type len notes saddr ed25519 Public Key 32 raddr ed25519 Public Key 32 rsig flag u8 1 If non-zero, rsig field is present rsig ed25519 EDCSA Sig (64) If present Feature Args Optional feature args, presence or absence of which should be determined by the value of the feat field. Currently only present if feat is 2. Field type len notes lock_hgt u64 8 Lock height, present if feat is 2 Unresolved questions Is block header version needed? NRD Kernels need to be included Future possibilities This RFC is envisaged as a necessary first step for all slate-exchange possibilities that would benefit from compactness, e.g: QR Code encoding of slates Armored slates Slatepack","title":"Slates"},{"location":"wiki/transactions/slates/#slates","text":"Title: slate-v4 (compact slates) Authors: Michael Cordner Start date: April 03 2020 RFC PR: mimblewimble/grin-rfcs#49 Tracking issue: mimblewimble/grin-wallet#317","title":"Slates"},{"location":"wiki/transactions/slates/#summary","text":"What is a slate? To exchange Grin, users must exchange transaction slates in one form or another. A transaction slate is a blob containing the necessary data to be included at each step of the transaction building process. This RFC describes the changes between version 3 and version 4 of the Slate transaction exchange format, which had the goal of reducing the contents of the Slate to be as minimal as possible.","title":"Summary"},{"location":"wiki/transactions/slates/#motivation","text":"Previously, the definition of Slate versions up to V3 had been put together with no regard for its size or/and redundant/irrelevant content. In order to facilitate future exchange method possibilities, it's desirable to ensure the Slate is as compact as possible, particularly on the 'first leg' of a transaction exchange which only actually requires minimal information from the transaction initiator. This RFC aims to define the contents of a streamlined \"compact\" slate by: Removing all redundant or unnecessary Slate fields Shortening the names of many Slate fields Reducing the size of the Slate to at all phases of a transaction Defining an optional highly-minimized binary format for Slate output Although this RFC doesn't address any particular transaction exchange methods that might be facilitated by this streamlining, one could envisage possibilities such as: An exchange placing the entire initial slate in a QR code Encoding the initial slate as an easily-cut-and-paste chunk","title":"Motivation"},{"location":"wiki/transactions/slates/#community-level-explanation","text":"There are two basic transaction workflows in a two-party Grin transaction: In the Basic workflow, a sender adds their inputs and change outputs to a transaction, and sends them, along with the fee, the amount and their signature data to the recipient. The recipient adds a output for the amount to the transaction, adds their signature data and returns to the sender, who completes the transaction and posts. In the Invoice workflow, the invoice creator adds a new output to a transaction, and sends the amount and signature data to the payer. The payer adds their inputs and change outputs to the transaction along with their signature data and fee information, then returns to the invoicer, who completes the transaction and posts. Although previous versions of the Slate included every party's complete inputs and outputs at every stage of the transaction, it is not technically necessary for the initiator to provide their inputs and outputs to the other party. It suffices for the initiator to store the input/output listing in their local transaction context, and only provide the amount, fee, excess and signature data to the other party. Recognising this, it is possible to ensure that the 'first-leg' of a transaction stage is extremely compact. For instance, version 3 of the Slate on transaction initiation may have looked something like the following: { \"version_info\": { \"version\": 3, \"orig_version\": 3, \"block_header_version\": 2 }, \"num_participants\": 2, \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"tx\": { \"offset\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"body\": { \"inputs\": [ { \"features\": \"Coinbase\", \"commit\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"features\": \"Coinbase\", \"commit\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ], \"outputs\": [ { \"features\": \"Plain\", \"commit\": \"0812276cc788e6870612296d926cba9f0e7b9810670710b5a6e6f1ba006d395774\", \"proof\": \"dcff6175390c602bfa92c2ffd1a9b2d84dcc9ea941f6f317bdd0f875244ef23e696fd17c71df79760ce5ce1a96aab1d15dd057358dc835e972febeb86d50ccec0dad7cfe0246d742eb753cf7b88c045d15bc7123f8cf7155647ccf663fca92a83c9a65d0ed756ea7ebffd2cac90c380a102ed9caaa355d175ed0bf58d3ac2f5e909d6c447dfc6b605e04925c2b17c33ebd1908c965a5541ea5d2ed45a0958e6402f89d7a56df1992e036d836e74017e73ccad5cb3a82b8e139e309792a31b15f3ffd72ed033253428c156c2b9799458a25c1da65b719780a22de7fe7f437ae2fccd22cf7ea357ab5aa66a5ef7d71fb0dc64aa0b5761f68278062bb39bb296c787e4cabc5e2a2933a416ce1c9a9696160386449c437e9120f7bb26e5b0e74d1f2e7d5bcd7aafb2a92b87d1548f1f911fb06af7bd6cc13cee29f7c9cb79021aed18186272af0e9d189ec107c81a8a3aeb4782b0d950e4881aa51b776bb6844b25bce97035b48a9bdb2aea3608687bcdd479d4fa998b5a839ff88558e4a29dff0ed13b55900abb5d439b70793d902ae9ad34587b18c919f6b875c91d14deeb1c373f5e76570d59a6549758f655f1128a54f162dfe8868e1587028e26ad91e528c5ae7ee9335fa58fb59022b5de29d80f0764a9917390d46db899acc6a5b416e25ecc9dccb7153646addcc81cadb5f0078febc7e05d7735aba494f39ef05697bbcc9b47b2ccc79595d75fc13c80678b5e237edce58d731f34c05b1ddcaa649acf2d865bbbc3ceda10508bcdd29d0496744644bf1c3516f6687dfeef5649c7dff90627d642739a59d91a8d1d0c4dc55d74a949e1074427664b467992c9e0f7d3af9d6ea79513e8946ddc0d356bac49878e64e6a95b0a30214214faf2ce317fa622ff3266b32a816e10a18e6d789a5da1f23e67b4f970a68a7bcd9e18825ee274b0483896a40\" } ], \"kernels\": [ { \"features\": \"Plain\", \"fee\": \"7000000\", \"lock_height\": \"0\", \"excess\": \"000000000000000000000000000000000000000000000000000000000000000000\", \"excess_sig\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } ] } }, \"amount\": \"60000000000\", \"fee\": \"7000000\", \"height\": \"5\", \"lock_height\": \"0\", \"ttl_cutoff_height\": null, \"payment_proof\": null, \"participant_data\": [ { \"id\": \"0\", \"public_blind_excess\": \"033ac2158fa0077f087de60c19d8e431753baa5b63b6e1477f05a2a6e7190d4592\", \"public_nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part_sig\": null, \"message\": null, \"message_sig\": null } ] } In version 4 of the Slate format, the initial Slate now looks like the following: { \"ver\": \"4:2\" \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", \"amt\": \"6000000000\", \"fee\": \"8000000\", \"sigs\": [ { \"xs\": \"023878ce845727f3a4ec76ca3f3db4b38a2d05d636b8c3632108b857fed63c96de\" \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ], } While a \"return\" slate might look something like the following: { \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S2\", \"off\": \"a4052c9200000001a6052c9200000002ed564fab50b75fc5ea32ce052fc9bebf\", \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", \"part\": \"8f07ddd5e9f5179cff19486034181ed76505baaad53e5d994064127b56c5841b54735cb9ed2f59fb457144f7b1c8226d08b54cbdd0eb7e6492950751b0bb54f9\" } ], \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" } ] } The 'return' slate from the recipient to the originator is expected to be larger, as it must include the recipient's outputs/inputs and proofs (as the party who posts the transaction needs all of this information). However, compacting the slate at each stage of its journey allows for future possibilities that may have been more difficult in previous iterations of the slate format. For instance, an initiator taking Grin payments might be expected to be better equipped to receive Grin transactions. They could present the payer with an invoice transaction for the amount compacted to the size of a QR code, which the payer could scan, accept, and then post back to the invoicer's listening wallet infrastructure. Compacting the slate also acts as a minor privacy-enhancer by hiding the initiator's outputs from the other party.","title":"Community-level explanation"},{"location":"wiki/transactions/slates/#reference-level-explanation","text":"","title":"Reference-level explanation"},{"location":"wiki/transactions/slates/#slate-definition-json","text":"Entries prefixed with // denote fields that may be omitted, as well as their default assumed values. # denotes a comment for the purposes of illustration. Field ordering is canonical. { # These fields are always present \"ver\": \"4:3\", \"id\": \"0436430c-2b02-624c-2032-570501212b00\", \"sta\": \"S1\", \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\", # These fields may or may not be present //\"num_parts: 2, //\"fee\": \"8000000\", //\"amt\": \"1000000000\", //\"feat\": 0, //\"ttl\": null, # Sigs is always present with at least one entry \"sigs\": [ { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", // \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } ] # These structs may or may not be present //\"coms\": null, //\"proof\": null, //\"feat_args\": null } A description of all fields and their meanings is as follows:","title":"Slate Definition - JSON"},{"location":"wiki/transactions/slates/#top-level-slate-struct","text":"","title":"Top-Level Slate Struct"},{"location":"wiki/transactions/slates/#fields","text":"","title":"Fields"},{"location":"wiki/transactions/slates/#always","text":"ver - The slate version and supported block header version, separated by a : id - The slate's UUID, standard hex-string encoding for UUIDs sta - 2 character String representing the current stage of the the transaction. See Status Codes off - The running transaction offset total, hex-string encoded. All parties select a random offset at the beginning of the transaction and subtract their offset from the excess value of their outputs. They then subtract the value of the inputs from the offset when committing to inputs, updating the total offset before sending to the next stage.","title":"Always"},{"location":"wiki/transactions/slates/#optional","text":"(depending on state and transaction options) num_parts - The number of participants in the transaction, assumed to be 2 if omitted amt - The transaction amount as a string parseable as a u64. May be omitted on a return journey. fee - The transaction fee as a string parseable as a u64. May be omitted on a return journey, except during an invoice transaction. feat - Kernel Features ID. If omitted, kernel is assumed to be Plain (0). If set to 1 or otherwise, any arguments required for a particular kernel feature set will be found in the feat_args struct. ttl - Time to Live, or block height beyond which wallets should refuse to further process the transaction. Assumed 0 (no ttl) if omitted from the slate.","title":"Optional"},{"location":"wiki/transactions/slates/#structs","text":"","title":"Structs"},{"location":"wiki/transactions/slates/#always_1","text":"sigs - An array of signature data containing the signature information of the last participant. See Signature Data","title":"Always"},{"location":"wiki/transactions/slates/#optional_1","text":"(depending on state of transaction) proof - An optional payment proof request. See Payment Proof Data coms - The Transaction; (link) is removed from the slate in favour of including this top-level Slate field that can be used to reconstruct the transaction object as expected by the Grin node. See Transaction Object Fields feat_args - Optional arguments for Kernel features.","title":"Optional"},{"location":"wiki/transactions/slates/#status-codes","text":"Valid values of the sta field and their meanings are: S1 - Standard (payer to payee) transaction flow, new transaction that incorporates the sender's inputs and change output(s), if any. Sender's signature nonce, excess (with kernel offset) is included and ready for sending to recipient. S2 - Standard transaction flow, recipient has created their outputs(s) and supplied their excess, nonce and partial signature, ready to return to recipient for completion. S3 - Standard transaction flow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting I1 - Invoice (payee to payer) transaction flow, new transaction that incorporates the Invoicer's output(s). Invoicer's signature nonce and excess (with kernel offset) is included and ready for sending to Invoicee. I2 - Invoice workflow, Invoicee has added their inputs and change output(s). Invoicee's signature, nonce and excess is included and ready for sending back to the invoicer. I3 - Invoice workflow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting","title":"Status Codes"},{"location":"wiki/transactions/slates/#signature-data","text":"An entry in the sigs array is as follows: { \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\", \"part\": null, \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\", } The sigs struct contains is comprised of an array of participant signature data, with each entry comprising: * xs - Hex string encoded short form public key on the secp256k1 curve representing the public blind excess for the participants outputs subtracted from each party's part of the offset. * part - Hex string encoded Aggregated (Schnorr) secp2561k signature represeting the participant's partial sig. May be omitted if the participant does not yet have enough data to create it * nonce - Hex string encoded The public key of the nonce chosen by the participant for their partial signature The other party's sig entry is removed from the slate before sending it back to the transaction initiator during the S2 and I2 phases.","title":"Signature Data"},{"location":"wiki/transactions/slates/#payment-proof-data","text":"If included, the proof structure is: \"proof\": { \"saddr\": \"7e008eb593ba17d116e282d6267a3c6aad87b910933ad34dfa4d7d2c92b6ba31\", // \"rsig\": null, \"raddr\": \"3a425bd5da5f0f78593251ede7fad0ecf7a95679d84b2cb405255d97ce068234\" } The proof struct is an optional payment proof request that must be filled out by the recipient if requested (only valid for basic transaction flow). Its fields are as follows: saddr - Hex string encoded short-form public key on the ed25519 curve, representing the sender's wallet address (see the payment proofs rfc for details. raddr - Hex string encoded short-form public key on the ed25519 curve represnting the recipient's wallet address rsig - Hex string encoded EdDSA ed25519 signature representing the recipient's payment-proof signature. Can be omitted if this has not yet been filled out","title":"Payment Proof Data"},{"location":"wiki/transactions/slates/#transaction-object-fields","text":"The V4 Version of the Slate contains its own separate representation of Grin's internal Transaction object. (Grin's internal transaction struct definition can be found here: Transaction ). Internally, the wallet will transform its representation into the format expected by the node while posting the transaction. The tx struct in a V4 Slate is removed, and is replaced instead by the following Top-Level fields. Wallets recreate the transaction object as expected by the Grin node from these fields before posting. coms is an array containing the outputs and inputs that have been added to the slate. These will appear during the I1 or S2 phases of a transaction. Each entry includes: f : The output features, assumed to be 'Plain' if omitted. 0 denotes Plain, 1 denotes Coinbase c : The output/input commitment, hex string Encoded p : The output's range proof, hex string Encoded. If this is included, the entry is assumed to be an output. If not, it is an input. When rebuilding the transaction kernel for the Node (done during the S3 or I3 phases,) the kernel is assumed to be 'Plain' unless the top-level feat field is non-zero. In this case, the kernel features are filled accordingly with any needed values from the feat_args struct. In a typical S3 phase, these fields may look something like: \"coms\": [ { \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\", \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\" }, { \"c\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\" }, { \"c\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\" } ],","title":"Transaction Object Fields"},{"location":"wiki/transactions/slates/#feature-arguments","text":"Depending on the chosen Kernel Feature set, feat_args may be populated with arguments specific to the kernel. The exact arguments that will be present here depend on the value of feat . Currently, the only supported kernel is HeightLocked (value 1) which has the arguments: \"feat_args\": { \"lock_hgt\": \"2343234\" // For HeightLocked kernels (1) }","title":"Feature arguments"},{"location":"wiki/transactions/slates/#changes-from-existing-v3-slate","text":"","title":"Changes from existing V3 Slate"},{"location":"wiki/transactions/slates/#top-level-slate-struct_1","text":"The version_info struct is removed, and is replaced with ver , which has the format \"[version]:[block header version]\" sta is added, with possible values S1|S2|S3|I1|I2|I3|NA num_participants is renamed to num_parts num_parts may be omitted from the slate. If omitted its value is assumed to be 2. amount is renamed to amt amt may be removed from the slate on the S2 phase of a transaction. fee may be removed from the slate on the S2 phase of a transaction. It may also be omitted when initiating an I1 transaction, and added during the I2 phase. lock_height is removed feat is added to the slate denoting the Kernel feature set. May be omitted from the slate if kernel is plain ttl_cutoff_height is renamed to ttl ttl may be omitted from the slate. If omitted its value is assumed to be 0 (no TTL). The participant_data struct is renamed to sigs tx is removed The coms (commitments) array is added, from which the final transaction object can be reconstructed The payment_proof struct is renamed to proof The feat_args struct is added, which may be populated for non-Plain kernels proof may be omitted from the slate if it is None (null), offset is added, which keeps track of the running offset total as it's modified by the participants","title":"Top-Level Slate Struct"},{"location":"wiki/transactions/slates/#participant-data-sigs","text":"public_blind_excess is renamed to xs public_nonce is renamed to nonce part_sig is renamed to part part may be omitted if it has not yet been filled out message is removed message_sig is removed id is removed. Parties can identify themselves via the keys stored in their transaction context","title":"Participant Data (sigs)"},{"location":"wiki/transactions/slates/#payment-proof-data-proof","text":"The sender_address field is renamed to saddr The receiver_address field is renamed to raddr The receiver_signature field is renamed to rsig rsig may be omitted if it has not yet been filled out","title":"Payment Proof Data (proof)"},{"location":"wiki/transactions/slates/#pretty-printing","text":"The examples above are pretty-printed for reference, but all Slates should remove all whitespace before sending to other parties. The whitespace and formatting can be re-added anywhere the Slate needs to be presented for debugging.","title":"Pretty-Printing"},{"location":"wiki/transactions/slates/#slate-definition-binary","text":"While the JSON slate remains the first-order slate definition, and should be accepted by all wallets and APIs, wallets should also have the ability to transform slates between the JSON format and a reduced binary format suitable for armoring or direct transfer. The definition of the V4 binary slate format follows. All integer values are Big-Endian. Slate V4 Field type len notes ver.slate_version u16 2 ver.block_header_version u16 2 id Uuid 16 binary Uuid representation sta u8 1 See Status Byte offset BlindingFactor 32 Optional field status u8 1 See Optional Field Status num_parts u8 (1) If present amt u64 (8) If present fee u64 (8) If present feat u8 (1) If present ttl u64 (8) If present sigs entries struct varies See Sigs Entries Optional struct status u8 1 See Optional Struct Status coms entries struct (varies) If present. See Coms Entries proof struct (varies) If present. See Proof feat_args entries struct (varies) If present. See Feature Args Status Byte Encodes slate status ( sta ) field, mapped as follows: State value NA (Unknown) 0 S1 1 S2 2 S3 3 I1 4 I2 5 I3 6 Optional Field Status A bit field that denotes the presence or absence of the optional slate fields. Each bit is mapped to particular slate field as follows: Bit 7 6 5 4 3 2 1 0 field ttl feat fee amt num_parts If the corresponding field for a bit is 1, the field is present and must be read accordingly. Sigs Entries Sigs Entries contains a length-prefixed array of entries corresponding to the sigs struct. Field type len notes length u8 1 entries struct varies array of entries, see below Each Sigs Entry is structured as follows: Field type len notes complete flag u8 1 If non-zero, entry contains part xs secp256k1 Public Key 33 nonce secp256k1 Public Key 33 part secp256k1 AggSig (64) If present Optional Struct Status A bit field that denotes the presence or absence of the optional slate structures. Each bit is mapped to particular slate structure as follows: Bit 7 6 5 4 3 2 1 0 struct proof coms If the corresponding field for a struct is 1, the struct is present and must be read accordingly. Coms Entries Coms Entries contains a length-prefixed array of entries corresponding to the coms struct. Field type len notes length u16 2 entries struct varies array of entries, see below Each Coms Entry is structured as follows: Field type len notes output flag u8 1 If non-zero, entry is output and contains p (proof) f u8 1 features (1 = Coinbase, 0 = Plain) c Commitment 33 p Rangeproof 675 If present Proof Optional Payment proof, with fields as follows Proof Field type len notes saddr ed25519 Public Key 32 raddr ed25519 Public Key 32 rsig flag u8 1 If non-zero, rsig field is present rsig ed25519 EDCSA Sig (64) If present Feature Args Optional feature args, presence or absence of which should be determined by the value of the feat field. Currently only present if feat is 2. Field type len notes lock_hgt u64 8 Lock height, present if feat is 2","title":"Slate Definition - Binary"},{"location":"wiki/transactions/slates/#unresolved-questions","text":"Is block header version needed? NRD Kernels need to be included","title":"Unresolved questions"},{"location":"wiki/transactions/slates/#future-possibilities","text":"This RFC is envisaged as a necessary first step for all slate-exchange possibilities that would benefit from compactness, e.g: QR Code encoding of slates Armored slates Slatepack","title":"Future possibilities"}]}